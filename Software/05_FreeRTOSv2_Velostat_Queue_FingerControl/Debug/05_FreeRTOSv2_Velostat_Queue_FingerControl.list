
05_FreeRTOSv2_Velostat_Queue_FingerControl.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000f9c4  08000110  08000110  00010110  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000003ec  0800fad4  0800fad4  0001fad4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800fec0  0800fec0  00020038  2**0
                  CONTENTS
  4 .ARM          00000000  0800fec0  0800fec0  00020038  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800fec0  0800fec0  00020038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800fec0  0800fec0  0001fec0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800fec4  0800fec4  0001fec4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000038  20000000  0800fec8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00004560  20000038  0800ff00  00020038  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20004598  0800ff00  00024598  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY
 12 .debug_info   00027168  00000000  00000000  00020061  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000489b  00000000  00000000  000471c9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000003a8  00000000  00000000  0004ba68  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  0001ac7b  00000000  00000000  0004be10  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   000209b5  00000000  00000000  00066a8b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    00099a5c  00000000  00000000  00087440  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000053  00000000  00000000  00120e9c  2**0
                  CONTENTS, READONLY
 19 .debug_frame  0000417c  00000000  00000000  00120ef0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loc    00017596  00000000  00000000  0012506c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_ranges 00000318  00000000  00000000  0013c608  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000110 <__do_global_dtors_aux>:
 8000110:	b510      	push	{r4, lr}
 8000112:	4c05      	ldr	r4, [pc, #20]	; (8000128 <__do_global_dtors_aux+0x18>)
 8000114:	7823      	ldrb	r3, [r4, #0]
 8000116:	b933      	cbnz	r3, 8000126 <__do_global_dtors_aux+0x16>
 8000118:	4b04      	ldr	r3, [pc, #16]	; (800012c <__do_global_dtors_aux+0x1c>)
 800011a:	b113      	cbz	r3, 8000122 <__do_global_dtors_aux+0x12>
 800011c:	4804      	ldr	r0, [pc, #16]	; (8000130 <__do_global_dtors_aux+0x20>)
 800011e:	f3af 8000 	nop.w
 8000122:	2301      	movs	r3, #1
 8000124:	7023      	strb	r3, [r4, #0]
 8000126:	bd10      	pop	{r4, pc}
 8000128:	20000038 	.word	0x20000038
 800012c:	00000000 	.word	0x00000000
 8000130:	0800fabc 	.word	0x0800fabc

08000134 <frame_dummy>:
 8000134:	b508      	push	{r3, lr}
 8000136:	4b03      	ldr	r3, [pc, #12]	; (8000144 <frame_dummy+0x10>)
 8000138:	b11b      	cbz	r3, 8000142 <frame_dummy+0xe>
 800013a:	4903      	ldr	r1, [pc, #12]	; (8000148 <frame_dummy+0x14>)
 800013c:	4803      	ldr	r0, [pc, #12]	; (800014c <frame_dummy+0x18>)
 800013e:	f3af 8000 	nop.w
 8000142:	bd08      	pop	{r3, pc}
 8000144:	00000000 	.word	0x00000000
 8000148:	2000003c 	.word	0x2000003c
 800014c:	0800fabc 	.word	0x0800fabc

08000150 <vApplicationMallocFailedHook>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000150:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000154:	4905      	ldr	r1, [pc, #20]	; (800016c <vApplicationMallocFailedHook+0x1c>)
 8000156:	68ca      	ldr	r2, [r1, #12]
 8000158:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800015c:	4b04      	ldr	r3, [pc, #16]	; (8000170 <vApplicationMallocFailedHook+0x20>)
 800015e:	4313      	orrs	r3, r2
 8000160:	60cb      	str	r3, [r1, #12]
 8000162:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000166:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8000168:	e7fd      	b.n	8000166 <vApplicationMallocFailedHook+0x16>
 800016a:	bf00      	nop
 800016c:	e000ed00 	.word	0xe000ed00
 8000170:	05fa0004 	.word	0x05fa0004

08000174 <Callback01>:
}

/* Callback01 function */
void Callback01(void *argument) {
	/* USER CODE BEGIN Callback01 */
	flagTimer = 1u;
 8000174:	4b01      	ldr	r3, [pc, #4]	; (800017c <Callback01+0x8>)
 8000176:	2201      	movs	r2, #1
 8000178:	801a      	strh	r2, [r3, #0]
	/* USER CODE END Callback01 */
}
 800017a:	4770      	bx	lr
 800017c:	200044d4 	.word	0x200044d4

08000180 <MX_GPIO_Init>:
static void MX_GPIO_Init(void) {
 8000180:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000184:	b089      	sub	sp, #36	; 0x24
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
 8000186:	2400      	movs	r4, #0
 8000188:	9404      	str	r4, [sp, #16]
 800018a:	9405      	str	r4, [sp, #20]
 800018c:	9406      	str	r4, [sp, #24]
 800018e:	9407      	str	r4, [sp, #28]
	__HAL_RCC_GPIOC_CLK_ENABLE();
 8000190:	4b38      	ldr	r3, [pc, #224]	; (8000274 <MX_GPIO_Init+0xf4>)
 8000192:	699a      	ldr	r2, [r3, #24]
 8000194:	f042 0210 	orr.w	r2, r2, #16
 8000198:	619a      	str	r2, [r3, #24]
 800019a:	699a      	ldr	r2, [r3, #24]
 800019c:	f002 0210 	and.w	r2, r2, #16
 80001a0:	9200      	str	r2, [sp, #0]
 80001a2:	9a00      	ldr	r2, [sp, #0]
	__HAL_RCC_GPIOD_CLK_ENABLE();
 80001a4:	699a      	ldr	r2, [r3, #24]
 80001a6:	f042 0220 	orr.w	r2, r2, #32
 80001aa:	619a      	str	r2, [r3, #24]
 80001ac:	699a      	ldr	r2, [r3, #24]
 80001ae:	f002 0220 	and.w	r2, r2, #32
 80001b2:	9201      	str	r2, [sp, #4]
 80001b4:	9a01      	ldr	r2, [sp, #4]
	__HAL_RCC_GPIOA_CLK_ENABLE();
 80001b6:	699a      	ldr	r2, [r3, #24]
 80001b8:	f042 0204 	orr.w	r2, r2, #4
 80001bc:	619a      	str	r2, [r3, #24]
 80001be:	699a      	ldr	r2, [r3, #24]
 80001c0:	f002 0204 	and.w	r2, r2, #4
 80001c4:	9202      	str	r2, [sp, #8]
 80001c6:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 80001c8:	699a      	ldr	r2, [r3, #24]
 80001ca:	f042 0208 	orr.w	r2, r2, #8
 80001ce:	619a      	str	r2, [r3, #24]
 80001d0:	699b      	ldr	r3, [r3, #24]
 80001d2:	f003 0308 	and.w	r3, r3, #8
 80001d6:	9303      	str	r3, [sp, #12]
 80001d8:	9b03      	ldr	r3, [sp, #12]
	HAL_GPIO_WritePin(LEDGreen_GPIO_Port, LEDGreen_Pin, GPIO_PIN_RESET);
 80001da:	4f27      	ldr	r7, [pc, #156]	; (8000278 <MX_GPIO_Init+0xf8>)
 80001dc:	4622      	mov	r2, r4
 80001de:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80001e2:	4638      	mov	r0, r7
 80001e4:	f003 ff85 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB,
 80001e8:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8000280 <MX_GPIO_Init+0x100>
 80001ec:	4622      	mov	r2, r4
 80001ee:	f24f 0104 	movw	r1, #61444	; 0xf004
 80001f2:	4648      	mov	r0, r9
 80001f4:	f003 ff7d 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(F_Scan_GPIO_Port, F_Scan_Pin, GPIO_PIN_RESET);
 80001f8:	f8df 8088 	ldr.w	r8, [pc, #136]	; 8000284 <MX_GPIO_Init+0x104>
 80001fc:	4622      	mov	r2, r4
 80001fe:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000202:	4640      	mov	r0, r8
 8000204:	f003 ff75 	bl	80040f2 <HAL_GPIO_WritePin>
	GPIO_InitStruct.Pin = LEDGreen_Pin;
 8000208:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800020c:	9304      	str	r3, [sp, #16]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800020e:	2601      	movs	r6, #1
 8000210:	9605      	str	r6, [sp, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000212:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000214:	2502      	movs	r5, #2
 8000216:	9507      	str	r5, [sp, #28]
	HAL_GPIO_Init(LEDGreen_GPIO_Port, &GPIO_InitStruct);
 8000218:	a904      	add	r1, sp, #16
 800021a:	4638      	mov	r0, r7
 800021c:	f003 fdd4 	bl	8003dc8 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = Btn0_Pin | Btn1_Pin;
 8000220:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8000224:	9304      	str	r3, [sp, #16]
	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000226:	4b15      	ldr	r3, [pc, #84]	; (800027c <MX_GPIO_Init+0xfc>)
 8000228:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800022a:	9406      	str	r4, [sp, #24]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800022c:	a904      	add	r1, sp, #16
 800022e:	4638      	mov	r0, r7
 8000230:	f003 fdca 	bl	8003dc8 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = A_Scan_Pin | B_Scan_Pin | C_Scan_Pin | D_Scan_Pin
 8000234:	f24f 0304 	movw	r3, #61444	; 0xf004
 8000238:	9304      	str	r3, [sp, #16]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800023a:	9605      	str	r6, [sp, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800023c:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800023e:	9507      	str	r5, [sp, #28]
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000240:	a904      	add	r1, sp, #16
 8000242:	4648      	mov	r0, r9
 8000244:	f003 fdc0 	bl	8003dc8 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = F_Scan_Pin;
 8000248:	f44f 7380 	mov.w	r3, #256	; 0x100
 800024c:	9304      	str	r3, [sp, #16]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800024e:	9605      	str	r6, [sp, #20]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000250:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000252:	9507      	str	r5, [sp, #28]
	HAL_GPIO_Init(F_Scan_GPIO_Port, &GPIO_InitStruct);
 8000254:	a904      	add	r1, sp, #16
 8000256:	4640      	mov	r0, r8
 8000258:	f003 fdb6 	bl	8003dc8 <HAL_GPIO_Init>
	HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0);
 800025c:	4622      	mov	r2, r4
 800025e:	2105      	movs	r1, #5
 8000260:	2028      	movs	r0, #40	; 0x28
 8000262:	f003 f94b 	bl	80034fc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8000266:	2028      	movs	r0, #40	; 0x28
 8000268:	f003 f97c 	bl	8003564 <HAL_NVIC_EnableIRQ>
}
 800026c:	b009      	add	sp, #36	; 0x24
 800026e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000272:	bf00      	nop
 8000274:	40021000 	.word	0x40021000
 8000278:	40011000 	.word	0x40011000
 800027c:	10210000 	.word	0x10210000
 8000280:	40010c00 	.word	0x40010c00
 8000284:	40010800 	.word	0x40010800

08000288 <User_DMA_XferCpltCallback>:
void User_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma) {
 8000288:	b508      	push	{r3, lr}
	if (hdma->Instance == hdma_memtomem_dma1_channel2.Instance) {
 800028a:	6803      	ldr	r3, [r0, #0]
 800028c:	4a0a      	ldr	r2, [pc, #40]	; (80002b8 <User_DMA_XferCpltCallback+0x30>)
 800028e:	6812      	ldr	r2, [r2, #0]
 8000290:	4293      	cmp	r3, r2
 8000292:	d004      	beq.n	800029e <User_DMA_XferCpltCallback+0x16>
	} else if (hdma->Instance == hdma_memtomem_dma1_channel3.Instance) {
 8000294:	4a09      	ldr	r2, [pc, #36]	; (80002bc <User_DMA_XferCpltCallback+0x34>)
 8000296:	6812      	ldr	r2, [r2, #0]
 8000298:	4293      	cmp	r3, r2
 800029a:	d006      	beq.n	80002aa <User_DMA_XferCpltCallback+0x22>
}
 800029c:	bd08      	pop	{r3, pc}
		osEventFlagsSet(velostatEventHandle, FlagVelostatDMAChn2_XferCplt);
 800029e:	2102      	movs	r1, #2
 80002a0:	4b07      	ldr	r3, [pc, #28]	; (80002c0 <User_DMA_XferCpltCallback+0x38>)
 80002a2:	6818      	ldr	r0, [r3, #0]
 80002a4:	f00b f9a8 	bl	800b5f8 <osEventFlagsSet>
 80002a8:	e7f8      	b.n	800029c <User_DMA_XferCpltCallback+0x14>
		osEventFlagsSet(velostatEventHandle, FlagVelostatDMAChn3_XferCplt);
 80002aa:	2120      	movs	r1, #32
 80002ac:	4b04      	ldr	r3, [pc, #16]	; (80002c0 <User_DMA_XferCpltCallback+0x38>)
 80002ae:	6818      	ldr	r0, [r3, #0]
 80002b0:	f00b f9a2 	bl	800b5f8 <osEventFlagsSet>
}
 80002b4:	e7f2      	b.n	800029c <User_DMA_XferCpltCallback+0x14>
 80002b6:	bf00      	nop
 80002b8:	20004424 	.word	0x20004424
 80002bc:	2000415c 	.word	0x2000415c
 80002c0:	20004474 	.word	0x20004474

080002c4 <StartHandStopServo>:
void StartHandStopServo(void *argument) {
 80002c4:	b508      	push	{r3, lr}
 80002c6:	e057      	b.n	8000378 <StartHandStopServo+0xb4>
			osEventFlagsClear(stopServoEventHandle, FlagStopServoBot1);
 80002c8:	2102      	movs	r1, #2
 80002ca:	6820      	ldr	r0, [r4, #0]
 80002cc:	f00b f9d2 	bl	800b674 <osEventFlagsClear>
			bot1->command = eServoStop;
 80002d0:	4b3f      	ldr	r3, [pc, #252]	; (80003d0 <StartHandStopServo+0x10c>)
 80002d2:	681b      	ldr	r3, [r3, #0]
 80002d4:	2200      	movs	r2, #0
 80002d6:	709a      	strb	r2, [r3, #2]
			osEventFlagsClear(handEventHandle, FlagHandBot1);
 80002d8:	2102      	movs	r1, #2
 80002da:	4b3e      	ldr	r3, [pc, #248]	; (80003d4 <StartHandStopServo+0x110>)
 80002dc:	6818      	ldr	r0, [r3, #0]
 80002de:	f00b f9c9 	bl	800b674 <osEventFlagsClear>
 80002e2:	e05a      	b.n	800039a <StartHandStopServo+0xd6>
			osEventFlagsClear(stopServoEventHandle, FlagStopServoBot2);
 80002e4:	2104      	movs	r1, #4
 80002e6:	4b3c      	ldr	r3, [pc, #240]	; (80003d8 <StartHandStopServo+0x114>)
 80002e8:	6818      	ldr	r0, [r3, #0]
 80002ea:	f00b f9c3 	bl	800b674 <osEventFlagsClear>
			bot2->command = eServoStop;
 80002ee:	4b3b      	ldr	r3, [pc, #236]	; (80003dc <StartHandStopServo+0x118>)
 80002f0:	681b      	ldr	r3, [r3, #0]
 80002f2:	2200      	movs	r2, #0
 80002f4:	709a      	strb	r2, [r3, #2]
			osEventFlagsClear(handEventHandle, FlagHandBot2);
 80002f6:	2108      	movs	r1, #8
 80002f8:	4b36      	ldr	r3, [pc, #216]	; (80003d4 <StartHandStopServo+0x110>)
 80002fa:	6818      	ldr	r0, [r3, #0]
 80002fc:	f00b f9ba 	bl	800b674 <osEventFlagsClear>
 8000300:	e050      	b.n	80003a4 <StartHandStopServo+0xe0>
			osEventFlagsClear(stopServoEventHandle, FlagStopServoBot3);
 8000302:	2108      	movs	r1, #8
 8000304:	4b34      	ldr	r3, [pc, #208]	; (80003d8 <StartHandStopServo+0x114>)
 8000306:	6818      	ldr	r0, [r3, #0]
 8000308:	f00b f9b4 	bl	800b674 <osEventFlagsClear>
			bot3->command = eServoStop;
 800030c:	4b34      	ldr	r3, [pc, #208]	; (80003e0 <StartHandStopServo+0x11c>)
 800030e:	681b      	ldr	r3, [r3, #0]
 8000310:	2200      	movs	r2, #0
 8000312:	709a      	strb	r2, [r3, #2]
			osEventFlagsClear(handEventHandle, FlagHandBot3);
 8000314:	2120      	movs	r1, #32
 8000316:	4b2f      	ldr	r3, [pc, #188]	; (80003d4 <StartHandStopServo+0x110>)
 8000318:	6818      	ldr	r0, [r3, #0]
 800031a:	f00b f9ab 	bl	800b674 <osEventFlagsClear>
 800031e:	e046      	b.n	80003ae <StartHandStopServo+0xea>
			osEventFlagsClear(stopServoEventHandle, FlagStopServoTop1);
 8000320:	2110      	movs	r1, #16
 8000322:	4b2d      	ldr	r3, [pc, #180]	; (80003d8 <StartHandStopServo+0x114>)
 8000324:	6818      	ldr	r0, [r3, #0]
 8000326:	f00b f9a5 	bl	800b674 <osEventFlagsClear>
			top1->command = eServoStop;
 800032a:	4b2e      	ldr	r3, [pc, #184]	; (80003e4 <StartHandStopServo+0x120>)
 800032c:	681b      	ldr	r3, [r3, #0]
 800032e:	2200      	movs	r2, #0
 8000330:	709a      	strb	r2, [r3, #2]
			osEventFlagsClear(handEventHandle, FlagHandTop1);
 8000332:	2104      	movs	r1, #4
 8000334:	4b27      	ldr	r3, [pc, #156]	; (80003d4 <StartHandStopServo+0x110>)
 8000336:	6818      	ldr	r0, [r3, #0]
 8000338:	f00b f99c 	bl	800b674 <osEventFlagsClear>
 800033c:	e03c      	b.n	80003b8 <StartHandStopServo+0xf4>
			osEventFlagsClear(stopServoEventHandle, FlagStopServoTop2);
 800033e:	2120      	movs	r1, #32
 8000340:	4b25      	ldr	r3, [pc, #148]	; (80003d8 <StartHandStopServo+0x114>)
 8000342:	6818      	ldr	r0, [r3, #0]
 8000344:	f00b f996 	bl	800b674 <osEventFlagsClear>
			top2->command = eServoStop;
 8000348:	4b27      	ldr	r3, [pc, #156]	; (80003e8 <StartHandStopServo+0x124>)
 800034a:	681b      	ldr	r3, [r3, #0]
 800034c:	2200      	movs	r2, #0
 800034e:	709a      	strb	r2, [r3, #2]
			osEventFlagsClear(handEventHandle, FlagHandTop2);
 8000350:	2110      	movs	r1, #16
 8000352:	4b20      	ldr	r3, [pc, #128]	; (80003d4 <StartHandStopServo+0x110>)
 8000354:	6818      	ldr	r0, [r3, #0]
 8000356:	f00b f98d 	bl	800b674 <osEventFlagsClear>
 800035a:	e032      	b.n	80003c2 <StartHandStopServo+0xfe>
			osEventFlagsClear(stopServoEventHandle, FlagStopServoTop3);
 800035c:	2140      	movs	r1, #64	; 0x40
 800035e:	4b1e      	ldr	r3, [pc, #120]	; (80003d8 <StartHandStopServo+0x114>)
 8000360:	6818      	ldr	r0, [r3, #0]
 8000362:	f00b f987 	bl	800b674 <osEventFlagsClear>
			top3->command = eServoStop;
 8000366:	4b21      	ldr	r3, [pc, #132]	; (80003ec <StartHandStopServo+0x128>)
 8000368:	681b      	ldr	r3, [r3, #0]
 800036a:	2200      	movs	r2, #0
 800036c:	709a      	strb	r2, [r3, #2]
			osEventFlagsClear(handEventHandle, FlagHandTop3);
 800036e:	2140      	movs	r1, #64	; 0x40
 8000370:	4b18      	ldr	r3, [pc, #96]	; (80003d4 <StartHandStopServo+0x110>)
 8000372:	6818      	ldr	r0, [r3, #0]
 8000374:	f00b f97e 	bl	800b674 <osEventFlagsClear>
		osEventFlagsWait(stopServoEventHandle,
 8000378:	4c17      	ldr	r4, [pc, #92]	; (80003d8 <StartHandStopServo+0x114>)
 800037a:	f04f 33ff 	mov.w	r3, #4294967295
 800037e:	2202      	movs	r2, #2
 8000380:	217e      	movs	r1, #126	; 0x7e
 8000382:	6820      	ldr	r0, [r4, #0]
 8000384:	f00b f9c4 	bl	800b710 <osEventFlagsWait>
		flag = osEventFlagsGet(stopServoEventHandle);
 8000388:	6820      	ldr	r0, [r4, #0]
 800038a:	f00b f9a3 	bl	800b6d4 <osEventFlagsGet>
 800038e:	4b18      	ldr	r3, [pc, #96]	; (80003f0 <StartHandStopServo+0x12c>)
 8000390:	6018      	str	r0, [r3, #0]
		if ((flag & FlagStopServoBot1) == FlagStopServoBot1) {
 8000392:	681b      	ldr	r3, [r3, #0]
 8000394:	f013 0f02 	tst.w	r3, #2
 8000398:	d196      	bne.n	80002c8 <StartHandStopServo+0x4>
		if ((flag & FlagStopServoBot2) == FlagStopServoBot2) {
 800039a:	4b15      	ldr	r3, [pc, #84]	; (80003f0 <StartHandStopServo+0x12c>)
 800039c:	681b      	ldr	r3, [r3, #0]
 800039e:	f013 0f04 	tst.w	r3, #4
 80003a2:	d19f      	bne.n	80002e4 <StartHandStopServo+0x20>
		if ((flag & FlagStopServoBot3) == FlagStopServoBot3) {
 80003a4:	4b12      	ldr	r3, [pc, #72]	; (80003f0 <StartHandStopServo+0x12c>)
 80003a6:	681b      	ldr	r3, [r3, #0]
 80003a8:	f013 0f08 	tst.w	r3, #8
 80003ac:	d1a9      	bne.n	8000302 <StartHandStopServo+0x3e>
		if ((flag & FlagStopServoTop1) == FlagStopServoTop1) {
 80003ae:	4b10      	ldr	r3, [pc, #64]	; (80003f0 <StartHandStopServo+0x12c>)
 80003b0:	681b      	ldr	r3, [r3, #0]
 80003b2:	f013 0f10 	tst.w	r3, #16
 80003b6:	d1b3      	bne.n	8000320 <StartHandStopServo+0x5c>
		if ((flag & FlagStopServoTop2) == FlagStopServoTop2) {
 80003b8:	4b0d      	ldr	r3, [pc, #52]	; (80003f0 <StartHandStopServo+0x12c>)
 80003ba:	681b      	ldr	r3, [r3, #0]
 80003bc:	f013 0f20 	tst.w	r3, #32
 80003c0:	d1bd      	bne.n	800033e <StartHandStopServo+0x7a>
		if ((flag & FlagStopServoTop3) == FlagStopServoTop3) {
 80003c2:	4b0b      	ldr	r3, [pc, #44]	; (80003f0 <StartHandStopServo+0x12c>)
 80003c4:	681b      	ldr	r3, [r3, #0]
 80003c6:	f013 0f40 	tst.w	r3, #64	; 0x40
 80003ca:	d0d5      	beq.n	8000378 <StartHandStopServo+0xb4>
 80003cc:	e7c6      	b.n	800035c <StartHandStopServo+0x98>
 80003ce:	bf00      	nop
 80003d0:	20004500 	.word	0x20004500
 80003d4:	200044f8 	.word	0x200044f8
 80003d8:	200044ec 	.word	0x200044ec
 80003dc:	200044fc 	.word	0x200044fc
 80003e0:	20004408 	.word	0x20004408
 80003e4:	20004418 	.word	0x20004418
 80003e8:	20004138 	.word	0x20004138
 80003ec:	20004150 	.word	0x20004150
 80003f0:	20000058 	.word	0x20000058

080003f4 <StartButtonHandler>:
void StartButtonHandler(void *argument) {
 80003f4:	b508      	push	{r3, lr}
 80003f6:	e010      	b.n	800041a <StartButtonHandler+0x26>
			if ((osEventFlagsGet(velostatEventHandle) & FlagVelostatEnable)
 80003f8:	4b45      	ldr	r3, [pc, #276]	; (8000510 <StartButtonHandler+0x11c>)
 80003fa:	6818      	ldr	r0, [r3, #0]
 80003fc:	f00b f96a 	bl	800b6d4 <osEventFlagsGet>
 8000400:	f010 0f80 	tst.w	r0, #128	; 0x80
 8000404:	d050      	beq.n	80004a8 <StartButtonHandler+0xb4>
				osEventFlagsClear(velostatEventHandle, FlagVelostatEnable);
 8000406:	2180      	movs	r1, #128	; 0x80
 8000408:	4b41      	ldr	r3, [pc, #260]	; (8000510 <StartButtonHandler+0x11c>)
 800040a:	6818      	ldr	r0, [r3, #0]
 800040c:	f00b f932 	bl	800b674 <osEventFlagsClear>
		if (isPress) {
 8000410:	4b40      	ldr	r3, [pc, #256]	; (8000514 <StartButtonHandler+0x120>)
 8000412:	881b      	ldrh	r3, [r3, #0]
 8000414:	b29b      	uxth	r3, r3
 8000416:	2b00      	cmp	r3, #0
 8000418:	d170      	bne.n	80004fc <StartButtonHandler+0x108>
		osThreadFlagsWait(1u, osFlagsWaitAll, osWaitForever);
 800041a:	f04f 32ff 	mov.w	r2, #4294967295
 800041e:	2101      	movs	r1, #1
 8000420:	4608      	mov	r0, r1
 8000422:	f00a fed1 	bl	800b1c8 <osThreadFlagsWait>
		switch (btn) {
 8000426:	4b3c      	ldr	r3, [pc, #240]	; (8000518 <StartButtonHandler+0x124>)
 8000428:	881b      	ldrh	r3, [r3, #0]
 800042a:	b29b      	uxth	r3, r3
 800042c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000430:	d0e2      	beq.n	80003f8 <StartButtonHandler+0x4>
 8000432:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8000436:	d1eb      	bne.n	8000410 <StartButtonHandler+0x1c>
			if ((osEventFlagsGet(velostatEventHandle) & FlagVelostatEnable)
 8000438:	4b35      	ldr	r3, [pc, #212]	; (8000510 <StartButtonHandler+0x11c>)
 800043a:	6818      	ldr	r0, [r3, #0]
 800043c:	f00b f94a 	bl	800b6d4 <osEventFlagsGet>
 8000440:	f010 0f80 	tst.w	r0, #128	; 0x80
 8000444:	d0e4      	beq.n	8000410 <StartButtonHandler+0x1c>
				if ((osEventFlagsGet(handEventHandle)
 8000446:	4b35      	ldr	r3, [pc, #212]	; (800051c <StartButtonHandler+0x128>)
 8000448:	6818      	ldr	r0, [r3, #0]
 800044a:	f00b f943 	bl	800b6d4 <osEventFlagsGet>
 800044e:	f010 0f80 	tst.w	r0, #128	; 0x80
 8000452:	d02f      	beq.n	80004b4 <StartButtonHandler+0xc0>
					osEventFlagsClear(handEventHandle,
 8000454:	2180      	movs	r1, #128	; 0x80
 8000456:	4b31      	ldr	r3, [pc, #196]	; (800051c <StartButtonHandler+0x128>)
 8000458:	6818      	ldr	r0, [r3, #0]
 800045a:	f00b f90b 	bl	800b674 <osEventFlagsClear>
					HAL_GPIO_WritePin(LEDGreen_GPIO_Port, LEDGreen_Pin,
 800045e:	2201      	movs	r2, #1
 8000460:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000464:	482e      	ldr	r0, [pc, #184]	; (8000520 <StartButtonHandler+0x12c>)
 8000466:	f003 fe44 	bl	80040f2 <HAL_GPIO_WritePin>
					vServoMove1(bot1, eServoUp);
 800046a:	2103      	movs	r1, #3
 800046c:	4b2d      	ldr	r3, [pc, #180]	; (8000524 <StartButtonHandler+0x130>)
 800046e:	6818      	ldr	r0, [r3, #0]
 8000470:	f00f fa89 	bl	800f986 <vServoMove1>
					vServoMove1(bot2, eServoUp);
 8000474:	2103      	movs	r1, #3
 8000476:	4b2c      	ldr	r3, [pc, #176]	; (8000528 <StartButtonHandler+0x134>)
 8000478:	6818      	ldr	r0, [r3, #0]
 800047a:	f00f fa84 	bl	800f986 <vServoMove1>
					vServoMove1(bot3, eServoUp);
 800047e:	2103      	movs	r1, #3
 8000480:	4b2a      	ldr	r3, [pc, #168]	; (800052c <StartButtonHandler+0x138>)
 8000482:	6818      	ldr	r0, [r3, #0]
 8000484:	f00f fa7f 	bl	800f986 <vServoMove1>
					vServoMove1(top1, eServoUp);
 8000488:	2103      	movs	r1, #3
 800048a:	4b29      	ldr	r3, [pc, #164]	; (8000530 <StartButtonHandler+0x13c>)
 800048c:	6818      	ldr	r0, [r3, #0]
 800048e:	f00f fa7a 	bl	800f986 <vServoMove1>
					vServoMove1(top2, eServoUp);
 8000492:	2103      	movs	r1, #3
 8000494:	4b27      	ldr	r3, [pc, #156]	; (8000534 <StartButtonHandler+0x140>)
 8000496:	6818      	ldr	r0, [r3, #0]
 8000498:	f00f fa75 	bl	800f986 <vServoMove1>
					vServoMove1(top3, eServoUp);
 800049c:	2103      	movs	r1, #3
 800049e:	4b26      	ldr	r3, [pc, #152]	; (8000538 <StartButtonHandler+0x144>)
 80004a0:	6818      	ldr	r0, [r3, #0]
 80004a2:	f00f fa70 	bl	800f986 <vServoMove1>
 80004a6:	e7b3      	b.n	8000410 <StartButtonHandler+0x1c>
				osEventFlagsSet(velostatEventHandle, FlagVelostatEnable);
 80004a8:	2180      	movs	r1, #128	; 0x80
 80004aa:	4b19      	ldr	r3, [pc, #100]	; (8000510 <StartButtonHandler+0x11c>)
 80004ac:	6818      	ldr	r0, [r3, #0]
 80004ae:	f00b f8a3 	bl	800b5f8 <osEventFlagsSet>
 80004b2:	e7ad      	b.n	8000410 <StartButtonHandler+0x1c>
					osEventFlagsSet(handEventHandle,
 80004b4:	2180      	movs	r1, #128	; 0x80
 80004b6:	4b19      	ldr	r3, [pc, #100]	; (800051c <StartButtonHandler+0x128>)
 80004b8:	6818      	ldr	r0, [r3, #0]
 80004ba:	f00b f89d 	bl	800b5f8 <osEventFlagsSet>
					HAL_GPIO_WritePin(LEDGreen_GPIO_Port, LEDGreen_Pin,
 80004be:	2200      	movs	r2, #0
 80004c0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80004c4:	4816      	ldr	r0, [pc, #88]	; (8000520 <StartButtonHandler+0x12c>)
 80004c6:	f003 fe14 	bl	80040f2 <HAL_GPIO_WritePin>
					flag12 = 0;
 80004ca:	2300      	movs	r3, #0
 80004cc:	4a1b      	ldr	r2, [pc, #108]	; (800053c <StartButtonHandler+0x148>)
 80004ce:	7013      	strb	r3, [r2, #0]
					flag13 = 0;
 80004d0:	4a1b      	ldr	r2, [pc, #108]	; (8000540 <StartButtonHandler+0x14c>)
 80004d2:	7013      	strb	r3, [r2, #0]
					flag123 = 0;
 80004d4:	4a1b      	ldr	r2, [pc, #108]	; (8000544 <StartButtonHandler+0x150>)
 80004d6:	7013      	strb	r3, [r2, #0]
					countRun = 0;
 80004d8:	4a1b      	ldr	r2, [pc, #108]	; (8000548 <StartButtonHandler+0x154>)
 80004da:	6013      	str	r3, [r2, #0]
					vServoMove1(bot1, eServoDown);
 80004dc:	2104      	movs	r1, #4
 80004de:	4b11      	ldr	r3, [pc, #68]	; (8000524 <StartButtonHandler+0x130>)
 80004e0:	6818      	ldr	r0, [r3, #0]
 80004e2:	f00f fa50 	bl	800f986 <vServoMove1>
					vServoMove1(bot2, eServoDown);
 80004e6:	2104      	movs	r1, #4
 80004e8:	4b0f      	ldr	r3, [pc, #60]	; (8000528 <StartButtonHandler+0x134>)
 80004ea:	6818      	ldr	r0, [r3, #0]
 80004ec:	f00f fa4b 	bl	800f986 <vServoMove1>
					vServoMove1(bot3, eServoDown);
 80004f0:	2104      	movs	r1, #4
 80004f2:	4b0e      	ldr	r3, [pc, #56]	; (800052c <StartButtonHandler+0x138>)
 80004f4:	6818      	ldr	r0, [r3, #0]
 80004f6:	f00f fa46 	bl	800f986 <vServoMove1>
 80004fa:	e789      	b.n	8000410 <StartButtonHandler+0x1c>
			isPress = 0u;
 80004fc:	4b05      	ldr	r3, [pc, #20]	; (8000514 <StartButtonHandler+0x120>)
 80004fe:	2200      	movs	r2, #0
 8000500:	801a      	strh	r2, [r3, #0]
			osTimerStart(myTimer01Handle, 1000u);
 8000502:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8000506:	4b11      	ldr	r3, [pc, #68]	; (800054c <StartButtonHandler+0x158>)
 8000508:	6818      	ldr	r0, [r3, #0]
 800050a:	f00a ff89 	bl	800b420 <osTimerStart>
 800050e:	e784      	b.n	800041a <StartButtonHandler+0x26>
 8000510:	20004474 	.word	0x20004474
 8000514:	2000440c 	.word	0x2000440c
 8000518:	200044f4 	.word	0x200044f4
 800051c:	200044f8 	.word	0x200044f8
 8000520:	40011000 	.word	0x40011000
 8000524:	20004500 	.word	0x20004500
 8000528:	200044fc 	.word	0x200044fc
 800052c:	20004408 	.word	0x20004408
 8000530:	20004418 	.word	0x20004418
 8000534:	20004138 	.word	0x20004138
 8000538:	20004150 	.word	0x20004150
 800053c:	2000446c 	.word	0x2000446c
 8000540:	20004148 	.word	0x20004148
 8000544:	20004234 	.word	0x20004234
 8000548:	20000054 	.word	0x20000054
 800054c:	20004420 	.word	0x20004420

08000550 <HAL_ADC_ConvCpltCallback>:
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
 8000550:	b508      	push	{r3, lr}
	if (hadc->Instance == ADC1)
 8000552:	6802      	ldr	r2, [r0, #0]
 8000554:	4b04      	ldr	r3, [pc, #16]	; (8000568 <HAL_ADC_ConvCpltCallback+0x18>)
 8000556:	429a      	cmp	r2, r3
 8000558:	d000      	beq.n	800055c <HAL_ADC_ConvCpltCallback+0xc>
}
 800055a:	bd08      	pop	{r3, pc}
		osEventFlagsSet(velostatEventHandle, FlagVelostatADC_ConvCplt);
 800055c:	2101      	movs	r1, #1
 800055e:	4b03      	ldr	r3, [pc, #12]	; (800056c <HAL_ADC_ConvCpltCallback+0x1c>)
 8000560:	6818      	ldr	r0, [r3, #0]
 8000562:	f00b f849 	bl	800b5f8 <osEventFlagsSet>
}
 8000566:	e7f8      	b.n	800055a <HAL_ADC_ConvCpltCallback+0xa>
 8000568:	40012400 	.word	0x40012400
 800056c:	20004474 	.word	0x20004474

08000570 <HAL_UART_TxCpltCallback>:
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
 8000570:	b508      	push	{r3, lr}
	if (huart->Instance == USART1) {
 8000572:	6802      	ldr	r2, [r0, #0]
 8000574:	4b05      	ldr	r3, [pc, #20]	; (800058c <HAL_UART_TxCpltCallback+0x1c>)
 8000576:	429a      	cmp	r2, r3
 8000578:	d000      	beq.n	800057c <HAL_UART_TxCpltCallback+0xc>
}
 800057a:	bd08      	pop	{r3, pc}
		endTx = HAL_GetTick() - startTx;
 800057c:	f001 fcae 	bl	8001edc <HAL_GetTick>
 8000580:	4b03      	ldr	r3, [pc, #12]	; (8000590 <HAL_UART_TxCpltCallback+0x20>)
 8000582:	681b      	ldr	r3, [r3, #0]
 8000584:	1ac0      	subs	r0, r0, r3
 8000586:	4b03      	ldr	r3, [pc, #12]	; (8000594 <HAL_UART_TxCpltCallback+0x24>)
 8000588:	6018      	str	r0, [r3, #0]
}
 800058a:	e7f6      	b.n	800057a <HAL_UART_TxCpltCallback+0xa>
 800058c:	40013800 	.word	0x40013800
 8000590:	20004228 	.word	0x20004228
 8000594:	200044dc 	.word	0x200044dc

08000598 <HAL_UART_RxCpltCallback>:
	if (huart->Instance == USART1) {
 8000598:	6802      	ldr	r2, [r0, #0]
 800059a:	4b09      	ldr	r3, [pc, #36]	; (80005c0 <HAL_UART_RxCpltCallback+0x28>)
 800059c:	429a      	cmp	r2, r3
 800059e:	d000      	beq.n	80005a2 <HAL_UART_RxCpltCallback+0xa>
 80005a0:	4770      	bx	lr
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
 80005a2:	b510      	push	{r4, lr}
 80005a4:	4604      	mov	r4, r0
		osEventFlagsSet(handEventHandle, FlagHandUART_RxCplt);
 80005a6:	2101      	movs	r1, #1
 80005a8:	4b06      	ldr	r3, [pc, #24]	; (80005c4 <HAL_UART_RxCpltCallback+0x2c>)
 80005aa:	6818      	ldr	r0, [r3, #0]
 80005ac:	f00b f824 	bl	800b5f8 <osEventFlagsSet>
		HAL_UART_Receive_DMA(huart, rxData, NumberOfRxData);
 80005b0:	2215      	movs	r2, #21
 80005b2:	4b05      	ldr	r3, [pc, #20]	; (80005c8 <HAL_UART_RxCpltCallback+0x30>)
 80005b4:	6819      	ldr	r1, [r3, #0]
 80005b6:	4620      	mov	r0, r4
 80005b8:	f00a f988 	bl	800a8cc <HAL_UART_Receive_DMA>
}
 80005bc:	bd10      	pop	{r4, pc}
 80005be:	bf00      	nop
 80005c0:	40013800 	.word	0x40013800
 80005c4:	200044f8 	.word	0x200044f8
 80005c8:	2000413c 	.word	0x2000413c

080005cc <HAL_GPIO_EXTI_Callback>:
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
 80005cc:	b508      	push	{r3, lr}
	if (flagTimer) {
 80005ce:	4b09      	ldr	r3, [pc, #36]	; (80005f4 <HAL_GPIO_EXTI_Callback+0x28>)
 80005d0:	881b      	ldrh	r3, [r3, #0]
 80005d2:	b29b      	uxth	r3, r3
 80005d4:	b903      	cbnz	r3, 80005d8 <HAL_GPIO_EXTI_Callback+0xc>
}
 80005d6:	bd08      	pop	{r3, pc}
		flagTimer = 0u;
 80005d8:	4b06      	ldr	r3, [pc, #24]	; (80005f4 <HAL_GPIO_EXTI_Callback+0x28>)
 80005da:	2200      	movs	r2, #0
 80005dc:	801a      	strh	r2, [r3, #0]
		btn = GPIO_Pin;
 80005de:	4b06      	ldr	r3, [pc, #24]	; (80005f8 <HAL_GPIO_EXTI_Callback+0x2c>)
 80005e0:	8018      	strh	r0, [r3, #0]
		isPress = 1u;
 80005e2:	2101      	movs	r1, #1
 80005e4:	4b05      	ldr	r3, [pc, #20]	; (80005fc <HAL_GPIO_EXTI_Callback+0x30>)
 80005e6:	8019      	strh	r1, [r3, #0]
		osThreadFlagsSet(ButtonHandlerHandle, 1u);
 80005e8:	4b05      	ldr	r3, [pc, #20]	; (8000600 <HAL_GPIO_EXTI_Callback+0x34>)
 80005ea:	6818      	ldr	r0, [r3, #0]
 80005ec:	f00a fd40 	bl	800b070 <osThreadFlagsSet>
}
 80005f0:	e7f1      	b.n	80005d6 <HAL_GPIO_EXTI_Callback+0xa>
 80005f2:	bf00      	nop
 80005f4:	200044d4 	.word	0x200044d4
 80005f8:	200044f4 	.word	0x200044f4
 80005fc:	2000440c 	.word	0x2000440c
 8000600:	200044f0 	.word	0x200044f0

08000604 <HAL_TIM_PeriodElapsedCallback>:
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 8000604:	b508      	push	{r3, lr}
	/* USER CODE BEGIN Callback 0 */

	/* USER CODE END Callback 0 */
	if (htim->Instance == TIM1) {
 8000606:	6802      	ldr	r2, [r0, #0]
 8000608:	4b03      	ldr	r3, [pc, #12]	; (8000618 <HAL_TIM_PeriodElapsedCallback+0x14>)
 800060a:	429a      	cmp	r2, r3
 800060c:	d000      	beq.n	8000610 <HAL_TIM_PeriodElapsedCallback+0xc>
		HAL_IncTick();
	}
	/* USER CODE BEGIN Callback 1 */

	/* USER CODE END Callback 1 */
}
 800060e:	bd08      	pop	{r3, pc}
		HAL_IncTick();
 8000610:	f001 fc58 	bl	8001ec4 <HAL_IncTick>
}
 8000614:	e7fb      	b.n	800060e <HAL_TIM_PeriodElapsedCallback+0xa>
 8000616:	bf00      	nop
 8000618:	40012c00 	.word	0x40012c00

0800061c <Error_Handler>:
  __ASM volatile ("cpsid i" : : : "memory");
 800061c:	b672      	cpsid	i
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
 800061e:	e7fe      	b.n	800061e <Error_Handler+0x2>

08000620 <MX_DMA_Init>:
static void MX_DMA_Init(void) {
 8000620:	b500      	push	{lr}
 8000622:	b083      	sub	sp, #12
	__HAL_RCC_DMA1_CLK_ENABLE();
 8000624:	4b33      	ldr	r3, [pc, #204]	; (80006f4 <MX_DMA_Init+0xd4>)
 8000626:	695a      	ldr	r2, [r3, #20]
 8000628:	f042 0201 	orr.w	r2, r2, #1
 800062c:	615a      	str	r2, [r3, #20]
 800062e:	695b      	ldr	r3, [r3, #20]
 8000630:	f003 0301 	and.w	r3, r3, #1
 8000634:	9301      	str	r3, [sp, #4]
 8000636:	9b01      	ldr	r3, [sp, #4]
	hdma_memtomem_dma1_channel2.Instance = DMA1_Channel2;
 8000638:	482f      	ldr	r0, [pc, #188]	; (80006f8 <MX_DMA_Init+0xd8>)
 800063a:	4b30      	ldr	r3, [pc, #192]	; (80006fc <MX_DMA_Init+0xdc>)
 800063c:	6003      	str	r3, [r0, #0]
	hdma_memtomem_dma1_channel2.Init.Direction = DMA_MEMORY_TO_MEMORY;
 800063e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000642:	6043      	str	r3, [r0, #4]
	hdma_memtomem_dma1_channel2.Init.PeriphInc = DMA_PINC_ENABLE;
 8000644:	2340      	movs	r3, #64	; 0x40
 8000646:	6083      	str	r3, [r0, #8]
	hdma_memtomem_dma1_channel2.Init.MemInc = DMA_MINC_ENABLE;
 8000648:	2380      	movs	r3, #128	; 0x80
 800064a:	60c3      	str	r3, [r0, #12]
	hdma_memtomem_dma1_channel2.Init.PeriphDataAlignment =
 800064c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000650:	6103      	str	r3, [r0, #16]
	hdma_memtomem_dma1_channel2.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8000652:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000656:	6143      	str	r3, [r0, #20]
	hdma_memtomem_dma1_channel2.Init.Mode = DMA_NORMAL;
 8000658:	2300      	movs	r3, #0
 800065a:	6183      	str	r3, [r0, #24]
	hdma_memtomem_dma1_channel2.Init.Priority = DMA_PRIORITY_LOW;
 800065c:	61c3      	str	r3, [r0, #28]
	if (HAL_DMA_Init(&hdma_memtomem_dma1_channel2) != HAL_OK) {
 800065e:	f003 f86d 	bl	800373c <HAL_DMA_Init>
 8000662:	2800      	cmp	r0, #0
 8000664:	d142      	bne.n	80006ec <MX_DMA_Init+0xcc>
	hdma_memtomem_dma1_channel3.Instance = DMA1_Channel3;
 8000666:	4826      	ldr	r0, [pc, #152]	; (8000700 <MX_DMA_Init+0xe0>)
 8000668:	4b26      	ldr	r3, [pc, #152]	; (8000704 <MX_DMA_Init+0xe4>)
 800066a:	6003      	str	r3, [r0, #0]
	hdma_memtomem_dma1_channel3.Init.Direction = DMA_MEMORY_TO_MEMORY;
 800066c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000670:	6043      	str	r3, [r0, #4]
	hdma_memtomem_dma1_channel3.Init.PeriphInc = DMA_PINC_ENABLE;
 8000672:	2340      	movs	r3, #64	; 0x40
 8000674:	6083      	str	r3, [r0, #8]
	hdma_memtomem_dma1_channel3.Init.MemInc = DMA_MINC_ENABLE;
 8000676:	2380      	movs	r3, #128	; 0x80
 8000678:	60c3      	str	r3, [r0, #12]
	hdma_memtomem_dma1_channel3.Init.PeriphDataAlignment =
 800067a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800067e:	6103      	str	r3, [r0, #16]
	hdma_memtomem_dma1_channel3.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8000680:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000684:	6143      	str	r3, [r0, #20]
	hdma_memtomem_dma1_channel3.Init.Mode = DMA_NORMAL;
 8000686:	2300      	movs	r3, #0
 8000688:	6183      	str	r3, [r0, #24]
	hdma_memtomem_dma1_channel3.Init.Priority = DMA_PRIORITY_MEDIUM;
 800068a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800068e:	61c3      	str	r3, [r0, #28]
	if (HAL_DMA_Init(&hdma_memtomem_dma1_channel3) != HAL_OK) {
 8000690:	f003 f854 	bl	800373c <HAL_DMA_Init>
 8000694:	bb60      	cbnz	r0, 80006f0 <MX_DMA_Init+0xd0>
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
 8000696:	2200      	movs	r2, #0
 8000698:	2105      	movs	r1, #5
 800069a:	200b      	movs	r0, #11
 800069c:	f002 ff2e 	bl	80034fc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 80006a0:	200b      	movs	r0, #11
 80006a2:	f002 ff5f 	bl	8003564 <HAL_NVIC_EnableIRQ>
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
 80006a6:	2200      	movs	r2, #0
 80006a8:	2105      	movs	r1, #5
 80006aa:	200c      	movs	r0, #12
 80006ac:	f002 ff26 	bl	80034fc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
 80006b0:	200c      	movs	r0, #12
 80006b2:	f002 ff57 	bl	8003564 <HAL_NVIC_EnableIRQ>
	HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 5, 0);
 80006b6:	2200      	movs	r2, #0
 80006b8:	2105      	movs	r1, #5
 80006ba:	200d      	movs	r0, #13
 80006bc:	f002 ff1e 	bl	80034fc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
 80006c0:	200d      	movs	r0, #13
 80006c2:	f002 ff4f 	bl	8003564 <HAL_NVIC_EnableIRQ>
	HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 5, 0);
 80006c6:	2200      	movs	r2, #0
 80006c8:	2105      	movs	r1, #5
 80006ca:	200e      	movs	r0, #14
 80006cc:	f002 ff16 	bl	80034fc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
 80006d0:	200e      	movs	r0, #14
 80006d2:	f002 ff47 	bl	8003564 <HAL_NVIC_EnableIRQ>
	HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 5, 0);
 80006d6:	2200      	movs	r2, #0
 80006d8:	2105      	movs	r1, #5
 80006da:	200f      	movs	r0, #15
 80006dc:	f002 ff0e 	bl	80034fc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 80006e0:	200f      	movs	r0, #15
 80006e2:	f002 ff3f 	bl	8003564 <HAL_NVIC_EnableIRQ>
}
 80006e6:	b003      	add	sp, #12
 80006e8:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 80006ec:	f7ff ff96 	bl	800061c <Error_Handler>
		Error_Handler();
 80006f0:	f7ff ff94 	bl	800061c <Error_Handler>
 80006f4:	40021000 	.word	0x40021000
 80006f8:	20004424 	.word	0x20004424
 80006fc:	4002001c 	.word	0x4002001c
 8000700:	2000415c 	.word	0x2000415c
 8000704:	40020030 	.word	0x40020030

08000708 <MX_ADC1_Init>:
static void MX_ADC1_Init(void) {
 8000708:	b500      	push	{lr}
 800070a:	b085      	sub	sp, #20
	ADC_MultiModeTypeDef multimode = { 0 };
 800070c:	2300      	movs	r3, #0
 800070e:	9303      	str	r3, [sp, #12]
	ADC_ChannelConfTypeDef sConfig = { 0 };
 8000710:	9300      	str	r3, [sp, #0]
 8000712:	9301      	str	r3, [sp, #4]
 8000714:	9302      	str	r3, [sp, #8]
	hadc1.Instance = ADC1;
 8000716:	482d      	ldr	r0, [pc, #180]	; (80007cc <MX_ADC1_Init+0xc4>)
 8000718:	4a2d      	ldr	r2, [pc, #180]	; (80007d0 <MX_ADC1_Init+0xc8>)
 800071a:	6002      	str	r2, [r0, #0]
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 800071c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000720:	6082      	str	r2, [r0, #8]
	hadc1.Init.ContinuousConvMode = DISABLE;
 8000722:	7303      	strb	r3, [r0, #12]
	hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000724:	7503      	strb	r3, [r0, #20]
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000726:	f44f 2260 	mov.w	r2, #917504	; 0xe0000
 800072a:	61c2      	str	r2, [r0, #28]
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800072c:	6043      	str	r3, [r0, #4]
	hadc1.Init.NbrOfConversion = 5;
 800072e:	2305      	movs	r3, #5
 8000730:	6103      	str	r3, [r0, #16]
	if (HAL_ADC_Init(&hadc1) != HAL_OK) {
 8000732:	f002 f8f2 	bl	800291a <HAL_ADC_Init>
 8000736:	2800      	cmp	r0, #0
 8000738:	d139      	bne.n	80007ae <MX_ADC1_Init+0xa6>
	multimode.Mode = ADC_DUALMODE_REGSIMULT;
 800073a:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
 800073e:	9303      	str	r3, [sp, #12]
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK) {
 8000740:	a903      	add	r1, sp, #12
 8000742:	4822      	ldr	r0, [pc, #136]	; (80007cc <MX_ADC1_Init+0xc4>)
 8000744:	f002 fe9c 	bl	8003480 <HAL_ADCEx_MultiModeConfigChannel>
 8000748:	2800      	cmp	r0, #0
 800074a:	d132      	bne.n	80007b2 <MX_ADC1_Init+0xaa>
	sConfig.Channel = ADC_CHANNEL_0;
 800074c:	2300      	movs	r3, #0
 800074e:	9300      	str	r3, [sp, #0]
	sConfig.Rank = ADC_REGULAR_RANK_1;
 8000750:	2301      	movs	r3, #1
 8000752:	9301      	str	r3, [sp, #4]
	sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
 8000754:	2307      	movs	r3, #7
 8000756:	9302      	str	r3, [sp, #8]
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 8000758:	4669      	mov	r1, sp
 800075a:	481c      	ldr	r0, [pc, #112]	; (80007cc <MX_ADC1_Init+0xc4>)
 800075c:	f001 fe1a 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000760:	bb48      	cbnz	r0, 80007b6 <MX_ADC1_Init+0xae>
	sConfig.Channel = ADC_CHANNEL_2;
 8000762:	2302      	movs	r3, #2
 8000764:	9300      	str	r3, [sp, #0]
	sConfig.Rank = ADC_REGULAR_RANK_2;
 8000766:	9301      	str	r3, [sp, #4]
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 8000768:	4669      	mov	r1, sp
 800076a:	4818      	ldr	r0, [pc, #96]	; (80007cc <MX_ADC1_Init+0xc4>)
 800076c:	f001 fe12 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000770:	bb18      	cbnz	r0, 80007ba <MX_ADC1_Init+0xb2>
	sConfig.Channel = ADC_CHANNEL_4;
 8000772:	2304      	movs	r3, #4
 8000774:	9300      	str	r3, [sp, #0]
	sConfig.Rank = ADC_REGULAR_RANK_3;
 8000776:	2303      	movs	r3, #3
 8000778:	9301      	str	r3, [sp, #4]
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 800077a:	4669      	mov	r1, sp
 800077c:	4813      	ldr	r0, [pc, #76]	; (80007cc <MX_ADC1_Init+0xc4>)
 800077e:	f001 fe09 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000782:	b9e0      	cbnz	r0, 80007be <MX_ADC1_Init+0xb6>
	sConfig.Channel = ADC_CHANNEL_6;
 8000784:	2306      	movs	r3, #6
 8000786:	9300      	str	r3, [sp, #0]
	sConfig.Rank = ADC_REGULAR_RANK_4;
 8000788:	2304      	movs	r3, #4
 800078a:	9301      	str	r3, [sp, #4]
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 800078c:	4669      	mov	r1, sp
 800078e:	480f      	ldr	r0, [pc, #60]	; (80007cc <MX_ADC1_Init+0xc4>)
 8000790:	f001 fe00 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000794:	b9a8      	cbnz	r0, 80007c2 <MX_ADC1_Init+0xba>
	sConfig.Channel = ADC_CHANNEL_8;
 8000796:	2308      	movs	r3, #8
 8000798:	9300      	str	r3, [sp, #0]
	sConfig.Rank = ADC_REGULAR_RANK_5;
 800079a:	2305      	movs	r3, #5
 800079c:	9301      	str	r3, [sp, #4]
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 800079e:	4669      	mov	r1, sp
 80007a0:	480a      	ldr	r0, [pc, #40]	; (80007cc <MX_ADC1_Init+0xc4>)
 80007a2:	f001 fdf7 	bl	8002394 <HAL_ADC_ConfigChannel>
 80007a6:	b970      	cbnz	r0, 80007c6 <MX_ADC1_Init+0xbe>
}
 80007a8:	b005      	add	sp, #20
 80007aa:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 80007ae:	f7ff ff35 	bl	800061c <Error_Handler>
		Error_Handler();
 80007b2:	f7ff ff33 	bl	800061c <Error_Handler>
		Error_Handler();
 80007b6:	f7ff ff31 	bl	800061c <Error_Handler>
		Error_Handler();
 80007ba:	f7ff ff2f 	bl	800061c <Error_Handler>
		Error_Handler();
 80007be:	f7ff ff2d 	bl	800061c <Error_Handler>
		Error_Handler();
 80007c2:	f7ff ff2b 	bl	800061c <Error_Handler>
		Error_Handler();
 80007c6:	f7ff ff29 	bl	800061c <Error_Handler>
 80007ca:	bf00      	nop
 80007cc:	200042d8 	.word	0x200042d8
 80007d0:	40012400 	.word	0x40012400

080007d4 <MX_USART1_UART_Init>:
static void MX_USART1_UART_Init(void) {
 80007d4:	b508      	push	{r3, lr}
	huart1.Instance = USART1;
 80007d6:	480a      	ldr	r0, [pc, #40]	; (8000800 <MX_USART1_UART_Init+0x2c>)
 80007d8:	4b0a      	ldr	r3, [pc, #40]	; (8000804 <MX_USART1_UART_Init+0x30>)
 80007da:	6003      	str	r3, [r0, #0]
	huart1.Init.BaudRate = 115200;
 80007dc:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80007e0:	6043      	str	r3, [r0, #4]
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80007e2:	2300      	movs	r3, #0
 80007e4:	6083      	str	r3, [r0, #8]
	huart1.Init.StopBits = UART_STOPBITS_1;
 80007e6:	60c3      	str	r3, [r0, #12]
	huart1.Init.Parity = UART_PARITY_NONE;
 80007e8:	6103      	str	r3, [r0, #16]
	huart1.Init.Mode = UART_MODE_TX_RX;
 80007ea:	220c      	movs	r2, #12
 80007ec:	6142      	str	r2, [r0, #20]
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80007ee:	6183      	str	r3, [r0, #24]
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80007f0:	61c3      	str	r3, [r0, #28]
	if (HAL_UART_Init(&huart1) != HAL_OK) {
 80007f2:	f008 ffd4 	bl	800979e <HAL_UART_Init>
 80007f6:	b900      	cbnz	r0, 80007fa <MX_USART1_UART_Init+0x26>
}
 80007f8:	bd08      	pop	{r3, pc}
		Error_Handler();
 80007fa:	f7ff ff0f 	bl	800061c <Error_Handler>
 80007fe:	bf00      	nop
 8000800:	20004360 	.word	0x20004360
 8000804:	40013800 	.word	0x40013800

08000808 <MX_TIM2_Init>:
static void MX_TIM2_Init(void) {
 8000808:	b500      	push	{lr}
 800080a:	b08f      	sub	sp, #60	; 0x3c
	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
 800080c:	2300      	movs	r3, #0
 800080e:	930a      	str	r3, [sp, #40]	; 0x28
 8000810:	930b      	str	r3, [sp, #44]	; 0x2c
 8000812:	930c      	str	r3, [sp, #48]	; 0x30
 8000814:	930d      	str	r3, [sp, #52]	; 0x34
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
 8000816:	9308      	str	r3, [sp, #32]
 8000818:	9309      	str	r3, [sp, #36]	; 0x24
	TIM_OC_InitTypeDef sConfigOC = { 0 };
 800081a:	9301      	str	r3, [sp, #4]
 800081c:	9302      	str	r3, [sp, #8]
 800081e:	9303      	str	r3, [sp, #12]
 8000820:	9304      	str	r3, [sp, #16]
 8000822:	9305      	str	r3, [sp, #20]
 8000824:	9306      	str	r3, [sp, #24]
 8000826:	9307      	str	r3, [sp, #28]
	htim2.Instance = TIM2;
 8000828:	4824      	ldr	r0, [pc, #144]	; (80008bc <MX_TIM2_Init+0xb4>)
 800082a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800082e:	6002      	str	r2, [r0, #0]
	htim2.Init.Prescaler = 1440 - 1;
 8000830:	f240 529f 	movw	r2, #1439	; 0x59f
 8000834:	6042      	str	r2, [r0, #4]
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000836:	6083      	str	r3, [r0, #8]
	htim2.Init.Period = 1000 - 1;
 8000838:	f240 32e7 	movw	r2, #999	; 0x3e7
 800083c:	60c2      	str	r2, [r0, #12]
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800083e:	6103      	str	r3, [r0, #16]
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8000840:	2380      	movs	r3, #128	; 0x80
 8000842:	6183      	str	r3, [r0, #24]
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK) {
 8000844:	f005 f9ba 	bl	8005bbc <HAL_TIM_Base_Init>
 8000848:	bb58      	cbnz	r0, 80008a2 <MX_TIM2_Init+0x9a>
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800084a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800084e:	930a      	str	r3, [sp, #40]	; 0x28
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) {
 8000850:	a90a      	add	r1, sp, #40	; 0x28
 8000852:	481a      	ldr	r0, [pc, #104]	; (80008bc <MX_TIM2_Init+0xb4>)
 8000854:	f005 fd26 	bl	80062a4 <HAL_TIM_ConfigClockSource>
 8000858:	bb28      	cbnz	r0, 80008a6 <MX_TIM2_Init+0x9e>
	if (HAL_TIM_PWM_Init(&htim2) != HAL_OK) {
 800085a:	4818      	ldr	r0, [pc, #96]	; (80008bc <MX_TIM2_Init+0xb4>)
 800085c:	f005 fa06 	bl	8005c6c <HAL_TIM_PWM_Init>
 8000860:	bb18      	cbnz	r0, 80008aa <MX_TIM2_Init+0xa2>
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8000862:	2300      	movs	r3, #0
 8000864:	9308      	str	r3, [sp, #32]
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000866:	9309      	str	r3, [sp, #36]	; 0x24
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig)
 8000868:	a908      	add	r1, sp, #32
 800086a:	4814      	ldr	r0, [pc, #80]	; (80008bc <MX_TIM2_Init+0xb4>)
 800086c:	f008 fe3e 	bl	80094ec <HAL_TIMEx_MasterConfigSynchronization>
 8000870:	b9e8      	cbnz	r0, 80008ae <MX_TIM2_Init+0xa6>
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8000872:	2360      	movs	r3, #96	; 0x60
 8000874:	9301      	str	r3, [sp, #4]
	sConfigOC.Pulse = 0;
 8000876:	2200      	movs	r2, #0
 8000878:	9202      	str	r2, [sp, #8]
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800087a:	9203      	str	r2, [sp, #12]
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800087c:	9205      	str	r2, [sp, #20]
	if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1)
 800087e:	a901      	add	r1, sp, #4
 8000880:	480e      	ldr	r0, [pc, #56]	; (80008bc <MX_TIM2_Init+0xb4>)
 8000882:	f005 fb2c 	bl	8005ede <HAL_TIM_PWM_ConfigChannel>
 8000886:	b9a0      	cbnz	r0, 80008b2 <MX_TIM2_Init+0xaa>
	if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2)
 8000888:	2204      	movs	r2, #4
 800088a:	eb0d 0102 	add.w	r1, sp, r2
 800088e:	480b      	ldr	r0, [pc, #44]	; (80008bc <MX_TIM2_Init+0xb4>)
 8000890:	f005 fb25 	bl	8005ede <HAL_TIM_PWM_ConfigChannel>
 8000894:	b978      	cbnz	r0, 80008b6 <MX_TIM2_Init+0xae>
	HAL_TIM_MspPostInit(&htim2);
 8000896:	4809      	ldr	r0, [pc, #36]	; (80008bc <MX_TIM2_Init+0xb4>)
 8000898:	f001 f8a4 	bl	80019e4 <HAL_TIM_MspPostInit>
}
 800089c:	b00f      	add	sp, #60	; 0x3c
 800089e:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 80008a2:	f7ff febb 	bl	800061c <Error_Handler>
		Error_Handler();
 80008a6:	f7ff feb9 	bl	800061c <Error_Handler>
		Error_Handler();
 80008aa:	f7ff feb7 	bl	800061c <Error_Handler>
		Error_Handler();
 80008ae:	f7ff feb5 	bl	800061c <Error_Handler>
		Error_Handler();
 80008b2:	f7ff feb3 	bl	800061c <Error_Handler>
		Error_Handler();
 80008b6:	f7ff feb1 	bl	800061c <Error_Handler>
 80008ba:	bf00      	nop
 80008bc:	20004484 	.word	0x20004484

080008c0 <MX_TIM3_Init>:
static void MX_TIM3_Init(void) {
 80008c0:	b500      	push	{lr}
 80008c2:	b08f      	sub	sp, #60	; 0x3c
	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
 80008c4:	2300      	movs	r3, #0
 80008c6:	930a      	str	r3, [sp, #40]	; 0x28
 80008c8:	930b      	str	r3, [sp, #44]	; 0x2c
 80008ca:	930c      	str	r3, [sp, #48]	; 0x30
 80008cc:	930d      	str	r3, [sp, #52]	; 0x34
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
 80008ce:	9308      	str	r3, [sp, #32]
 80008d0:	9309      	str	r3, [sp, #36]	; 0x24
	TIM_OC_InitTypeDef sConfigOC = { 0 };
 80008d2:	9301      	str	r3, [sp, #4]
 80008d4:	9302      	str	r3, [sp, #8]
 80008d6:	9303      	str	r3, [sp, #12]
 80008d8:	9304      	str	r3, [sp, #16]
 80008da:	9305      	str	r3, [sp, #20]
 80008dc:	9306      	str	r3, [sp, #24]
 80008de:	9307      	str	r3, [sp, #28]
	htim3.Instance = TIM3;
 80008e0:	4823      	ldr	r0, [pc, #140]	; (8000970 <MX_TIM3_Init+0xb0>)
 80008e2:	4a24      	ldr	r2, [pc, #144]	; (8000974 <MX_TIM3_Init+0xb4>)
 80008e4:	6002      	str	r2, [r0, #0]
	htim3.Init.Prescaler = 1440 - 1;
 80008e6:	f240 529f 	movw	r2, #1439	; 0x59f
 80008ea:	6042      	str	r2, [r0, #4]
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 80008ec:	6083      	str	r3, [r0, #8]
	htim3.Init.Period = 1000 - 1;
 80008ee:	f240 32e7 	movw	r2, #999	; 0x3e7
 80008f2:	60c2      	str	r2, [r0, #12]
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80008f4:	6103      	str	r3, [r0, #16]
	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 80008f6:	2380      	movs	r3, #128	; 0x80
 80008f8:	6183      	str	r3, [r0, #24]
	if (HAL_TIM_Base_Init(&htim3) != HAL_OK) {
 80008fa:	f005 f95f 	bl	8005bbc <HAL_TIM_Base_Init>
 80008fe:	bb58      	cbnz	r0, 8000958 <MX_TIM3_Init+0x98>
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000900:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000904:	930a      	str	r3, [sp, #40]	; 0x28
	if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK) {
 8000906:	a90a      	add	r1, sp, #40	; 0x28
 8000908:	4819      	ldr	r0, [pc, #100]	; (8000970 <MX_TIM3_Init+0xb0>)
 800090a:	f005 fccb 	bl	80062a4 <HAL_TIM_ConfigClockSource>
 800090e:	bb28      	cbnz	r0, 800095c <MX_TIM3_Init+0x9c>
	if (HAL_TIM_PWM_Init(&htim3) != HAL_OK) {
 8000910:	4817      	ldr	r0, [pc, #92]	; (8000970 <MX_TIM3_Init+0xb0>)
 8000912:	f005 f9ab 	bl	8005c6c <HAL_TIM_PWM_Init>
 8000916:	bb18      	cbnz	r0, 8000960 <MX_TIM3_Init+0xa0>
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8000918:	2300      	movs	r3, #0
 800091a:	9308      	str	r3, [sp, #32]
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800091c:	9309      	str	r3, [sp, #36]	; 0x24
	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig)
 800091e:	a908      	add	r1, sp, #32
 8000920:	4813      	ldr	r0, [pc, #76]	; (8000970 <MX_TIM3_Init+0xb0>)
 8000922:	f008 fde3 	bl	80094ec <HAL_TIMEx_MasterConfigSynchronization>
 8000926:	b9e8      	cbnz	r0, 8000964 <MX_TIM3_Init+0xa4>
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8000928:	2360      	movs	r3, #96	; 0x60
 800092a:	9301      	str	r3, [sp, #4]
	sConfigOC.Pulse = 0;
 800092c:	2200      	movs	r2, #0
 800092e:	9202      	str	r2, [sp, #8]
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8000930:	9203      	str	r2, [sp, #12]
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8000932:	9205      	str	r2, [sp, #20]
	if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1)
 8000934:	a901      	add	r1, sp, #4
 8000936:	480e      	ldr	r0, [pc, #56]	; (8000970 <MX_TIM3_Init+0xb0>)
 8000938:	f005 fad1 	bl	8005ede <HAL_TIM_PWM_ConfigChannel>
 800093c:	b9a0      	cbnz	r0, 8000968 <MX_TIM3_Init+0xa8>
	if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2)
 800093e:	2204      	movs	r2, #4
 8000940:	eb0d 0102 	add.w	r1, sp, r2
 8000944:	480a      	ldr	r0, [pc, #40]	; (8000970 <MX_TIM3_Init+0xb0>)
 8000946:	f005 faca 	bl	8005ede <HAL_TIM_PWM_ConfigChannel>
 800094a:	b978      	cbnz	r0, 800096c <MX_TIM3_Init+0xac>
	HAL_TIM_MspPostInit(&htim3);
 800094c:	4808      	ldr	r0, [pc, #32]	; (8000970 <MX_TIM3_Init+0xb0>)
 800094e:	f001 f849 	bl	80019e4 <HAL_TIM_MspPostInit>
}
 8000952:	b00f      	add	sp, #60	; 0x3c
 8000954:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 8000958:	f7ff fe60 	bl	800061c <Error_Handler>
		Error_Handler();
 800095c:	f7ff fe5e 	bl	800061c <Error_Handler>
		Error_Handler();
 8000960:	f7ff fe5c 	bl	800061c <Error_Handler>
		Error_Handler();
 8000964:	f7ff fe5a 	bl	800061c <Error_Handler>
		Error_Handler();
 8000968:	f7ff fe58 	bl	800061c <Error_Handler>
		Error_Handler();
 800096c:	f7ff fe56 	bl	800061c <Error_Handler>
 8000970:	20004238 	.word	0x20004238
 8000974:	40000400 	.word	0x40000400

08000978 <MX_TIM4_Init>:
static void MX_TIM4_Init(void) {
 8000978:	b500      	push	{lr}
 800097a:	b08f      	sub	sp, #60	; 0x3c
	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
 800097c:	2300      	movs	r3, #0
 800097e:	930a      	str	r3, [sp, #40]	; 0x28
 8000980:	930b      	str	r3, [sp, #44]	; 0x2c
 8000982:	930c      	str	r3, [sp, #48]	; 0x30
 8000984:	930d      	str	r3, [sp, #52]	; 0x34
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
 8000986:	9308      	str	r3, [sp, #32]
 8000988:	9309      	str	r3, [sp, #36]	; 0x24
	TIM_OC_InitTypeDef sConfigOC = { 0 };
 800098a:	9301      	str	r3, [sp, #4]
 800098c:	9302      	str	r3, [sp, #8]
 800098e:	9303      	str	r3, [sp, #12]
 8000990:	9304      	str	r3, [sp, #16]
 8000992:	9305      	str	r3, [sp, #20]
 8000994:	9306      	str	r3, [sp, #24]
 8000996:	9307      	str	r3, [sp, #28]
	htim4.Instance = TIM4;
 8000998:	4823      	ldr	r0, [pc, #140]	; (8000a28 <MX_TIM4_Init+0xb0>)
 800099a:	4a24      	ldr	r2, [pc, #144]	; (8000a2c <MX_TIM4_Init+0xb4>)
 800099c:	6002      	str	r2, [r0, #0]
	htim4.Init.Prescaler = 1440 - 1;
 800099e:	f240 529f 	movw	r2, #1439	; 0x59f
 80009a2:	6042      	str	r2, [r0, #4]
	htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 80009a4:	6083      	str	r3, [r0, #8]
	htim4.Init.Period = 1000 - 1;
 80009a6:	f240 32e7 	movw	r2, #999	; 0x3e7
 80009aa:	60c2      	str	r2, [r0, #12]
	htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80009ac:	6103      	str	r3, [r0, #16]
	htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80009ae:	6183      	str	r3, [r0, #24]
	if (HAL_TIM_Base_Init(&htim4) != HAL_OK) {
 80009b0:	f005 f904 	bl	8005bbc <HAL_TIM_Base_Init>
 80009b4:	bb58      	cbnz	r0, 8000a0e <MX_TIM4_Init+0x96>
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80009b6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80009ba:	930a      	str	r3, [sp, #40]	; 0x28
	if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK) {
 80009bc:	a90a      	add	r1, sp, #40	; 0x28
 80009be:	481a      	ldr	r0, [pc, #104]	; (8000a28 <MX_TIM4_Init+0xb0>)
 80009c0:	f005 fc70 	bl	80062a4 <HAL_TIM_ConfigClockSource>
 80009c4:	bb28      	cbnz	r0, 8000a12 <MX_TIM4_Init+0x9a>
	if (HAL_TIM_PWM_Init(&htim4) != HAL_OK) {
 80009c6:	4818      	ldr	r0, [pc, #96]	; (8000a28 <MX_TIM4_Init+0xb0>)
 80009c8:	f005 f950 	bl	8005c6c <HAL_TIM_PWM_Init>
 80009cc:	bb18      	cbnz	r0, 8000a16 <MX_TIM4_Init+0x9e>
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80009ce:	2300      	movs	r3, #0
 80009d0:	9308      	str	r3, [sp, #32]
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80009d2:	9309      	str	r3, [sp, #36]	; 0x24
	if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig)
 80009d4:	a908      	add	r1, sp, #32
 80009d6:	4814      	ldr	r0, [pc, #80]	; (8000a28 <MX_TIM4_Init+0xb0>)
 80009d8:	f008 fd88 	bl	80094ec <HAL_TIMEx_MasterConfigSynchronization>
 80009dc:	b9e8      	cbnz	r0, 8000a1a <MX_TIM4_Init+0xa2>
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80009de:	2360      	movs	r3, #96	; 0x60
 80009e0:	9301      	str	r3, [sp, #4]
	sConfigOC.Pulse = 0;
 80009e2:	2200      	movs	r2, #0
 80009e4:	9202      	str	r2, [sp, #8]
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80009e6:	9203      	str	r2, [sp, #12]
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80009e8:	9205      	str	r2, [sp, #20]
	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1)
 80009ea:	a901      	add	r1, sp, #4
 80009ec:	480e      	ldr	r0, [pc, #56]	; (8000a28 <MX_TIM4_Init+0xb0>)
 80009ee:	f005 fa76 	bl	8005ede <HAL_TIM_PWM_ConfigChannel>
 80009f2:	b9a0      	cbnz	r0, 8000a1e <MX_TIM4_Init+0xa6>
	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2)
 80009f4:	2204      	movs	r2, #4
 80009f6:	eb0d 0102 	add.w	r1, sp, r2
 80009fa:	480b      	ldr	r0, [pc, #44]	; (8000a28 <MX_TIM4_Init+0xb0>)
 80009fc:	f005 fa6f 	bl	8005ede <HAL_TIM_PWM_ConfigChannel>
 8000a00:	b978      	cbnz	r0, 8000a22 <MX_TIM4_Init+0xaa>
	HAL_TIM_MspPostInit(&htim4);
 8000a02:	4809      	ldr	r0, [pc, #36]	; (8000a28 <MX_TIM4_Init+0xb0>)
 8000a04:	f000 ffee 	bl	80019e4 <HAL_TIM_MspPostInit>
}
 8000a08:	b00f      	add	sp, #60	; 0x3c
 8000a0a:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 8000a0e:	f7ff fe05 	bl	800061c <Error_Handler>
		Error_Handler();
 8000a12:	f7ff fe03 	bl	800061c <Error_Handler>
		Error_Handler();
 8000a16:	f7ff fe01 	bl	800061c <Error_Handler>
		Error_Handler();
 8000a1a:	f7ff fdff 	bl	800061c <Error_Handler>
		Error_Handler();
 8000a1e:	f7ff fdfd 	bl	800061c <Error_Handler>
		Error_Handler();
 8000a22:	f7ff fdfb 	bl	800061c <Error_Handler>
 8000a26:	bf00      	nop
 8000a28:	200041a0 	.word	0x200041a0
 8000a2c:	40000800 	.word	0x40000800

08000a30 <MX_ADC2_Init>:
static void MX_ADC2_Init(void) {
 8000a30:	b500      	push	{lr}
 8000a32:	b085      	sub	sp, #20
	ADC_ChannelConfTypeDef sConfig = { 0 };
 8000a34:	2300      	movs	r3, #0
 8000a36:	9301      	str	r3, [sp, #4]
 8000a38:	9302      	str	r3, [sp, #8]
 8000a3a:	9303      	str	r3, [sp, #12]
	hadc2.Instance = ADC2;
 8000a3c:	4827      	ldr	r0, [pc, #156]	; (8000adc <MX_ADC2_Init+0xac>)
 8000a3e:	4a28      	ldr	r2, [pc, #160]	; (8000ae0 <MX_ADC2_Init+0xb0>)
 8000a40:	6002      	str	r2, [r0, #0]
	hadc2.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8000a42:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000a46:	6082      	str	r2, [r0, #8]
	hadc2.Init.ContinuousConvMode = DISABLE;
 8000a48:	7303      	strb	r3, [r0, #12]
	hadc2.Init.DiscontinuousConvMode = DISABLE;
 8000a4a:	7503      	strb	r3, [r0, #20]
	hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000a4c:	f44f 2260 	mov.w	r2, #917504	; 0xe0000
 8000a50:	61c2      	str	r2, [r0, #28]
	hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000a52:	6043      	str	r3, [r0, #4]
	hadc2.Init.NbrOfConversion = 5;
 8000a54:	2305      	movs	r3, #5
 8000a56:	6103      	str	r3, [r0, #16]
	if (HAL_ADC_Init(&hadc2) != HAL_OK) {
 8000a58:	f001 ff5f 	bl	800291a <HAL_ADC_Init>
 8000a5c:	2800      	cmp	r0, #0
 8000a5e:	d131      	bne.n	8000ac4 <MX_ADC2_Init+0x94>
	sConfig.Channel = ADC_CHANNEL_1;
 8000a60:	2301      	movs	r3, #1
 8000a62:	9301      	str	r3, [sp, #4]
	sConfig.Rank = ADC_REGULAR_RANK_1;
 8000a64:	9302      	str	r3, [sp, #8]
	sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
 8000a66:	2307      	movs	r3, #7
 8000a68:	9303      	str	r3, [sp, #12]
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
 8000a6a:	a901      	add	r1, sp, #4
 8000a6c:	481b      	ldr	r0, [pc, #108]	; (8000adc <MX_ADC2_Init+0xac>)
 8000a6e:	f001 fc91 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000a72:	bb48      	cbnz	r0, 8000ac8 <MX_ADC2_Init+0x98>
	sConfig.Channel = ADC_CHANNEL_3;
 8000a74:	2303      	movs	r3, #3
 8000a76:	9301      	str	r3, [sp, #4]
	sConfig.Rank = ADC_REGULAR_RANK_2;
 8000a78:	2302      	movs	r3, #2
 8000a7a:	9302      	str	r3, [sp, #8]
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
 8000a7c:	a901      	add	r1, sp, #4
 8000a7e:	4817      	ldr	r0, [pc, #92]	; (8000adc <MX_ADC2_Init+0xac>)
 8000a80:	f001 fc88 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000a84:	bb10      	cbnz	r0, 8000acc <MX_ADC2_Init+0x9c>
	sConfig.Channel = ADC_CHANNEL_5;
 8000a86:	2305      	movs	r3, #5
 8000a88:	9301      	str	r3, [sp, #4]
	sConfig.Rank = ADC_REGULAR_RANK_3;
 8000a8a:	2303      	movs	r3, #3
 8000a8c:	9302      	str	r3, [sp, #8]
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
 8000a8e:	a901      	add	r1, sp, #4
 8000a90:	4812      	ldr	r0, [pc, #72]	; (8000adc <MX_ADC2_Init+0xac>)
 8000a92:	f001 fc7f 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000a96:	b9d8      	cbnz	r0, 8000ad0 <MX_ADC2_Init+0xa0>
	sConfig.Channel = ADC_CHANNEL_7;
 8000a98:	2307      	movs	r3, #7
 8000a9a:	9301      	str	r3, [sp, #4]
	sConfig.Rank = ADC_REGULAR_RANK_4;
 8000a9c:	2304      	movs	r3, #4
 8000a9e:	9302      	str	r3, [sp, #8]
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
 8000aa0:	eb0d 0103 	add.w	r1, sp, r3
 8000aa4:	480d      	ldr	r0, [pc, #52]	; (8000adc <MX_ADC2_Init+0xac>)
 8000aa6:	f001 fc75 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000aaa:	b998      	cbnz	r0, 8000ad4 <MX_ADC2_Init+0xa4>
	sConfig.Channel = ADC_CHANNEL_9;
 8000aac:	2309      	movs	r3, #9
 8000aae:	9301      	str	r3, [sp, #4]
	sConfig.Rank = ADC_REGULAR_RANK_5;
 8000ab0:	2305      	movs	r3, #5
 8000ab2:	9302      	str	r3, [sp, #8]
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
 8000ab4:	a901      	add	r1, sp, #4
 8000ab6:	4809      	ldr	r0, [pc, #36]	; (8000adc <MX_ADC2_Init+0xac>)
 8000ab8:	f001 fc6c 	bl	8002394 <HAL_ADC_ConfigChannel>
 8000abc:	b960      	cbnz	r0, 8000ad8 <MX_ADC2_Init+0xa8>
}
 8000abe:	b005      	add	sp, #20
 8000ac0:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 8000ac4:	f7ff fdaa 	bl	800061c <Error_Handler>
		Error_Handler();
 8000ac8:	f7ff fda8 	bl	800061c <Error_Handler>
		Error_Handler();
 8000acc:	f7ff fda6 	bl	800061c <Error_Handler>
		Error_Handler();
 8000ad0:	f7ff fda4 	bl	800061c <Error_Handler>
		Error_Handler();
 8000ad4:	f7ff fda2 	bl	800061c <Error_Handler>
		Error_Handler();
 8000ad8:	f7ff fda0 	bl	800061c <Error_Handler>
 8000adc:	200041ec 	.word	0x200041ec
 8000ae0:	40012800 	.word	0x40012800

08000ae4 <SystemClock_Config>:
void SystemClock_Config(void) {
 8000ae4:	b500      	push	{lr}
 8000ae6:	b095      	sub	sp, #84	; 0x54
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
 8000ae8:	2300      	movs	r3, #0
 8000aea:	930d      	str	r3, [sp, #52]	; 0x34
 8000aec:	930f      	str	r3, [sp, #60]	; 0x3c
 8000aee:	9310      	str	r3, [sp, #64]	; 0x40
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
 8000af0:	9305      	str	r3, [sp, #20]
 8000af2:	9306      	str	r3, [sp, #24]
 8000af4:	9307      	str	r3, [sp, #28]
 8000af6:	9308      	str	r3, [sp, #32]
 8000af8:	9309      	str	r3, [sp, #36]	; 0x24
	RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 };
 8000afa:	9301      	str	r3, [sp, #4]
 8000afc:	9302      	str	r3, [sp, #8]
 8000afe:	9303      	str	r3, [sp, #12]
 8000b00:	9304      	str	r3, [sp, #16]
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000b02:	2101      	movs	r1, #1
 8000b04:	910a      	str	r1, [sp, #40]	; 0x28
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000b06:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000b0a:	920b      	str	r2, [sp, #44]	; 0x2c
	RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 8000b0c:	930c      	str	r3, [sp, #48]	; 0x30
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000b0e:	910e      	str	r1, [sp, #56]	; 0x38
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000b10:	2302      	movs	r3, #2
 8000b12:	9311      	str	r3, [sp, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000b14:	9212      	str	r2, [sp, #72]	; 0x48
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8000b16:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
 8000b1a:	9313      	str	r3, [sp, #76]	; 0x4c
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
 8000b1c:	a80a      	add	r0, sp, #40	; 0x28
 8000b1e:	f003 fbad 	bl	800427c <HAL_RCC_OscConfig>
 8000b22:	b9c8      	cbnz	r0, 8000b58 <SystemClock_Config+0x74>
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 8000b24:	230f      	movs	r3, #15
 8000b26:	9305      	str	r3, [sp, #20]
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000b28:	2102      	movs	r1, #2
 8000b2a:	9106      	str	r1, [sp, #24]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000b2c:	2300      	movs	r3, #0
 8000b2e:	9307      	str	r3, [sp, #28]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8000b30:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000b34:	9208      	str	r2, [sp, #32]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000b36:	9309      	str	r3, [sp, #36]	; 0x24
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
 8000b38:	a805      	add	r0, sp, #20
 8000b3a:	f003 fe0f 	bl	800475c <HAL_RCC_ClockConfig>
 8000b3e:	b968      	cbnz	r0, 8000b5c <SystemClock_Config+0x78>
	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 8000b40:	2302      	movs	r3, #2
 8000b42:	9301      	str	r3, [sp, #4]
	PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;
 8000b44:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000b48:	9303      	str	r3, [sp, #12]
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) {
 8000b4a:	a801      	add	r0, sp, #4
 8000b4c:	f003 ff6c 	bl	8004a28 <HAL_RCCEx_PeriphCLKConfig>
 8000b50:	b930      	cbnz	r0, 8000b60 <SystemClock_Config+0x7c>
}
 8000b52:	b015      	add	sp, #84	; 0x54
 8000b54:	f85d fb04 	ldr.w	pc, [sp], #4
		Error_Handler();
 8000b58:	f7ff fd60 	bl	800061c <Error_Handler>
		Error_Handler();
 8000b5c:	f7ff fd5e 	bl	800061c <Error_Handler>
		Error_Handler();
 8000b60:	f7ff fd5c 	bl	800061c <Error_Handler>

08000b64 <main>:
int main(void) {
 8000b64:	b508      	push	{r3, lr}
	HAL_Init();
 8000b66:	f001 f99b 	bl	8001ea0 <HAL_Init>
	scanRowth = 0u;
 8000b6a:	2400      	movs	r4, #0
 8000b6c:	4b55      	ldr	r3, [pc, #340]	; (8000cc4 <main+0x160>)
 8000b6e:	801c      	strh	r4, [r3, #0]
	first = 1u;
 8000b70:	2301      	movs	r3, #1
 8000b72:	4a55      	ldr	r2, [pc, #340]	; (8000cc8 <main+0x164>)
 8000b74:	8013      	strh	r3, [r2, #0]
	peakControlMode = 0u;
 8000b76:	4a55      	ldr	r2, [pc, #340]	; (8000ccc <main+0x168>)
 8000b78:	8014      	strh	r4, [r2, #0]
	flagTimer = 1u;
 8000b7a:	4a55      	ldr	r2, [pc, #340]	; (8000cd0 <main+0x16c>)
 8000b7c:	8013      	strh	r3, [r2, #0]
	timeDelay = 200u;
 8000b7e:	4b55      	ldr	r3, [pc, #340]	; (8000cd4 <main+0x170>)
 8000b80:	22c8      	movs	r2, #200	; 0xc8
 8000b82:	801a      	strh	r2, [r3, #0]
	isPress = 0u;
 8000b84:	4b54      	ldr	r3, [pc, #336]	; (8000cd8 <main+0x174>)
 8000b86:	801c      	strh	r4, [r3, #0]
	SystemClock_Config();
 8000b88:	f7ff ffac 	bl	8000ae4 <SystemClock_Config>
	MX_GPIO_Init();
 8000b8c:	f7ff faf8 	bl	8000180 <MX_GPIO_Init>
	MX_DMA_Init();
 8000b90:	f7ff fd46 	bl	8000620 <MX_DMA_Init>
	MX_ADC1_Init();
 8000b94:	f7ff fdb8 	bl	8000708 <MX_ADC1_Init>
	MX_USART1_UART_Init();
 8000b98:	f7ff fe1c 	bl	80007d4 <MX_USART1_UART_Init>
	MX_TIM2_Init();
 8000b9c:	f7ff fe34 	bl	8000808 <MX_TIM2_Init>
	MX_TIM3_Init();
 8000ba0:	f7ff fe8e 	bl	80008c0 <MX_TIM3_Init>
	MX_TIM4_Init();
 8000ba4:	f7ff fee8 	bl	8000978 <MX_TIM4_Init>
	MX_ADC2_Init();
 8000ba8:	f7ff ff42 	bl	8000a30 <MX_ADC2_Init>
	osKernelInitialize();
 8000bac:	f009 fee2 	bl	800a974 <osKernelInitialize>
	myTimer01Handle = osTimerNew(Callback01, osTimerOnce, NULL,
 8000bb0:	4b4a      	ldr	r3, [pc, #296]	; (8000cdc <main+0x178>)
 8000bb2:	4622      	mov	r2, r4
 8000bb4:	4621      	mov	r1, r4
 8000bb6:	484a      	ldr	r0, [pc, #296]	; (8000ce0 <main+0x17c>)
 8000bb8:	f00a fbb8 	bl	800b32c <osTimerNew>
 8000bbc:	4b49      	ldr	r3, [pc, #292]	; (8000ce4 <main+0x180>)
 8000bbe:	6018      	str	r0, [r3, #0]
	velostatQueueHandle = osMessageQueueNew(3, sizeof(uint16_t*),
 8000bc0:	4a49      	ldr	r2, [pc, #292]	; (8000ce8 <main+0x184>)
 8000bc2:	2104      	movs	r1, #4
 8000bc4:	2003      	movs	r0, #3
 8000bc6:	f00b f867 	bl	800bc98 <osMessageQueueNew>
 8000bca:	4b48      	ldr	r3, [pc, #288]	; (8000cec <main+0x188>)
 8000bcc:	6018      	str	r0, [r3, #0]
	handQueueHandle = osMessageQueueNew(3, sizeof(uint16_t*),
 8000bce:	4a48      	ldr	r2, [pc, #288]	; (8000cf0 <main+0x18c>)
 8000bd0:	2104      	movs	r1, #4
 8000bd2:	2003      	movs	r0, #3
 8000bd4:	f00b f860 	bl	800bc98 <osMessageQueueNew>
 8000bd8:	4b46      	ldr	r3, [pc, #280]	; (8000cf4 <main+0x190>)
 8000bda:	6018      	str	r0, [r3, #0]
	VelostatScanADCHandle = osThreadNew(StartVelostatScanADC, NULL,
 8000bdc:	4a46      	ldr	r2, [pc, #280]	; (8000cf8 <main+0x194>)
 8000bde:	4621      	mov	r1, r4
 8000be0:	4846      	ldr	r0, [pc, #280]	; (8000cfc <main+0x198>)
 8000be2:	f00a f801 	bl	800abe8 <osThreadNew>
 8000be6:	4b46      	ldr	r3, [pc, #280]	; (8000d00 <main+0x19c>)
 8000be8:	6018      	str	r0, [r3, #0]
	VelostatProcessOutputHandle = osThreadNew(StartVelostatProcessOutput, NULL,
 8000bea:	4a46      	ldr	r2, [pc, #280]	; (8000d04 <main+0x1a0>)
 8000bec:	4621      	mov	r1, r4
 8000bee:	4846      	ldr	r0, [pc, #280]	; (8000d08 <main+0x1a4>)
 8000bf0:	f009 fffa 	bl	800abe8 <osThreadNew>
 8000bf4:	4b45      	ldr	r3, [pc, #276]	; (8000d0c <main+0x1a8>)
 8000bf6:	6018      	str	r0, [r3, #0]
	VelostatTransmitHandle = osThreadNew(StartVelostatTransmit, NULL,
 8000bf8:	4a45      	ldr	r2, [pc, #276]	; (8000d10 <main+0x1ac>)
 8000bfa:	4621      	mov	r1, r4
 8000bfc:	4845      	ldr	r0, [pc, #276]	; (8000d14 <main+0x1b0>)
 8000bfe:	f009 fff3 	bl	800abe8 <osThreadNew>
 8000c02:	4b45      	ldr	r3, [pc, #276]	; (8000d18 <main+0x1b4>)
 8000c04:	6018      	str	r0, [r3, #0]
	HandBot1Handle = osThreadNew(StartHandBot1, NULL, &HandBot1_attributes);
 8000c06:	4a45      	ldr	r2, [pc, #276]	; (8000d1c <main+0x1b8>)
 8000c08:	4621      	mov	r1, r4
 8000c0a:	4845      	ldr	r0, [pc, #276]	; (8000d20 <main+0x1bc>)
 8000c0c:	f009 ffec 	bl	800abe8 <osThreadNew>
 8000c10:	4b44      	ldr	r3, [pc, #272]	; (8000d24 <main+0x1c0>)
 8000c12:	6018      	str	r0, [r3, #0]
	HandTop1Handle = osThreadNew(StartHandTop1, NULL, &HandTop1_attributes);
 8000c14:	4a44      	ldr	r2, [pc, #272]	; (8000d28 <main+0x1c4>)
 8000c16:	4621      	mov	r1, r4
 8000c18:	4844      	ldr	r0, [pc, #272]	; (8000d2c <main+0x1c8>)
 8000c1a:	f009 ffe5 	bl	800abe8 <osThreadNew>
 8000c1e:	4b44      	ldr	r3, [pc, #272]	; (8000d30 <main+0x1cc>)
 8000c20:	6018      	str	r0, [r3, #0]
	HandBot2Handle = osThreadNew(StartHandBot2, NULL, &HandBot2_attributes);
 8000c22:	4a44      	ldr	r2, [pc, #272]	; (8000d34 <main+0x1d0>)
 8000c24:	4621      	mov	r1, r4
 8000c26:	4844      	ldr	r0, [pc, #272]	; (8000d38 <main+0x1d4>)
 8000c28:	f009 ffde 	bl	800abe8 <osThreadNew>
 8000c2c:	4b43      	ldr	r3, [pc, #268]	; (8000d3c <main+0x1d8>)
 8000c2e:	6018      	str	r0, [r3, #0]
	HandTop2Handle = osThreadNew(StartHandTop2, NULL, &HandTop2_attributes);
 8000c30:	4a43      	ldr	r2, [pc, #268]	; (8000d40 <main+0x1dc>)
 8000c32:	4621      	mov	r1, r4
 8000c34:	4843      	ldr	r0, [pc, #268]	; (8000d44 <main+0x1e0>)
 8000c36:	f009 ffd7 	bl	800abe8 <osThreadNew>
 8000c3a:	4b43      	ldr	r3, [pc, #268]	; (8000d48 <main+0x1e4>)
 8000c3c:	6018      	str	r0, [r3, #0]
	HandBot3Handle = osThreadNew(StartHandBot3, NULL, &HandBot3_attributes);
 8000c3e:	4a43      	ldr	r2, [pc, #268]	; (8000d4c <main+0x1e8>)
 8000c40:	4621      	mov	r1, r4
 8000c42:	4843      	ldr	r0, [pc, #268]	; (8000d50 <main+0x1ec>)
 8000c44:	f009 ffd0 	bl	800abe8 <osThreadNew>
 8000c48:	4b42      	ldr	r3, [pc, #264]	; (8000d54 <main+0x1f0>)
 8000c4a:	6018      	str	r0, [r3, #0]
	HandTop3Handle = osThreadNew(StartHandTop3, NULL, &HandTop3_attributes);
 8000c4c:	4a42      	ldr	r2, [pc, #264]	; (8000d58 <main+0x1f4>)
 8000c4e:	4621      	mov	r1, r4
 8000c50:	4842      	ldr	r0, [pc, #264]	; (8000d5c <main+0x1f8>)
 8000c52:	f009 ffc9 	bl	800abe8 <osThreadNew>
 8000c56:	4b42      	ldr	r3, [pc, #264]	; (8000d60 <main+0x1fc>)
 8000c58:	6018      	str	r0, [r3, #0]
	HandRxHandlerHandle = osThreadNew(StartHandRxHandler, NULL,
 8000c5a:	4a42      	ldr	r2, [pc, #264]	; (8000d64 <main+0x200>)
 8000c5c:	4621      	mov	r1, r4
 8000c5e:	4842      	ldr	r0, [pc, #264]	; (8000d68 <main+0x204>)
 8000c60:	f009 ffc2 	bl	800abe8 <osThreadNew>
 8000c64:	4b41      	ldr	r3, [pc, #260]	; (8000d6c <main+0x208>)
 8000c66:	6018      	str	r0, [r3, #0]
	HandMatrixHandlerHandle = osThreadNew(StartHandMatrixHandler, NULL,
 8000c68:	4a41      	ldr	r2, [pc, #260]	; (8000d70 <main+0x20c>)
 8000c6a:	4621      	mov	r1, r4
 8000c6c:	4841      	ldr	r0, [pc, #260]	; (8000d74 <main+0x210>)
 8000c6e:	f009 ffbb 	bl	800abe8 <osThreadNew>
 8000c72:	4b41      	ldr	r3, [pc, #260]	; (8000d78 <main+0x214>)
 8000c74:	6018      	str	r0, [r3, #0]
	HandPeakControlHandle = osThreadNew(StartHandPeakControl, NULL,
 8000c76:	4a41      	ldr	r2, [pc, #260]	; (8000d7c <main+0x218>)
 8000c78:	4621      	mov	r1, r4
 8000c7a:	4841      	ldr	r0, [pc, #260]	; (8000d80 <main+0x21c>)
 8000c7c:	f009 ffb4 	bl	800abe8 <osThreadNew>
 8000c80:	4b40      	ldr	r3, [pc, #256]	; (8000d84 <main+0x220>)
 8000c82:	6018      	str	r0, [r3, #0]
	ButtonHandlerHandle = osThreadNew(StartButtonHandler, NULL,
 8000c84:	4a40      	ldr	r2, [pc, #256]	; (8000d88 <main+0x224>)
 8000c86:	4621      	mov	r1, r4
 8000c88:	4840      	ldr	r0, [pc, #256]	; (8000d8c <main+0x228>)
 8000c8a:	f009 ffad 	bl	800abe8 <osThreadNew>
 8000c8e:	4b40      	ldr	r3, [pc, #256]	; (8000d90 <main+0x22c>)
 8000c90:	6018      	str	r0, [r3, #0]
	HandStopServoHandle = osThreadNew(StartHandStopServo, NULL,
 8000c92:	4a40      	ldr	r2, [pc, #256]	; (8000d94 <main+0x230>)
 8000c94:	4621      	mov	r1, r4
 8000c96:	4840      	ldr	r0, [pc, #256]	; (8000d98 <main+0x234>)
 8000c98:	f009 ffa6 	bl	800abe8 <osThreadNew>
 8000c9c:	4b3f      	ldr	r3, [pc, #252]	; (8000d9c <main+0x238>)
 8000c9e:	6018      	str	r0, [r3, #0]
	handEventHandle = osEventFlagsNew(&handEvent_attributes);
 8000ca0:	483f      	ldr	r0, [pc, #252]	; (8000da0 <main+0x23c>)
 8000ca2:	f00a fc75 	bl	800b590 <osEventFlagsNew>
 8000ca6:	4b3f      	ldr	r3, [pc, #252]	; (8000da4 <main+0x240>)
 8000ca8:	6018      	str	r0, [r3, #0]
	velostatEventHandle = osEventFlagsNew(&velostatEvent_attributes);
 8000caa:	483f      	ldr	r0, [pc, #252]	; (8000da8 <main+0x244>)
 8000cac:	f00a fc70 	bl	800b590 <osEventFlagsNew>
 8000cb0:	4b3e      	ldr	r3, [pc, #248]	; (8000dac <main+0x248>)
 8000cb2:	6018      	str	r0, [r3, #0]
	stopServoEventHandle = osEventFlagsNew(&stopServoEvent_attributes);
 8000cb4:	483e      	ldr	r0, [pc, #248]	; (8000db0 <main+0x24c>)
 8000cb6:	f00a fc6b 	bl	800b590 <osEventFlagsNew>
 8000cba:	4b3e      	ldr	r3, [pc, #248]	; (8000db4 <main+0x250>)
 8000cbc:	6018      	str	r0, [r3, #0]
	osKernelStart();
 8000cbe:	f009 fea3 	bl	800aa08 <osKernelStart>
	while (1) {
 8000cc2:	e7fe      	b.n	8000cc2 <main+0x15e>
 8000cc4:	2000422c 	.word	0x2000422c
 8000cc8:	200044d2 	.word	0x200044d2
 8000ccc:	20004236 	.word	0x20004236
 8000cd0:	200044d4 	.word	0x200044d4
 8000cd4:	2000435c 	.word	0x2000435c
 8000cd8:	2000440c 	.word	0x2000440c
 8000cdc:	0800fe20 	.word	0x0800fe20
 8000ce0:	08000175 	.word	0x08000175
 8000ce4:	20004420 	.word	0x20004420
 8000ce8:	0800fe50 	.word	0x0800fe50
 8000cec:	20004470 	.word	0x20004470
 8000cf0:	0800fe08 	.word	0x0800fe08
 8000cf4:	2000447c 	.word	0x2000447c
 8000cf8:	0800fdb0 	.word	0x0800fdb0
 8000cfc:	08000db9 	.word	0x08000db9
 8000d00:	200043b0 	.word	0x200043b0
 8000d04:	0800fd8c 	.word	0x0800fd8c
 8000d08:	08000e81 	.word	0x08000e81
 8000d0c:	20004280 	.word	0x20004280
 8000d10:	0800fdd4 	.word	0x0800fdd4
 8000d14:	08000f2d 	.word	0x08000f2d
 8000d18:	20004358 	.word	0x20004358
 8000d1c:	0800fc24 	.word	0x0800fc24
 8000d20:	08000fd5 	.word	0x08000fd5
 8000d24:	2000421c 	.word	0x2000421c
 8000d28:	0800fd20 	.word	0x0800fd20
 8000d2c:	08001025 	.word	0x08001025
 8000d30:	200043a4 	.word	0x200043a4
 8000d34:	0800fc48 	.word	0x0800fc48
 8000d38:	08001075 	.word	0x08001075
 8000d3c:	2000414c 	.word	0x2000414c
 8000d40:	0800fd44 	.word	0x0800fd44
 8000d44:	080010c5 	.word	0x080010c5
 8000d48:	20004478 	.word	0x20004478
 8000d4c:	0800fc6c 	.word	0x0800fc6c
 8000d50:	08001115 	.word	0x08001115
 8000d54:	200044cc 	.word	0x200044cc
 8000d58:	0800fd68 	.word	0x0800fd68
 8000d5c:	08001165 	.word	0x08001165
 8000d60:	20004140 	.word	0x20004140
 8000d64:	0800fcd8 	.word	0x0800fcd8
 8000d68:	080011b5 	.word	0x080011b5
 8000d6c:	200043ac 	.word	0x200043ac
 8000d70:	0800fc90 	.word	0x0800fc90
 8000d74:	08001305 	.word	0x08001305
 8000d78:	20004284 	.word	0x20004284
 8000d7c:	0800fcb4 	.word	0x0800fcb4
 8000d80:	08001371 	.word	0x08001371
 8000d84:	20004144 	.word	0x20004144
 8000d88:	0800fc00 	.word	0x0800fc00
 8000d8c:	080003f5 	.word	0x080003f5
 8000d90:	200044f0 	.word	0x200044f0
 8000d94:	0800fcfc 	.word	0x0800fcfc
 8000d98:	080002c5 	.word	0x080002c5
 8000d9c:	2000441c 	.word	0x2000441c
 8000da0:	0800fdf8 	.word	0x0800fdf8
 8000da4:	200044f8 	.word	0x200044f8
 8000da8:	0800fe40 	.word	0x0800fe40
 8000dac:	20004474 	.word	0x20004474
 8000db0:	0800fe30 	.word	0x0800fe30
 8000db4:	200044ec 	.word	0x200044ec

08000db8 <StartVelostatScanADC>:
void StartVelostatScanADC(void *argument) {
 8000db8:	b570      	push	{r4, r5, r6, lr}
	ptrCellsBuffer = (uint32_t*) pvPortMalloc(
 8000dba:	f44f 705c 	mov.w	r0, #880	; 0x370
 8000dbe:	f00e fb85 	bl	800f4cc <pvPortMalloc>
 8000dc2:	4a28      	ldr	r2, [pc, #160]	; (8000e64 <StartVelostatScanADC+0xac>)
 8000dc4:	6010      	str	r0, [r2, #0]
	if (ptrCellsBuffer == NULL)
 8000dc6:	b148      	cbz	r0, 8000ddc <StartVelostatScanADC+0x24>
	HAL_ADCEx_Calibration_Start(&hadc2);
 8000dc8:	4827      	ldr	r0, [pc, #156]	; (8000e68 <StartVelostatScanADC+0xb0>)
 8000dca:	f001 ff11 	bl	8002bf0 <HAL_ADCEx_Calibration_Start>
	HAL_ADCEx_Calibration_Start(&hadc1);
 8000dce:	4827      	ldr	r0, [pc, #156]	; (8000e6c <StartVelostatScanADC+0xb4>)
 8000dd0:	f001 ff0e 	bl	8002bf0 <HAL_ADCEx_Calibration_Start>
	scanRowth = 0u;
 8000dd4:	4b26      	ldr	r3, [pc, #152]	; (8000e70 <StartVelostatScanADC+0xb8>)
 8000dd6:	2200      	movs	r2, #0
 8000dd8:	801a      	strh	r2, [r3, #0]
 8000dda:	e009      	b.n	8000df0 <StartVelostatScanADC+0x38>
		Error_Handler();
 8000ddc:	f7ff fc1e 	bl	800061c <Error_Handler>
			++scanRowth;
 8000de0:	3301      	adds	r3, #1
 8000de2:	4a23      	ldr	r2, [pc, #140]	; (8000e70 <StartVelostatScanADC+0xb8>)
 8000de4:	8013      	strh	r3, [r2, #0]
			osEventFlagsSet(velostatEventHandle, FlagVelostatSortDataNotFull);
 8000de6:	2108      	movs	r1, #8
 8000de8:	4b22      	ldr	r3, [pc, #136]	; (8000e74 <StartVelostatScanADC+0xbc>)
 8000dea:	6818      	ldr	r0, [r3, #0]
 8000dec:	f00a fc04 	bl	800b5f8 <osEventFlagsSet>
		osEventFlagsWait(velostatEventHandle, FlagVelostatEnable,
 8000df0:	4d20      	ldr	r5, [pc, #128]	; (8000e74 <StartVelostatScanADC+0xbc>)
 8000df2:	f04f 33ff 	mov.w	r3, #4294967295
 8000df6:	2203      	movs	r2, #3
 8000df8:	2180      	movs	r1, #128	; 0x80
 8000dfa:	6828      	ldr	r0, [r5, #0]
 8000dfc:	f00a fc88 	bl	800b710 <osEventFlagsWait>
		osEventFlagsWait(velostatEventHandle,
 8000e00:	2364      	movs	r3, #100	; 0x64
 8000e02:	2200      	movs	r2, #0
 8000e04:	2148      	movs	r1, #72	; 0x48
 8000e06:	6828      	ldr	r0, [r5, #0]
 8000e08:	f00a fc82 	bl	800b710 <osEventFlagsWait>
		Scan_74238(scanRowth);
 8000e0c:	4c18      	ldr	r4, [pc, #96]	; (8000e70 <StartVelostatScanADC+0xb8>)
 8000e0e:	8820      	ldrh	r0, [r4, #0]
 8000e10:	f00e fc80 	bl	800f714 <Scan_74238>
		ptr = ptrCellsBuffer;
 8000e14:	4b13      	ldr	r3, [pc, #76]	; (8000e64 <StartVelostatScanADC+0xac>)
 8000e16:	681e      	ldr	r6, [r3, #0]
		ptr += (scanRowth * NumberOfConversion);
 8000e18:	8823      	ldrh	r3, [r4, #0]
 8000e1a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000e1e:	eb06 0683 	add.w	r6, r6, r3, lsl #2
		HAL_ADC_Start(&hadc2);
 8000e22:	4811      	ldr	r0, [pc, #68]	; (8000e68 <StartVelostatScanADC+0xb0>)
 8000e24:	f001 fbca 	bl	80025bc <HAL_ADC_Start>
		HAL_ADCEx_MultiModeStart_DMA(&hadc1, (uint32_t*) ptr,
 8000e28:	2205      	movs	r2, #5
 8000e2a:	4631      	mov	r1, r6
 8000e2c:	480f      	ldr	r0, [pc, #60]	; (8000e6c <StartVelostatScanADC+0xb4>)
 8000e2e:	f002 f932 	bl	8003096 <HAL_ADCEx_MultiModeStart_DMA>
		osEventFlagsWait(velostatEventHandle, FlagVelostatADC_ConvCplt,
 8000e32:	f04f 33ff 	mov.w	r3, #4294967295
 8000e36:	2201      	movs	r2, #1
 8000e38:	4611      	mov	r1, r2
 8000e3a:	6828      	ldr	r0, [r5, #0]
 8000e3c:	f00a fc68 	bl	800b710 <osEventFlagsWait>
		if (scanRowth >= (NumberOfScanLimit - 1)) {
 8000e40:	8823      	ldrh	r3, [r4, #0]
 8000e42:	2b2a      	cmp	r3, #42	; 0x2a
 8000e44:	d9cc      	bls.n	8000de0 <StartVelostatScanADC+0x28>
			scanRowth -= (NumberOfScanLimit - 1);
 8000e46:	3b2b      	subs	r3, #43	; 0x2b
 8000e48:	8023      	strh	r3, [r4, #0]
			osEventFlagsSet(velostatEventHandle, FlagVelostatSortDataFull);
 8000e4a:	2110      	movs	r1, #16
 8000e4c:	6828      	ldr	r0, [r5, #0]
 8000e4e:	f00a fbd3 	bl	800b5f8 <osEventFlagsSet>
			endScan = HAL_GetTick() - startScan;
 8000e52:	f001 f843 	bl	8001edc <HAL_GetTick>
 8000e56:	4b08      	ldr	r3, [pc, #32]	; (8000e78 <StartVelostatScanADC+0xc0>)
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	1ac0      	subs	r0, r0, r3
 8000e5c:	4b07      	ldr	r3, [pc, #28]	; (8000e7c <StartVelostatScanADC+0xc4>)
 8000e5e:	6018      	str	r0, [r3, #0]
 8000e60:	e7c6      	b.n	8000df0 <StartVelostatScanADC+0x38>
 8000e62:	bf00      	nop
 8000e64:	20004224 	.word	0x20004224
 8000e68:	200041ec 	.word	0x200041ec
 8000e6c:	200042d8 	.word	0x200042d8
 8000e70:	2000422c 	.word	0x2000422c
 8000e74:	20004474 	.word	0x20004474
 8000e78:	200042d4 	.word	0x200042d4
 8000e7c:	200041e8 	.word	0x200041e8

08000e80 <StartVelostatProcessOutput>:
void StartVelostatProcessOutput(void *argument) {
 8000e80:	b500      	push	{lr}
 8000e82:	b083      	sub	sp, #12
	hdma_memtomem_dma1_channel2.XferCpltCallback = User_DMA_XferCpltCallback;
 8000e84:	4b23      	ldr	r3, [pc, #140]	; (8000f14 <StartVelostatProcessOutput+0x94>)
 8000e86:	4a24      	ldr	r2, [pc, #144]	; (8000f18 <StartVelostatProcessOutput+0x98>)
 8000e88:	629a      	str	r2, [r3, #40]	; 0x28
 8000e8a:	e00e      	b.n	8000eaa <StartVelostatProcessOutput+0x2a>
			Error_Handler();
 8000e8c:	f7ff fbc6 	bl	800061c <Error_Handler>
			vPortFree(ptr);
 8000e90:	9801      	ldr	r0, [sp, #4]
 8000e92:	f00e fb9d 	bl	800f5d0 <vPortFree>
 8000e96:	e008      	b.n	8000eaa <StartVelostatProcessOutput+0x2a>
			osEventFlagsSet(velostatEventHandle, FlagVelostatEnqueue);
 8000e98:	2140      	movs	r1, #64	; 0x40
 8000e9a:	4b20      	ldr	r3, [pc, #128]	; (8000f1c <StartVelostatProcessOutput+0x9c>)
 8000e9c:	6818      	ldr	r0, [r3, #0]
 8000e9e:	f00a fbab 	bl	800b5f8 <osEventFlagsSet>
			startScan = HAL_GetTick();
 8000ea2:	f001 f81b 	bl	8001edc <HAL_GetTick>
 8000ea6:	4b1e      	ldr	r3, [pc, #120]	; (8000f20 <StartVelostatProcessOutput+0xa0>)
 8000ea8:	6018      	str	r0, [r3, #0]
		osEventFlagsWait(velostatEventHandle, FlagVelostatSortDataFull,
 8000eaa:	f04f 33ff 	mov.w	r3, #4294967295
 8000eae:	2201      	movs	r2, #1
 8000eb0:	2110      	movs	r1, #16
 8000eb2:	481a      	ldr	r0, [pc, #104]	; (8000f1c <StartVelostatProcessOutput+0x9c>)
 8000eb4:	6800      	ldr	r0, [r0, #0]
 8000eb6:	f00a fc2b 	bl	800b710 <osEventFlagsWait>
		ptr = (uint16_t*) pvPortMalloc(NumberOfCells * sizeof(uint16_t));
 8000eba:	f44f 705c 	mov.w	r0, #880	; 0x370
 8000ebe:	f00e fb05 	bl	800f4cc <pvPortMalloc>
 8000ec2:	4602      	mov	r2, r0
 8000ec4:	9001      	str	r0, [sp, #4]
		if (ptr == NULL)
 8000ec6:	2800      	cmp	r0, #0
 8000ec8:	d0e0      	beq.n	8000e8c <StartVelostatProcessOutput+0xc>
		HAL_DMA_Start_IT(&hdma_memtomem_dma1_channel2,
 8000eca:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
 8000ece:	4915      	ldr	r1, [pc, #84]	; (8000f24 <StartVelostatProcessOutput+0xa4>)
 8000ed0:	6809      	ldr	r1, [r1, #0]
 8000ed2:	4810      	ldr	r0, [pc, #64]	; (8000f14 <StartVelostatProcessOutput+0x94>)
 8000ed4:	f002 fcc4 	bl	8003860 <HAL_DMA_Start_IT>
		osEventFlagsWait(velostatEventHandle, FlagVelostatDMAChn2_XferCplt,
 8000ed8:	f04f 33ff 	mov.w	r3, #4294967295
 8000edc:	2201      	movs	r2, #1
 8000ede:	2102      	movs	r1, #2
 8000ee0:	480e      	ldr	r0, [pc, #56]	; (8000f1c <StartVelostatProcessOutput+0x9c>)
 8000ee2:	6800      	ldr	r0, [r0, #0]
 8000ee4:	f00a fc14 	bl	800b710 <osEventFlagsWait>
		ptr[85u] = ptr[86u];
 8000ee8:	9b01      	ldr	r3, [sp, #4]
 8000eea:	f8b3 20ac 	ldrh.w	r2, [r3, #172]	; 0xac
 8000eee:	f8a3 20aa 	strh.w	r2, [r3, #170]	; 0xaa
		ptr[95u] = ptr[105u];
 8000ef2:	f8b3 20d2 	ldrh.w	r2, [r3, #210]	; 0xd2
 8000ef6:	f8a3 20be 	strh.w	r2, [r3, #190]	; 0xbe
		stat = osMessageQueuePut(velostatQueueHandle, &ptr, 0, 35u);
 8000efa:	2323      	movs	r3, #35	; 0x23
 8000efc:	2200      	movs	r2, #0
 8000efe:	a901      	add	r1, sp, #4
 8000f00:	4809      	ldr	r0, [pc, #36]	; (8000f28 <StartVelostatProcessOutput+0xa8>)
 8000f02:	6800      	ldr	r0, [r0, #0]
 8000f04:	f00a ff26 	bl	800bd54 <osMessageQueuePut>
		if (stat == osErrorTimeout) {
 8000f08:	f110 0f02 	cmn.w	r0, #2
 8000f0c:	d0c0      	beq.n	8000e90 <StartVelostatProcessOutput+0x10>
		} else if (stat == osOK) {
 8000f0e:	2800      	cmp	r0, #0
 8000f10:	d1cb      	bne.n	8000eaa <StartVelostatProcessOutput+0x2a>
 8000f12:	e7c1      	b.n	8000e98 <StartVelostatProcessOutput+0x18>
 8000f14:	20004424 	.word	0x20004424
 8000f18:	08000289 	.word	0x08000289
 8000f1c:	20004474 	.word	0x20004474
 8000f20:	200042d4 	.word	0x200042d4
 8000f24:	20004224 	.word	0x20004224
 8000f28:	20004470 	.word	0x20004470

08000f2c <StartVelostatTransmit>:
void StartVelostatTransmit(void *argument) {
 8000f2c:	b510      	push	{r4, lr}
 8000f2e:	b082      	sub	sp, #8
	uint16_t *buffer = (uint16_t*) pvPortMalloc(
 8000f30:	f44f 705d 	mov.w	r0, #884	; 0x374
 8000f34:	f00e faca 	bl	800f4cc <pvPortMalloc>
	if (buffer == NULL)
 8000f38:	b158      	cbz	r0, 8000f52 <StartVelostatTransmit+0x26>
 8000f3a:	4604      	mov	r4, r0
	buffer[0] = 0xaaaa;
 8000f3c:	f64a 23aa 	movw	r3, #43690	; 0xaaaa
 8000f40:	8003      	strh	r3, [r0, #0]
	buffer[TxBufferSize - 1] = 0x5555;
 8000f42:	f245 5355 	movw	r3, #21845	; 0x5555
 8000f46:	f8a0 3372 	strh.w	r3, [r0, #882]	; 0x372
	hdma_memtomem_dma1_channel3.XferCpltCallback = User_DMA_XferCpltCallback;
 8000f4a:	4b1b      	ldr	r3, [pc, #108]	; (8000fb8 <StartVelostatTransmit+0x8c>)
 8000f4c:	4a1b      	ldr	r2, [pc, #108]	; (8000fbc <StartVelostatTransmit+0x90>)
 8000f4e:	629a      	str	r2, [r3, #40]	; 0x28
 8000f50:	e007      	b.n	8000f62 <StartVelostatTransmit+0x36>
		Error_Handler();
 8000f52:	f7ff fb63 	bl	800061c <Error_Handler>
			HAL_UART_Transmit_DMA(&huart1, (uint8_t*) buffer,
 8000f56:	f44f 725d 	mov.w	r2, #884	; 0x374
 8000f5a:	4621      	mov	r1, r4
 8000f5c:	4818      	ldr	r0, [pc, #96]	; (8000fc0 <StartVelostatTransmit+0x94>)
 8000f5e:	f008 fe23 	bl	8009ba8 <HAL_UART_Transmit_DMA>
		stat = osMessageQueueGet(velostatQueueHandle, &buf, NULL,
 8000f62:	f04f 33ff 	mov.w	r3, #4294967295
 8000f66:	2200      	movs	r2, #0
 8000f68:	a901      	add	r1, sp, #4
 8000f6a:	4816      	ldr	r0, [pc, #88]	; (8000fc4 <StartVelostatTransmit+0x98>)
 8000f6c:	6800      	ldr	r0, [r0, #0]
 8000f6e:	f00a ff41 	bl	800bdf4 <osMessageQueueGet>
		if (stat == osOK) {
 8000f72:	2800      	cmp	r0, #0
 8000f74:	d1f5      	bne.n	8000f62 <StartVelostatTransmit+0x36>
			startTx = HAL_GetTick();
 8000f76:	f000 ffb1 	bl	8001edc <HAL_GetTick>
 8000f7a:	4b13      	ldr	r3, [pc, #76]	; (8000fc8 <StartVelostatTransmit+0x9c>)
 8000f7c:	6018      	str	r0, [r3, #0]
			HAL_DMA_Start_IT(&hdma_memtomem_dma1_channel3, (uint32_t) buf,
 8000f7e:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
 8000f82:	1ca2      	adds	r2, r4, #2
 8000f84:	9901      	ldr	r1, [sp, #4]
 8000f86:	480c      	ldr	r0, [pc, #48]	; (8000fb8 <StartVelostatTransmit+0x8c>)
 8000f88:	f002 fc6a 	bl	8003860 <HAL_DMA_Start_IT>
			osEventFlagsWait(velostatEventHandle, FlagVelostatDMAChn3_XferCplt,
 8000f8c:	f04f 33ff 	mov.w	r3, #4294967295
 8000f90:	2201      	movs	r2, #1
 8000f92:	2120      	movs	r1, #32
 8000f94:	480d      	ldr	r0, [pc, #52]	; (8000fcc <StartVelostatTransmit+0xa0>)
 8000f96:	6800      	ldr	r0, [r0, #0]
 8000f98:	f00a fbba 	bl	800b710 <osEventFlagsWait>
			if (osMessageQueuePut(handQueueHandle, &buf, 0, 50u) != osOK)
 8000f9c:	2332      	movs	r3, #50	; 0x32
 8000f9e:	2200      	movs	r2, #0
 8000fa0:	a901      	add	r1, sp, #4
 8000fa2:	480b      	ldr	r0, [pc, #44]	; (8000fd0 <StartVelostatTransmit+0xa4>)
 8000fa4:	6800      	ldr	r0, [r0, #0]
 8000fa6:	f00a fed5 	bl	800bd54 <osMessageQueuePut>
 8000faa:	2800      	cmp	r0, #0
 8000fac:	d0d3      	beq.n	8000f56 <StartVelostatTransmit+0x2a>
				vPortFree(buf);
 8000fae:	9801      	ldr	r0, [sp, #4]
 8000fb0:	f00e fb0e 	bl	800f5d0 <vPortFree>
 8000fb4:	e7cf      	b.n	8000f56 <StartVelostatTransmit+0x2a>
 8000fb6:	bf00      	nop
 8000fb8:	2000415c 	.word	0x2000415c
 8000fbc:	08000289 	.word	0x08000289
 8000fc0:	20004360 	.word	0x20004360
 8000fc4:	20004470 	.word	0x20004470
 8000fc8:	20004228 	.word	0x20004228
 8000fcc:	20004474 	.word	0x20004474
 8000fd0:	2000447c 	.word	0x2000447c

08000fd4 <StartHandBot1>:
void StartHandBot1(void *argument) {
 8000fd4:	b500      	push	{lr}
 8000fd6:	b083      	sub	sp, #12
	bot1 = (Servo*) pvPortMalloc(sizeof(Servo));
 8000fd8:	201c      	movs	r0, #28
 8000fda:	f00e fa77 	bl	800f4cc <pvPortMalloc>
 8000fde:	4b0e      	ldr	r3, [pc, #56]	; (8001018 <StartHandBot1+0x44>)
 8000fe0:	6018      	str	r0, [r3, #0]
	if (bot1 == NULL)
 8000fe2:	b1b8      	cbz	r0, 8001014 <StartHandBot1+0x40>
	vServoInit(bot1, &htim2, TIM_CHANNEL_1, handEventHandle, FlagHandBot1);
 8000fe4:	2302      	movs	r3, #2
 8000fe6:	9300      	str	r3, [sp, #0]
 8000fe8:	4b0c      	ldr	r3, [pc, #48]	; (800101c <StartHandBot1+0x48>)
 8000fea:	681b      	ldr	r3, [r3, #0]
 8000fec:	2200      	movs	r2, #0
 8000fee:	490c      	ldr	r1, [pc, #48]	; (8001020 <StartHandBot1+0x4c>)
 8000ff0:	f00e fbe6 	bl	800f7c0 <vServoInit>
	bot1->downLimit = 41u;
 8000ff4:	4b08      	ldr	r3, [pc, #32]	; (8001018 <StartHandBot1+0x44>)
 8000ff6:	681a      	ldr	r2, [r3, #0]
 8000ff8:	2129      	movs	r1, #41	; 0x29
 8000ffa:	70d1      	strb	r1, [r2, #3]
	bot1->upLimit = 66u;
 8000ffc:	6818      	ldr	r0, [r3, #0]
 8000ffe:	2342      	movs	r3, #66	; 0x42
 8001000:	7103      	strb	r3, [r0, #4]
	bot1->isReverse = 0u;
 8001002:	2300      	movs	r3, #0
 8001004:	7143      	strb	r3, [r0, #5]
	vServoStart(bot1);
 8001006:	f00e fbfb 	bl	800f800 <vServoStart>
		eServoMove(bot1);
 800100a:	4b03      	ldr	r3, [pc, #12]	; (8001018 <StartHandBot1+0x44>)
 800100c:	6818      	ldr	r0, [r3, #0]
 800100e:	f00e fc16 	bl	800f83e <eServoMove>
	for (;;) {
 8001012:	e7fa      	b.n	800100a <StartHandBot1+0x36>
		Error_Handler();
 8001014:	f7ff fb02 	bl	800061c <Error_Handler>
 8001018:	20004500 	.word	0x20004500
 800101c:	200044f8 	.word	0x200044f8
 8001020:	20004484 	.word	0x20004484

08001024 <StartHandTop1>:
void StartHandTop1(void *argument) {
 8001024:	b500      	push	{lr}
 8001026:	b083      	sub	sp, #12
	top1 = (Servo*) pvPortMalloc(sizeof(Servo));
 8001028:	201c      	movs	r0, #28
 800102a:	f00e fa4f 	bl	800f4cc <pvPortMalloc>
 800102e:	4b0e      	ldr	r3, [pc, #56]	; (8001068 <StartHandTop1+0x44>)
 8001030:	6018      	str	r0, [r3, #0]
	if (top1 == NULL)
 8001032:	b1b0      	cbz	r0, 8001062 <StartHandTop1+0x3e>
	vServoInit(top1, &htim2, TIM_CHANNEL_2, handEventHandle, FlagHandTop1);
 8001034:	2204      	movs	r2, #4
 8001036:	9200      	str	r2, [sp, #0]
 8001038:	4b0c      	ldr	r3, [pc, #48]	; (800106c <StartHandTop1+0x48>)
 800103a:	681b      	ldr	r3, [r3, #0]
 800103c:	490c      	ldr	r1, [pc, #48]	; (8001070 <StartHandTop1+0x4c>)
 800103e:	f00e fbbf 	bl	800f7c0 <vServoInit>
	top1->downLimit = 28u;
 8001042:	4b09      	ldr	r3, [pc, #36]	; (8001068 <StartHandTop1+0x44>)
 8001044:	681a      	ldr	r2, [r3, #0]
 8001046:	211c      	movs	r1, #28
 8001048:	70d1      	strb	r1, [r2, #3]
	top1->upLimit = 84u;
 800104a:	6818      	ldr	r0, [r3, #0]
 800104c:	2354      	movs	r3, #84	; 0x54
 800104e:	7103      	strb	r3, [r0, #4]
	top1->isReverse = 1u;
 8001050:	2301      	movs	r3, #1
 8001052:	7143      	strb	r3, [r0, #5]
	vServoStart(top1);
 8001054:	f00e fbd4 	bl	800f800 <vServoStart>
		eServoMove(top1);
 8001058:	4b03      	ldr	r3, [pc, #12]	; (8001068 <StartHandTop1+0x44>)
 800105a:	6818      	ldr	r0, [r3, #0]
 800105c:	f00e fbef 	bl	800f83e <eServoMove>
	for (;;) {
 8001060:	e7fa      	b.n	8001058 <StartHandTop1+0x34>
		Error_Handler();
 8001062:	f7ff fadb 	bl	800061c <Error_Handler>
 8001066:	bf00      	nop
 8001068:	20004418 	.word	0x20004418
 800106c:	200044f8 	.word	0x200044f8
 8001070:	20004484 	.word	0x20004484

08001074 <StartHandBot2>:
void StartHandBot2(void *argument) {
 8001074:	b500      	push	{lr}
 8001076:	b083      	sub	sp, #12
	bot2 = (Servo*) pvPortMalloc(sizeof(Servo));
 8001078:	201c      	movs	r0, #28
 800107a:	f00e fa27 	bl	800f4cc <pvPortMalloc>
 800107e:	4b0e      	ldr	r3, [pc, #56]	; (80010b8 <StartHandBot2+0x44>)
 8001080:	6018      	str	r0, [r3, #0]
	if (bot2 == NULL)
 8001082:	b1b8      	cbz	r0, 80010b4 <StartHandBot2+0x40>
	vServoInit(bot2, &htim3, TIM_CHANNEL_1, handEventHandle, FlagHandBot2);
 8001084:	2308      	movs	r3, #8
 8001086:	9300      	str	r3, [sp, #0]
 8001088:	4b0c      	ldr	r3, [pc, #48]	; (80010bc <StartHandBot2+0x48>)
 800108a:	681b      	ldr	r3, [r3, #0]
 800108c:	2200      	movs	r2, #0
 800108e:	490c      	ldr	r1, [pc, #48]	; (80010c0 <StartHandBot2+0x4c>)
 8001090:	f00e fb96 	bl	800f7c0 <vServoInit>
	bot2->downLimit = 45u;
 8001094:	4b08      	ldr	r3, [pc, #32]	; (80010b8 <StartHandBot2+0x44>)
 8001096:	681a      	ldr	r2, [r3, #0]
 8001098:	212d      	movs	r1, #45	; 0x2d
 800109a:	70d1      	strb	r1, [r2, #3]
	bot2->upLimit = 78u;
 800109c:	6818      	ldr	r0, [r3, #0]
 800109e:	234e      	movs	r3, #78	; 0x4e
 80010a0:	7103      	strb	r3, [r0, #4]
	bot2->isReverse = 0u;
 80010a2:	2300      	movs	r3, #0
 80010a4:	7143      	strb	r3, [r0, #5]
	vServoStart(bot2);
 80010a6:	f00e fbab 	bl	800f800 <vServoStart>
		eServoMove(bot2);
 80010aa:	4b03      	ldr	r3, [pc, #12]	; (80010b8 <StartHandBot2+0x44>)
 80010ac:	6818      	ldr	r0, [r3, #0]
 80010ae:	f00e fbc6 	bl	800f83e <eServoMove>
	for (;;) {
 80010b2:	e7fa      	b.n	80010aa <StartHandBot2+0x36>
		Error_Handler();
 80010b4:	f7ff fab2 	bl	800061c <Error_Handler>
 80010b8:	200044fc 	.word	0x200044fc
 80010bc:	200044f8 	.word	0x200044f8
 80010c0:	20004238 	.word	0x20004238

080010c4 <StartHandTop2>:
void StartHandTop2(void *argument) {
 80010c4:	b500      	push	{lr}
 80010c6:	b083      	sub	sp, #12
	top2 = (Servo*) pvPortMalloc(sizeof(Servo));
 80010c8:	201c      	movs	r0, #28
 80010ca:	f00e f9ff 	bl	800f4cc <pvPortMalloc>
 80010ce:	4b0e      	ldr	r3, [pc, #56]	; (8001108 <StartHandTop2+0x44>)
 80010d0:	6018      	str	r0, [r3, #0]
	if (top2 == NULL)
 80010d2:	b1b8      	cbz	r0, 8001104 <StartHandTop2+0x40>
	vServoInit(top2, &htim3, TIM_CHANNEL_2, handEventHandle, FlagHandTop2);
 80010d4:	2310      	movs	r3, #16
 80010d6:	9300      	str	r3, [sp, #0]
 80010d8:	4b0c      	ldr	r3, [pc, #48]	; (800110c <StartHandTop2+0x48>)
 80010da:	681b      	ldr	r3, [r3, #0]
 80010dc:	2204      	movs	r2, #4
 80010de:	490c      	ldr	r1, [pc, #48]	; (8001110 <StartHandTop2+0x4c>)
 80010e0:	f00e fb6e 	bl	800f7c0 <vServoInit>
	top2->downLimit = 34u;
 80010e4:	4b08      	ldr	r3, [pc, #32]	; (8001108 <StartHandTop2+0x44>)
 80010e6:	681a      	ldr	r2, [r3, #0]
 80010e8:	2122      	movs	r1, #34	; 0x22
 80010ea:	70d1      	strb	r1, [r2, #3]
	top2->upLimit = 89u;
 80010ec:	6818      	ldr	r0, [r3, #0]
 80010ee:	2359      	movs	r3, #89	; 0x59
 80010f0:	7103      	strb	r3, [r0, #4]
	top2->isReverse = 0u;
 80010f2:	2300      	movs	r3, #0
 80010f4:	7143      	strb	r3, [r0, #5]
	vServoStart(top2);
 80010f6:	f00e fb83 	bl	800f800 <vServoStart>
		eServoMove(top2);
 80010fa:	4b03      	ldr	r3, [pc, #12]	; (8001108 <StartHandTop2+0x44>)
 80010fc:	6818      	ldr	r0, [r3, #0]
 80010fe:	f00e fb9e 	bl	800f83e <eServoMove>
	for (;;) {
 8001102:	e7fa      	b.n	80010fa <StartHandTop2+0x36>
		Error_Handler();
 8001104:	f7ff fa8a 	bl	800061c <Error_Handler>
 8001108:	20004138 	.word	0x20004138
 800110c:	200044f8 	.word	0x200044f8
 8001110:	20004238 	.word	0x20004238

08001114 <StartHandBot3>:
void StartHandBot3(void *argument) {
 8001114:	b500      	push	{lr}
 8001116:	b083      	sub	sp, #12
	bot3 = (Servo*) pvPortMalloc(sizeof(Servo));
 8001118:	201c      	movs	r0, #28
 800111a:	f00e f9d7 	bl	800f4cc <pvPortMalloc>
 800111e:	4b0e      	ldr	r3, [pc, #56]	; (8001158 <StartHandBot3+0x44>)
 8001120:	6018      	str	r0, [r3, #0]
	if (bot3 == NULL)
 8001122:	b1b8      	cbz	r0, 8001154 <StartHandBot3+0x40>
	vServoInit(bot3, &htim4, TIM_CHANNEL_1, handEventHandle, FlagHandBot3);
 8001124:	2320      	movs	r3, #32
 8001126:	9300      	str	r3, [sp, #0]
 8001128:	4b0c      	ldr	r3, [pc, #48]	; (800115c <StartHandBot3+0x48>)
 800112a:	681b      	ldr	r3, [r3, #0]
 800112c:	2200      	movs	r2, #0
 800112e:	490c      	ldr	r1, [pc, #48]	; (8001160 <StartHandBot3+0x4c>)
 8001130:	f00e fb46 	bl	800f7c0 <vServoInit>
	bot3->downLimit = 48u;
 8001134:	4b08      	ldr	r3, [pc, #32]	; (8001158 <StartHandBot3+0x44>)
 8001136:	681a      	ldr	r2, [r3, #0]
 8001138:	2130      	movs	r1, #48	; 0x30
 800113a:	70d1      	strb	r1, [r2, #3]
	bot3->upLimit = 75u;
 800113c:	6818      	ldr	r0, [r3, #0]
 800113e:	234b      	movs	r3, #75	; 0x4b
 8001140:	7103      	strb	r3, [r0, #4]
	bot3->isReverse = 1u;
 8001142:	2301      	movs	r3, #1
 8001144:	7143      	strb	r3, [r0, #5]
	vServoStart(bot3);
 8001146:	f00e fb5b 	bl	800f800 <vServoStart>
		eServoMove(bot3);
 800114a:	4b03      	ldr	r3, [pc, #12]	; (8001158 <StartHandBot3+0x44>)
 800114c:	6818      	ldr	r0, [r3, #0]
 800114e:	f00e fb76 	bl	800f83e <eServoMove>
	for (;;) {
 8001152:	e7fa      	b.n	800114a <StartHandBot3+0x36>
		Error_Handler();
 8001154:	f7ff fa62 	bl	800061c <Error_Handler>
 8001158:	20004408 	.word	0x20004408
 800115c:	200044f8 	.word	0x200044f8
 8001160:	200041a0 	.word	0x200041a0

08001164 <StartHandTop3>:
void StartHandTop3(void *argument) {
 8001164:	b500      	push	{lr}
 8001166:	b083      	sub	sp, #12
	top3 = (Servo*) pvPortMalloc(sizeof(Servo));
 8001168:	201c      	movs	r0, #28
 800116a:	f00e f9af 	bl	800f4cc <pvPortMalloc>
 800116e:	4b0e      	ldr	r3, [pc, #56]	; (80011a8 <StartHandTop3+0x44>)
 8001170:	6018      	str	r0, [r3, #0]
	if (top3 == NULL)
 8001172:	b1b8      	cbz	r0, 80011a4 <StartHandTop3+0x40>
	vServoInit(top3, &htim4, TIM_CHANNEL_2, handEventHandle, FlagHandTop3);
 8001174:	2340      	movs	r3, #64	; 0x40
 8001176:	9300      	str	r3, [sp, #0]
 8001178:	4b0c      	ldr	r3, [pc, #48]	; (80011ac <StartHandTop3+0x48>)
 800117a:	681b      	ldr	r3, [r3, #0]
 800117c:	2204      	movs	r2, #4
 800117e:	490c      	ldr	r1, [pc, #48]	; (80011b0 <StartHandTop3+0x4c>)
 8001180:	f00e fb1e 	bl	800f7c0 <vServoInit>
	top3->downLimit = 45u;
 8001184:	4b08      	ldr	r3, [pc, #32]	; (80011a8 <StartHandTop3+0x44>)
 8001186:	681a      	ldr	r2, [r3, #0]
 8001188:	212d      	movs	r1, #45	; 0x2d
 800118a:	70d1      	strb	r1, [r2, #3]
	top3->upLimit = 108u;
 800118c:	6818      	ldr	r0, [r3, #0]
 800118e:	236c      	movs	r3, #108	; 0x6c
 8001190:	7103      	strb	r3, [r0, #4]
	top3->isReverse = 1u;
 8001192:	2301      	movs	r3, #1
 8001194:	7143      	strb	r3, [r0, #5]
	vServoStart(top3);
 8001196:	f00e fb33 	bl	800f800 <vServoStart>
		eServoMove(top3);
 800119a:	4b03      	ldr	r3, [pc, #12]	; (80011a8 <StartHandTop3+0x44>)
 800119c:	6818      	ldr	r0, [r3, #0]
 800119e:	f00e fb4e 	bl	800f83e <eServoMove>
	for (;;) {
 80011a2:	e7fa      	b.n	800119a <StartHandTop3+0x36>
		Error_Handler();
 80011a4:	f7ff fa3a 	bl	800061c <Error_Handler>
 80011a8:	20004150 	.word	0x20004150
 80011ac:	200044f8 	.word	0x200044f8
 80011b0:	200041a0 	.word	0x200041a0

080011b4 <StartHandRxHandler>:
void StartHandRxHandler(void *argument) {
 80011b4:	b538      	push	{r3, r4, r5, lr}
	rxData = (uint8_t*) pvPortMalloc(NumberOfRxData * sizeof(uint8_t));
 80011b6:	2015      	movs	r0, #21
 80011b8:	f00e f988 	bl	800f4cc <pvPortMalloc>
 80011bc:	4a46      	ldr	r2, [pc, #280]	; (80012d8 <StartHandRxHandler+0x124>)
 80011be:	6010      	str	r0, [r2, #0]
	if (rxData == NULL)
 80011c0:	b158      	cbz	r0, 80011da <StartHandRxHandler+0x26>
	uint8_t *buffer = (uint8_t*) pvPortMalloc(NumberOfRxData * sizeof(uint8_t));
 80011c2:	2015      	movs	r0, #21
 80011c4:	f00e f982 	bl	800f4cc <pvPortMalloc>
	if (buffer == NULL)
 80011c8:	4604      	mov	r4, r0
 80011ca:	b140      	cbz	r0, 80011de <StartHandRxHandler+0x2a>
	HAL_UART_Receive_DMA(&huart1, rxData, NumberOfRxData);
 80011cc:	2215      	movs	r2, #21
 80011ce:	4b42      	ldr	r3, [pc, #264]	; (80012d8 <StartHandRxHandler+0x124>)
 80011d0:	6819      	ldr	r1, [r3, #0]
 80011d2:	4842      	ldr	r0, [pc, #264]	; (80012dc <StartHandRxHandler+0x128>)
 80011d4:	f009 fb7a 	bl	800a8cc <HAL_UART_Receive_DMA>
 80011d8:	e013      	b.n	8001202 <StartHandRxHandler+0x4e>
		Error_Handler();
 80011da:	f7ff fa1f 	bl	800061c <Error_Handler>
		Error_Handler();
 80011de:	f7ff fa1d 	bl	800061c <Error_Handler>
		if ((buffer[0] == Head) && (buffer[NumberOfRxData - 1] == Tail)) {
 80011e2:	7d22      	ldrb	r2, [r4, #20]
 80011e4:	2a55      	cmp	r2, #85	; 0x55
 80011e6:	d125      	bne.n	8001234 <StartHandRxHandler+0x80>
			countRun = 0u;
 80011e8:	4b3d      	ldr	r3, [pc, #244]	; (80012e0 <StartHandRxHandler+0x12c>)
 80011ea:	2200      	movs	r2, #0
 80011ec:	601a      	str	r2, [r3, #0]
			if ((osEventFlagsGet(handEventHandle) & FlagHandPeakControlEnable)
 80011ee:	4b3d      	ldr	r3, [pc, #244]	; (80012e4 <StartHandRxHandler+0x130>)
 80011f0:	6818      	ldr	r0, [r3, #0]
 80011f2:	f00a fa6f 	bl	800b6d4 <osEventFlagsGet>
 80011f6:	f010 0f80 	tst.w	r0, #128	; 0x80
 80011fa:	d048      	beq.n	800128e <StartHandRxHandler+0xda>
			servoLevel = buffer[19];
 80011fc:	7ce2      	ldrb	r2, [r4, #19]
 80011fe:	4b3a      	ldr	r3, [pc, #232]	; (80012e8 <StartHandRxHandler+0x134>)
 8001200:	701a      	strb	r2, [r3, #0]
		osEventFlagsWait(handEventHandle, FlagHandUART_RxCplt, osFlagsWaitAll,
 8001202:	f04f 33ff 	mov.w	r3, #4294967295
 8001206:	2201      	movs	r2, #1
 8001208:	4611      	mov	r1, r2
 800120a:	4836      	ldr	r0, [pc, #216]	; (80012e4 <StartHandRxHandler+0x130>)
 800120c:	6800      	ldr	r0, [r0, #0]
 800120e:	f00a fa7f 	bl	800b710 <osEventFlagsWait>
		memcpy(buffer, rxData, NumberOfRxData);
 8001212:	4b31      	ldr	r3, [pc, #196]	; (80012d8 <StartHandRxHandler+0x124>)
 8001214:	681b      	ldr	r3, [r3, #0]
 8001216:	681a      	ldr	r2, [r3, #0]
 8001218:	685d      	ldr	r5, [r3, #4]
 800121a:	6898      	ldr	r0, [r3, #8]
 800121c:	68d9      	ldr	r1, [r3, #12]
 800121e:	6022      	str	r2, [r4, #0]
 8001220:	6065      	str	r5, [r4, #4]
 8001222:	60a0      	str	r0, [r4, #8]
 8001224:	60e1      	str	r1, [r4, #12]
 8001226:	691a      	ldr	r2, [r3, #16]
 8001228:	6122      	str	r2, [r4, #16]
 800122a:	7d1b      	ldrb	r3, [r3, #20]
 800122c:	7523      	strb	r3, [r4, #20]
		if ((buffer[0] == Head) && (buffer[NumberOfRxData - 1] == Tail)) {
 800122e:	7823      	ldrb	r3, [r4, #0]
 8001230:	2baa      	cmp	r3, #170	; 0xaa
 8001232:	d0d6      	beq.n	80011e2 <StartHandRxHandler+0x2e>
		else if ((buffer[0] == Tail) && (buffer[NumberOfRxData - 1] == Head)) {
 8001234:	2b55      	cmp	r3, #85	; 0x55
 8001236:	d1e4      	bne.n	8001202 <StartHandRxHandler+0x4e>
 8001238:	7d23      	ldrb	r3, [r4, #20]
 800123a:	2baa      	cmp	r3, #170	; 0xaa
 800123c:	d1e1      	bne.n	8001202 <StartHandRxHandler+0x4e>
			vServoUpdateSetup(bot1, buffer, 1);
 800123e:	2201      	movs	r2, #1
 8001240:	4621      	mov	r1, r4
 8001242:	4b2a      	ldr	r3, [pc, #168]	; (80012ec <StartHandRxHandler+0x138>)
 8001244:	6818      	ldr	r0, [r3, #0]
 8001246:	f00e fbc6 	bl	800f9d6 <vServoUpdateSetup>
			vServoUpdateSetup(bot2, buffer, 7);
 800124a:	2207      	movs	r2, #7
 800124c:	4621      	mov	r1, r4
 800124e:	4b28      	ldr	r3, [pc, #160]	; (80012f0 <StartHandRxHandler+0x13c>)
 8001250:	6818      	ldr	r0, [r3, #0]
 8001252:	f00e fbc0 	bl	800f9d6 <vServoUpdateSetup>
			vServoUpdateSetup(bot3, buffer, 13);
 8001256:	220d      	movs	r2, #13
 8001258:	4621      	mov	r1, r4
 800125a:	4b26      	ldr	r3, [pc, #152]	; (80012f4 <StartHandRxHandler+0x140>)
 800125c:	6818      	ldr	r0, [r3, #0]
 800125e:	f00e fbba 	bl	800f9d6 <vServoUpdateSetup>
			vServoUpdateSetup(top1, buffer, 4);
 8001262:	2204      	movs	r2, #4
 8001264:	4621      	mov	r1, r4
 8001266:	4b24      	ldr	r3, [pc, #144]	; (80012f8 <StartHandRxHandler+0x144>)
 8001268:	6818      	ldr	r0, [r3, #0]
 800126a:	f00e fbb4 	bl	800f9d6 <vServoUpdateSetup>
			vServoUpdateSetup(top2, buffer, 10);
 800126e:	220a      	movs	r2, #10
 8001270:	4621      	mov	r1, r4
 8001272:	4b22      	ldr	r3, [pc, #136]	; (80012fc <StartHandRxHandler+0x148>)
 8001274:	6818      	ldr	r0, [r3, #0]
 8001276:	f00e fbae 	bl	800f9d6 <vServoUpdateSetup>
			vServoUpdateSetup(top3, buffer, 16);
 800127a:	2210      	movs	r2, #16
 800127c:	4621      	mov	r1, r4
 800127e:	4b20      	ldr	r3, [pc, #128]	; (8001300 <StartHandRxHandler+0x14c>)
 8001280:	6818      	ldr	r0, [r3, #0]
 8001282:	f00e fba8 	bl	800f9d6 <vServoUpdateSetup>
			servoLevel = buffer[19];
 8001286:	7ce2      	ldrb	r2, [r4, #19]
 8001288:	4b17      	ldr	r3, [pc, #92]	; (80012e8 <StartHandRxHandler+0x134>)
 800128a:	701a      	strb	r2, [r3, #0]
 800128c:	e7b9      	b.n	8001202 <StartHandRxHandler+0x4e>
				vServoUpdateCommand(bot1, buffer, 1);
 800128e:	2201      	movs	r2, #1
 8001290:	4621      	mov	r1, r4
 8001292:	4b16      	ldr	r3, [pc, #88]	; (80012ec <StartHandRxHandler+0x138>)
 8001294:	6818      	ldr	r0, [r3, #0]
 8001296:	f00e fb83 	bl	800f9a0 <vServoUpdateCommand>
				vServoUpdateCommand(bot2, buffer, 7);
 800129a:	2207      	movs	r2, #7
 800129c:	4621      	mov	r1, r4
 800129e:	4b14      	ldr	r3, [pc, #80]	; (80012f0 <StartHandRxHandler+0x13c>)
 80012a0:	6818      	ldr	r0, [r3, #0]
 80012a2:	f00e fb7d 	bl	800f9a0 <vServoUpdateCommand>
				vServoUpdateCommand(bot3, buffer, 13);
 80012a6:	220d      	movs	r2, #13
 80012a8:	4621      	mov	r1, r4
 80012aa:	4b12      	ldr	r3, [pc, #72]	; (80012f4 <StartHandRxHandler+0x140>)
 80012ac:	6818      	ldr	r0, [r3, #0]
 80012ae:	f00e fb77 	bl	800f9a0 <vServoUpdateCommand>
				vServoUpdateCommand(top3, buffer, 16);
 80012b2:	2210      	movs	r2, #16
 80012b4:	4621      	mov	r1, r4
 80012b6:	4b12      	ldr	r3, [pc, #72]	; (8001300 <StartHandRxHandler+0x14c>)
 80012b8:	6818      	ldr	r0, [r3, #0]
 80012ba:	f00e fb71 	bl	800f9a0 <vServoUpdateCommand>
				vServoUpdateCommand(top2, buffer, 10);
 80012be:	220a      	movs	r2, #10
 80012c0:	4621      	mov	r1, r4
 80012c2:	4b0e      	ldr	r3, [pc, #56]	; (80012fc <StartHandRxHandler+0x148>)
 80012c4:	6818      	ldr	r0, [r3, #0]
 80012c6:	f00e fb6b 	bl	800f9a0 <vServoUpdateCommand>
				vServoUpdateCommand(top1, buffer, 4);
 80012ca:	2204      	movs	r2, #4
 80012cc:	4621      	mov	r1, r4
 80012ce:	4b0a      	ldr	r3, [pc, #40]	; (80012f8 <StartHandRxHandler+0x144>)
 80012d0:	6818      	ldr	r0, [r3, #0]
 80012d2:	f00e fb65 	bl	800f9a0 <vServoUpdateCommand>
 80012d6:	e791      	b.n	80011fc <StartHandRxHandler+0x48>
 80012d8:	2000413c 	.word	0x2000413c
 80012dc:	20004360 	.word	0x20004360
 80012e0:	20000054 	.word	0x20000054
 80012e4:	200044f8 	.word	0x200044f8
 80012e8:	20004130 	.word	0x20004130
 80012ec:	20004500 	.word	0x20004500
 80012f0:	200044fc 	.word	0x200044fc
 80012f4:	20004408 	.word	0x20004408
 80012f8:	20004418 	.word	0x20004418
 80012fc:	20004138 	.word	0x20004138
 8001300:	20004150 	.word	0x20004150

08001304 <StartHandMatrixHandler>:
void StartHandMatrixHandler(void *argument) {
 8001304:	b500      	push	{lr}
 8001306:	b083      	sub	sp, #12
	matrix = (MyArray*) xMyArrayCreate(440u, 10u, 44u);
 8001308:	222c      	movs	r2, #44	; 0x2c
 800130a:	210a      	movs	r1, #10
 800130c:	f44f 70dc 	mov.w	r0, #440	; 0x1b8
 8001310:	f00e f9a4 	bl	800f65c <xMyArrayCreate>
 8001314:	4a13      	ldr	r2, [pc, #76]	; (8001364 <StartHandMatrixHandler+0x60>)
 8001316:	6010      	str	r0, [r2, #0]
	if (matrix == NULL)
 8001318:	b950      	cbnz	r0, 8001330 <StartHandMatrixHandler+0x2c>
		Error_Handler();
 800131a:	f7ff f97f 	bl	800061c <Error_Handler>
			vPortFree(buf);
 800131e:	9801      	ldr	r0, [sp, #4]
 8001320:	f00e f956 	bl	800f5d0 <vPortFree>
			osEventFlagsSet(handEventHandle, FlagHandMatrix);
 8001324:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001328:	4b0f      	ldr	r3, [pc, #60]	; (8001368 <StartHandMatrixHandler+0x64>)
 800132a:	6818      	ldr	r0, [r3, #0]
 800132c:	f00a f964 	bl	800b5f8 <osEventFlagsSet>
		stat = osMessageQueueGet(handQueueHandle, &buf, NULL, osWaitForever);
 8001330:	f04f 33ff 	mov.w	r3, #4294967295
 8001334:	2200      	movs	r2, #0
 8001336:	a901      	add	r1, sp, #4
 8001338:	480c      	ldr	r0, [pc, #48]	; (800136c <StartHandMatrixHandler+0x68>)
 800133a:	6800      	ldr	r0, [r0, #0]
 800133c:	f00a fd5a 	bl	800bdf4 <osMessageQueueGet>
		if (stat == osOK) {
 8001340:	2800      	cmp	r0, #0
 8001342:	d1f5      	bne.n	8001330 <StartHandMatrixHandler+0x2c>
			for (uint16_t i = 0u; i < NumberOfCells; i++)
 8001344:	2300      	movs	r3, #0
 8001346:	f5b3 7fdc 	cmp.w	r3, #440	; 0x1b8
 800134a:	d2e8      	bcs.n	800131e <StartHandMatrixHandler+0x1a>
				matrix->data[i] = buf[i];
 800134c:	4a05      	ldr	r2, [pc, #20]	; (8001364 <StartHandMatrixHandler+0x60>)
 800134e:	6812      	ldr	r2, [r2, #0]
 8001350:	6812      	ldr	r2, [r2, #0]
 8001352:	9901      	ldr	r1, [sp, #4]
 8001354:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
 8001358:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
			for (uint16_t i = 0u; i < NumberOfCells; i++)
 800135c:	3301      	adds	r3, #1
 800135e:	b29b      	uxth	r3, r3
 8001360:	e7f1      	b.n	8001346 <StartHandMatrixHandler+0x42>
 8001362:	bf00      	nop
 8001364:	20004468 	.word	0x20004468
 8001368:	200044f8 	.word	0x200044f8
 800136c:	2000447c 	.word	0x2000447c

08001370 <StartHandPeakControl>:
void StartHandPeakControl(void *argument) {
 8001370:	b580      	push	{r7, lr}
 8001372:	b082      	sub	sp, #8
	botArray = xMyArrayCreate(120u, 5u, 24u);
 8001374:	2218      	movs	r2, #24
 8001376:	2105      	movs	r1, #5
 8001378:	2078      	movs	r0, #120	; 0x78
 800137a:	f00e f96f 	bl	800f65c <xMyArrayCreate>
 800137e:	4a97      	ldr	r2, [pc, #604]	; (80015dc <StartHandPeakControl+0x26c>)
 8001380:	6010      	str	r0, [r2, #0]
	if (botArray == NULL)
 8001382:	2800      	cmp	r0, #0
 8001384:	d049      	beq.n	800141a <StartHandPeakControl+0xaa>
	topArray = xMyArrayCreate(120u, 5u, 24u);
 8001386:	2218      	movs	r2, #24
 8001388:	2105      	movs	r1, #5
 800138a:	2078      	movs	r0, #120	; 0x78
 800138c:	f00e f966 	bl	800f65c <xMyArrayCreate>
 8001390:	4a93      	ldr	r2, [pc, #588]	; (80015e0 <StartHandPeakControl+0x270>)
 8001392:	6010      	str	r0, [r2, #0]
	if (topArray == NULL)
 8001394:	2800      	cmp	r0, #0
 8001396:	d042      	beq.n	800141e <StartHandPeakControl+0xae>
	bot1Array = xMyArrayCreate(40u, 5u, 8u);
 8001398:	2208      	movs	r2, #8
 800139a:	2105      	movs	r1, #5
 800139c:	2028      	movs	r0, #40	; 0x28
 800139e:	f00e f95d 	bl	800f65c <xMyArrayCreate>
 80013a2:	4a90      	ldr	r2, [pc, #576]	; (80015e4 <StartHandPeakControl+0x274>)
 80013a4:	6010      	str	r0, [r2, #0]
	if (bot1Array == NULL)
 80013a6:	2800      	cmp	r0, #0
 80013a8:	d03b      	beq.n	8001422 <StartHandPeakControl+0xb2>
	bot2Array = xMyArrayCreate(40u, 5u, 8u);
 80013aa:	2208      	movs	r2, #8
 80013ac:	2105      	movs	r1, #5
 80013ae:	2028      	movs	r0, #40	; 0x28
 80013b0:	f00e f954 	bl	800f65c <xMyArrayCreate>
 80013b4:	4a8c      	ldr	r2, [pc, #560]	; (80015e8 <StartHandPeakControl+0x278>)
 80013b6:	6010      	str	r0, [r2, #0]
	if (bot2Array == NULL)
 80013b8:	2800      	cmp	r0, #0
 80013ba:	d034      	beq.n	8001426 <StartHandPeakControl+0xb6>
	bot3Array = xMyArrayCreate(40u, 5u, 8u);
 80013bc:	2208      	movs	r2, #8
 80013be:	2105      	movs	r1, #5
 80013c0:	2028      	movs	r0, #40	; 0x28
 80013c2:	f00e f94b 	bl	800f65c <xMyArrayCreate>
 80013c6:	4a89      	ldr	r2, [pc, #548]	; (80015ec <StartHandPeakControl+0x27c>)
 80013c8:	6010      	str	r0, [r2, #0]
	if (bot3Array == NULL)
 80013ca:	b370      	cbz	r0, 800142a <StartHandPeakControl+0xba>
	top1Array = xMyArrayCreate(40u, 5u, 8u);
 80013cc:	2208      	movs	r2, #8
 80013ce:	2105      	movs	r1, #5
 80013d0:	2028      	movs	r0, #40	; 0x28
 80013d2:	f00e f943 	bl	800f65c <xMyArrayCreate>
 80013d6:	4a86      	ldr	r2, [pc, #536]	; (80015f0 <StartHandPeakControl+0x280>)
 80013d8:	6010      	str	r0, [r2, #0]
	if (top1Array == NULL)
 80013da:	b340      	cbz	r0, 800142e <StartHandPeakControl+0xbe>
	top2Array = xMyArrayCreate(40u, 5u, 8u);
 80013dc:	2208      	movs	r2, #8
 80013de:	2105      	movs	r1, #5
 80013e0:	2028      	movs	r0, #40	; 0x28
 80013e2:	f00e f93b 	bl	800f65c <xMyArrayCreate>
 80013e6:	4a83      	ldr	r2, [pc, #524]	; (80015f4 <StartHandPeakControl+0x284>)
 80013e8:	6010      	str	r0, [r2, #0]
	if (top2Array == NULL)
 80013ea:	b310      	cbz	r0, 8001432 <StartHandPeakControl+0xc2>
	top3Array = xMyArrayCreate(40u, 5u, 8u);
 80013ec:	2208      	movs	r2, #8
 80013ee:	2105      	movs	r1, #5
 80013f0:	2028      	movs	r0, #40	; 0x28
 80013f2:	f00e f933 	bl	800f65c <xMyArrayCreate>
 80013f6:	4a80      	ldr	r2, [pc, #512]	; (80015f8 <StartHandPeakControl+0x288>)
 80013f8:	6010      	str	r0, [r2, #0]
	if (top3Array == NULL)
 80013fa:	b1e0      	cbz	r0, 8001436 <StartHandPeakControl+0xc6>
	countRun = 0u;
 80013fc:	4b7f      	ldr	r3, [pc, #508]	; (80015fc <StartHandPeakControl+0x28c>)
 80013fe:	2200      	movs	r2, #0
 8001400:	601a      	str	r2, [r3, #0]
	HAL_GPIO_WritePin(LEDGreen_GPIO_Port, LEDGreen_Pin, GPIO_PIN_SET); //off led
 8001402:	2201      	movs	r2, #1
 8001404:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001408:	487d      	ldr	r0, [pc, #500]	; (8001600 <StartHandPeakControl+0x290>)
 800140a:	f002 fe72 	bl	80040f2 <HAL_GPIO_WritePin>
	osEventFlagsClear(handEventHandle, FlagHandPeakControlEnable);
 800140e:	2180      	movs	r1, #128	; 0x80
 8001410:	4b7c      	ldr	r3, [pc, #496]	; (8001604 <StartHandPeakControl+0x294>)
 8001412:	6818      	ldr	r0, [r3, #0]
 8001414:	f00a f92e 	bl	800b674 <osEventFlagsClear>
 8001418:	e020      	b.n	800145c <StartHandPeakControl+0xec>
		Error_Handler();
 800141a:	f7ff f8ff 	bl	800061c <Error_Handler>
		Error_Handler();
 800141e:	f7ff f8fd 	bl	800061c <Error_Handler>
		Error_Handler();
 8001422:	f7ff f8fb 	bl	800061c <Error_Handler>
		Error_Handler();
 8001426:	f7ff f8f9 	bl	800061c <Error_Handler>
		Error_Handler();
 800142a:	f7ff f8f7 	bl	800061c <Error_Handler>
		Error_Handler();
 800142e:	f7ff f8f5 	bl	800061c <Error_Handler>
		Error_Handler();
 8001432:	f7ff f8f3 	bl	800061c <Error_Handler>
		Error_Handler();
 8001436:	f7ff f8f1 	bl	800061c <Error_Handler>
			flag13 = 1;
 800143a:	4b73      	ldr	r3, [pc, #460]	; (8001608 <StartHandPeakControl+0x298>)
 800143c:	2201      	movs	r2, #1
 800143e:	701a      	strb	r2, [r3, #0]
			osEventFlagsSet(stopServoEventHandle,
 8001440:	210a      	movs	r1, #10
 8001442:	4b72      	ldr	r3, [pc, #456]	; (800160c <StartHandPeakControl+0x29c>)
 8001444:	6818      	ldr	r0, [r3, #0]
 8001446:	f00a f8d7 	bl	800b5f8 <osEventFlagsSet>
		if ((flag123 == 0) && (flag12 == 1) && (flag13 == 1)) {
 800144a:	4b71      	ldr	r3, [pc, #452]	; (8001610 <StartHandPeakControl+0x2a0>)
 800144c:	781b      	ldrb	r3, [r3, #0]
 800144e:	b92b      	cbnz	r3, 800145c <StartHandPeakControl+0xec>
 8001450:	4b70      	ldr	r3, [pc, #448]	; (8001614 <StartHandPeakControl+0x2a4>)
 8001452:	781b      	ldrb	r3, [r3, #0]
 8001454:	b2db      	uxtb	r3, r3
 8001456:	2b01      	cmp	r3, #1
 8001458:	f000 80f2 	beq.w	8001640 <StartHandPeakControl+0x2d0>
		osEventFlagsWait(handEventHandle, FlagHandPeakControlEnable,
 800145c:	4c69      	ldr	r4, [pc, #420]	; (8001604 <StartHandPeakControl+0x294>)
 800145e:	f04f 33ff 	mov.w	r3, #4294967295
 8001462:	2203      	movs	r2, #3
 8001464:	2180      	movs	r1, #128	; 0x80
 8001466:	6820      	ldr	r0, [r4, #0]
 8001468:	f00a f952 	bl	800b710 <osEventFlagsWait>
		osEventFlagsWait(handEventHandle, FlagHandMatrix, osFlagsWaitAll,
 800146c:	f04f 33ff 	mov.w	r3, #4294967295
 8001470:	2201      	movs	r2, #1
 8001472:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001476:	6820      	ldr	r0, [r4, #0]
 8001478:	f00a f94a 	bl	800b710 <osEventFlagsWait>
		eMyArraySplit(matrix, botArray, 5u, 0u);
 800147c:	4d57      	ldr	r5, [pc, #348]	; (80015dc <StartHandPeakControl+0x26c>)
 800147e:	4e66      	ldr	r6, [pc, #408]	; (8001618 <StartHandPeakControl+0x2a8>)
 8001480:	2300      	movs	r3, #0
 8001482:	2205      	movs	r2, #5
 8001484:	6829      	ldr	r1, [r5, #0]
 8001486:	6830      	ldr	r0, [r6, #0]
 8001488:	f00e f906 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(matrix, topArray, 0u, 0u);
 800148c:	4c54      	ldr	r4, [pc, #336]	; (80015e0 <StartHandPeakControl+0x270>)
 800148e:	2300      	movs	r3, #0
 8001490:	461a      	mov	r2, r3
 8001492:	6821      	ldr	r1, [r4, #0]
 8001494:	6830      	ldr	r0, [r6, #0]
 8001496:	f00e f8ff 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(botArray, bot1Array, 0u, 0u);
 800149a:	f8df a148 	ldr.w	sl, [pc, #328]	; 80015e4 <StartHandPeakControl+0x274>
 800149e:	2300      	movs	r3, #0
 80014a0:	461a      	mov	r2, r3
 80014a2:	f8da 1000 	ldr.w	r1, [sl]
 80014a6:	6828      	ldr	r0, [r5, #0]
 80014a8:	f00e f8f6 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(botArray, bot2Array, 0u, 8u);
 80014ac:	f8df 9138 	ldr.w	r9, [pc, #312]	; 80015e8 <StartHandPeakControl+0x278>
 80014b0:	2308      	movs	r3, #8
 80014b2:	2200      	movs	r2, #0
 80014b4:	f8d9 1000 	ldr.w	r1, [r9]
 80014b8:	6828      	ldr	r0, [r5, #0]
 80014ba:	f00e f8ed 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(botArray, bot3Array, 0u, 16u);
 80014be:	f8df 812c 	ldr.w	r8, [pc, #300]	; 80015ec <StartHandPeakControl+0x27c>
 80014c2:	2310      	movs	r3, #16
 80014c4:	2200      	movs	r2, #0
 80014c6:	f8d8 1000 	ldr.w	r1, [r8]
 80014ca:	6828      	ldr	r0, [r5, #0]
 80014cc:	f00e f8e4 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(topArray, top1Array, 0u, 0u);
 80014d0:	4f47      	ldr	r7, [pc, #284]	; (80015f0 <StartHandPeakControl+0x280>)
 80014d2:	2300      	movs	r3, #0
 80014d4:	461a      	mov	r2, r3
 80014d6:	6839      	ldr	r1, [r7, #0]
 80014d8:	6820      	ldr	r0, [r4, #0]
 80014da:	f00e f8dd 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(topArray, top2Array, 0u, 8u);
 80014de:	4e45      	ldr	r6, [pc, #276]	; (80015f4 <StartHandPeakControl+0x284>)
 80014e0:	2308      	movs	r3, #8
 80014e2:	2200      	movs	r2, #0
 80014e4:	6831      	ldr	r1, [r6, #0]
 80014e6:	6820      	ldr	r0, [r4, #0]
 80014e8:	f00e f8d6 	bl	800f698 <eMyArraySplit>
		eMyArraySplit(topArray, top3Array, 0u, 16u);
 80014ec:	4d42      	ldr	r5, [pc, #264]	; (80015f8 <StartHandPeakControl+0x288>)
 80014ee:	2310      	movs	r3, #16
 80014f0:	2200      	movs	r2, #0
 80014f2:	6829      	ldr	r1, [r5, #0]
 80014f4:	6820      	ldr	r0, [r4, #0]
 80014f6:	f00e f8cf 	bl	800f698 <eMyArraySplit>
		maxBot1 = uMyArrayFindMax(bot1Array);
 80014fa:	f8da 0000 	ldr.w	r0, [sl]
 80014fe:	f00e f8f9 	bl	800f6f4 <uMyArrayFindMax>
 8001502:	4b46      	ldr	r3, [pc, #280]	; (800161c <StartHandPeakControl+0x2ac>)
 8001504:	8018      	strh	r0, [r3, #0]
		maxBot2 = uMyArrayFindMax(bot2Array);
 8001506:	f8d9 0000 	ldr.w	r0, [r9]
 800150a:	f00e f8f3 	bl	800f6f4 <uMyArrayFindMax>
 800150e:	4b44      	ldr	r3, [pc, #272]	; (8001620 <StartHandPeakControl+0x2b0>)
 8001510:	8018      	strh	r0, [r3, #0]
		maxBot3 = uMyArrayFindMax(bot3Array);
 8001512:	f8d8 0000 	ldr.w	r0, [r8]
 8001516:	f00e f8ed 	bl	800f6f4 <uMyArrayFindMax>
 800151a:	4b42      	ldr	r3, [pc, #264]	; (8001624 <StartHandPeakControl+0x2b4>)
 800151c:	8018      	strh	r0, [r3, #0]
		maxTop1 = uMyArrayFindMax(top1Array);
 800151e:	6838      	ldr	r0, [r7, #0]
 8001520:	f00e f8e8 	bl	800f6f4 <uMyArrayFindMax>
 8001524:	4b40      	ldr	r3, [pc, #256]	; (8001628 <StartHandPeakControl+0x2b8>)
 8001526:	8018      	strh	r0, [r3, #0]
		maxTop2 = uMyArrayFindMax(top2Array);
 8001528:	6830      	ldr	r0, [r6, #0]
 800152a:	f00e f8e3 	bl	800f6f4 <uMyArrayFindMax>
 800152e:	4b3f      	ldr	r3, [pc, #252]	; (800162c <StartHandPeakControl+0x2bc>)
 8001530:	8018      	strh	r0, [r3, #0]
		maxTop3 = uMyArrayFindMax(top3Array);
 8001532:	6828      	ldr	r0, [r5, #0]
 8001534:	f00e f8de 	bl	800f6f4 <uMyArrayFindMax>
 8001538:	4b3d      	ldr	r3, [pc, #244]	; (8001630 <StartHandPeakControl+0x2c0>)
 800153a:	8018      	strh	r0, [r3, #0]
		threshHoldValue = threshHold[servoLevel] * 2u;
 800153c:	4b3d      	ldr	r3, [pc, #244]	; (8001634 <StartHandPeakControl+0x2c4>)
 800153e:	781a      	ldrb	r2, [r3, #0]
 8001540:	4b3d      	ldr	r3, [pc, #244]	; (8001638 <StartHandPeakControl+0x2c8>)
 8001542:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8001546:	005b      	lsls	r3, r3, #1
 8001548:	b29b      	uxth	r3, r3
 800154a:	4a3c      	ldr	r2, [pc, #240]	; (800163c <StartHandPeakControl+0x2cc>)
 800154c:	8013      	strh	r3, [r2, #0]
		if ((flag12 == 0)
 800154e:	4b31      	ldr	r3, [pc, #196]	; (8001614 <StartHandPeakControl+0x2a4>)
 8001550:	781b      	ldrb	r3, [r3, #0]
 8001552:	bb0b      	cbnz	r3, 8001598 <StartHandPeakControl+0x228>
				&& ((maxBot1 + maxBot2 + 100u > threshHoldValue)
 8001554:	4b31      	ldr	r3, [pc, #196]	; (800161c <StartHandPeakControl+0x2ac>)
 8001556:	881b      	ldrh	r3, [r3, #0]
 8001558:	b29b      	uxth	r3, r3
 800155a:	4a31      	ldr	r2, [pc, #196]	; (8001620 <StartHandPeakControl+0x2b0>)
 800155c:	8812      	ldrh	r2, [r2, #0]
 800155e:	b292      	uxth	r2, r2
 8001560:	4413      	add	r3, r2
 8001562:	3364      	adds	r3, #100	; 0x64
 8001564:	4a35      	ldr	r2, [pc, #212]	; (800163c <StartHandPeakControl+0x2cc>)
 8001566:	8812      	ldrh	r2, [r2, #0]
 8001568:	b292      	uxth	r2, r2
 800156a:	4293      	cmp	r3, r2
 800156c:	d80c      	bhi.n	8001588 <StartHandPeakControl+0x218>
						|| (maxTop1 + maxTop2 + 100u > threshHoldValue))) {
 800156e:	4b2e      	ldr	r3, [pc, #184]	; (8001628 <StartHandPeakControl+0x2b8>)
 8001570:	881b      	ldrh	r3, [r3, #0]
 8001572:	b29b      	uxth	r3, r3
 8001574:	4a2d      	ldr	r2, [pc, #180]	; (800162c <StartHandPeakControl+0x2bc>)
 8001576:	8812      	ldrh	r2, [r2, #0]
 8001578:	b292      	uxth	r2, r2
 800157a:	4413      	add	r3, r2
 800157c:	3364      	adds	r3, #100	; 0x64
 800157e:	4a2f      	ldr	r2, [pc, #188]	; (800163c <StartHandPeakControl+0x2cc>)
 8001580:	8812      	ldrh	r2, [r2, #0]
 8001582:	b292      	uxth	r2, r2
 8001584:	4293      	cmp	r3, r2
 8001586:	d907      	bls.n	8001598 <StartHandPeakControl+0x228>
			flag12 = 1;
 8001588:	4b22      	ldr	r3, [pc, #136]	; (8001614 <StartHandPeakControl+0x2a4>)
 800158a:	2201      	movs	r2, #1
 800158c:	701a      	strb	r2, [r3, #0]
			osEventFlagsSet(stopServoEventHandle,
 800158e:	2106      	movs	r1, #6
 8001590:	4b1e      	ldr	r3, [pc, #120]	; (800160c <StartHandPeakControl+0x29c>)
 8001592:	6818      	ldr	r0, [r3, #0]
 8001594:	f00a f830 	bl	800b5f8 <osEventFlagsSet>
		if ((flag13 == 0)
 8001598:	4b1b      	ldr	r3, [pc, #108]	; (8001608 <StartHandPeakControl+0x298>)
 800159a:	781b      	ldrb	r3, [r3, #0]
 800159c:	2b00      	cmp	r3, #0
 800159e:	f47f af54 	bne.w	800144a <StartHandPeakControl+0xda>
				&& ((maxBot1 + maxBot3 + 100u > threshHoldValue)
 80015a2:	4b1e      	ldr	r3, [pc, #120]	; (800161c <StartHandPeakControl+0x2ac>)
 80015a4:	881b      	ldrh	r3, [r3, #0]
 80015a6:	b29b      	uxth	r3, r3
 80015a8:	4a1e      	ldr	r2, [pc, #120]	; (8001624 <StartHandPeakControl+0x2b4>)
 80015aa:	8812      	ldrh	r2, [r2, #0]
 80015ac:	b292      	uxth	r2, r2
 80015ae:	4413      	add	r3, r2
 80015b0:	3364      	adds	r3, #100	; 0x64
 80015b2:	4a22      	ldr	r2, [pc, #136]	; (800163c <StartHandPeakControl+0x2cc>)
 80015b4:	8812      	ldrh	r2, [r2, #0]
 80015b6:	b292      	uxth	r2, r2
 80015b8:	4293      	cmp	r3, r2
 80015ba:	f63f af3e 	bhi.w	800143a <StartHandPeakControl+0xca>
						|| (maxTop1 + maxTop3 + 100u > threshHoldValue))) {
 80015be:	4b1a      	ldr	r3, [pc, #104]	; (8001628 <StartHandPeakControl+0x2b8>)
 80015c0:	881b      	ldrh	r3, [r3, #0]
 80015c2:	b29b      	uxth	r3, r3
 80015c4:	4a1a      	ldr	r2, [pc, #104]	; (8001630 <StartHandPeakControl+0x2c0>)
 80015c6:	8812      	ldrh	r2, [r2, #0]
 80015c8:	b292      	uxth	r2, r2
 80015ca:	4413      	add	r3, r2
 80015cc:	3364      	adds	r3, #100	; 0x64
 80015ce:	4a1b      	ldr	r2, [pc, #108]	; (800163c <StartHandPeakControl+0x2cc>)
 80015d0:	8812      	ldrh	r2, [r2, #0]
 80015d2:	b292      	uxth	r2, r2
 80015d4:	4293      	cmp	r3, r2
 80015d6:	f67f af38 	bls.w	800144a <StartHandPeakControl+0xda>
 80015da:	e72e      	b.n	800143a <StartHandPeakControl+0xca>
 80015dc:	20004220 	.word	0x20004220
 80015e0:	20004410 	.word	0x20004410
 80015e4:	20004154 	.word	0x20004154
 80015e8:	20004404 	.word	0x20004404
 80015ec:	20004134 	.word	0x20004134
 80015f0:	2000428c 	.word	0x2000428c
 80015f4:	20004230 	.word	0x20004230
 80015f8:	200044e0 	.word	0x200044e0
 80015fc:	20000054 	.word	0x20000054
 8001600:	40011000 	.word	0x40011000
 8001604:	200044f8 	.word	0x200044f8
 8001608:	20004148 	.word	0x20004148
 800160c:	200044ec 	.word	0x200044ec
 8001610:	20004234 	.word	0x20004234
 8001614:	2000446c 	.word	0x2000446c
 8001618:	20004468 	.word	0x20004468
 800161c:	2000430c 	.word	0x2000430c
 8001620:	200043fe 	.word	0x200043fe
 8001624:	20004158 	.word	0x20004158
 8001628:	20004400 	.word	0x20004400
 800162c:	200044d0 	.word	0x200044d0
 8001630:	200044e8 	.word	0x200044e8
 8001634:	20004130 	.word	0x20004130
 8001638:	20000000 	.word	0x20000000
 800163c:	200044d8 	.word	0x200044d8
		if ((flag123 == 0) && (flag12 == 1) && (flag13 == 1)) {
 8001640:	4b49      	ldr	r3, [pc, #292]	; (8001768 <StartHandPeakControl+0x3f8>)
 8001642:	781b      	ldrb	r3, [r3, #0]
 8001644:	b2db      	uxtb	r3, r3
 8001646:	2b01      	cmp	r3, #1
 8001648:	f47f af08 	bne.w	800145c <StartHandPeakControl+0xec>
			flag123 = 1;
 800164c:	4b47      	ldr	r3, [pc, #284]	; (800176c <StartHandPeakControl+0x3fc>)
 800164e:	2201      	movs	r2, #1
 8001650:	701a      	strb	r2, [r3, #0]
			volatile uint16_t temp = threshHold[servoLevel];
 8001652:	4b47      	ldr	r3, [pc, #284]	; (8001770 <StartHandPeakControl+0x400>)
 8001654:	781a      	ldrb	r2, [r3, #0]
 8001656:	4b47      	ldr	r3, [pc, #284]	; (8001774 <StartHandPeakControl+0x404>)
 8001658:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800165c:	f8ad 3006 	strh.w	r3, [sp, #6]
			if (maxBot1 > temp || maxTop1 > temp)
 8001660:	4b45      	ldr	r3, [pc, #276]	; (8001778 <StartHandPeakControl+0x408>)
 8001662:	881a      	ldrh	r2, [r3, #0]
 8001664:	b292      	uxth	r2, r2
 8001666:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800166a:	b29b      	uxth	r3, r3
 800166c:	429a      	cmp	r2, r3
 800166e:	d807      	bhi.n	8001680 <StartHandPeakControl+0x310>
 8001670:	4b42      	ldr	r3, [pc, #264]	; (800177c <StartHandPeakControl+0x40c>)
 8001672:	881a      	ldrh	r2, [r3, #0]
 8001674:	b292      	uxth	r2, r2
 8001676:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800167a:	b29b      	uxth	r3, r3
 800167c:	429a      	cmp	r2, r3
 800167e:	d92f      	bls.n	80016e0 <StartHandPeakControl+0x370>
				vServoMove1(bot1, eServoUp1);
 8001680:	2101      	movs	r1, #1
 8001682:	4b3f      	ldr	r3, [pc, #252]	; (8001780 <StartHandPeakControl+0x410>)
 8001684:	6818      	ldr	r0, [r3, #0]
 8001686:	f00e f97e 	bl	800f986 <vServoMove1>
			if (maxBot2 > temp || maxTop2 > temp)
 800168a:	4b3e      	ldr	r3, [pc, #248]	; (8001784 <StartHandPeakControl+0x414>)
 800168c:	881a      	ldrh	r2, [r3, #0]
 800168e:	b292      	uxth	r2, r2
 8001690:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001694:	b29b      	uxth	r3, r3
 8001696:	429a      	cmp	r2, r3
 8001698:	d807      	bhi.n	80016aa <StartHandPeakControl+0x33a>
 800169a:	4b3b      	ldr	r3, [pc, #236]	; (8001788 <StartHandPeakControl+0x418>)
 800169c:	881a      	ldrh	r2, [r3, #0]
 800169e:	b292      	uxth	r2, r2
 80016a0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80016a4:	b29b      	uxth	r3, r3
 80016a6:	429a      	cmp	r2, r3
 80016a8:	d930      	bls.n	800170c <StartHandPeakControl+0x39c>
				vServoMove1(bot2, eServoUp1);
 80016aa:	2101      	movs	r1, #1
 80016ac:	4b37      	ldr	r3, [pc, #220]	; (800178c <StartHandPeakControl+0x41c>)
 80016ae:	6818      	ldr	r0, [r3, #0]
 80016b0:	f00e f969 	bl	800f986 <vServoMove1>
			if (maxBot3 > temp || maxTop3 > temp)
 80016b4:	4b36      	ldr	r3, [pc, #216]	; (8001790 <StartHandPeakControl+0x420>)
 80016b6:	881a      	ldrh	r2, [r3, #0]
 80016b8:	b292      	uxth	r2, r2
 80016ba:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80016be:	b29b      	uxth	r3, r3
 80016c0:	429a      	cmp	r2, r3
 80016c2:	d807      	bhi.n	80016d4 <StartHandPeakControl+0x364>
 80016c4:	4b33      	ldr	r3, [pc, #204]	; (8001794 <StartHandPeakControl+0x424>)
 80016c6:	881a      	ldrh	r2, [r3, #0]
 80016c8:	b292      	uxth	r2, r2
 80016ca:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80016ce:	b29b      	uxth	r3, r3
 80016d0:	429a      	cmp	r2, r3
 80016d2:	d931      	bls.n	8001738 <StartHandPeakControl+0x3c8>
				vServoMove1(bot3, eServoUp1);
 80016d4:	2101      	movs	r1, #1
 80016d6:	4b30      	ldr	r3, [pc, #192]	; (8001798 <StartHandPeakControl+0x428>)
 80016d8:	6818      	ldr	r0, [r3, #0]
 80016da:	f00e f954 	bl	800f986 <vServoMove1>
 80016de:	e6bd      	b.n	800145c <StartHandPeakControl+0xec>
			else if (maxBot1 < temp && maxTop1 < temp)
 80016e0:	4b25      	ldr	r3, [pc, #148]	; (8001778 <StartHandPeakControl+0x408>)
 80016e2:	881a      	ldrh	r2, [r3, #0]
 80016e4:	b292      	uxth	r2, r2
 80016e6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80016ea:	b29b      	uxth	r3, r3
 80016ec:	429a      	cmp	r2, r3
 80016ee:	d2cc      	bcs.n	800168a <StartHandPeakControl+0x31a>
 80016f0:	4b22      	ldr	r3, [pc, #136]	; (800177c <StartHandPeakControl+0x40c>)
 80016f2:	881a      	ldrh	r2, [r3, #0]
 80016f4:	b292      	uxth	r2, r2
 80016f6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80016fa:	b29b      	uxth	r3, r3
 80016fc:	429a      	cmp	r2, r3
 80016fe:	d2c4      	bcs.n	800168a <StartHandPeakControl+0x31a>
				vServoMove1(bot1, eServoDown1);
 8001700:	2102      	movs	r1, #2
 8001702:	4b1f      	ldr	r3, [pc, #124]	; (8001780 <StartHandPeakControl+0x410>)
 8001704:	6818      	ldr	r0, [r3, #0]
 8001706:	f00e f93e 	bl	800f986 <vServoMove1>
 800170a:	e7be      	b.n	800168a <StartHandPeakControl+0x31a>
			else if (maxBot2 < temp && maxTop2 < temp)
 800170c:	4b1d      	ldr	r3, [pc, #116]	; (8001784 <StartHandPeakControl+0x414>)
 800170e:	881a      	ldrh	r2, [r3, #0]
 8001710:	b292      	uxth	r2, r2
 8001712:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001716:	b29b      	uxth	r3, r3
 8001718:	429a      	cmp	r2, r3
 800171a:	d2cb      	bcs.n	80016b4 <StartHandPeakControl+0x344>
 800171c:	4b1a      	ldr	r3, [pc, #104]	; (8001788 <StartHandPeakControl+0x418>)
 800171e:	881a      	ldrh	r2, [r3, #0]
 8001720:	b292      	uxth	r2, r2
 8001722:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001726:	b29b      	uxth	r3, r3
 8001728:	429a      	cmp	r2, r3
 800172a:	d2c3      	bcs.n	80016b4 <StartHandPeakControl+0x344>
				vServoMove1(bot2, eServoDown1);
 800172c:	2102      	movs	r1, #2
 800172e:	4b17      	ldr	r3, [pc, #92]	; (800178c <StartHandPeakControl+0x41c>)
 8001730:	6818      	ldr	r0, [r3, #0]
 8001732:	f00e f928 	bl	800f986 <vServoMove1>
 8001736:	e7bd      	b.n	80016b4 <StartHandPeakControl+0x344>
			else if (maxBot3 < temp && maxTop3 < temp)
 8001738:	4b15      	ldr	r3, [pc, #84]	; (8001790 <StartHandPeakControl+0x420>)
 800173a:	881a      	ldrh	r2, [r3, #0]
 800173c:	b292      	uxth	r2, r2
 800173e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001742:	b29b      	uxth	r3, r3
 8001744:	429a      	cmp	r2, r3
 8001746:	f4bf ae89 	bcs.w	800145c <StartHandPeakControl+0xec>
 800174a:	4b12      	ldr	r3, [pc, #72]	; (8001794 <StartHandPeakControl+0x424>)
 800174c:	881a      	ldrh	r2, [r3, #0]
 800174e:	b292      	uxth	r2, r2
 8001750:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001754:	b29b      	uxth	r3, r3
 8001756:	429a      	cmp	r2, r3
 8001758:	f4bf ae80 	bcs.w	800145c <StartHandPeakControl+0xec>
				vServoMove1(bot3, eServoDown1);
 800175c:	2102      	movs	r1, #2
 800175e:	4b0e      	ldr	r3, [pc, #56]	; (8001798 <StartHandPeakControl+0x428>)
 8001760:	6818      	ldr	r0, [r3, #0]
 8001762:	f00e f910 	bl	800f986 <vServoMove1>
 8001766:	e679      	b.n	800145c <StartHandPeakControl+0xec>
 8001768:	20004148 	.word	0x20004148
 800176c:	20004234 	.word	0x20004234
 8001770:	20004130 	.word	0x20004130
 8001774:	20000000 	.word	0x20000000
 8001778:	2000430c 	.word	0x2000430c
 800177c:	20004400 	.word	0x20004400
 8001780:	20004500 	.word	0x20004500
 8001784:	200043fe 	.word	0x200043fe
 8001788:	200044d0 	.word	0x200044d0
 800178c:	200044fc 	.word	0x200044fc
 8001790:	20004158 	.word	0x20004158
 8001794:	200044e8 	.word	0x200044e8
 8001798:	20004408 	.word	0x20004408

0800179c <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                                                            /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800179c:	b500      	push	{lr}
 800179e:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 80017a0:	4b11      	ldr	r3, [pc, #68]	; (80017e8 <HAL_MspInit+0x4c>)
 80017a2:	699a      	ldr	r2, [r3, #24]
 80017a4:	f042 0201 	orr.w	r2, r2, #1
 80017a8:	619a      	str	r2, [r3, #24]
 80017aa:	699a      	ldr	r2, [r3, #24]
 80017ac:	f002 0201 	and.w	r2, r2, #1
 80017b0:	9200      	str	r2, [sp, #0]
 80017b2:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80017b4:	69da      	ldr	r2, [r3, #28]
 80017b6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80017ba:	61da      	str	r2, [r3, #28]
 80017bc:	69db      	ldr	r3, [r3, #28]
 80017be:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80017c2:	9301      	str	r3, [sp, #4]
 80017c4:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80017c6:	2200      	movs	r2, #0
 80017c8:	210f      	movs	r1, #15
 80017ca:	f06f 0001 	mvn.w	r0, #1
 80017ce:	f001 fe95 	bl	80034fc <HAL_NVIC_SetPriority>

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 80017d2:	4a06      	ldr	r2, [pc, #24]	; (80017ec <HAL_MspInit+0x50>)
 80017d4:	6853      	ldr	r3, [r2, #4]
 80017d6:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 80017da:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80017de:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80017e0:	b003      	add	sp, #12
 80017e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80017e6:	bf00      	nop
 80017e8:	40021000 	.word	0x40021000
 80017ec:	40010000 	.word	0x40010000

080017f0 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 80017f0:	b530      	push	{r4, r5, lr}
 80017f2:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80017f4:	2300      	movs	r3, #0
 80017f6:	9306      	str	r3, [sp, #24]
 80017f8:	9307      	str	r3, [sp, #28]
 80017fa:	9308      	str	r3, [sp, #32]
 80017fc:	9309      	str	r3, [sp, #36]	; 0x24
  if(hadc->Instance==ADC1)
 80017fe:	6803      	ldr	r3, [r0, #0]
 8001800:	4a3c      	ldr	r2, [pc, #240]	; (80018f4 <HAL_ADC_MspInit+0x104>)
 8001802:	4293      	cmp	r3, r2
 8001804:	d004      	beq.n	8001810 <HAL_ADC_MspInit+0x20>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
  else if(hadc->Instance==ADC2)
 8001806:	4a3c      	ldr	r2, [pc, #240]	; (80018f8 <HAL_ADC_MspInit+0x108>)
 8001808:	4293      	cmp	r3, r2
 800180a:	d047      	beq.n	800189c <HAL_ADC_MspInit+0xac>
  /* USER CODE BEGIN ADC2_MspInit 1 */

  /* USER CODE END ADC2_MspInit 1 */
  }

}
 800180c:	b00b      	add	sp, #44	; 0x2c
 800180e:	bd30      	pop	{r4, r5, pc}
 8001810:	4604      	mov	r4, r0
    __HAL_RCC_ADC1_CLK_ENABLE();
 8001812:	4b3a      	ldr	r3, [pc, #232]	; (80018fc <HAL_ADC_MspInit+0x10c>)
 8001814:	699a      	ldr	r2, [r3, #24]
 8001816:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800181a:	619a      	str	r2, [r3, #24]
 800181c:	699a      	ldr	r2, [r3, #24]
 800181e:	f402 7200 	and.w	r2, r2, #512	; 0x200
 8001822:	9200      	str	r2, [sp, #0]
 8001824:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001826:	699a      	ldr	r2, [r3, #24]
 8001828:	f042 0204 	orr.w	r2, r2, #4
 800182c:	619a      	str	r2, [r3, #24]
 800182e:	699a      	ldr	r2, [r3, #24]
 8001830:	f002 0204 	and.w	r2, r2, #4
 8001834:	9201      	str	r2, [sp, #4]
 8001836:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001838:	699a      	ldr	r2, [r3, #24]
 800183a:	f042 0208 	orr.w	r2, r2, #8
 800183e:	619a      	str	r2, [r3, #24]
 8001840:	699b      	ldr	r3, [r3, #24]
 8001842:	f003 0308 	and.w	r3, r3, #8
 8001846:	9302      	str	r3, [sp, #8]
 8001848:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_6;
 800184a:	2355      	movs	r3, #85	; 0x55
 800184c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800184e:	2503      	movs	r5, #3
 8001850:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001852:	a906      	add	r1, sp, #24
 8001854:	482a      	ldr	r0, [pc, #168]	; (8001900 <HAL_ADC_MspInit+0x110>)
 8001856:	f002 fab7 	bl	8003dc8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800185a:	2301      	movs	r3, #1
 800185c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800185e:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001860:	a906      	add	r1, sp, #24
 8001862:	4828      	ldr	r0, [pc, #160]	; (8001904 <HAL_ADC_MspInit+0x114>)
 8001864:	f002 fab0 	bl	8003dc8 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA1_Channel1;
 8001868:	4827      	ldr	r0, [pc, #156]	; (8001908 <HAL_ADC_MspInit+0x118>)
 800186a:	4b28      	ldr	r3, [pc, #160]	; (800190c <HAL_ADC_MspInit+0x11c>)
 800186c:	6003      	str	r3, [r0, #0]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800186e:	2300      	movs	r3, #0
 8001870:	6043      	str	r3, [r0, #4]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 8001872:	6083      	str	r3, [r0, #8]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8001874:	2280      	movs	r2, #128	; 0x80
 8001876:	60c2      	str	r2, [r0, #12]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8001878:	f44f 7200 	mov.w	r2, #512	; 0x200
 800187c:	6102      	str	r2, [r0, #16]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 800187e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001882:	6142      	str	r2, [r0, #20]
    hdma_adc1.Init.Mode = DMA_NORMAL;
 8001884:	6183      	str	r3, [r0, #24]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 8001886:	61c3      	str	r3, [r0, #28]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8001888:	f001 ff58 	bl	800373c <HAL_DMA_Init>
 800188c:	b918      	cbnz	r0, 8001896 <HAL_ADC_MspInit+0xa6>
    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);
 800188e:	4b1e      	ldr	r3, [pc, #120]	; (8001908 <HAL_ADC_MspInit+0x118>)
 8001890:	6223      	str	r3, [r4, #32]
 8001892:	625c      	str	r4, [r3, #36]	; 0x24
 8001894:	e7ba      	b.n	800180c <HAL_ADC_MspInit+0x1c>
      Error_Handler();
 8001896:	f7fe fec1 	bl	800061c <Error_Handler>
 800189a:	e7f8      	b.n	800188e <HAL_ADC_MspInit+0x9e>
    __HAL_RCC_ADC2_CLK_ENABLE();
 800189c:	4b17      	ldr	r3, [pc, #92]	; (80018fc <HAL_ADC_MspInit+0x10c>)
 800189e:	699a      	ldr	r2, [r3, #24]
 80018a0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80018a4:	619a      	str	r2, [r3, #24]
 80018a6:	699a      	ldr	r2, [r3, #24]
 80018a8:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 80018ac:	9203      	str	r2, [sp, #12]
 80018ae:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80018b0:	699a      	ldr	r2, [r3, #24]
 80018b2:	f042 0204 	orr.w	r2, r2, #4
 80018b6:	619a      	str	r2, [r3, #24]
 80018b8:	699a      	ldr	r2, [r3, #24]
 80018ba:	f002 0204 	and.w	r2, r2, #4
 80018be:	9204      	str	r2, [sp, #16]
 80018c0:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80018c2:	699a      	ldr	r2, [r3, #24]
 80018c4:	f042 0208 	orr.w	r2, r2, #8
 80018c8:	619a      	str	r2, [r3, #24]
 80018ca:	699b      	ldr	r3, [r3, #24]
 80018cc:	f003 0308 	and.w	r3, r3, #8
 80018d0:	9305      	str	r3, [sp, #20]
 80018d2:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_5|GPIO_PIN_7;
 80018d4:	23aa      	movs	r3, #170	; 0xaa
 80018d6:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80018d8:	2403      	movs	r4, #3
 80018da:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80018dc:	a906      	add	r1, sp, #24
 80018de:	4808      	ldr	r0, [pc, #32]	; (8001900 <HAL_ADC_MspInit+0x110>)
 80018e0:	f002 fa72 	bl	8003dc8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 80018e4:	2302      	movs	r3, #2
 80018e6:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80018e8:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80018ea:	a906      	add	r1, sp, #24
 80018ec:	4805      	ldr	r0, [pc, #20]	; (8001904 <HAL_ADC_MspInit+0x114>)
 80018ee:	f002 fa6b 	bl	8003dc8 <HAL_GPIO_Init>
}
 80018f2:	e78b      	b.n	800180c <HAL_ADC_MspInit+0x1c>
 80018f4:	40012400 	.word	0x40012400
 80018f8:	40012800 	.word	0x40012800
 80018fc:	40021000 	.word	0x40021000
 8001900:	40010800 	.word	0x40010800
 8001904:	40010c00 	.word	0x40010c00
 8001908:	200043b4 	.word	0x200043b4
 800190c:	40020008 	.word	0x40020008

08001910 <HAL_ADC_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
 8001910:	b510      	push	{r4, lr}
  if(hadc->Instance==ADC1)
 8001912:	6803      	ldr	r3, [r0, #0]
 8001914:	4a14      	ldr	r2, [pc, #80]	; (8001968 <HAL_ADC_MspDeInit+0x58>)
 8001916:	4293      	cmp	r3, r2
 8001918:	d003      	beq.n	8001922 <HAL_ADC_MspDeInit+0x12>
    HAL_DMA_DeInit(hadc->DMA_Handle);
  /* USER CODE BEGIN ADC1_MspDeInit 1 */

  /* USER CODE END ADC1_MspDeInit 1 */
  }
  else if(hadc->Instance==ADC2)
 800191a:	4a14      	ldr	r2, [pc, #80]	; (800196c <HAL_ADC_MspDeInit+0x5c>)
 800191c:	4293      	cmp	r3, r2
 800191e:	d013      	beq.n	8001948 <HAL_ADC_MspDeInit+0x38>
  /* USER CODE BEGIN ADC2_MspDeInit 1 */

  /* USER CODE END ADC2_MspDeInit 1 */
  }

}
 8001920:	bd10      	pop	{r4, pc}
 8001922:	4604      	mov	r4, r0
    __HAL_RCC_ADC1_CLK_DISABLE();
 8001924:	f502 426c 	add.w	r2, r2, #60416	; 0xec00
 8001928:	6993      	ldr	r3, [r2, #24]
 800192a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800192e:	6193      	str	r3, [r2, #24]
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_6);
 8001930:	2155      	movs	r1, #85	; 0x55
 8001932:	480f      	ldr	r0, [pc, #60]	; (8001970 <HAL_ADC_MspDeInit+0x60>)
 8001934:	f002 fb58 	bl	8003fe8 <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_0);
 8001938:	2101      	movs	r1, #1
 800193a:	480e      	ldr	r0, [pc, #56]	; (8001974 <HAL_ADC_MspDeInit+0x64>)
 800193c:	f002 fb54 	bl	8003fe8 <HAL_GPIO_DeInit>
    HAL_DMA_DeInit(hadc->DMA_Handle);
 8001940:	6a20      	ldr	r0, [r4, #32]
 8001942:	f001 ff31 	bl	80037a8 <HAL_DMA_DeInit>
 8001946:	e7eb      	b.n	8001920 <HAL_ADC_MspDeInit+0x10>
    __HAL_RCC_ADC2_CLK_DISABLE();
 8001948:	f502 4268 	add.w	r2, r2, #59392	; 0xe800
 800194c:	6993      	ldr	r3, [r2, #24]
 800194e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001952:	6193      	str	r3, [r2, #24]
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_5|GPIO_PIN_7);
 8001954:	21aa      	movs	r1, #170	; 0xaa
 8001956:	4806      	ldr	r0, [pc, #24]	; (8001970 <HAL_ADC_MspDeInit+0x60>)
 8001958:	f002 fb46 	bl	8003fe8 <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_1);
 800195c:	2102      	movs	r1, #2
 800195e:	4805      	ldr	r0, [pc, #20]	; (8001974 <HAL_ADC_MspDeInit+0x64>)
 8001960:	f002 fb42 	bl	8003fe8 <HAL_GPIO_DeInit>
}
 8001964:	e7dc      	b.n	8001920 <HAL_ADC_MspDeInit+0x10>
 8001966:	bf00      	nop
 8001968:	40012400 	.word	0x40012400
 800196c:	40012800 	.word	0x40012800
 8001970:	40010800 	.word	0x40010800
 8001974:	40010c00 	.word	0x40010c00

08001978 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8001978:	b084      	sub	sp, #16
  if(htim_base->Instance==TIM2)
 800197a:	6803      	ldr	r3, [r0, #0]
 800197c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001980:	d007      	beq.n	8001992 <HAL_TIM_Base_MspInit+0x1a>
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(htim_base->Instance==TIM3)
 8001982:	4a15      	ldr	r2, [pc, #84]	; (80019d8 <HAL_TIM_Base_MspInit+0x60>)
 8001984:	4293      	cmp	r3, r2
 8001986:	d010      	beq.n	80019aa <HAL_TIM_Base_MspInit+0x32>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(htim_base->Instance==TIM4)
 8001988:	4a14      	ldr	r2, [pc, #80]	; (80019dc <HAL_TIM_Base_MspInit+0x64>)
 800198a:	4293      	cmp	r3, r2
 800198c:	d018      	beq.n	80019c0 <HAL_TIM_Base_MspInit+0x48>
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }

}
 800198e:	b004      	add	sp, #16
 8001990:	4770      	bx	lr
    __HAL_RCC_TIM2_CLK_ENABLE();
 8001992:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8001996:	69da      	ldr	r2, [r3, #28]
 8001998:	f042 0201 	orr.w	r2, r2, #1
 800199c:	61da      	str	r2, [r3, #28]
 800199e:	69db      	ldr	r3, [r3, #28]
 80019a0:	f003 0301 	and.w	r3, r3, #1
 80019a4:	9301      	str	r3, [sp, #4]
 80019a6:	9b01      	ldr	r3, [sp, #4]
 80019a8:	e7f1      	b.n	800198e <HAL_TIM_Base_MspInit+0x16>
    __HAL_RCC_TIM3_CLK_ENABLE();
 80019aa:	4b0d      	ldr	r3, [pc, #52]	; (80019e0 <HAL_TIM_Base_MspInit+0x68>)
 80019ac:	69da      	ldr	r2, [r3, #28]
 80019ae:	f042 0202 	orr.w	r2, r2, #2
 80019b2:	61da      	str	r2, [r3, #28]
 80019b4:	69db      	ldr	r3, [r3, #28]
 80019b6:	f003 0302 	and.w	r3, r3, #2
 80019ba:	9302      	str	r3, [sp, #8]
 80019bc:	9b02      	ldr	r3, [sp, #8]
 80019be:	e7e6      	b.n	800198e <HAL_TIM_Base_MspInit+0x16>
    __HAL_RCC_TIM4_CLK_ENABLE();
 80019c0:	4b07      	ldr	r3, [pc, #28]	; (80019e0 <HAL_TIM_Base_MspInit+0x68>)
 80019c2:	69da      	ldr	r2, [r3, #28]
 80019c4:	f042 0204 	orr.w	r2, r2, #4
 80019c8:	61da      	str	r2, [r3, #28]
 80019ca:	69db      	ldr	r3, [r3, #28]
 80019cc:	f003 0304 	and.w	r3, r3, #4
 80019d0:	9303      	str	r3, [sp, #12]
 80019d2:	9b03      	ldr	r3, [sp, #12]
}
 80019d4:	e7db      	b.n	800198e <HAL_TIM_Base_MspInit+0x16>
 80019d6:	bf00      	nop
 80019d8:	40000400 	.word	0x40000400
 80019dc:	40000800 	.word	0x40000800
 80019e0:	40021000 	.word	0x40021000

080019e4 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 80019e4:	b510      	push	{r4, lr}
 80019e6:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80019e8:	2300      	movs	r3, #0
 80019ea:	9304      	str	r3, [sp, #16]
 80019ec:	9305      	str	r3, [sp, #20]
 80019ee:	9306      	str	r3, [sp, #24]
 80019f0:	9307      	str	r3, [sp, #28]
  if(htim->Instance==TIM2)
 80019f2:	6803      	ldr	r3, [r0, #0]
 80019f4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80019f8:	d007      	beq.n	8001a0a <HAL_TIM_MspPostInit+0x26>

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(htim->Instance==TIM3)
 80019fa:	4a34      	ldr	r2, [pc, #208]	; (8001acc <HAL_TIM_MspPostInit+0xe8>)
 80019fc:	4293      	cmp	r3, r2
 80019fe:	d034      	beq.n	8001a6a <HAL_TIM_MspPostInit+0x86>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(htim->Instance==TIM4)
 8001a00:	4a33      	ldr	r2, [pc, #204]	; (8001ad0 <HAL_TIM_MspPostInit+0xec>)
 8001a02:	4293      	cmp	r3, r2
 8001a04:	d04e      	beq.n	8001aa4 <HAL_TIM_MspPostInit+0xc0>
  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }

}
 8001a06:	b008      	add	sp, #32
 8001a08:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a0a:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8001a0e:	699a      	ldr	r2, [r3, #24]
 8001a10:	f042 0204 	orr.w	r2, r2, #4
 8001a14:	619a      	str	r2, [r3, #24]
 8001a16:	699a      	ldr	r2, [r3, #24]
 8001a18:	f002 0204 	and.w	r2, r2, #4
 8001a1c:	9200      	str	r2, [sp, #0]
 8001a1e:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001a20:	699a      	ldr	r2, [r3, #24]
 8001a22:	f042 0208 	orr.w	r2, r2, #8
 8001a26:	619a      	str	r2, [r3, #24]
 8001a28:	699b      	ldr	r3, [r3, #24]
 8001a2a:	f003 0308 	and.w	r3, r3, #8
 8001a2e:	9301      	str	r3, [sp, #4]
 8001a30:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_15;
 8001a32:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001a36:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001a38:	2402      	movs	r4, #2
 8001a3a:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a3c:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001a3e:	a904      	add	r1, sp, #16
 8001a40:	4824      	ldr	r0, [pc, #144]	; (8001ad4 <HAL_TIM_MspPostInit+0xf0>)
 8001a42:	f002 f9c1 	bl	8003dc8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8001a46:	2308      	movs	r3, #8
 8001a48:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001a4a:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a4c:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001a4e:	a904      	add	r1, sp, #16
 8001a50:	4821      	ldr	r0, [pc, #132]	; (8001ad8 <HAL_TIM_MspPostInit+0xf4>)
 8001a52:	f002 f9b9 	bl	8003dc8 <HAL_GPIO_Init>
    __HAL_AFIO_REMAP_TIM2_PARTIAL_1();
 8001a56:	4a21      	ldr	r2, [pc, #132]	; (8001adc <HAL_TIM_MspPostInit+0xf8>)
 8001a58:	6853      	ldr	r3, [r2, #4]
 8001a5a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001a5e:	f043 63e0 	orr.w	r3, r3, #117440512	; 0x7000000
 8001a62:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001a66:	6053      	str	r3, [r2, #4]
 8001a68:	e7cd      	b.n	8001a06 <HAL_TIM_MspPostInit+0x22>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001a6a:	4b1d      	ldr	r3, [pc, #116]	; (8001ae0 <HAL_TIM_MspPostInit+0xfc>)
 8001a6c:	699a      	ldr	r2, [r3, #24]
 8001a6e:	f042 0208 	orr.w	r2, r2, #8
 8001a72:	619a      	str	r2, [r3, #24]
 8001a74:	699b      	ldr	r3, [r3, #24]
 8001a76:	f003 0308 	and.w	r3, r3, #8
 8001a7a:	9302      	str	r3, [sp, #8]
 8001a7c:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 8001a7e:	2330      	movs	r3, #48	; 0x30
 8001a80:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001a82:	2302      	movs	r3, #2
 8001a84:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a86:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001a88:	a904      	add	r1, sp, #16
 8001a8a:	4813      	ldr	r0, [pc, #76]	; (8001ad8 <HAL_TIM_MspPostInit+0xf4>)
 8001a8c:	f002 f99c 	bl	8003dc8 <HAL_GPIO_Init>
    __HAL_AFIO_REMAP_TIM3_PARTIAL();
 8001a90:	4a12      	ldr	r2, [pc, #72]	; (8001adc <HAL_TIM_MspPostInit+0xf8>)
 8001a92:	6853      	ldr	r3, [r2, #4]
 8001a94:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8001a98:	f043 63e0 	orr.w	r3, r3, #117440512	; 0x7000000
 8001a9c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001aa0:	6053      	str	r3, [r2, #4]
 8001aa2:	e7b0      	b.n	8001a06 <HAL_TIM_MspPostInit+0x22>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001aa4:	4b0e      	ldr	r3, [pc, #56]	; (8001ae0 <HAL_TIM_MspPostInit+0xfc>)
 8001aa6:	699a      	ldr	r2, [r3, #24]
 8001aa8:	f042 0208 	orr.w	r2, r2, #8
 8001aac:	619a      	str	r2, [r3, #24]
 8001aae:	699b      	ldr	r3, [r3, #24]
 8001ab0:	f003 0308 	and.w	r3, r3, #8
 8001ab4:	9303      	str	r3, [sp, #12]
 8001ab6:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8001ab8:	23c0      	movs	r3, #192	; 0xc0
 8001aba:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001abc:	2302      	movs	r3, #2
 8001abe:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001ac0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001ac2:	a904      	add	r1, sp, #16
 8001ac4:	4804      	ldr	r0, [pc, #16]	; (8001ad8 <HAL_TIM_MspPostInit+0xf4>)
 8001ac6:	f002 f97f 	bl	8003dc8 <HAL_GPIO_Init>
}
 8001aca:	e79c      	b.n	8001a06 <HAL_TIM_MspPostInit+0x22>
 8001acc:	40000400 	.word	0x40000400
 8001ad0:	40000800 	.word	0x40000800
 8001ad4:	40010800 	.word	0x40010800
 8001ad8:	40010c00 	.word	0x40010c00
 8001adc:	40010000 	.word	0x40010000
 8001ae0:	40021000 	.word	0x40021000

08001ae4 <HAL_TIM_Base_MspDeInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM2)
 8001ae4:	6803      	ldr	r3, [r0, #0]
 8001ae6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001aea:	d006      	beq.n	8001afa <HAL_TIM_Base_MspDeInit+0x16>
    __HAL_RCC_TIM2_CLK_DISABLE();
  /* USER CODE BEGIN TIM2_MspDeInit 1 */

  /* USER CODE END TIM2_MspDeInit 1 */
  }
  else if(htim_base->Instance==TIM3)
 8001aec:	4a0d      	ldr	r2, [pc, #52]	; (8001b24 <HAL_TIM_Base_MspDeInit+0x40>)
 8001aee:	4293      	cmp	r3, r2
 8001af0:	d009      	beq.n	8001b06 <HAL_TIM_Base_MspDeInit+0x22>
    __HAL_RCC_TIM3_CLK_DISABLE();
  /* USER CODE BEGIN TIM3_MspDeInit 1 */

  /* USER CODE END TIM3_MspDeInit 1 */
  }
  else if(htim_base->Instance==TIM4)
 8001af2:	4a0d      	ldr	r2, [pc, #52]	; (8001b28 <HAL_TIM_Base_MspDeInit+0x44>)
 8001af4:	4293      	cmp	r3, r2
 8001af6:	d00d      	beq.n	8001b14 <HAL_TIM_Base_MspDeInit+0x30>
  /* USER CODE BEGIN TIM4_MspDeInit 1 */

  /* USER CODE END TIM4_MspDeInit 1 */
  }

}
 8001af8:	4770      	bx	lr
    __HAL_RCC_TIM2_CLK_DISABLE();
 8001afa:	4a0c      	ldr	r2, [pc, #48]	; (8001b2c <HAL_TIM_Base_MspDeInit+0x48>)
 8001afc:	69d3      	ldr	r3, [r2, #28]
 8001afe:	f023 0301 	bic.w	r3, r3, #1
 8001b02:	61d3      	str	r3, [r2, #28]
 8001b04:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_DISABLE();
 8001b06:	f502 3203 	add.w	r2, r2, #134144	; 0x20c00
 8001b0a:	69d3      	ldr	r3, [r2, #28]
 8001b0c:	f023 0302 	bic.w	r3, r3, #2
 8001b10:	61d3      	str	r3, [r2, #28]
 8001b12:	4770      	bx	lr
    __HAL_RCC_TIM4_CLK_DISABLE();
 8001b14:	f502 3202 	add.w	r2, r2, #133120	; 0x20800
 8001b18:	69d3      	ldr	r3, [r2, #28]
 8001b1a:	f023 0304 	bic.w	r3, r3, #4
 8001b1e:	61d3      	str	r3, [r2, #28]
}
 8001b20:	e7ea      	b.n	8001af8 <HAL_TIM_Base_MspDeInit+0x14>
 8001b22:	bf00      	nop
 8001b24:	40000400 	.word	0x40000400
 8001b28:	40000800 	.word	0x40000800
 8001b2c:	40021000 	.word	0x40021000

08001b30 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001b30:	b570      	push	{r4, r5, r6, lr}
 8001b32:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001b34:	2300      	movs	r3, #0
 8001b36:	9302      	str	r3, [sp, #8]
 8001b38:	9303      	str	r3, [sp, #12]
 8001b3a:	9304      	str	r3, [sp, #16]
 8001b3c:	9305      	str	r3, [sp, #20]
  if(huart->Instance==USART1)
 8001b3e:	6802      	ldr	r2, [r0, #0]
 8001b40:	4b33      	ldr	r3, [pc, #204]	; (8001c10 <HAL_UART_MspInit+0xe0>)
 8001b42:	429a      	cmp	r2, r3
 8001b44:	d001      	beq.n	8001b4a <HAL_UART_MspInit+0x1a>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 8001b46:	b006      	add	sp, #24
 8001b48:	bd70      	pop	{r4, r5, r6, pc}
 8001b4a:	4604      	mov	r4, r0
    __HAL_RCC_USART1_CLK_ENABLE();
 8001b4c:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
 8001b50:	699a      	ldr	r2, [r3, #24]
 8001b52:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b56:	619a      	str	r2, [r3, #24]
 8001b58:	699a      	ldr	r2, [r3, #24]
 8001b5a:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8001b5e:	9200      	str	r2, [sp, #0]
 8001b60:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001b62:	699a      	ldr	r2, [r3, #24]
 8001b64:	f042 0204 	orr.w	r2, r2, #4
 8001b68:	619a      	str	r2, [r3, #24]
 8001b6a:	699b      	ldr	r3, [r3, #24]
 8001b6c:	f003 0304 	and.w	r3, r3, #4
 8001b70:	9301      	str	r3, [sp, #4]
 8001b72:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8001b74:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001b78:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b7a:	2302      	movs	r3, #2
 8001b7c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8001b7e:	2303      	movs	r3, #3
 8001b80:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b82:	4e24      	ldr	r6, [pc, #144]	; (8001c14 <HAL_UART_MspInit+0xe4>)
 8001b84:	a902      	add	r1, sp, #8
 8001b86:	4630      	mov	r0, r6
 8001b88:	f002 f91e 	bl	8003dc8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8001b8c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001b90:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001b92:	2500      	movs	r5, #0
 8001b94:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b96:	9504      	str	r5, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b98:	a902      	add	r1, sp, #8
 8001b9a:	4630      	mov	r0, r6
 8001b9c:	f002 f914 	bl	8003dc8 <HAL_GPIO_Init>
    hdma_usart1_tx.Instance = DMA1_Channel4;
 8001ba0:	481d      	ldr	r0, [pc, #116]	; (8001c18 <HAL_UART_MspInit+0xe8>)
 8001ba2:	4b1e      	ldr	r3, [pc, #120]	; (8001c1c <HAL_UART_MspInit+0xec>)
 8001ba4:	6003      	str	r3, [r0, #0]
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001ba6:	2310      	movs	r3, #16
 8001ba8:	6043      	str	r3, [r0, #4]
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001baa:	6085      	str	r5, [r0, #8]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001bac:	2380      	movs	r3, #128	; 0x80
 8001bae:	60c3      	str	r3, [r0, #12]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001bb0:	6105      	str	r5, [r0, #16]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001bb2:	6145      	str	r5, [r0, #20]
    hdma_usart1_tx.Init.Mode = DMA_NORMAL;
 8001bb4:	6185      	str	r5, [r0, #24]
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_HIGH;
 8001bb6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001bba:	61c3      	str	r3, [r0, #28]
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 8001bbc:	f001 fdbe 	bl	800373c <HAL_DMA_Init>
 8001bc0:	b9f8      	cbnz	r0, 8001c02 <HAL_UART_MspInit+0xd2>
    __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx);
 8001bc2:	4b15      	ldr	r3, [pc, #84]	; (8001c18 <HAL_UART_MspInit+0xe8>)
 8001bc4:	6363      	str	r3, [r4, #52]	; 0x34
 8001bc6:	625c      	str	r4, [r3, #36]	; 0x24
    hdma_usart1_rx.Instance = DMA1_Channel5;
 8001bc8:	4815      	ldr	r0, [pc, #84]	; (8001c20 <HAL_UART_MspInit+0xf0>)
 8001bca:	4b16      	ldr	r3, [pc, #88]	; (8001c24 <HAL_UART_MspInit+0xf4>)
 8001bcc:	6003      	str	r3, [r0, #0]
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001bce:	2300      	movs	r3, #0
 8001bd0:	6043      	str	r3, [r0, #4]
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001bd2:	6083      	str	r3, [r0, #8]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8001bd4:	2280      	movs	r2, #128	; 0x80
 8001bd6:	60c2      	str	r2, [r0, #12]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001bd8:	6103      	str	r3, [r0, #16]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001bda:	6143      	str	r3, [r0, #20]
    hdma_usart1_rx.Init.Mode = DMA_NORMAL;
 8001bdc:	6183      	str	r3, [r0, #24]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8001bde:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8001be2:	61c3      	str	r3, [r0, #28]
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 8001be4:	f001 fdaa 	bl	800373c <HAL_DMA_Init>
 8001be8:	b970      	cbnz	r0, 8001c08 <HAL_UART_MspInit+0xd8>
    __HAL_LINKDMA(huart,hdmarx,hdma_usart1_rx);
 8001bea:	4b0d      	ldr	r3, [pc, #52]	; (8001c20 <HAL_UART_MspInit+0xf0>)
 8001bec:	63a3      	str	r3, [r4, #56]	; 0x38
 8001bee:	625c      	str	r4, [r3, #36]	; 0x24
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 8001bf0:	2200      	movs	r2, #0
 8001bf2:	2105      	movs	r1, #5
 8001bf4:	2025      	movs	r0, #37	; 0x25
 8001bf6:	f001 fc81 	bl	80034fc <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8001bfa:	2025      	movs	r0, #37	; 0x25
 8001bfc:	f001 fcb2 	bl	8003564 <HAL_NVIC_EnableIRQ>
}
 8001c00:	e7a1      	b.n	8001b46 <HAL_UART_MspInit+0x16>
      Error_Handler();
 8001c02:	f7fe fd0b 	bl	800061c <Error_Handler>
 8001c06:	e7dc      	b.n	8001bc2 <HAL_UART_MspInit+0x92>
      Error_Handler();
 8001c08:	f7fe fd08 	bl	800061c <Error_Handler>
 8001c0c:	e7ed      	b.n	8001bea <HAL_UART_MspInit+0xba>
 8001c0e:	bf00      	nop
 8001c10:	40013800 	.word	0x40013800
 8001c14:	40010800 	.word	0x40010800
 8001c18:	20004290 	.word	0x20004290
 8001c1c:	40020044 	.word	0x40020044
 8001c20:	20004310 	.word	0x20004310
 8001c24:	40020058 	.word	0x40020058

08001c28 <HAL_UART_MspDeInit>:
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
{
  if(huart->Instance==USART1)
 8001c28:	6802      	ldr	r2, [r0, #0]
 8001c2a:	4b0d      	ldr	r3, [pc, #52]	; (8001c60 <HAL_UART_MspDeInit+0x38>)
 8001c2c:	429a      	cmp	r2, r3
 8001c2e:	d000      	beq.n	8001c32 <HAL_UART_MspDeInit+0xa>
 8001c30:	4770      	bx	lr
{
 8001c32:	b510      	push	{r4, lr}
 8001c34:	4604      	mov	r4, r0
  {
  /* USER CODE BEGIN USART1_MspDeInit 0 */

  /* USER CODE END USART1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_USART1_CLK_DISABLE();
 8001c36:	4a0b      	ldr	r2, [pc, #44]	; (8001c64 <HAL_UART_MspDeInit+0x3c>)
 8001c38:	6993      	ldr	r3, [r2, #24]
 8001c3a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001c3e:	6193      	str	r3, [r2, #24]

    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);
 8001c40:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8001c44:	4808      	ldr	r0, [pc, #32]	; (8001c68 <HAL_UART_MspDeInit+0x40>)
 8001c46:	f002 f9cf 	bl	8003fe8 <HAL_GPIO_DeInit>

    /* USART1 DMA DeInit */
    HAL_DMA_DeInit(huart->hdmatx);
 8001c4a:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8001c4c:	f001 fdac 	bl	80037a8 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(huart->hdmarx);
 8001c50:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001c52:	f001 fda9 	bl	80037a8 <HAL_DMA_DeInit>

    /* USART1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(USART1_IRQn);
 8001c56:	2025      	movs	r0, #37	; 0x25
 8001c58:	f001 fc92 	bl	8003580 <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN USART1_MspDeInit 1 */

  /* USER CODE END USART1_MspDeInit 1 */
  }

}
 8001c5c:	bd10      	pop	{r4, pc}
 8001c5e:	bf00      	nop
 8001c60:	40013800 	.word	0x40013800
 8001c64:	40021000 	.word	0x40021000
 8001c68:	40010800 	.word	0x40010800

08001c6c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001c6c:	b500      	push	{lr}
 8001c6e:	b089      	sub	sp, #36	; 0x24
 8001c70:	4601      	mov	r1, r0
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_IRQn, TickPriority ,0);
 8001c72:	2200      	movs	r2, #0
 8001c74:	2019      	movs	r0, #25
 8001c76:	f001 fc41 	bl	80034fc <HAL_NVIC_SetPriority>

  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);
 8001c7a:	2019      	movs	r0, #25
 8001c7c:	f001 fc72 	bl	8003564 <HAL_NVIC_EnableIRQ>
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 8001c80:	4b14      	ldr	r3, [pc, #80]	; (8001cd4 <HAL_InitTick+0x68>)
 8001c82:	699a      	ldr	r2, [r3, #24]
 8001c84:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001c88:	619a      	str	r2, [r3, #24]
 8001c8a:	699b      	ldr	r3, [r3, #24]
 8001c8c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001c90:	9301      	str	r3, [sp, #4]
 8001c92:	9b01      	ldr	r3, [sp, #4]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001c94:	a902      	add	r1, sp, #8
 8001c96:	a803      	add	r0, sp, #12
 8001c98:	f002 fe96 	bl	80049c8 <HAL_RCC_GetClockConfig>

  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 8001c9c:	f002 fe2a 	bl	80048f4 <HAL_RCC_GetPCLK2Freq>
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8001ca0:	4b0d      	ldr	r3, [pc, #52]	; (8001cd8 <HAL_InitTick+0x6c>)
 8001ca2:	fba3 2300 	umull	r2, r3, r3, r0
 8001ca6:	0c9b      	lsrs	r3, r3, #18
 8001ca8:	3b01      	subs	r3, #1

  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8001caa:	480c      	ldr	r0, [pc, #48]	; (8001cdc <HAL_InitTick+0x70>)
 8001cac:	4a0c      	ldr	r2, [pc, #48]	; (8001ce0 <HAL_InitTick+0x74>)
 8001cae:	6002      	str	r2, [r0, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 8001cb0:	f240 32e7 	movw	r2, #999	; 0x3e7
 8001cb4:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8001cb6:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 8001cb8:	2300      	movs	r3, #0
 8001cba:	6103      	str	r3, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001cbc:	6083      	str	r3, [r0, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8001cbe:	f003 ff7d 	bl	8005bbc <HAL_TIM_Base_Init>
 8001cc2:	b118      	cbz	r0, 8001ccc <HAL_InitTick+0x60>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }

  /* Return function status */
  return HAL_ERROR;
 8001cc4:	2001      	movs	r0, #1
}
 8001cc6:	b009      	add	sp, #36	; 0x24
 8001cc8:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_TIM_Base_Start_IT(&htim1);
 8001ccc:	4803      	ldr	r0, [pc, #12]	; (8001cdc <HAL_InitTick+0x70>)
 8001cce:	f003 f937 	bl	8004f40 <HAL_TIM_Base_Start_IT>
 8001cd2:	e7f8      	b.n	8001cc6 <HAL_InitTick+0x5a>
 8001cd4:	40021000 	.word	0x40021000
 8001cd8:	431bde83 	.word	0x431bde83
 8001cdc:	20004504 	.word	0x20004504
 8001ce0:	40012c00 	.word	0x40012c00

08001ce4 <HAL_SuspendTick>:
  * @retval None
  */
void HAL_SuspendTick(void)
{
  /* Disable TIM1 update Interrupt */
  __HAL_TIM_DISABLE_IT(&htim1, TIM_IT_UPDATE);
 8001ce4:	4b03      	ldr	r3, [pc, #12]	; (8001cf4 <HAL_SuspendTick+0x10>)
 8001ce6:	681a      	ldr	r2, [r3, #0]
 8001ce8:	68d3      	ldr	r3, [r2, #12]
 8001cea:	f023 0301 	bic.w	r3, r3, #1
 8001cee:	60d3      	str	r3, [r2, #12]
}
 8001cf0:	4770      	bx	lr
 8001cf2:	bf00      	nop
 8001cf4:	20004504 	.word	0x20004504

08001cf8 <HAL_ResumeTick>:
  * @retval None
  */
void HAL_ResumeTick(void)
{
  /* Enable TIM1 Update interrupt */
  __HAL_TIM_ENABLE_IT(&htim1, TIM_IT_UPDATE);
 8001cf8:	4b03      	ldr	r3, [pc, #12]	; (8001d08 <HAL_ResumeTick+0x10>)
 8001cfa:	681a      	ldr	r2, [r3, #0]
 8001cfc:	68d3      	ldr	r3, [r2, #12]
 8001cfe:	f043 0301 	orr.w	r3, r3, #1
 8001d02:	60d3      	str	r3, [r2, #12]
}
 8001d04:	4770      	bx	lr
 8001d06:	bf00      	nop
 8001d08:	20004504 	.word	0x20004504

08001d0c <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8001d0c:	e7fe      	b.n	8001d0c <NMI_Handler>

08001d0e <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001d0e:	e7fe      	b.n	8001d0e <HardFault_Handler>

08001d10 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001d10:	e7fe      	b.n	8001d10 <MemManage_Handler>

08001d12 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001d12:	e7fe      	b.n	8001d12 <BusFault_Handler>

08001d14 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001d14:	e7fe      	b.n	8001d14 <UsageFault_Handler>

08001d16 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001d16:	4770      	bx	lr

08001d18 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 8001d18:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 8001d1a:	4802      	ldr	r0, [pc, #8]	; (8001d24 <DMA1_Channel1_IRQHandler+0xc>)
 8001d1c:	f001 ff5e 	bl	8003bdc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 8001d20:	bd08      	pop	{r3, pc}
 8001d22:	bf00      	nop
 8001d24:	200043b4 	.word	0x200043b4

08001d28 <DMA1_Channel2_IRQHandler>:

/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
 8001d28:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_memtomem_dma1_channel2);
 8001d2a:	4802      	ldr	r0, [pc, #8]	; (8001d34 <DMA1_Channel2_IRQHandler+0xc>)
 8001d2c:	f001 ff56 	bl	8003bdc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}
 8001d30:	bd08      	pop	{r3, pc}
 8001d32:	bf00      	nop
 8001d34:	20004424 	.word	0x20004424

08001d38 <DMA1_Channel3_IRQHandler>:

/**
  * @brief This function handles DMA1 channel3 global interrupt.
  */
void DMA1_Channel3_IRQHandler(void)
{
 8001d38:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel3_IRQn 0 */

  /* USER CODE END DMA1_Channel3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_memtomem_dma1_channel3);
 8001d3a:	4802      	ldr	r0, [pc, #8]	; (8001d44 <DMA1_Channel3_IRQHandler+0xc>)
 8001d3c:	f001 ff4e 	bl	8003bdc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel3_IRQn 1 */

  /* USER CODE END DMA1_Channel3_IRQn 1 */
}
 8001d40:	bd08      	pop	{r3, pc}
 8001d42:	bf00      	nop
 8001d44:	2000415c 	.word	0x2000415c

08001d48 <DMA1_Channel4_IRQHandler>:

/**
  * @brief This function handles DMA1 channel4 global interrupt.
  */
void DMA1_Channel4_IRQHandler(void)
{
 8001d48:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel4_IRQn 0 */

  /* USER CODE END DMA1_Channel4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 8001d4a:	4802      	ldr	r0, [pc, #8]	; (8001d54 <DMA1_Channel4_IRQHandler+0xc>)
 8001d4c:	f001 ff46 	bl	8003bdc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */

  /* USER CODE END DMA1_Channel4_IRQn 1 */
}
 8001d50:	bd08      	pop	{r3, pc}
 8001d52:	bf00      	nop
 8001d54:	20004290 	.word	0x20004290

08001d58 <DMA1_Channel5_IRQHandler>:

/**
  * @brief This function handles DMA1 channel5 global interrupt.
  */
void DMA1_Channel5_IRQHandler(void)
{
 8001d58:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 8001d5a:	4802      	ldr	r0, [pc, #8]	; (8001d64 <DMA1_Channel5_IRQHandler+0xc>)
 8001d5c:	f001 ff3e 	bl	8003bdc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel5_IRQn 1 */

  /* USER CODE END DMA1_Channel5_IRQn 1 */
}
 8001d60:	bd08      	pop	{r3, pc}
 8001d62:	bf00      	nop
 8001d64:	20004310 	.word	0x20004310

08001d68 <TIM1_UP_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt.
  */
void TIM1_UP_IRQHandler(void)
{
 8001d68:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_IRQn 0 */

  /* USER CODE END TIM1_UP_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8001d6a:	4802      	ldr	r0, [pc, #8]	; (8001d74 <TIM1_UP_IRQHandler+0xc>)
 8001d6c:	f003 fdc3 	bl	80058f6 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_IRQn 1 */

  /* USER CODE END TIM1_UP_IRQn 1 */
}
 8001d70:	bd08      	pop	{r3, pc}
 8001d72:	bf00      	nop
 8001d74:	20004504 	.word	0x20004504

08001d78 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8001d78:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8001d7a:	4802      	ldr	r0, [pc, #8]	; (8001d84 <USART1_IRQHandler+0xc>)
 8001d7c:	f008 fb3c 	bl	800a3f8 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8001d80:	bd08      	pop	{r3, pc}
 8001d82:	bf00      	nop
 8001d84:	20004360 	.word	0x20004360

08001d88 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8001d88:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_14);
 8001d8a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001d8e:	f002 f9d7 	bl	8004140 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_15);
 8001d92:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001d96:	f002 f9d3 	bl	8004140 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8001d9a:	bd08      	pop	{r3, pc}

08001d9c <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001d9c:	4770      	bx	lr

08001d9e <SystemCoreClockUpdate>:
#if defined(STM32F100xB) || defined(STM32F100xE)
  uint32_t prediv1factor = 0U;
#endif /* STM32F100xB or STM32F100xE */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8001d9e:	4b1f      	ldr	r3, [pc, #124]	; (8001e1c <SystemCoreClockUpdate+0x7e>)
 8001da0:	685b      	ldr	r3, [r3, #4]
 8001da2:	f003 030c 	and.w	r3, r3, #12
  
  switch (tmp)
 8001da6:	2b04      	cmp	r3, #4
 8001da8:	d014      	beq.n	8001dd4 <SystemCoreClockUpdate+0x36>
 8001daa:	2b08      	cmp	r3, #8
 8001dac:	d016      	beq.n	8001ddc <SystemCoreClockUpdate+0x3e>
 8001dae:	b11b      	cbz	r3, 8001db8 <SystemCoreClockUpdate+0x1a>
      }
#endif /* STM32F105xC */ 
      break;

    default:
      SystemCoreClock = HSI_VALUE;
 8001db0:	4b1b      	ldr	r3, [pc, #108]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001db2:	4a1c      	ldr	r2, [pc, #112]	; (8001e24 <SystemCoreClockUpdate+0x86>)
 8001db4:	601a      	str	r2, [r3, #0]
      break;
 8001db6:	e002      	b.n	8001dbe <SystemCoreClockUpdate+0x20>
      SystemCoreClock = HSI_VALUE;
 8001db8:	4b19      	ldr	r3, [pc, #100]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001dba:	4a1a      	ldr	r2, [pc, #104]	; (8001e24 <SystemCoreClockUpdate+0x86>)
 8001dbc:	601a      	str	r2, [r3, #0]
  }
  
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 8001dbe:	4b17      	ldr	r3, [pc, #92]	; (8001e1c <SystemCoreClockUpdate+0x7e>)
 8001dc0:	685b      	ldr	r3, [r3, #4]
 8001dc2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001dc6:	4a18      	ldr	r2, [pc, #96]	; (8001e28 <SystemCoreClockUpdate+0x8a>)
 8001dc8:	5cd1      	ldrb	r1, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 8001dca:	4a15      	ldr	r2, [pc, #84]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001dcc:	6813      	ldr	r3, [r2, #0]
 8001dce:	40cb      	lsrs	r3, r1
 8001dd0:	6013      	str	r3, [r2, #0]
}
 8001dd2:	4770      	bx	lr
      SystemCoreClock = HSE_VALUE;
 8001dd4:	4b12      	ldr	r3, [pc, #72]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001dd6:	4a13      	ldr	r2, [pc, #76]	; (8001e24 <SystemCoreClockUpdate+0x86>)
 8001dd8:	601a      	str	r2, [r3, #0]
      break;
 8001dda:	e7f0      	b.n	8001dbe <SystemCoreClockUpdate+0x20>
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8001ddc:	4a0f      	ldr	r2, [pc, #60]	; (8001e1c <SystemCoreClockUpdate+0x7e>)
 8001dde:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8001de0:	6852      	ldr	r2, [r2, #4]
      pllmull = ( pllmull >> 18U) + 2U;
 8001de2:	f3c3 4383 	ubfx	r3, r3, #18, #4
 8001de6:	3302      	adds	r3, #2
      if (pllsource == 0x00U)
 8001de8:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 8001dec:	d105      	bne.n	8001dfa <SystemCoreClockUpdate+0x5c>
        SystemCoreClock = (HSI_VALUE >> 1U) * pllmull;
 8001dee:	4a0f      	ldr	r2, [pc, #60]	; (8001e2c <SystemCoreClockUpdate+0x8e>)
 8001df0:	fb02 f303 	mul.w	r3, r2, r3
 8001df4:	4a0a      	ldr	r2, [pc, #40]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001df6:	6013      	str	r3, [r2, #0]
 8001df8:	e7e1      	b.n	8001dbe <SystemCoreClockUpdate+0x20>
        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
 8001dfa:	4a08      	ldr	r2, [pc, #32]	; (8001e1c <SystemCoreClockUpdate+0x7e>)
 8001dfc:	6852      	ldr	r2, [r2, #4]
 8001dfe:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001e02:	d005      	beq.n	8001e10 <SystemCoreClockUpdate+0x72>
          SystemCoreClock = (HSE_VALUE >> 1U) * pllmull;
 8001e04:	4a09      	ldr	r2, [pc, #36]	; (8001e2c <SystemCoreClockUpdate+0x8e>)
 8001e06:	fb02 f303 	mul.w	r3, r2, r3
 8001e0a:	4a05      	ldr	r2, [pc, #20]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001e0c:	6013      	str	r3, [r2, #0]
 8001e0e:	e7d6      	b.n	8001dbe <SystemCoreClockUpdate+0x20>
          SystemCoreClock = HSE_VALUE * pllmull;
 8001e10:	4a04      	ldr	r2, [pc, #16]	; (8001e24 <SystemCoreClockUpdate+0x86>)
 8001e12:	fb02 f303 	mul.w	r3, r2, r3
 8001e16:	4a02      	ldr	r2, [pc, #8]	; (8001e20 <SystemCoreClockUpdate+0x82>)
 8001e18:	6013      	str	r3, [r2, #0]
 8001e1a:	e7d0      	b.n	8001dbe <SystemCoreClockUpdate+0x20>
 8001e1c:	40021000 	.word	0x40021000
 8001e20:	20000028 	.word	0x20000028
 8001e24:	007a1200 	.word	0x007a1200
 8001e28:	0800fe68 	.word	0x0800fe68
 8001e2c:	003d0900 	.word	0x003d0900
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8001e30:	4770      	bx	lr

08001e32 <HAL_MspDeInit>:
__weak void HAL_MspDeInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
 8001e32:	4770      	bx	lr

08001e34 <HAL_DeInit>:
{
 8001e34:	b510      	push	{r4, lr}
  __HAL_RCC_APB1_FORCE_RESET();
 8001e36:	4b06      	ldr	r3, [pc, #24]	; (8001e50 <HAL_DeInit+0x1c>)
 8001e38:	f04f 32ff 	mov.w	r2, #4294967295
 8001e3c:	60da      	str	r2, [r3, #12]
  __HAL_RCC_APB1_RELEASE_RESET();
 8001e3e:	2400      	movs	r4, #0
 8001e40:	611c      	str	r4, [r3, #16]
  __HAL_RCC_APB2_FORCE_RESET();
 8001e42:	60da      	str	r2, [r3, #12]
  __HAL_RCC_APB2_RELEASE_RESET();
 8001e44:	60dc      	str	r4, [r3, #12]
  HAL_MspDeInit();
 8001e46:	f7ff fff4 	bl	8001e32 <HAL_MspDeInit>
}
 8001e4a:	4620      	mov	r0, r4
 8001e4c:	bd10      	pop	{r4, pc}
 8001e4e:	bf00      	nop
 8001e50:	40021000 	.word	0x40021000
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001e54:	b510      	push	{r4, lr}
 8001e56:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001e58:	4b0e      	ldr	r3, [pc, #56]	; (8001e94 <HAL_DeInit+0x60>)
 8001e5a:	7818      	ldrb	r0, [r3, #0]
 8001e5c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001e60:	fbb3 f3f0 	udiv	r3, r3, r0
 8001e64:	4a0c      	ldr	r2, [pc, #48]	; (8001e98 <HAL_DeInit+0x64>)
 8001e66:	6810      	ldr	r0, [r2, #0]
 8001e68:	fbb0 f0f3 	udiv	r0, r0, r3
 8001e6c:	f001 fbac 	bl	80035c8 <HAL_SYSTICK_Config>
 8001e70:	b968      	cbnz	r0, 8001e8e <HAL_DeInit+0x5a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001e72:	2c0f      	cmp	r4, #15
 8001e74:	d901      	bls.n	8001e7a <HAL_DeInit+0x46>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 8001e76:	2001      	movs	r0, #1
 8001e78:	e00a      	b.n	8001e90 <HAL_DeInit+0x5c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001e7a:	2200      	movs	r2, #0
 8001e7c:	4621      	mov	r1, r4
 8001e7e:	f04f 30ff 	mov.w	r0, #4294967295
 8001e82:	f001 fb3b 	bl	80034fc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001e86:	4b05      	ldr	r3, [pc, #20]	; (8001e9c <HAL_DeInit+0x68>)
 8001e88:	601c      	str	r4, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8001e8a:	2000      	movs	r0, #0
 8001e8c:	e000      	b.n	8001e90 <HAL_DeInit+0x5c>
    return HAL_ERROR;
 8001e8e:	2001      	movs	r0, #1
}
 8001e90:	bd10      	pop	{r4, pc}
 8001e92:	bf00      	nop
 8001e94:	2000002c 	.word	0x2000002c
 8001e98:	20000028 	.word	0x20000028
 8001e9c:	20000030 	.word	0x20000030

08001ea0 <HAL_Init>:
{
 8001ea0:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001ea2:	4a07      	ldr	r2, [pc, #28]	; (8001ec0 <HAL_Init+0x20>)
 8001ea4:	6813      	ldr	r3, [r2, #0]
 8001ea6:	f043 0310 	orr.w	r3, r3, #16
 8001eaa:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001eac:	2003      	movs	r0, #3
 8001eae:	f001 fb13 	bl	80034d8 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8001eb2:	2000      	movs	r0, #0
 8001eb4:	f7ff feda 	bl	8001c6c <HAL_InitTick>
  HAL_MspInit();
 8001eb8:	f7ff fc70 	bl	800179c <HAL_MspInit>
}
 8001ebc:	2000      	movs	r0, #0
 8001ebe:	bd08      	pop	{r3, pc}
 8001ec0:	40022000 	.word	0x40022000

08001ec4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8001ec4:	4a03      	ldr	r2, [pc, #12]	; (8001ed4 <HAL_IncTick+0x10>)
 8001ec6:	6811      	ldr	r1, [r2, #0]
 8001ec8:	4b03      	ldr	r3, [pc, #12]	; (8001ed8 <HAL_IncTick+0x14>)
 8001eca:	781b      	ldrb	r3, [r3, #0]
 8001ecc:	440b      	add	r3, r1
 8001ece:	6013      	str	r3, [r2, #0]
}
 8001ed0:	4770      	bx	lr
 8001ed2:	bf00      	nop
 8001ed4:	2000454c 	.word	0x2000454c
 8001ed8:	2000002c 	.word	0x2000002c

08001edc <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001edc:	4b01      	ldr	r3, [pc, #4]	; (8001ee4 <HAL_GetTick+0x8>)
 8001ede:	6818      	ldr	r0, [r3, #0]
}
 8001ee0:	4770      	bx	lr
 8001ee2:	bf00      	nop
 8001ee4:	2000454c 	.word	0x2000454c

08001ee8 <HAL_GetTickPrio>:
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
  return uwTickPrio;
}
 8001ee8:	4b01      	ldr	r3, [pc, #4]	; (8001ef0 <HAL_GetTickPrio+0x8>)
 8001eea:	6818      	ldr	r0, [r3, #0]
 8001eec:	4770      	bx	lr
 8001eee:	bf00      	nop
 8001ef0:	20000030 	.word	0x20000030

08001ef4 <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
 8001ef4:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status  = HAL_OK;
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
 8001ef6:	4b08      	ldr	r3, [pc, #32]	; (8001f18 <HAL_SetTickFreq+0x24>)
 8001ef8:	781c      	ldrb	r4, [r3, #0]
 8001efa:	4284      	cmp	r4, r0
 8001efc:	d101      	bne.n	8001f02 <HAL_SetTickFreq+0xe>
  HAL_StatusTypeDef status  = HAL_OK;
 8001efe:	2000      	movs	r0, #0
      uwTickFreq = prevTickFreq;
    }
  }

  return status;
}
 8001f00:	bd10      	pop	{r4, pc}
    uwTickFreq = Freq;
 8001f02:	7018      	strb	r0, [r3, #0]
    status = HAL_InitTick(uwTickPrio);
 8001f04:	4b05      	ldr	r3, [pc, #20]	; (8001f1c <HAL_SetTickFreq+0x28>)
 8001f06:	6818      	ldr	r0, [r3, #0]
 8001f08:	f7ff feb0 	bl	8001c6c <HAL_InitTick>
    if (status != HAL_OK)
 8001f0c:	2800      	cmp	r0, #0
 8001f0e:	d0f7      	beq.n	8001f00 <HAL_SetTickFreq+0xc>
      uwTickFreq = prevTickFreq;
 8001f10:	4b01      	ldr	r3, [pc, #4]	; (8001f18 <HAL_SetTickFreq+0x24>)
 8001f12:	701c      	strb	r4, [r3, #0]
 8001f14:	e7f4      	b.n	8001f00 <HAL_SetTickFreq+0xc>
 8001f16:	bf00      	nop
 8001f18:	2000002c 	.word	0x2000002c
 8001f1c:	20000030 	.word	0x20000030

08001f20 <HAL_GetTickFreq>:
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
  return uwTickFreq;
}
 8001f20:	4b01      	ldr	r3, [pc, #4]	; (8001f28 <HAL_GetTickFreq+0x8>)
 8001f22:	7818      	ldrb	r0, [r3, #0]
 8001f24:	4770      	bx	lr
 8001f26:	bf00      	nop
 8001f28:	2000002c 	.word	0x2000002c

08001f2c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001f2c:	b538      	push	{r3, r4, r5, lr}
 8001f2e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001f30:	f7ff ffd4 	bl	8001edc <HAL_GetTick>
 8001f34:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001f36:	f1b4 3fff 	cmp.w	r4, #4294967295
 8001f3a:	d002      	beq.n	8001f42 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8001f3c:	4b04      	ldr	r3, [pc, #16]	; (8001f50 <HAL_Delay+0x24>)
 8001f3e:	781b      	ldrb	r3, [r3, #0]
 8001f40:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8001f42:	f7ff ffcb 	bl	8001edc <HAL_GetTick>
 8001f46:	1b40      	subs	r0, r0, r5
 8001f48:	42a0      	cmp	r0, r4
 8001f4a:	d3fa      	bcc.n	8001f42 <HAL_Delay+0x16>
  {
  }
}
 8001f4c:	bd38      	pop	{r3, r4, r5, pc}
 8001f4e:	bf00      	nop
 8001f50:	2000002c 	.word	0x2000002c
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8001f54:	4a02      	ldr	r2, [pc, #8]	; (8001f60 <HAL_Delay+0x34>)
 8001f56:	6813      	ldr	r3, [r2, #0]
 8001f58:	f023 0302 	bic.w	r3, r3, #2
 8001f5c:	6013      	str	r3, [r2, #0]
}
 8001f5e:	4770      	bx	lr
 8001f60:	e000e010 	.word	0xe000e010
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8001f64:	4a02      	ldr	r2, [pc, #8]	; (8001f70 <HAL_Delay+0x44>)
 8001f66:	6813      	ldr	r3, [r2, #0]
 8001f68:	f043 0302 	orr.w	r3, r3, #2
 8001f6c:	6013      	str	r3, [r2, #0]
}
 8001f6e:	4770      	bx	lr
 8001f70:	e000e010 	.word	0xe000e010

08001f74 <HAL_GetHalVersion>:
  * @retval version 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
  return __STM32F1xx_HAL_VERSION;
}
 8001f74:	4800      	ldr	r0, [pc, #0]	; (8001f78 <HAL_GetHalVersion+0x4>)
 8001f76:	4770      	bx	lr
 8001f78:	01010800 	.word	0x01010800

08001f7c <HAL_GetREVID>:
  *       Refer to errata sheet of these devices for more details.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
  return ((DBGMCU->IDCODE) >> DBGMCU_IDCODE_REV_ID_Pos);
 8001f7c:	4b01      	ldr	r3, [pc, #4]	; (8001f84 <HAL_GetREVID+0x8>)
 8001f7e:	6818      	ldr	r0, [r3, #0]
}
 8001f80:	0c00      	lsrs	r0, r0, #16
 8001f82:	4770      	bx	lr
 8001f84:	e0042000 	.word	0xe0042000

08001f88 <HAL_GetDEVID>:
  *       Refer to errata sheet of these devices for more details.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
  return ((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
 8001f88:	4b02      	ldr	r3, [pc, #8]	; (8001f94 <HAL_GetDEVID+0xc>)
 8001f8a:	6818      	ldr	r0, [r3, #0]
}
 8001f8c:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8001f90:	4770      	bx	lr
 8001f92:	bf00      	nop
 8001f94:	e0042000 	.word	0xe0042000

08001f98 <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
   return(READ_REG(*((uint32_t *)UID_BASE)));
}
 8001f98:	4b01      	ldr	r3, [pc, #4]	; (8001fa0 <HAL_GetUIDw0+0x8>)
 8001f9a:	6818      	ldr	r0, [r3, #0]
 8001f9c:	4770      	bx	lr
 8001f9e:	bf00      	nop
 8001fa0:	1ffff7e8 	.word	0x1ffff7e8

08001fa4 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
   return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 8001fa4:	4b01      	ldr	r3, [pc, #4]	; (8001fac <HAL_GetUIDw1+0x8>)
 8001fa6:	6818      	ldr	r0, [r3, #0]
 8001fa8:	4770      	bx	lr
 8001faa:	bf00      	nop
 8001fac:	1ffff7ec 	.word	0x1ffff7ec

08001fb0 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
   return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 8001fb0:	4b01      	ldr	r3, [pc, #4]	; (8001fb8 <HAL_GetUIDw2+0x8>)
 8001fb2:	6818      	ldr	r0, [r3, #0]
 8001fb4:	4770      	bx	lr
 8001fb6:	bf00      	nop
 8001fb8:	1ffff7f0 	.word	0x1ffff7f0

08001fbc <HAL_DBGMCU_EnableDBGSleepMode>:
  * @brief  Enable the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8001fbc:	4a02      	ldr	r2, [pc, #8]	; (8001fc8 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 8001fbe:	6853      	ldr	r3, [r2, #4]
 8001fc0:	f043 0301 	orr.w	r3, r3, #1
 8001fc4:	6053      	str	r3, [r2, #4]
}
 8001fc6:	4770      	bx	lr
 8001fc8:	e0042000 	.word	0xe0042000

08001fcc <HAL_DBGMCU_DisableDBGSleepMode>:
  *       Refer to errata sheet of these devices for more details.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8001fcc:	4a02      	ldr	r2, [pc, #8]	; (8001fd8 <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 8001fce:	6853      	ldr	r3, [r2, #4]
 8001fd0:	f023 0301 	bic.w	r3, r3, #1
 8001fd4:	6053      	str	r3, [r2, #4]
}
 8001fd6:	4770      	bx	lr
 8001fd8:	e0042000 	.word	0xe0042000

08001fdc <HAL_DBGMCU_EnableDBGStopMode>:
  *       Refer to errata sheet of these devices for more details.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8001fdc:	4a02      	ldr	r2, [pc, #8]	; (8001fe8 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 8001fde:	6853      	ldr	r3, [r2, #4]
 8001fe0:	f043 0302 	orr.w	r3, r3, #2
 8001fe4:	6053      	str	r3, [r2, #4]
}
 8001fe6:	4770      	bx	lr
 8001fe8:	e0042000 	.word	0xe0042000

08001fec <HAL_DBGMCU_DisableDBGStopMode>:
  *       Refer to errata sheet of these devices for more details.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8001fec:	4a02      	ldr	r2, [pc, #8]	; (8001ff8 <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 8001fee:	6853      	ldr	r3, [r2, #4]
 8001ff0:	f023 0302 	bic.w	r3, r3, #2
 8001ff4:	6053      	str	r3, [r2, #4]
}
 8001ff6:	4770      	bx	lr
 8001ff8:	e0042000 	.word	0xe0042000

08001ffc <HAL_DBGMCU_EnableDBGStandbyMode>:
  *       Refer to errata sheet of these devices for more details.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8001ffc:	4a02      	ldr	r2, [pc, #8]	; (8002008 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 8001ffe:	6853      	ldr	r3, [r2, #4]
 8002000:	f043 0304 	orr.w	r3, r3, #4
 8002004:	6053      	str	r3, [r2, #4]
}
 8002006:	4770      	bx	lr
 8002008:	e0042000 	.word	0xe0042000

0800200c <HAL_DBGMCU_DisableDBGStandbyMode>:
  *       Refer to errata sheet of these devices for more details.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 800200c:	4a02      	ldr	r2, [pc, #8]	; (8002018 <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 800200e:	6853      	ldr	r3, [r2, #4]
 8002010:	f023 0304 	bic.w	r3, r3, #4
 8002014:	6053      	str	r3, [r2, #4]
}
 8002016:	4770      	bx	lr
 8002018:	e0042000 	.word	0xe0042000
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspInit must be implemented in the user file.
   */ 
}
 800201c:	4770      	bx	lr
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspDeInit must be implemented in the user file.
   */ 
}
 800201e:	4770      	bx	lr

08002020 <HAL_ADC_PollForConversion>:
  * @param  hadc: ADC handle
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8002020:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002022:	b083      	sub	sp, #12
 8002024:	4605      	mov	r5, r0
 8002026:	460c      	mov	r4, r1
  uint32_t tickstart = 0U;
  
  /* Variables for polling in case of scan mode enabled and polling for each  */
  /* conversion.                                                              */
  __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
 8002028:	2300      	movs	r3, #0
 800202a:	9301      	str	r3, [sp, #4]
 
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 800202c:	f7ff ff56 	bl	8001edc <HAL_GetTick>
  
  /* Verification that ADC configuration is compliant with polling for        */
  /* each conversion:                                                         */
  /* Particular case is ADC configured in DMA mode                            */
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
 8002030:	682b      	ldr	r3, [r5, #0]
 8002032:	689a      	ldr	r2, [r3, #8]
 8002034:	f412 7f80 	tst.w	r2, #256	; 0x100
 8002038:	d123      	bne.n	8002082 <HAL_ADC_PollForConversion+0x62>
 800203a:	4607      	mov	r7, r0
  /*    from ADC conversion time (selected sampling time + conversion time of */
  /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
  /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
  /*    As flag EOC is not set after each conversion, no timeout status can   */
  /*    be set.                                                               */
  if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
 800203c:	685a      	ldr	r2, [r3, #4]
 800203e:	f412 7f80 	tst.w	r2, #256	; 0x100
 8002042:	d103      	bne.n	800204c <HAL_ADC_PollForConversion+0x2c>
      HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
 8002044:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
 8002046:	f413 0f70 	tst.w	r3, #15728640	; 0xf00000
 800204a:	d029      	beq.n	80020a0 <HAL_ADC_PollForConversion+0x80>
    /* Replace polling by wait for maximum conversion time */
    /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
    /*    and ADC maximum conversion cycles on all channels.                  */
    /*  - Wait for the expected ADC clock cycles delay                        */
    Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
                                          / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
 800204c:	4b50      	ldr	r3, [pc, #320]	; (8002190 <HAL_ADC_PollForConversion+0x170>)
 800204e:	681e      	ldr	r6, [r3, #0]
 8002050:	2002      	movs	r0, #2
 8002052:	f002 fd89 	bl	8004b68 <HAL_RCCEx_GetPeriphCLKFreq>
 8002056:	fbb6 f0f0 	udiv	r0, r6, r0
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 800205a:	682b      	ldr	r3, [r5, #0]
 800205c:	6919      	ldr	r1, [r3, #16]
 800205e:	4a4d      	ldr	r2, [pc, #308]	; (8002194 <HAL_ADC_PollForConversion+0x174>)
 8002060:	4211      	tst	r1, r2
 8002062:	d136      	bne.n	80020d2 <HAL_ADC_PollForConversion+0xb2>
 8002064:	68d9      	ldr	r1, [r3, #12]
 8002066:	f102 425c 	add.w	r2, r2, #3690987520	; 0xdc000000
 800206a:	4211      	tst	r1, r2
 800206c:	d131      	bne.n	80020d2 <HAL_ADC_PollForConversion+0xb2>
 800206e:	6919      	ldr	r1, [r3, #16]
 8002070:	4a49      	ldr	r2, [pc, #292]	; (8002198 <HAL_ADC_PollForConversion+0x178>)
 8002072:	4211      	tst	r1, r2
 8002074:	d140      	bne.n	80020f8 <HAL_ADC_PollForConversion+0xd8>
 8002076:	68da      	ldr	r2, [r3, #12]
 8002078:	4b48      	ldr	r3, [pc, #288]	; (800219c <HAL_ADC_PollForConversion+0x17c>)
 800207a:	421a      	tst	r2, r3
 800207c:	d03e      	beq.n	80020fc <HAL_ADC_PollForConversion+0xdc>
 800207e:	2629      	movs	r6, #41	; 0x29
 8002080:	e041      	b.n	8002106 <HAL_ADC_PollForConversion+0xe6>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002082:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002084:	f043 0320 	orr.w	r3, r3, #32
 8002088:	62ab      	str	r3, [r5, #40]	; 0x28
    __HAL_UNLOCK(hadc);
 800208a:	2300      	movs	r3, #0
 800208c:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    return HAL_ERROR;
 8002090:	2001      	movs	r0, #1
    }
  }
  
  /* Return ADC state */
  return HAL_OK;
}
 8002092:	b003      	add	sp, #12
 8002094:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
 8002096:	682b      	ldr	r3, [r5, #0]
 8002098:	681b      	ldr	r3, [r3, #0]
 800209a:	f013 0f02 	tst.w	r3, #2
 800209e:	d00f      	beq.n	80020c0 <HAL_ADC_PollForConversion+0xa0>
    while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
 80020a0:	682b      	ldr	r3, [r5, #0]
 80020a2:	681b      	ldr	r3, [r3, #0]
 80020a4:	f013 0f02 	tst.w	r3, #2
 80020a8:	d14f      	bne.n	800214a <HAL_ADC_PollForConversion+0x12a>
      if(Timeout != HAL_MAX_DELAY)
 80020aa:	f1b4 3fff 	cmp.w	r4, #4294967295
 80020ae:	d0f7      	beq.n	80020a0 <HAL_ADC_PollForConversion+0x80>
        if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
 80020b0:	2c00      	cmp	r4, #0
 80020b2:	d0f0      	beq.n	8002096 <HAL_ADC_PollForConversion+0x76>
 80020b4:	f7ff ff12 	bl	8001edc <HAL_GetTick>
 80020b8:	1bc3      	subs	r3, r0, r7
 80020ba:	42a3      	cmp	r3, r4
 80020bc:	d9f0      	bls.n	80020a0 <HAL_ADC_PollForConversion+0x80>
 80020be:	e7ea      	b.n	8002096 <HAL_ADC_PollForConversion+0x76>
            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80020c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80020c2:	f043 0304 	orr.w	r3, r3, #4
 80020c6:	62ab      	str	r3, [r5, #40]	; 0x28
            __HAL_UNLOCK(hadc);
 80020c8:	2300      	movs	r3, #0
 80020ca:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
            return HAL_TIMEOUT;
 80020ce:	2003      	movs	r0, #3
 80020d0:	e7df      	b.n	8002092 <HAL_ADC_PollForConversion+0x72>
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 80020d2:	6919      	ldr	r1, [r3, #16]
 80020d4:	4a30      	ldr	r2, [pc, #192]	; (8002198 <HAL_ADC_PollForConversion+0x178>)
 80020d6:	4211      	tst	r1, r2
 80020d8:	d104      	bne.n	80020e4 <HAL_ADC_PollForConversion+0xc4>
 80020da:	68d9      	ldr	r1, [r3, #12]
 80020dc:	f102 426e 	add.w	r2, r2, #3992977408	; 0xee000000
 80020e0:	4211      	tst	r1, r2
 80020e2:	d00d      	beq.n	8002100 <HAL_ADC_PollForConversion+0xe0>
 80020e4:	6919      	ldr	r1, [r3, #16]
 80020e6:	4a2e      	ldr	r2, [pc, #184]	; (80021a0 <HAL_ADC_PollForConversion+0x180>)
 80020e8:	400a      	ands	r2, r1
 80020ea:	b95a      	cbnz	r2, 8002104 <HAL_ADC_PollForConversion+0xe4>
 80020ec:	68da      	ldr	r2, [r3, #12]
 80020ee:	4b2c      	ldr	r3, [pc, #176]	; (80021a0 <HAL_ADC_PollForConversion+0x180>)
 80020f0:	4013      	ands	r3, r2
 80020f2:	b15b      	cbz	r3, 800210c <HAL_ADC_PollForConversion+0xec>
 80020f4:	26fc      	movs	r6, #252	; 0xfc
 80020f6:	e006      	b.n	8002106 <HAL_ADC_PollForConversion+0xe6>
 80020f8:	2629      	movs	r6, #41	; 0x29
 80020fa:	e004      	b.n	8002106 <HAL_ADC_PollForConversion+0xe6>
 80020fc:	2614      	movs	r6, #20
 80020fe:	e002      	b.n	8002106 <HAL_ADC_PollForConversion+0xe6>
 8002100:	2654      	movs	r6, #84	; 0x54
 8002102:	e000      	b.n	8002106 <HAL_ADC_PollForConversion+0xe6>
 8002104:	26fc      	movs	r6, #252	; 0xfc
    Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
 8002106:	fb06 f600 	mul.w	r6, r6, r0
    while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 800210a:	e007      	b.n	800211c <HAL_ADC_PollForConversion+0xfc>
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 800210c:	2654      	movs	r6, #84	; 0x54
 800210e:	e7fa      	b.n	8002106 <HAL_ADC_PollForConversion+0xe6>
          if(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 8002110:	9b01      	ldr	r3, [sp, #4]
 8002112:	42b3      	cmp	r3, r6
 8002114:	d310      	bcc.n	8002138 <HAL_ADC_PollForConversion+0x118>
      Conversion_Timeout_CPU_cycles ++;
 8002116:	9b01      	ldr	r3, [sp, #4]
 8002118:	3301      	adds	r3, #1
 800211a:	9301      	str	r3, [sp, #4]
    while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	42b3      	cmp	r3, r6
 8002120:	d213      	bcs.n	800214a <HAL_ADC_PollForConversion+0x12a>
      if(Timeout != HAL_MAX_DELAY)
 8002122:	f1b4 3fff 	cmp.w	r4, #4294967295
 8002126:	d0f6      	beq.n	8002116 <HAL_ADC_PollForConversion+0xf6>
        if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
 8002128:	2c00      	cmp	r4, #0
 800212a:	d0f1      	beq.n	8002110 <HAL_ADC_PollForConversion+0xf0>
 800212c:	f7ff fed6 	bl	8001edc <HAL_GetTick>
 8002130:	1bc0      	subs	r0, r0, r7
 8002132:	42a0      	cmp	r0, r4
 8002134:	d9ef      	bls.n	8002116 <HAL_ADC_PollForConversion+0xf6>
 8002136:	e7eb      	b.n	8002110 <HAL_ADC_PollForConversion+0xf0>
            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8002138:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800213a:	f043 0304 	orr.w	r3, r3, #4
 800213e:	62ab      	str	r3, [r5, #40]	; 0x28
            __HAL_UNLOCK(hadc);
 8002140:	2300      	movs	r3, #0
 8002142:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
            return HAL_TIMEOUT;
 8002146:	2003      	movs	r0, #3
 8002148:	e7a3      	b.n	8002092 <HAL_ADC_PollForConversion+0x72>
  __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 800214a:	682b      	ldr	r3, [r5, #0]
 800214c:	f06f 0212 	mvn.w	r2, #18
 8002150:	601a      	str	r2, [r3, #0]
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8002152:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002154:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002158:	62ab      	str	r3, [r5, #40]	; 0x28
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 800215a:	682b      	ldr	r3, [r5, #0]
 800215c:	689b      	ldr	r3, [r3, #8]
 800215e:	f403 2360 	and.w	r3, r3, #917504	; 0xe0000
 8002162:	f5b3 2f60 	cmp.w	r3, #917504	; 0xe0000
 8002166:	d001      	beq.n	800216c <HAL_ADC_PollForConversion+0x14c>
  return HAL_OK;
 8002168:	2000      	movs	r0, #0
 800216a:	e792      	b.n	8002092 <HAL_ADC_PollForConversion+0x72>
     (hadc->Init.ContinuousConvMode == DISABLE)   )
 800216c:	7b28      	ldrb	r0, [r5, #12]
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 800216e:	b960      	cbnz	r0, 800218a <HAL_ADC_PollForConversion+0x16a>
    CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 8002170:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002172:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002176:	62ab      	str	r3, [r5, #40]	; 0x28
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8002178:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800217a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800217e:	d188      	bne.n	8002092 <HAL_ADC_PollForConversion+0x72>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8002180:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002182:	f043 0301 	orr.w	r3, r3, #1
 8002186:	62ab      	str	r3, [r5, #40]	; 0x28
 8002188:	e783      	b.n	8002092 <HAL_ADC_PollForConversion+0x72>
  return HAL_OK;
 800218a:	2000      	movs	r0, #0
 800218c:	e781      	b.n	8002092 <HAL_ADC_PollForConversion+0x72>
 800218e:	bf00      	nop
 8002190:	20000028 	.word	0x20000028
 8002194:	24924924 	.word	0x24924924
 8002198:	12492492 	.word	0x12492492
 800219c:	00492492 	.word	0x00492492
 80021a0:	00249249 	.word	0x00249249

080021a4 <HAL_ADC_PollForEvent>:
  *            @arg ADC_AWD_EVENT: ADC Analog watchdog event.
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
{
 80021a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80021a8:	4605      	mov	r5, r0
 80021aa:	460e      	mov	r6, r1
 80021ac:	4617      	mov	r7, r2
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_EVENT_TYPE(EventType));
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 80021ae:	f7ff fe95 	bl	8001edc <HAL_GetTick>
 80021b2:	4680      	mov	r8, r0
  
  /* Check selected event flag */
  while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
 80021b4:	682b      	ldr	r3, [r5, #0]
 80021b6:	681c      	ldr	r4, [r3, #0]
 80021b8:	ea36 0204 	bics.w	r2, r6, r4
 80021bc:	d018      	beq.n	80021f0 <HAL_ADC_PollForEvent+0x4c>
  {
    /* Check if timeout is disabled (set to infinite wait) */
    if(Timeout != HAL_MAX_DELAY)
 80021be:	f1b7 3fff 	cmp.w	r7, #4294967295
 80021c2:	d0f7      	beq.n	80021b4 <HAL_ADC_PollForEvent+0x10>
    {
      if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
 80021c4:	b96f      	cbnz	r7, 80021e2 <HAL_ADC_PollForEvent+0x3e>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
 80021c6:	682b      	ldr	r3, [r5, #0]
 80021c8:	681b      	ldr	r3, [r3, #0]
 80021ca:	ea36 0303 	bics.w	r3, r6, r3
 80021ce:	d0f1      	beq.n	80021b4 <HAL_ADC_PollForEvent+0x10>
        {
          /* Update ADC state machine to timeout */
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80021d0:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80021d2:	f043 0304 	orr.w	r3, r3, #4
 80021d6:	62ab      	str	r3, [r5, #40]	; 0x28

          /* Process unlocked */
          __HAL_UNLOCK(hadc);
 80021d8:	2300      	movs	r3, #0
 80021da:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24

          return HAL_TIMEOUT;
 80021de:	2003      	movs	r0, #3
 80021e0:	e00e      	b.n	8002200 <HAL_ADC_PollForEvent+0x5c>
      if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
 80021e2:	f7ff fe7b 	bl	8001edc <HAL_GetTick>
 80021e6:	eba0 0008 	sub.w	r0, r0, r8
 80021ea:	42b8      	cmp	r0, r7
 80021ec:	d9e2      	bls.n	80021b4 <HAL_ADC_PollForEvent+0x10>
 80021ee:	e7ea      	b.n	80021c6 <HAL_ADC_PollForEvent+0x22>
    }
  }
  
  /* Analog watchdog (level out of window) event */
  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 80021f0:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80021f2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80021f6:	62aa      	str	r2, [r5, #40]	; 0x28
    
  /* Clear ADC analog watchdog flag */
  __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 80021f8:	f06f 0201 	mvn.w	r2, #1
 80021fc:	601a      	str	r2, [r3, #0]
  
  /* Return ADC state */
  return HAL_OK;
 80021fe:	2000      	movs	r0, #0
}
 8002200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002204 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 8002204:	6803      	ldr	r3, [r0, #0]
 8002206:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
}
 8002208:	4770      	bx	lr
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ConvCpltCallback must be implemented in the user file.
   */
}
 800220a:	4770      	bx	lr

0800220c <ADC_DMAConvCplt>:
  * @brief  DMA transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
{
 800220c:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800220e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 
  /* Update state machine on conversion status if not in error state */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 8002210:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002212:	f012 0f50 	tst.w	r2, #80	; 0x50
 8002216:	d11e      	bne.n	8002256 <ADC_DMAConvCplt+0x4a>
  {
    /* Update ADC state machine */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8002218:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800221a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800221e:	629a      	str	r2, [r3, #40]	; 0x28
    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going.        */
    /* Note: On STM32F1 devices, in case of sequencer enabled                 */
    /*       (several ranks selected), end of conversion flag is raised       */
    /*       at the end of the sequence.                                      */
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8002220:	681a      	ldr	r2, [r3, #0]
 8002222:	6892      	ldr	r2, [r2, #8]
 8002224:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 8002228:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 800222c:	d003      	beq.n	8002236 <ADC_DMAConvCplt+0x2a>
    
    /* Conversion complete callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 800222e:	4618      	mov	r0, r3
 8002230:	f7fe f98e 	bl	8000550 <HAL_ADC_ConvCpltCallback>
  else
  {
    /* Call DMA error callback */
    hadc->DMA_Handle->XferErrorCallback(hdma);
  }
}
 8002234:	bd08      	pop	{r3, pc}
       (hadc->Init.ContinuousConvMode == DISABLE)   )
 8002236:	7b1a      	ldrb	r2, [r3, #12]
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8002238:	2a00      	cmp	r2, #0
 800223a:	d1f8      	bne.n	800222e <ADC_DMAConvCplt+0x22>
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 800223c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800223e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8002242:	629a      	str	r2, [r3, #40]	; 0x28
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8002244:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002246:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 800224a:	d1f0      	bne.n	800222e <ADC_DMAConvCplt+0x22>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 800224c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800224e:	f042 0201 	orr.w	r2, r2, #1
 8002252:	629a      	str	r2, [r3, #40]	; 0x28
 8002254:	e7eb      	b.n	800222e <ADC_DMAConvCplt+0x22>
    hadc->DMA_Handle->XferErrorCallback(hdma);
 8002256:	6a1b      	ldr	r3, [r3, #32]
 8002258:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800225a:	4798      	blx	r3
}
 800225c:	e7ea      	b.n	8002234 <ADC_DMAConvCplt+0x28>

0800225e <HAL_ADC_ConvHalfCpltCallback>:
}
 800225e:	4770      	bx	lr

08002260 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 8002260:	b508      	push	{r3, lr}
  
  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8002262:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8002264:	f7ff fffb 	bl	800225e <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8002268:	bd08      	pop	{r3, pc}

0800226a <HAL_ADC_LevelOutOfWindowCallback>:
}
 800226a:	4770      	bx	lr

0800226c <HAL_ADC_IRQHandler>:
{
 800226c:	b510      	push	{r4, lr}
 800226e:	4604      	mov	r4, r0
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
 8002270:	6803      	ldr	r3, [r0, #0]
 8002272:	685a      	ldr	r2, [r3, #4]
 8002274:	f012 0f20 	tst.w	r2, #32
 8002278:	d018      	beq.n	80022ac <HAL_ADC_IRQHandler+0x40>
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
 800227a:	681a      	ldr	r2, [r3, #0]
 800227c:	f012 0f02 	tst.w	r2, #2
 8002280:	d014      	beq.n	80022ac <HAL_ADC_IRQHandler+0x40>
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8002282:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8002284:	f012 0f10 	tst.w	r2, #16
 8002288:	d103      	bne.n	8002292 <HAL_ADC_IRQHandler+0x26>
        SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 800228a:	6a82      	ldr	r2, [r0, #40]	; 0x28
 800228c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002290:	6282      	str	r2, [r0, #40]	; 0x28
      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8002292:	689a      	ldr	r2, [r3, #8]
 8002294:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 8002298:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 800229c:	d038      	beq.n	8002310 <HAL_ADC_IRQHandler+0xa4>
      HAL_ADC_ConvCpltCallback(hadc);
 800229e:	4620      	mov	r0, r4
 80022a0:	f7fe f956 	bl	8000550 <HAL_ADC_ConvCpltCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 80022a4:	6823      	ldr	r3, [r4, #0]
 80022a6:	f06f 0212 	mvn.w	r2, #18
 80022aa:	601a      	str	r2, [r3, #0]
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
 80022ac:	6823      	ldr	r3, [r4, #0]
 80022ae:	685a      	ldr	r2, [r3, #4]
 80022b0:	f012 0f80 	tst.w	r2, #128	; 0x80
 80022b4:	d022      	beq.n	80022fc <HAL_ADC_IRQHandler+0x90>
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
 80022b6:	681a      	ldr	r2, [r3, #0]
 80022b8:	f012 0f04 	tst.w	r2, #4
 80022bc:	d01e      	beq.n	80022fc <HAL_ADC_IRQHandler+0x90>
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80022be:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80022c0:	f012 0f10 	tst.w	r2, #16
 80022c4:	d103      	bne.n	80022ce <HAL_ADC_IRQHandler+0x62>
        SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80022c6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80022c8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80022cc:	62a2      	str	r2, [r4, #40]	; 0x28
      if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
 80022ce:	689a      	ldr	r2, [r3, #8]
 80022d0:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
 80022d4:	f5b2 4fe0 	cmp.w	r2, #28672	; 0x7000
 80022d8:	d031      	beq.n	800233e <HAL_ADC_IRQHandler+0xd2>
         (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
 80022da:	685a      	ldr	r2, [r3, #4]
      if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
 80022dc:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80022e0:	d105      	bne.n	80022ee <HAL_ADC_IRQHandler+0x82>
         (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
 80022e2:	689a      	ldr	r2, [r3, #8]
 80022e4:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
         (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
 80022e8:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 80022ec:	d024      	beq.n	8002338 <HAL_ADC_IRQHandler+0xcc>
      HAL_ADCEx_InjectedConvCpltCallback(hadc);
 80022ee:	4620      	mov	r0, r4
 80022f0:	f000 ffb6 	bl	8003260 <HAL_ADCEx_InjectedConvCpltCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
 80022f4:	6823      	ldr	r3, [r4, #0]
 80022f6:	f06f 020c 	mvn.w	r2, #12
 80022fa:	601a      	str	r2, [r3, #0]
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
 80022fc:	6823      	ldr	r3, [r4, #0]
 80022fe:	685a      	ldr	r2, [r3, #4]
 8002300:	f012 0f40 	tst.w	r2, #64	; 0x40
 8002304:	d003      	beq.n	800230e <HAL_ADC_IRQHandler+0xa2>
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
 8002306:	681b      	ldr	r3, [r3, #0]
 8002308:	f013 0f01 	tst.w	r3, #1
 800230c:	d128      	bne.n	8002360 <HAL_ADC_IRQHandler+0xf4>
}
 800230e:	bd10      	pop	{r4, pc}
         (hadc->Init.ContinuousConvMode == DISABLE)   )
 8002310:	7b22      	ldrb	r2, [r4, #12]
      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8002312:	2a00      	cmp	r2, #0
 8002314:	d1c3      	bne.n	800229e <HAL_ADC_IRQHandler+0x32>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8002316:	685a      	ldr	r2, [r3, #4]
 8002318:	f022 0220 	bic.w	r2, r2, #32
 800231c:	605a      	str	r2, [r3, #4]
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 800231e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002320:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002324:	62a3      	str	r3, [r4, #40]	; 0x28
        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8002326:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002328:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800232c:	d1b7      	bne.n	800229e <HAL_ADC_IRQHandler+0x32>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 800232e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002330:	f043 0301 	orr.w	r3, r3, #1
 8002334:	62a3      	str	r3, [r4, #40]	; 0x28
 8002336:	e7b2      	b.n	800229e <HAL_ADC_IRQHandler+0x32>
          (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
 8002338:	7b22      	ldrb	r2, [r4, #12]
         (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
 800233a:	2a00      	cmp	r2, #0
 800233c:	d1d7      	bne.n	80022ee <HAL_ADC_IRQHandler+0x82>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 800233e:	685a      	ldr	r2, [r3, #4]
 8002340:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002344:	605a      	str	r2, [r3, #4]
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
 8002346:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002348:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800234c:	62a3      	str	r3, [r4, #40]	; 0x28
        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 800234e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002350:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002354:	d1cb      	bne.n	80022ee <HAL_ADC_IRQHandler+0x82>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8002356:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002358:	f043 0301 	orr.w	r3, r3, #1
 800235c:	62a3      	str	r3, [r4, #40]	; 0x28
 800235e:	e7c6      	b.n	80022ee <HAL_ADC_IRQHandler+0x82>
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8002360:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002362:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002366:	62a3      	str	r3, [r4, #40]	; 0x28
      HAL_ADC_LevelOutOfWindowCallback(hadc);
 8002368:	4620      	mov	r0, r4
 800236a:	f7ff ff7e 	bl	800226a <HAL_ADC_LevelOutOfWindowCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 800236e:	6823      	ldr	r3, [r4, #0]
 8002370:	f06f 0201 	mvn.w	r2, #1
 8002374:	601a      	str	r2, [r3, #0]
}
 8002376:	e7ca      	b.n	800230e <HAL_ADC_IRQHandler+0xa2>

08002378 <HAL_ADC_ErrorCallback>:
}
 8002378:	4770      	bx	lr

0800237a <ADC_DMAError>:
  * @brief  DMA error callback 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)   
{
 800237a:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800237c:	6a40      	ldr	r0, [r0, #36]	; 0x24
  
  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 800237e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002380:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002384:	6283      	str	r3, [r0, #40]	; 0x28
  
  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 8002386:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002388:	f043 0304 	orr.w	r3, r3, #4
 800238c:	62c3      	str	r3, [r0, #44]	; 0x2c
  
  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 800238e:	f7ff fff3 	bl	8002378 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8002392:	bd08      	pop	{r3, pc}

08002394 <HAL_ADC_ConfigChannel>:
{ 
 8002394:	b430      	push	{r4, r5}
 8002396:	b082      	sub	sp, #8
  __IO uint32_t wait_loop_index = 0U;
 8002398:	2200      	movs	r2, #0
 800239a:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 800239c:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 80023a0:	2a01      	cmp	r2, #1
 80023a2:	f000 808b 	beq.w	80024bc <HAL_ADC_ConfigChannel+0x128>
 80023a6:	4603      	mov	r3, r0
 80023a8:	2201      	movs	r2, #1
 80023aa:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
  if (sConfig->Rank < 7U)
 80023ae:	684a      	ldr	r2, [r1, #4]
 80023b0:	2a06      	cmp	r2, #6
 80023b2:	d829      	bhi.n	8002408 <HAL_ADC_ConfigChannel+0x74>
    MODIFY_REG(hadc->Instance->SQR3                        ,
 80023b4:	6805      	ldr	r5, [r0, #0]
 80023b6:	6b68      	ldr	r0, [r5, #52]	; 0x34
 80023b8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80023bc:	3a05      	subs	r2, #5
 80023be:	241f      	movs	r4, #31
 80023c0:	4094      	lsls	r4, r2
 80023c2:	ea20 0004 	bic.w	r0, r0, r4
 80023c6:	680c      	ldr	r4, [r1, #0]
 80023c8:	fa04 f202 	lsl.w	r2, r4, r2
 80023cc:	4302      	orrs	r2, r0
 80023ce:	636a      	str	r2, [r5, #52]	; 0x34
  if (sConfig->Channel >= ADC_CHANNEL_10)
 80023d0:	680a      	ldr	r2, [r1, #0]
 80023d2:	2a09      	cmp	r2, #9
 80023d4:	d938      	bls.n	8002448 <HAL_ADC_ConfigChannel+0xb4>
    MODIFY_REG(hadc->Instance->SMPR1                             ,
 80023d6:	681d      	ldr	r5, [r3, #0]
 80023d8:	68e8      	ldr	r0, [r5, #12]
 80023da:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80023de:	3a1e      	subs	r2, #30
 80023e0:	2407      	movs	r4, #7
 80023e2:	4094      	lsls	r4, r2
 80023e4:	ea20 0004 	bic.w	r0, r0, r4
 80023e8:	688c      	ldr	r4, [r1, #8]
 80023ea:	fa04 f202 	lsl.w	r2, r4, r2
 80023ee:	4302      	orrs	r2, r0
 80023f0:	60ea      	str	r2, [r5, #12]
  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
 80023f2:	680a      	ldr	r2, [r1, #0]
 80023f4:	3a10      	subs	r2, #16
 80023f6:	2a01      	cmp	r2, #1
 80023f8:	d934      	bls.n	8002464 <HAL_ADC_ConfigChannel+0xd0>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80023fa:	2000      	movs	r0, #0
  __HAL_UNLOCK(hadc);
 80023fc:	2200      	movs	r2, #0
 80023fe:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
}
 8002402:	b002      	add	sp, #8
 8002404:	bc30      	pop	{r4, r5}
 8002406:	4770      	bx	lr
  else if (sConfig->Rank < 13U)
 8002408:	2a0c      	cmp	r2, #12
 800240a:	d80e      	bhi.n	800242a <HAL_ADC_ConfigChannel+0x96>
    MODIFY_REG(hadc->Instance->SQR2                        ,
 800240c:	6805      	ldr	r5, [r0, #0]
 800240e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8002410:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8002414:	3a23      	subs	r2, #35	; 0x23
 8002416:	241f      	movs	r4, #31
 8002418:	4094      	lsls	r4, r2
 800241a:	ea20 0004 	bic.w	r0, r0, r4
 800241e:	680c      	ldr	r4, [r1, #0]
 8002420:	fa04 f202 	lsl.w	r2, r4, r2
 8002424:	4302      	orrs	r2, r0
 8002426:	632a      	str	r2, [r5, #48]	; 0x30
 8002428:	e7d2      	b.n	80023d0 <HAL_ADC_ConfigChannel+0x3c>
    MODIFY_REG(hadc->Instance->SQR1                        ,
 800242a:	6805      	ldr	r5, [r0, #0]
 800242c:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800242e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8002432:	3a41      	subs	r2, #65	; 0x41
 8002434:	241f      	movs	r4, #31
 8002436:	4094      	lsls	r4, r2
 8002438:	ea20 0004 	bic.w	r0, r0, r4
 800243c:	680c      	ldr	r4, [r1, #0]
 800243e:	fa04 f202 	lsl.w	r2, r4, r2
 8002442:	4302      	orrs	r2, r0
 8002444:	62ea      	str	r2, [r5, #44]	; 0x2c
 8002446:	e7c3      	b.n	80023d0 <HAL_ADC_ConfigChannel+0x3c>
    MODIFY_REG(hadc->Instance->SMPR2                             ,
 8002448:	681d      	ldr	r5, [r3, #0]
 800244a:	6928      	ldr	r0, [r5, #16]
 800244c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8002450:	2407      	movs	r4, #7
 8002452:	4094      	lsls	r4, r2
 8002454:	ea20 0004 	bic.w	r0, r0, r4
 8002458:	688c      	ldr	r4, [r1, #8]
 800245a:	fa04 f202 	lsl.w	r2, r4, r2
 800245e:	4302      	orrs	r2, r0
 8002460:	612a      	str	r2, [r5, #16]
 8002462:	e7c6      	b.n	80023f2 <HAL_ADC_ConfigChannel+0x5e>
    if (hadc->Instance == ADC1)
 8002464:	681a      	ldr	r2, [r3, #0]
 8002466:	4816      	ldr	r0, [pc, #88]	; (80024c0 <HAL_ADC_ConfigChannel+0x12c>)
 8002468:	4282      	cmp	r2, r0
 800246a:	d005      	beq.n	8002478 <HAL_ADC_ConfigChannel+0xe4>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800246c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800246e:	f042 0220 	orr.w	r2, r2, #32
 8002472:	629a      	str	r2, [r3, #40]	; 0x28
      tmp_hal_status = HAL_ERROR;
 8002474:	2001      	movs	r0, #1
 8002476:	e7c1      	b.n	80023fc <HAL_ADC_ConfigChannel+0x68>
      if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
 8002478:	6890      	ldr	r0, [r2, #8]
 800247a:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 800247e:	d11b      	bne.n	80024b8 <HAL_ADC_ConfigChannel+0x124>
        SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 8002480:	6890      	ldr	r0, [r2, #8]
 8002482:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8002486:	6090      	str	r0, [r2, #8]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8002488:	680a      	ldr	r2, [r1, #0]
 800248a:	2a10      	cmp	r2, #16
 800248c:	d001      	beq.n	8002492 <HAL_ADC_ConfigChannel+0xfe>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800248e:	2000      	movs	r0, #0
 8002490:	e7b4      	b.n	80023fc <HAL_ADC_ConfigChannel+0x68>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8002492:	4a0c      	ldr	r2, [pc, #48]	; (80024c4 <HAL_ADC_ConfigChannel+0x130>)
 8002494:	6812      	ldr	r2, [r2, #0]
 8002496:	490c      	ldr	r1, [pc, #48]	; (80024c8 <HAL_ADC_ConfigChannel+0x134>)
 8002498:	fba1 1202 	umull	r1, r2, r1, r2
 800249c:	0c92      	lsrs	r2, r2, #18
 800249e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80024a2:	0052      	lsls	r2, r2, #1
 80024a4:	9201      	str	r2, [sp, #4]
          while(wait_loop_index != 0U)
 80024a6:	e002      	b.n	80024ae <HAL_ADC_ConfigChannel+0x11a>
            wait_loop_index--;
 80024a8:	9a01      	ldr	r2, [sp, #4]
 80024aa:	3a01      	subs	r2, #1
 80024ac:	9201      	str	r2, [sp, #4]
          while(wait_loop_index != 0U)
 80024ae:	9a01      	ldr	r2, [sp, #4]
 80024b0:	2a00      	cmp	r2, #0
 80024b2:	d1f9      	bne.n	80024a8 <HAL_ADC_ConfigChannel+0x114>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80024b4:	2000      	movs	r0, #0
 80024b6:	e7a1      	b.n	80023fc <HAL_ADC_ConfigChannel+0x68>
 80024b8:	2000      	movs	r0, #0
 80024ba:	e79f      	b.n	80023fc <HAL_ADC_ConfigChannel+0x68>
  __HAL_LOCK(hadc);
 80024bc:	2002      	movs	r0, #2
 80024be:	e7a0      	b.n	8002402 <HAL_ADC_ConfigChannel+0x6e>
 80024c0:	40012400 	.word	0x40012400
 80024c4:	20000028 	.word	0x20000028
 80024c8:	431bde83 	.word	0x431bde83

080024cc <HAL_ADC_AnalogWDGConfig>:
  __HAL_LOCK(hadc);
 80024cc:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80024d0:	2b01      	cmp	r3, #1
 80024d2:	d026      	beq.n	8002522 <HAL_ADC_AnalogWDGConfig+0x56>
{
 80024d4:	b430      	push	{r4, r5}
  __HAL_LOCK(hadc);
 80024d6:	2301      	movs	r3, #1
 80024d8:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  if(AnalogWDGConfig->ITMode == ENABLE)
 80024dc:	7a0b      	ldrb	r3, [r1, #8]
 80024de:	2b01      	cmp	r3, #1
 80024e0:	d019      	beq.n	8002516 <HAL_ADC_AnalogWDGConfig+0x4a>
    __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
 80024e2:	6802      	ldr	r2, [r0, #0]
 80024e4:	6853      	ldr	r3, [r2, #4]
 80024e6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80024ea:	6053      	str	r3, [r2, #4]
  MODIFY_REG(hadc->Instance->CR1            ,
 80024ec:	6804      	ldr	r4, [r0, #0]
 80024ee:	6862      	ldr	r2, [r4, #4]
 80024f0:	4b0d      	ldr	r3, [pc, #52]	; (8002528 <HAL_ADC_AnalogWDGConfig+0x5c>)
 80024f2:	4013      	ands	r3, r2
 80024f4:	680a      	ldr	r2, [r1, #0]
 80024f6:	684d      	ldr	r5, [r1, #4]
 80024f8:	432a      	orrs	r2, r5
 80024fa:	4313      	orrs	r3, r2
 80024fc:	6063      	str	r3, [r4, #4]
  WRITE_REG(hadc->Instance->HTR, AnalogWDGConfig->HighThreshold);
 80024fe:	6803      	ldr	r3, [r0, #0]
 8002500:	68ca      	ldr	r2, [r1, #12]
 8002502:	625a      	str	r2, [r3, #36]	; 0x24
  WRITE_REG(hadc->Instance->LTR, AnalogWDGConfig->LowThreshold);
 8002504:	6803      	ldr	r3, [r0, #0]
 8002506:	690a      	ldr	r2, [r1, #16]
 8002508:	629a      	str	r2, [r3, #40]	; 0x28
  __HAL_UNLOCK(hadc);
 800250a:	2300      	movs	r3, #0
 800250c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 8002510:	4618      	mov	r0, r3
}
 8002512:	bc30      	pop	{r4, r5}
 8002514:	4770      	bx	lr
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
 8002516:	6802      	ldr	r2, [r0, #0]
 8002518:	6853      	ldr	r3, [r2, #4]
 800251a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800251e:	6053      	str	r3, [r2, #4]
 8002520:	e7e4      	b.n	80024ec <HAL_ADC_AnalogWDGConfig+0x20>
  __HAL_LOCK(hadc);
 8002522:	2002      	movs	r0, #2
}
 8002524:	4770      	bx	lr
 8002526:	bf00      	nop
 8002528:	ff3ffde0 	.word	0xff3ffde0

0800252c <HAL_ADC_GetState>:
  return hadc->State;
 800252c:	6a80      	ldr	r0, [r0, #40]	; 0x28
}
 800252e:	4770      	bx	lr

08002530 <HAL_ADC_GetError>:
  return hadc->ErrorCode;
 8002530:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
 8002532:	4770      	bx	lr

08002534 <ADC_Enable>:
{
 8002534:	b530      	push	{r4, r5, lr}
 8002536:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0U;
 8002538:	2300      	movs	r3, #0
 800253a:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 800253c:	6803      	ldr	r3, [r0, #0]
 800253e:	689a      	ldr	r2, [r3, #8]
 8002540:	f012 0f01 	tst.w	r2, #1
 8002544:	d132      	bne.n	80025ac <ADC_Enable+0x78>
 8002546:	4604      	mov	r4, r0
    __HAL_ADC_ENABLE(hadc);
 8002548:	689a      	ldr	r2, [r3, #8]
 800254a:	f042 0201 	orr.w	r2, r2, #1
 800254e:	609a      	str	r2, [r3, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 8002550:	4b18      	ldr	r3, [pc, #96]	; (80025b4 <ADC_Enable+0x80>)
 8002552:	681b      	ldr	r3, [r3, #0]
 8002554:	4a18      	ldr	r2, [pc, #96]	; (80025b8 <ADC_Enable+0x84>)
 8002556:	fba2 2303 	umull	r2, r3, r2, r3
 800255a:	0c9b      	lsrs	r3, r3, #18
 800255c:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0U)
 800255e:	9b01      	ldr	r3, [sp, #4]
 8002560:	b11b      	cbz	r3, 800256a <ADC_Enable+0x36>
      wait_loop_index--;
 8002562:	9b01      	ldr	r3, [sp, #4]
 8002564:	3b01      	subs	r3, #1
 8002566:	9301      	str	r3, [sp, #4]
 8002568:	e7f9      	b.n	800255e <ADC_Enable+0x2a>
    tickstart = HAL_GetTick();
 800256a:	f7ff fcb7 	bl	8001edc <HAL_GetTick>
 800256e:	4605      	mov	r5, r0
    while(ADC_IS_ENABLE(hadc) == RESET)
 8002570:	6823      	ldr	r3, [r4, #0]
 8002572:	689b      	ldr	r3, [r3, #8]
 8002574:	f013 0f01 	tst.w	r3, #1
 8002578:	d116      	bne.n	80025a8 <ADC_Enable+0x74>
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 800257a:	f7ff fcaf 	bl	8001edc <HAL_GetTick>
 800257e:	1b43      	subs	r3, r0, r5
 8002580:	2b02      	cmp	r3, #2
 8002582:	d9f5      	bls.n	8002570 <ADC_Enable+0x3c>
        if(ADC_IS_ENABLE(hadc) == RESET)
 8002584:	6823      	ldr	r3, [r4, #0]
 8002586:	689b      	ldr	r3, [r3, #8]
 8002588:	f013 0f01 	tst.w	r3, #1
 800258c:	d1f0      	bne.n	8002570 <ADC_Enable+0x3c>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800258e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002590:	f043 0310 	orr.w	r3, r3, #16
 8002594:	62a3      	str	r3, [r4, #40]	; 0x28
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002596:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002598:	f043 0301 	orr.w	r3, r3, #1
 800259c:	62e3      	str	r3, [r4, #44]	; 0x2c
          __HAL_UNLOCK(hadc);
 800259e:	2300      	movs	r3, #0
 80025a0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
          return HAL_ERROR;
 80025a4:	2001      	movs	r0, #1
 80025a6:	e002      	b.n	80025ae <ADC_Enable+0x7a>
  return HAL_OK;
 80025a8:	2000      	movs	r0, #0
 80025aa:	e000      	b.n	80025ae <ADC_Enable+0x7a>
 80025ac:	2000      	movs	r0, #0
}
 80025ae:	b003      	add	sp, #12
 80025b0:	bd30      	pop	{r4, r5, pc}
 80025b2:	bf00      	nop
 80025b4:	20000028 	.word	0x20000028
 80025b8:	431bde83 	.word	0x431bde83

080025bc <HAL_ADC_Start>:
  __HAL_LOCK(hadc);
 80025bc:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80025c0:	2b01      	cmp	r3, #1
 80025c2:	d068      	beq.n	8002696 <HAL_ADC_Start+0xda>
{
 80025c4:	b510      	push	{r4, lr}
 80025c6:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 80025c8:	2301      	movs	r3, #1
 80025ca:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  tmp_hal_status = ADC_Enable(hadc);
 80025ce:	f7ff ffb1 	bl	8002534 <ADC_Enable>
  if (tmp_hal_status == HAL_OK)
 80025d2:	2800      	cmp	r0, #0
 80025d4:	d15b      	bne.n	800268e <HAL_ADC_Start+0xd2>
    ADC_STATE_CLR_SET(hadc->State,
 80025d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80025d8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80025dc:	f023 0301 	bic.w	r3, r3, #1
 80025e0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80025e4:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 80025e6:	6823      	ldr	r3, [r4, #0]
 80025e8:	4a2c      	ldr	r2, [pc, #176]	; (800269c <HAL_ADC_Start+0xe0>)
 80025ea:	4293      	cmp	r3, r2
 80025ec:	d027      	beq.n	800263e <HAL_ADC_Start+0x82>
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80025ee:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80025f0:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80025f4:	62a2      	str	r2, [r4, #40]	; 0x28
      if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80025f6:	685a      	ldr	r2, [r3, #4]
 80025f8:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80025fc:	d005      	beq.n	800260a <HAL_ADC_Start+0x4e>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80025fe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002600:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002604:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002608:	62a2      	str	r2, [r4, #40]	; 0x28
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 800260a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800260c:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 8002610:	d02b      	beq.n	800266a <HAL_ADC_Start+0xae>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8002612:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002614:	f022 0206 	bic.w	r2, r2, #6
 8002618:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_UNLOCK(hadc);
 800261a:	2200      	movs	r2, #0
 800261c:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
 8002620:	f06f 0202 	mvn.w	r2, #2
 8002624:	601a      	str	r2, [r3, #0]
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 8002626:	6823      	ldr	r3, [r4, #0]
 8002628:	689a      	ldr	r2, [r3, #8]
 800262a:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 800262e:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 8002632:	d01d      	beq.n	8002670 <HAL_ADC_Start+0xb4>
      SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
 8002634:	689a      	ldr	r2, [r3, #8]
 8002636:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800263a:	609a      	str	r2, [r3, #8]
 800263c:	e02a      	b.n	8002694 <HAL_ADC_Start+0xd8>
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800263e:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 8002642:	6852      	ldr	r2, [r2, #4]
 8002644:	f412 2f70 	tst.w	r2, #983040	; 0xf0000
 8002648:	d0d1      	beq.n	80025ee <HAL_ADC_Start+0x32>
      SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 800264a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800264c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8002650:	62a2      	str	r2, [r4, #40]	; 0x28
      if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
 8002652:	4a13      	ldr	r2, [pc, #76]	; (80026a0 <HAL_ADC_Start+0xe4>)
 8002654:	6852      	ldr	r2, [r2, #4]
 8002656:	f412 6f80 	tst.w	r2, #1024	; 0x400
 800265a:	d0d6      	beq.n	800260a <HAL_ADC_Start+0x4e>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 800265c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800265e:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002662:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002666:	62a2      	str	r2, [r4, #40]	; 0x28
 8002668:	e7cf      	b.n	800260a <HAL_ADC_Start+0x4e>
      ADC_CLEAR_ERRORCODE(hadc);
 800266a:	2200      	movs	r2, #0
 800266c:	62e2      	str	r2, [r4, #44]	; 0x2c
 800266e:	e7d4      	b.n	800261a <HAL_ADC_Start+0x5e>
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 8002670:	4a0a      	ldr	r2, [pc, #40]	; (800269c <HAL_ADC_Start+0xe0>)
 8002672:	4293      	cmp	r3, r2
 8002674:	d004      	beq.n	8002680 <HAL_ADC_Start+0xc4>
      SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
 8002676:	689a      	ldr	r2, [r3, #8]
 8002678:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
 800267c:	609a      	str	r2, [r3, #8]
 800267e:	e009      	b.n	8002694 <HAL_ADC_Start+0xd8>
        ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
 8002680:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 8002684:	6852      	ldr	r2, [r2, #4]
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 8002686:	f412 2f70 	tst.w	r2, #983040	; 0xf0000
 800268a:	d1d3      	bne.n	8002634 <HAL_ADC_Start+0x78>
 800268c:	e7f3      	b.n	8002676 <HAL_ADC_Start+0xba>
    __HAL_UNLOCK(hadc);
 800268e:	2300      	movs	r3, #0
 8002690:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8002694:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8002696:	2002      	movs	r0, #2
}
 8002698:	4770      	bx	lr
 800269a:	bf00      	nop
 800269c:	40012800 	.word	0x40012800
 80026a0:	40012400 	.word	0x40012400

080026a4 <HAL_ADC_Start_IT>:
  __HAL_LOCK(hadc);
 80026a4:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80026a8:	2b01      	cmp	r3, #1
 80026aa:	d06d      	beq.n	8002788 <HAL_ADC_Start_IT+0xe4>
{
 80026ac:	b510      	push	{r4, lr}
 80026ae:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 80026b0:	2301      	movs	r3, #1
 80026b2:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  tmp_hal_status = ADC_Enable(hadc);
 80026b6:	f7ff ff3d 	bl	8002534 <ADC_Enable>
  if (tmp_hal_status == HAL_OK)
 80026ba:	2800      	cmp	r0, #0
 80026bc:	d160      	bne.n	8002780 <HAL_ADC_Start_IT+0xdc>
    ADC_STATE_CLR_SET(hadc->State,
 80026be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80026c0:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80026c4:	f023 0301 	bic.w	r3, r3, #1
 80026c8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80026cc:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 80026ce:	6823      	ldr	r3, [r4, #0]
 80026d0:	4a2e      	ldr	r2, [pc, #184]	; (800278c <HAL_ADC_Start_IT+0xe8>)
 80026d2:	4293      	cmp	r3, r2
 80026d4:	d02c      	beq.n	8002730 <HAL_ADC_Start_IT+0x8c>
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80026d6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80026d8:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80026dc:	62a2      	str	r2, [r4, #40]	; 0x28
      if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80026de:	685a      	ldr	r2, [r3, #4]
 80026e0:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80026e4:	d005      	beq.n	80026f2 <HAL_ADC_Start_IT+0x4e>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80026e6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80026e8:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80026ec:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80026f0:	62a2      	str	r2, [r4, #40]	; 0x28
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80026f2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80026f4:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 80026f8:	d030      	beq.n	800275c <HAL_ADC_Start_IT+0xb8>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80026fa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80026fc:	f022 0206 	bic.w	r2, r2, #6
 8002700:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_UNLOCK(hadc);
 8002702:	2200      	movs	r2, #0
 8002704:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
 8002708:	f06f 0202 	mvn.w	r2, #2
 800270c:	601a      	str	r2, [r3, #0]
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
 800270e:	6822      	ldr	r2, [r4, #0]
 8002710:	6853      	ldr	r3, [r2, #4]
 8002712:	f043 0320 	orr.w	r3, r3, #32
 8002716:	6053      	str	r3, [r2, #4]
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 8002718:	6823      	ldr	r3, [r4, #0]
 800271a:	689a      	ldr	r2, [r3, #8]
 800271c:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 8002720:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 8002724:	d01d      	beq.n	8002762 <HAL_ADC_Start_IT+0xbe>
      SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
 8002726:	689a      	ldr	r2, [r3, #8]
 8002728:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800272c:	609a      	str	r2, [r3, #8]
 800272e:	e02a      	b.n	8002786 <HAL_ADC_Start_IT+0xe2>
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8002730:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 8002734:	6852      	ldr	r2, [r2, #4]
 8002736:	f412 2f70 	tst.w	r2, #983040	; 0xf0000
 800273a:	d0cc      	beq.n	80026d6 <HAL_ADC_Start_IT+0x32>
      SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 800273c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800273e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8002742:	62a2      	str	r2, [r4, #40]	; 0x28
      if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
 8002744:	4a12      	ldr	r2, [pc, #72]	; (8002790 <HAL_ADC_Start_IT+0xec>)
 8002746:	6852      	ldr	r2, [r2, #4]
 8002748:	f412 6f80 	tst.w	r2, #1024	; 0x400
 800274c:	d0d1      	beq.n	80026f2 <HAL_ADC_Start_IT+0x4e>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 800274e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002750:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002754:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002758:	62a2      	str	r2, [r4, #40]	; 0x28
 800275a:	e7ca      	b.n	80026f2 <HAL_ADC_Start_IT+0x4e>
      ADC_CLEAR_ERRORCODE(hadc);
 800275c:	2200      	movs	r2, #0
 800275e:	62e2      	str	r2, [r4, #44]	; 0x2c
 8002760:	e7cf      	b.n	8002702 <HAL_ADC_Start_IT+0x5e>
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 8002762:	4a0a      	ldr	r2, [pc, #40]	; (800278c <HAL_ADC_Start_IT+0xe8>)
 8002764:	4293      	cmp	r3, r2
 8002766:	d004      	beq.n	8002772 <HAL_ADC_Start_IT+0xce>
      SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
 8002768:	689a      	ldr	r2, [r3, #8]
 800276a:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
 800276e:	609a      	str	r2, [r3, #8]
 8002770:	e009      	b.n	8002786 <HAL_ADC_Start_IT+0xe2>
        ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
 8002772:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 8002776:	6852      	ldr	r2, [r2, #4]
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 8002778:	f412 2f70 	tst.w	r2, #983040	; 0xf0000
 800277c:	d1d3      	bne.n	8002726 <HAL_ADC_Start_IT+0x82>
 800277e:	e7f3      	b.n	8002768 <HAL_ADC_Start_IT+0xc4>
    __HAL_UNLOCK(hadc);
 8002780:	2300      	movs	r3, #0
 8002782:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8002786:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8002788:	2002      	movs	r0, #2
}
 800278a:	4770      	bx	lr
 800278c:	40012800 	.word	0x40012800
 8002790:	40012400 	.word	0x40012400

08002794 <HAL_ADC_Start_DMA>:
{
 8002794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002796:	4604      	mov	r4, r0
 8002798:	460d      	mov	r5, r1
 800279a:	4616      	mov	r6, r2
  if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
 800279c:	6803      	ldr	r3, [r0, #0]
 800279e:	4944      	ldr	r1, [pc, #272]	; (80028b0 <HAL_ADC_Start_DMA+0x11c>)
 80027a0:	428b      	cmp	r3, r1
 80027a2:	d059      	beq.n	8002858 <HAL_ADC_Start_DMA+0xc4>
 80027a4:	4a43      	ldr	r2, [pc, #268]	; (80028b4 <HAL_ADC_Start_DMA+0x120>)
 80027a6:	4293      	cmp	r3, r2
 80027a8:	d056      	beq.n	8002858 <HAL_ADC_Start_DMA+0xc4>
    __HAL_LOCK(hadc);
 80027aa:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80027ae:	2b01      	cmp	r3, #1
 80027b0:	d07c      	beq.n	80028ac <HAL_ADC_Start_DMA+0x118>
 80027b2:	2301      	movs	r3, #1
 80027b4:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    tmp_hal_status = ADC_Enable(hadc);
 80027b8:	4620      	mov	r0, r4
 80027ba:	f7ff febb 	bl	8002534 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 80027be:	4607      	mov	r7, r0
 80027c0:	2800      	cmp	r0, #0
 80027c2:	d16e      	bne.n	80028a2 <HAL_ADC_Start_DMA+0x10e>
      ADC_STATE_CLR_SET(hadc->State,
 80027c4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80027c6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80027ca:	f023 0301 	bic.w	r3, r3, #1
 80027ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80027d2:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 80027d4:	6822      	ldr	r2, [r4, #0]
 80027d6:	4b37      	ldr	r3, [pc, #220]	; (80028b4 <HAL_ADC_Start_DMA+0x120>)
 80027d8:	429a      	cmp	r2, r3
 80027da:	d044      	beq.n	8002866 <HAL_ADC_Start_DMA+0xd2>
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80027dc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80027de:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80027e2:	62a3      	str	r3, [r4, #40]	; 0x28
      if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80027e4:	6853      	ldr	r3, [r2, #4]
 80027e6:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80027ea:	d005      	beq.n	80027f8 <HAL_ADC_Start_DMA+0x64>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80027ec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80027ee:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80027f2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80027f6:	62a3      	str	r3, [r4, #40]	; 0x28
      if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80027f8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80027fa:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80027fe:	d048      	beq.n	8002892 <HAL_ADC_Start_DMA+0xfe>
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8002800:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002802:	f023 0306 	bic.w	r3, r3, #6
 8002806:	62e3      	str	r3, [r4, #44]	; 0x2c
      __HAL_UNLOCK(hadc);
 8002808:	2300      	movs	r3, #0
 800280a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800280e:	6a23      	ldr	r3, [r4, #32]
 8002810:	4a29      	ldr	r2, [pc, #164]	; (80028b8 <HAL_ADC_Start_DMA+0x124>)
 8002812:	629a      	str	r2, [r3, #40]	; 0x28
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8002814:	6a23      	ldr	r3, [r4, #32]
 8002816:	4a29      	ldr	r2, [pc, #164]	; (80028bc <HAL_ADC_Start_DMA+0x128>)
 8002818:	62da      	str	r2, [r3, #44]	; 0x2c
      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 800281a:	6a23      	ldr	r3, [r4, #32]
 800281c:	4a28      	ldr	r2, [pc, #160]	; (80028c0 <HAL_ADC_Start_DMA+0x12c>)
 800281e:	631a      	str	r2, [r3, #48]	; 0x30
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
 8002820:	6823      	ldr	r3, [r4, #0]
 8002822:	f06f 0202 	mvn.w	r2, #2
 8002826:	601a      	str	r2, [r3, #0]
      SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
 8002828:	6822      	ldr	r2, [r4, #0]
 800282a:	6893      	ldr	r3, [r2, #8]
 800282c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002830:	6093      	str	r3, [r2, #8]
      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8002832:	6821      	ldr	r1, [r4, #0]
 8002834:	4633      	mov	r3, r6
 8002836:	462a      	mov	r2, r5
 8002838:	314c      	adds	r1, #76	; 0x4c
 800283a:	6a20      	ldr	r0, [r4, #32]
 800283c:	f001 f810 	bl	8003860 <HAL_DMA_Start_IT>
      if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
 8002840:	6823      	ldr	r3, [r4, #0]
 8002842:	689a      	ldr	r2, [r3, #8]
 8002844:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 8002848:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 800284c:	d024      	beq.n	8002898 <HAL_ADC_Start_DMA+0x104>
        SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
 800284e:	689a      	ldr	r2, [r3, #8]
 8002850:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8002854:	609a      	str	r2, [r3, #8]
 8002856:	e027      	b.n	80028a8 <HAL_ADC_Start_DMA+0x114>
  if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
 8002858:	4b15      	ldr	r3, [pc, #84]	; (80028b0 <HAL_ADC_Start_DMA+0x11c>)
 800285a:	685b      	ldr	r3, [r3, #4]
 800285c:	f413 2f70 	tst.w	r3, #983040	; 0xf0000
 8002860:	d0a3      	beq.n	80027aa <HAL_ADC_Start_DMA+0x16>
    tmp_hal_status = HAL_ERROR;
 8002862:	2701      	movs	r7, #1
 8002864:	e020      	b.n	80028a8 <HAL_ADC_Start_DMA+0x114>
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8002866:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800286a:	685b      	ldr	r3, [r3, #4]
 800286c:	f413 2f70 	tst.w	r3, #983040	; 0xf0000
 8002870:	d0b4      	beq.n	80027dc <HAL_ADC_Start_DMA+0x48>
      SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8002872:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002874:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002878:	62a3      	str	r3, [r4, #40]	; 0x28
      if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
 800287a:	4b0d      	ldr	r3, [pc, #52]	; (80028b0 <HAL_ADC_Start_DMA+0x11c>)
 800287c:	685b      	ldr	r3, [r3, #4]
 800287e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8002882:	d0b9      	beq.n	80027f8 <HAL_ADC_Start_DMA+0x64>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 8002884:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002886:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800288a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800288e:	62a3      	str	r3, [r4, #40]	; 0x28
 8002890:	e7b2      	b.n	80027f8 <HAL_ADC_Start_DMA+0x64>
        ADC_CLEAR_ERRORCODE(hadc);
 8002892:	2300      	movs	r3, #0
 8002894:	62e3      	str	r3, [r4, #44]	; 0x2c
 8002896:	e7b7      	b.n	8002808 <HAL_ADC_Start_DMA+0x74>
        SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
 8002898:	689a      	ldr	r2, [r3, #8]
 800289a:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
 800289e:	609a      	str	r2, [r3, #8]
 80028a0:	e002      	b.n	80028a8 <HAL_ADC_Start_DMA+0x114>
      __HAL_UNLOCK(hadc);
 80028a2:	2300      	movs	r3, #0
 80028a4:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 80028a8:	4638      	mov	r0, r7
 80028aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hadc);
 80028ac:	2702      	movs	r7, #2
 80028ae:	e7fb      	b.n	80028a8 <HAL_ADC_Start_DMA+0x114>
 80028b0:	40012400 	.word	0x40012400
 80028b4:	40012800 	.word	0x40012800
 80028b8:	0800220d 	.word	0x0800220d
 80028bc:	08002261 	.word	0x08002261
 80028c0:	0800237b 	.word	0x0800237b

080028c4 <ADC_ConversionStop_Disable>:
{
 80028c4:	b538      	push	{r3, r4, r5, lr}
  if (ADC_IS_ENABLE(hadc) != RESET)
 80028c6:	6803      	ldr	r3, [r0, #0]
 80028c8:	689a      	ldr	r2, [r3, #8]
 80028ca:	f012 0f01 	tst.w	r2, #1
 80028ce:	d101      	bne.n	80028d4 <ADC_ConversionStop_Disable+0x10>
  return HAL_OK;
 80028d0:	2000      	movs	r0, #0
}
 80028d2:	bd38      	pop	{r3, r4, r5, pc}
 80028d4:	4604      	mov	r4, r0
    __HAL_ADC_DISABLE(hadc);
 80028d6:	689a      	ldr	r2, [r3, #8]
 80028d8:	f022 0201 	bic.w	r2, r2, #1
 80028dc:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
 80028de:	f7ff fafd 	bl	8001edc <HAL_GetTick>
 80028e2:	4605      	mov	r5, r0
    while(ADC_IS_ENABLE(hadc) != RESET)
 80028e4:	6823      	ldr	r3, [r4, #0]
 80028e6:	689b      	ldr	r3, [r3, #8]
 80028e8:	f013 0f01 	tst.w	r3, #1
 80028ec:	d013      	beq.n	8002916 <ADC_ConversionStop_Disable+0x52>
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 80028ee:	f7ff faf5 	bl	8001edc <HAL_GetTick>
 80028f2:	1b43      	subs	r3, r0, r5
 80028f4:	2b02      	cmp	r3, #2
 80028f6:	d9f5      	bls.n	80028e4 <ADC_ConversionStop_Disable+0x20>
        if(ADC_IS_ENABLE(hadc) != RESET)
 80028f8:	6823      	ldr	r3, [r4, #0]
 80028fa:	689b      	ldr	r3, [r3, #8]
 80028fc:	f013 0f01 	tst.w	r3, #1
 8002900:	d0f0      	beq.n	80028e4 <ADC_ConversionStop_Disable+0x20>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002902:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002904:	f043 0310 	orr.w	r3, r3, #16
 8002908:	62a3      	str	r3, [r4, #40]	; 0x28
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800290a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800290c:	f043 0301 	orr.w	r3, r3, #1
 8002910:	62e3      	str	r3, [r4, #44]	; 0x2c
          return HAL_ERROR;
 8002912:	2001      	movs	r0, #1
 8002914:	e7dd      	b.n	80028d2 <ADC_ConversionStop_Disable+0xe>
  return HAL_OK;
 8002916:	2000      	movs	r0, #0
 8002918:	e7db      	b.n	80028d2 <ADC_ConversionStop_Disable+0xe>

0800291a <HAL_ADC_Init>:
  if(hadc == NULL)
 800291a:	2800      	cmp	r0, #0
 800291c:	d07b      	beq.n	8002a16 <HAL_ADC_Init+0xfc>
{
 800291e:	b570      	push	{r4, r5, r6, lr}
 8002920:	4604      	mov	r4, r0
  if (hadc->State == HAL_ADC_STATE_RESET)
 8002922:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002924:	2b00      	cmp	r3, #0
 8002926:	d04d      	beq.n	80029c4 <HAL_ADC_Init+0xaa>
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002928:	4620      	mov	r0, r4
 800292a:	f7ff ffcb 	bl	80028c4 <ADC_ConversionStop_Disable>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 800292e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002930:	f013 0310 	ands.w	r3, r3, #16
 8002934:	d169      	bne.n	8002a0a <HAL_ADC_Init+0xf0>
 8002936:	2800      	cmp	r0, #0
 8002938:	d167      	bne.n	8002a0a <HAL_ADC_Init+0xf0>
    ADC_STATE_CLR_SET(hadc->State,
 800293a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800293c:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
 8002940:	f022 0202 	bic.w	r2, r2, #2
 8002944:	f042 0202 	orr.w	r2, r2, #2
 8002948:	62a2      	str	r2, [r4, #40]	; 0x28
    tmp_cr2 |= (hadc->Init.DataAlign                                          |
 800294a:	6862      	ldr	r2, [r4, #4]
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv)            |
 800294c:	69e1      	ldr	r1, [r4, #28]
    tmp_cr2 |= (hadc->Init.DataAlign                                          |
 800294e:	430a      	orrs	r2, r1
                ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)   );
 8002950:	7b21      	ldrb	r1, [r4, #12]
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv)            |
 8002952:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8002956:	68a5      	ldr	r5, [r4, #8]
 8002958:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800295c:	d002      	beq.n	8002964 <HAL_ADC_Init+0x4a>
 800295e:	2d01      	cmp	r5, #1
 8002960:	d036      	beq.n	80029d0 <HAL_ADC_Init+0xb6>
 8002962:	461d      	mov	r5, r3
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002964:	7d26      	ldrb	r6, [r4, #20]
 8002966:	2e01      	cmp	r6, #1
 8002968:	d035      	beq.n	80029d6 <HAL_ADC_Init+0xbc>
      MODIFY_REG(hadc->Instance->CR1,
 800296a:	6826      	ldr	r6, [r4, #0]
 800296c:	6871      	ldr	r1, [r6, #4]
 800296e:	f421 4169 	bic.w	r1, r1, #59648	; 0xe900
 8002972:	4329      	orrs	r1, r5
 8002974:	6071      	str	r1, [r6, #4]
      MODIFY_REG(hadc->Instance->CR2,
 8002976:	6825      	ldr	r5, [r4, #0]
 8002978:	68ae      	ldr	r6, [r5, #8]
 800297a:	4928      	ldr	r1, [pc, #160]	; (8002a1c <HAL_ADC_Init+0x102>)
 800297c:	4031      	ands	r1, r6
 800297e:	4311      	orrs	r1, r2
 8002980:	60a9      	str	r1, [r5, #8]
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
 8002982:	68a1      	ldr	r1, [r4, #8]
 8002984:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8002988:	d001      	beq.n	800298e <HAL_ADC_Init+0x74>
 800298a:	2901      	cmp	r1, #1
 800298c:	d102      	bne.n	8002994 <HAL_ADC_Init+0x7a>
      tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
 800298e:	6923      	ldr	r3, [r4, #16]
 8002990:	3b01      	subs	r3, #1
 8002992:	051b      	lsls	r3, r3, #20
    MODIFY_REG(hadc->Instance->SQR1,
 8002994:	6825      	ldr	r5, [r4, #0]
 8002996:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8002998:	f421 0170 	bic.w	r1, r1, #15728640	; 0xf00000
 800299c:	430b      	orrs	r3, r1
 800299e:	62eb      	str	r3, [r5, #44]	; 0x2c
    if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
 80029a0:	6823      	ldr	r3, [r4, #0]
 80029a2:	6899      	ldr	r1, [r3, #8]
 80029a4:	4b1e      	ldr	r3, [pc, #120]	; (8002a20 <HAL_ADC_Init+0x106>)
 80029a6:	400b      	ands	r3, r1
 80029a8:	429a      	cmp	r2, r3
 80029aa:	d025      	beq.n	80029f8 <HAL_ADC_Init+0xde>
      ADC_STATE_CLR_SET(hadc->State,
 80029ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80029ae:	f023 0312 	bic.w	r3, r3, #18
 80029b2:	f043 0310 	orr.w	r3, r3, #16
 80029b6:	62a3      	str	r3, [r4, #40]	; 0x28
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80029b8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80029ba:	f043 0301 	orr.w	r3, r3, #1
 80029be:	62e3      	str	r3, [r4, #44]	; 0x2c
      tmp_hal_status = HAL_ERROR;
 80029c0:	2001      	movs	r0, #1
 80029c2:	e027      	b.n	8002a14 <HAL_ADC_Init+0xfa>
    ADC_CLEAR_ERRORCODE(hadc);
 80029c4:	62c3      	str	r3, [r0, #44]	; 0x2c
    hadc->Lock = HAL_UNLOCKED;
 80029c6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    HAL_ADC_MspInit(hadc);
 80029ca:	f7fe ff11 	bl	80017f0 <HAL_ADC_MspInit>
 80029ce:	e7ab      	b.n	8002928 <HAL_ADC_Init+0xe>
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 80029d0:	f44f 7580 	mov.w	r5, #256	; 0x100
 80029d4:	e7c6      	b.n	8002964 <HAL_ADC_Init+0x4a>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 80029d6:	b931      	cbnz	r1, 80029e6 <HAL_ADC_Init+0xcc>
        SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
 80029d8:	69a1      	ldr	r1, [r4, #24]
 80029da:	3901      	subs	r1, #1
 80029dc:	ea45 3141 	orr.w	r1, r5, r1, lsl #13
 80029e0:	f441 6500 	orr.w	r5, r1, #2048	; 0x800
 80029e4:	e7c1      	b.n	800296a <HAL_ADC_Init+0x50>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80029e6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80029e8:	f041 0120 	orr.w	r1, r1, #32
 80029ec:	62a1      	str	r1, [r4, #40]	; 0x28
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80029ee:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80029f0:	f041 0101 	orr.w	r1, r1, #1
 80029f4:	62e1      	str	r1, [r4, #44]	; 0x2c
 80029f6:	e7b8      	b.n	800296a <HAL_ADC_Init+0x50>
      ADC_CLEAR_ERRORCODE(hadc);
 80029f8:	2300      	movs	r3, #0
 80029fa:	62e3      	str	r3, [r4, #44]	; 0x2c
      ADC_STATE_CLR_SET(hadc->State,
 80029fc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80029fe:	f023 0303 	bic.w	r3, r3, #3
 8002a02:	f043 0301 	orr.w	r3, r3, #1
 8002a06:	62a3      	str	r3, [r4, #40]	; 0x28
 8002a08:	e004      	b.n	8002a14 <HAL_ADC_Init+0xfa>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002a0a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002a0c:	f043 0310 	orr.w	r3, r3, #16
 8002a10:	62a3      	str	r3, [r4, #40]	; 0x28
    tmp_hal_status = HAL_ERROR;
 8002a12:	2001      	movs	r0, #1
}
 8002a14:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8002a16:	2001      	movs	r0, #1
}
 8002a18:	4770      	bx	lr
 8002a1a:	bf00      	nop
 8002a1c:	ffe1f7fd 	.word	0xffe1f7fd
 8002a20:	ff1f0efe 	.word	0xff1f0efe

08002a24 <HAL_ADC_DeInit>:
{
 8002a24:	b538      	push	{r3, r4, r5, lr}
  if(hadc == NULL)
 8002a26:	2800      	cmp	r0, #0
 8002a28:	d074      	beq.n	8002b14 <HAL_ADC_DeInit+0xf0>
 8002a2a:	4604      	mov	r4, r0
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 8002a2c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a2e:	f043 0302 	orr.w	r3, r3, #2
 8002a32:	6283      	str	r3, [r0, #40]	; 0x28
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002a34:	f7ff ff46 	bl	80028c4 <ADC_ConversionStop_Disable>
  if (tmp_hal_status == HAL_OK)
 8002a38:	4605      	mov	r5, r0
 8002a3a:	b120      	cbz	r0, 8002a46 <HAL_ADC_DeInit+0x22>
  __HAL_UNLOCK(hadc);
 8002a3c:	2300      	movs	r3, #0
 8002a3e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8002a42:	4628      	mov	r0, r5
 8002a44:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
 8002a46:	6823      	ldr	r3, [r4, #0]
 8002a48:	f06f 021f 	mvn.w	r2, #31
 8002a4c:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_AWDEN   | ADC_CR1_JAWDEN | ADC_CR1_DISCNUM | 
 8002a4e:	6822      	ldr	r2, [r4, #0]
 8002a50:	6851      	ldr	r1, [r2, #4]
 8002a52:	4b31      	ldr	r3, [pc, #196]	; (8002b18 <HAL_ADC_DeInit+0xf4>)
 8002a54:	400b      	ands	r3, r1
 8002a56:	6053      	str	r3, [r2, #4]
    CLEAR_BIT(hadc->Instance->CR2, (ADC_CR2_TSVREFE | ADC_CR2_SWSTART | ADC_CR2_JSWSTART | 
 8002a58:	6822      	ldr	r2, [r4, #0]
 8002a5a:	6891      	ldr	r1, [r2, #8]
 8002a5c:	4b2f      	ldr	r3, [pc, #188]	; (8002b1c <HAL_ADC_DeInit+0xf8>)
 8002a5e:	400b      	ands	r3, r1
 8002a60:	6093      	str	r3, [r2, #8]
    CLEAR_BIT(hadc->Instance->SMPR1, (ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16 | ADC_SMPR1_SMP15 | 
 8002a62:	6822      	ldr	r2, [r4, #0]
 8002a64:	68d3      	ldr	r3, [r2, #12]
 8002a66:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8002a6a:	60d3      	str	r3, [r2, #12]
    CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP9 | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | 
 8002a6c:	6822      	ldr	r2, [r4, #0]
 8002a6e:	6913      	ldr	r3, [r2, #16]
 8002a70:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 8002a74:	6113      	str	r3, [r2, #16]
    CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
 8002a76:	6822      	ldr	r2, [r4, #0]
 8002a78:	6953      	ldr	r3, [r2, #20]
 8002a7a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002a7e:	f023 030f 	bic.w	r3, r3, #15
 8002a82:	6153      	str	r3, [r2, #20]
    CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
 8002a84:	6822      	ldr	r2, [r4, #0]
 8002a86:	6993      	ldr	r3, [r2, #24]
 8002a88:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002a8c:	f023 030f 	bic.w	r3, r3, #15
 8002a90:	6193      	str	r3, [r2, #24]
    CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
 8002a92:	6822      	ldr	r2, [r4, #0]
 8002a94:	69d3      	ldr	r3, [r2, #28]
 8002a96:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002a9a:	f023 030f 	bic.w	r3, r3, #15
 8002a9e:	61d3      	str	r3, [r2, #28]
    CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
 8002aa0:	6822      	ldr	r2, [r4, #0]
 8002aa2:	6a13      	ldr	r3, [r2, #32]
 8002aa4:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002aa8:	f023 030f 	bic.w	r3, r3, #15
 8002aac:	6213      	str	r3, [r2, #32]
    CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
 8002aae:	6822      	ldr	r2, [r4, #0]
 8002ab0:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8002ab2:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002ab6:	f023 030f 	bic.w	r3, r3, #15
 8002aba:	6253      	str	r3, [r2, #36]	; 0x24
    CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
 8002abc:	6822      	ldr	r2, [r4, #0]
 8002abe:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8002ac0:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002ac4:	f023 030f 	bic.w	r3, r3, #15
 8002ac8:	6293      	str	r3, [r2, #40]	; 0x28
    CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
 8002aca:	6822      	ldr	r2, [r4, #0]
 8002acc:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8002ace:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8002ad2:	62d3      	str	r3, [r2, #44]	; 0x2c
    CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
 8002ad4:	6822      	ldr	r2, [r4, #0]
 8002ad6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8002ad8:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8002adc:	62d3      	str	r3, [r2, #44]	; 0x2c
    CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10 | 
 8002ade:	6822      	ldr	r2, [r4, #0]
 8002ae0:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8002ae2:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 8002ae6:	6313      	str	r3, [r2, #48]	; 0x30
    CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4 | 
 8002ae8:	6822      	ldr	r2, [r4, #0]
 8002aea:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8002aec:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 8002af0:	6353      	str	r3, [r2, #52]	; 0x34
    CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
 8002af2:	6822      	ldr	r2, [r4, #0]
 8002af4:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8002af6:	0d9b      	lsrs	r3, r3, #22
 8002af8:	059b      	lsls	r3, r3, #22
 8002afa:	6393      	str	r3, [r2, #56]	; 0x38
    CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
 8002afc:	6822      	ldr	r2, [r4, #0]
 8002afe:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8002b00:	0d9b      	lsrs	r3, r3, #22
 8002b02:	059b      	lsls	r3, r3, #22
 8002b04:	6393      	str	r3, [r2, #56]	; 0x38
    HAL_ADC_MspDeInit(hadc);
 8002b06:	4620      	mov	r0, r4
 8002b08:	f7fe ff02 	bl	8001910 <HAL_ADC_MspDeInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8002b0c:	2300      	movs	r3, #0
 8002b0e:	62e3      	str	r3, [r4, #44]	; 0x2c
    hadc->State = HAL_ADC_STATE_RESET; 
 8002b10:	62a3      	str	r3, [r4, #40]	; 0x28
 8002b12:	e793      	b.n	8002a3c <HAL_ADC_DeInit+0x18>
     return HAL_ERROR;
 8002b14:	2501      	movs	r5, #1
 8002b16:	e794      	b.n	8002a42 <HAL_ADC_DeInit+0x1e>
 8002b18:	ff3f0000 	.word	0xff3f0000
 8002b1c:	ff0106f0 	.word	0xff0106f0

08002b20 <HAL_ADC_Stop>:
  __HAL_LOCK(hadc);
 8002b20:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002b24:	2b01      	cmp	r3, #1
 8002b26:	d013      	beq.n	8002b50 <HAL_ADC_Stop+0x30>
{
 8002b28:	b510      	push	{r4, lr}
 8002b2a:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002b2c:	2301      	movs	r3, #1
 8002b2e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002b32:	f7ff fec7 	bl	80028c4 <ADC_ConversionStop_Disable>
  if (tmp_hal_status == HAL_OK)
 8002b36:	b938      	cbnz	r0, 8002b48 <HAL_ADC_Stop+0x28>
    ADC_STATE_CLR_SET(hadc->State,
 8002b38:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b3a:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8002b3e:	f023 0301 	bic.w	r3, r3, #1
 8002b42:	f043 0301 	orr.w	r3, r3, #1
 8002b46:	62a3      	str	r3, [r4, #40]	; 0x28
  __HAL_UNLOCK(hadc);
 8002b48:	2300      	movs	r3, #0
 8002b4a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8002b4e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8002b50:	2002      	movs	r0, #2
}
 8002b52:	4770      	bx	lr

08002b54 <HAL_ADC_Stop_IT>:
  __HAL_LOCK(hadc);
 8002b54:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002b58:	2b01      	cmp	r3, #1
 8002b5a:	d018      	beq.n	8002b8e <HAL_ADC_Stop_IT+0x3a>
{
 8002b5c:	b510      	push	{r4, lr}
 8002b5e:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002b60:	2301      	movs	r3, #1
 8002b62:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002b66:	f7ff fead 	bl	80028c4 <ADC_ConversionStop_Disable>
  if (tmp_hal_status == HAL_OK)
 8002b6a:	b960      	cbnz	r0, 8002b86 <HAL_ADC_Stop_IT+0x32>
    __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8002b6c:	6822      	ldr	r2, [r4, #0]
 8002b6e:	6853      	ldr	r3, [r2, #4]
 8002b70:	f023 0320 	bic.w	r3, r3, #32
 8002b74:	6053      	str	r3, [r2, #4]
    ADC_STATE_CLR_SET(hadc->State,
 8002b76:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b78:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8002b7c:	f023 0301 	bic.w	r3, r3, #1
 8002b80:	f043 0301 	orr.w	r3, r3, #1
 8002b84:	62a3      	str	r3, [r4, #40]	; 0x28
  __HAL_UNLOCK(hadc);
 8002b86:	2300      	movs	r3, #0
 8002b88:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8002b8c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8002b8e:	2002      	movs	r0, #2
}
 8002b90:	4770      	bx	lr

08002b92 <HAL_ADC_Stop_DMA>:
  __HAL_LOCK(hadc);
 8002b92:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002b96:	2b01      	cmp	r3, #1
 8002b98:	d027      	beq.n	8002bea <HAL_ADC_Stop_DMA+0x58>
{
 8002b9a:	b510      	push	{r4, lr}
 8002b9c:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002b9e:	2301      	movs	r3, #1
 8002ba0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002ba4:	f7ff fe8e 	bl	80028c4 <ADC_ConversionStop_Disable>
  if (tmp_hal_status == HAL_OK)
 8002ba8:	b948      	cbnz	r0, 8002bbe <HAL_ADC_Stop_DMA+0x2c>
    CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
 8002baa:	6822      	ldr	r2, [r4, #0]
 8002bac:	6893      	ldr	r3, [r2, #8]
 8002bae:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002bb2:	6093      	str	r3, [r2, #8]
    if (hadc->DMA_Handle->State == HAL_DMA_STATE_BUSY)
 8002bb4:	6a23      	ldr	r3, [r4, #32]
 8002bb6:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 8002bba:	2a02      	cmp	r2, #2
 8002bbc:	d003      	beq.n	8002bc6 <HAL_ADC_Stop_DMA+0x34>
  __HAL_UNLOCK(hadc);
 8002bbe:	2300      	movs	r3, #0
 8002bc0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8002bc4:	bd10      	pop	{r4, pc}
      tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
 8002bc6:	4618      	mov	r0, r3
 8002bc8:	f000 fe84 	bl	80038d4 <HAL_DMA_Abort>
      if (tmp_hal_status == HAL_OK)
 8002bcc:	b940      	cbnz	r0, 8002be0 <HAL_ADC_Stop_DMA+0x4e>
        ADC_STATE_CLR_SET(hadc->State,
 8002bce:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002bd0:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8002bd4:	f023 0301 	bic.w	r3, r3, #1
 8002bd8:	f043 0301 	orr.w	r3, r3, #1
 8002bdc:	62a3      	str	r3, [r4, #40]	; 0x28
 8002bde:	e7ee      	b.n	8002bbe <HAL_ADC_Stop_DMA+0x2c>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8002be0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002be2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002be6:	62a3      	str	r3, [r4, #40]	; 0x28
 8002be8:	e7e9      	b.n	8002bbe <HAL_ADC_Stop_DMA+0x2c>
  __HAL_LOCK(hadc);
 8002bea:	2002      	movs	r0, #2
}
 8002bec:	4770      	bx	lr
 8002bee:	bf00      	nop

08002bf0 <HAL_ADCEx_Calibration_Start>:
  *         the completion of this function.
  * @param  hadc: ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
{
 8002bf0:	b570      	push	{r4, r5, r6, lr}
 8002bf2:	b082      	sub	sp, #8
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0U;
 8002bf4:	2300      	movs	r3, #0
 8002bf6:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 8002bf8:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002bfc:	2b01      	cmp	r3, #1
 8002bfe:	d072      	beq.n	8002ce6 <HAL_ADCEx_Calibration_Start+0xf6>
 8002c00:	4604      	mov	r4, r0
 8002c02:	2301      	movs	r3, #1
 8002c04:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  /* 1. Calibration prerequisite:                                             */
  /*    - ADC must be disabled for at least two ADC clock cycles in disable   */
  /*      mode before ADC enable                                              */
  /* Stop potential conversion on going, on regular and injected groups       */
  /* Disable ADC peripheral */
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002c08:	f7ff fe5c 	bl	80028c4 <ADC_ConversionStop_Disable>
  
  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
 8002c0c:	4605      	mov	r5, r0
 8002c0e:	b128      	cbz	r0, 8002c1c <HAL_ADCEx_Calibration_Start+0x2c>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002c10:	2300      	movs	r3, #0
 8002c12:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 8002c16:	4628      	mov	r0, r5
 8002c18:	b002      	add	sp, #8
 8002c1a:	bd70      	pop	{r4, r5, r6, pc}
    ADC_STATE_CLR_SET(hadc->State,
 8002c1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002c1e:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8002c22:	f023 0302 	bic.w	r3, r3, #2
 8002c26:	f043 0302 	orr.w	r3, r3, #2
 8002c2a:	62a3      	str	r3, [r4, #40]	; 0x28
                        / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
 8002c2c:	4b2f      	ldr	r3, [pc, #188]	; (8002cec <HAL_ADCEx_Calibration_Start+0xfc>)
 8002c2e:	681e      	ldr	r6, [r3, #0]
 8002c30:	2002      	movs	r0, #2
 8002c32:	f001 ff99 	bl	8004b68 <HAL_RCCEx_GetPeriphCLKFreq>
 8002c36:	fbb6 f6f0 	udiv	r6, r6, r0
                       * ADC_PRECALIBRATION_DELAY_ADCCLOCKCYCLES        );
 8002c3a:	0076      	lsls	r6, r6, #1
    wait_loop_index = ((SystemCoreClock
 8002c3c:	9601      	str	r6, [sp, #4]
    while(wait_loop_index != 0U)
 8002c3e:	e002      	b.n	8002c46 <HAL_ADCEx_Calibration_Start+0x56>
      wait_loop_index--;
 8002c40:	9b01      	ldr	r3, [sp, #4]
 8002c42:	3b01      	subs	r3, #1
 8002c44:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0U)
 8002c46:	9b01      	ldr	r3, [sp, #4]
 8002c48:	2b00      	cmp	r3, #0
 8002c4a:	d1f9      	bne.n	8002c40 <HAL_ADCEx_Calibration_Start+0x50>
    ADC_Enable(hadc);
 8002c4c:	4620      	mov	r0, r4
 8002c4e:	f7ff fc71 	bl	8002534 <ADC_Enable>
    SET_BIT(hadc->Instance->CR2, ADC_CR2_RSTCAL);
 8002c52:	6822      	ldr	r2, [r4, #0]
 8002c54:	6893      	ldr	r3, [r2, #8]
 8002c56:	f043 0308 	orr.w	r3, r3, #8
 8002c5a:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();  
 8002c5c:	f7ff f93e 	bl	8001edc <HAL_GetTick>
 8002c60:	4606      	mov	r6, r0
    while(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_RSTCAL))
 8002c62:	6823      	ldr	r3, [r4, #0]
 8002c64:	689a      	ldr	r2, [r3, #8]
 8002c66:	f012 0f08 	tst.w	r2, #8
 8002c6a:	d014      	beq.n	8002c96 <HAL_ADCEx_Calibration_Start+0xa6>
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 8002c6c:	f7ff f936 	bl	8001edc <HAL_GetTick>
 8002c70:	1b80      	subs	r0, r0, r6
 8002c72:	280a      	cmp	r0, #10
 8002c74:	d9f5      	bls.n	8002c62 <HAL_ADCEx_Calibration_Start+0x72>
        if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_RSTCAL))
 8002c76:	6823      	ldr	r3, [r4, #0]
 8002c78:	689b      	ldr	r3, [r3, #8]
 8002c7a:	f013 0f08 	tst.w	r3, #8
 8002c7e:	d0f0      	beq.n	8002c62 <HAL_ADCEx_Calibration_Start+0x72>
          ADC_STATE_CLR_SET(hadc->State,
 8002c80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002c82:	f023 0312 	bic.w	r3, r3, #18
 8002c86:	f043 0310 	orr.w	r3, r3, #16
 8002c8a:	62a3      	str	r3, [r4, #40]	; 0x28
          __HAL_UNLOCK(hadc);
 8002c8c:	2300      	movs	r3, #0
 8002c8e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
          return HAL_ERROR;
 8002c92:	2501      	movs	r5, #1
 8002c94:	e7bf      	b.n	8002c16 <HAL_ADCEx_Calibration_Start+0x26>
    SET_BIT(hadc->Instance->CR2, ADC_CR2_CAL);
 8002c96:	689a      	ldr	r2, [r3, #8]
 8002c98:	f042 0204 	orr.w	r2, r2, #4
 8002c9c:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();  
 8002c9e:	f7ff f91d 	bl	8001edc <HAL_GetTick>
 8002ca2:	4606      	mov	r6, r0
    while(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_CAL))
 8002ca4:	6823      	ldr	r3, [r4, #0]
 8002ca6:	689b      	ldr	r3, [r3, #8]
 8002ca8:	f013 0f04 	tst.w	r3, #4
 8002cac:	d014      	beq.n	8002cd8 <HAL_ADCEx_Calibration_Start+0xe8>
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 8002cae:	f7ff f915 	bl	8001edc <HAL_GetTick>
 8002cb2:	1b80      	subs	r0, r0, r6
 8002cb4:	280a      	cmp	r0, #10
 8002cb6:	d9f5      	bls.n	8002ca4 <HAL_ADCEx_Calibration_Start+0xb4>
        if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_CAL))
 8002cb8:	6823      	ldr	r3, [r4, #0]
 8002cba:	689b      	ldr	r3, [r3, #8]
 8002cbc:	f013 0f04 	tst.w	r3, #4
 8002cc0:	d0f0      	beq.n	8002ca4 <HAL_ADCEx_Calibration_Start+0xb4>
          ADC_STATE_CLR_SET(hadc->State,
 8002cc2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002cc4:	f023 0312 	bic.w	r3, r3, #18
 8002cc8:	f043 0310 	orr.w	r3, r3, #16
 8002ccc:	62a3      	str	r3, [r4, #40]	; 0x28
          __HAL_UNLOCK(hadc);
 8002cce:	2300      	movs	r3, #0
 8002cd0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
          return HAL_ERROR;
 8002cd4:	2501      	movs	r5, #1
 8002cd6:	e79e      	b.n	8002c16 <HAL_ADCEx_Calibration_Start+0x26>
    ADC_STATE_CLR_SET(hadc->State,
 8002cd8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002cda:	f023 0303 	bic.w	r3, r3, #3
 8002cde:	f043 0301 	orr.w	r3, r3, #1
 8002ce2:	62a3      	str	r3, [r4, #40]	; 0x28
 8002ce4:	e794      	b.n	8002c10 <HAL_ADCEx_Calibration_Start+0x20>
  __HAL_LOCK(hadc);
 8002ce6:	2502      	movs	r5, #2
 8002ce8:	e795      	b.n	8002c16 <HAL_ADCEx_Calibration_Start+0x26>
 8002cea:	bf00      	nop
 8002cec:	20000028 	.word	0x20000028

08002cf0 <HAL_ADCEx_InjectedStart>:
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8002cf0:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002cf4:	2b01      	cmp	r3, #1
 8002cf6:	d052      	beq.n	8002d9e <HAL_ADCEx_InjectedStart+0xae>
{
 8002cf8:	b510      	push	{r4, lr}
 8002cfa:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002cfc:	2301      	movs	r3, #1
 8002cfe:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    
  /* Enable the ADC peripheral */
  tmp_hal_status = ADC_Enable(hadc);
 8002d02:	f7ff fc17 	bl	8002534 <ADC_Enable>
  
  /* Start conversion if ADC is effectively enabled */
  if (tmp_hal_status == HAL_OK)
 8002d06:	2800      	cmp	r0, #0
 8002d08:	d145      	bne.n	8002d96 <HAL_ADCEx_InjectedStart+0xa6>
  {
    /* Set ADC state                                                          */
    /* - Clear state bitfield related to injected group conversion results    */
    /* - Set state bitfield related to injected operation                     */
    ADC_STATE_CLR_SET(hadc->State,
 8002d0a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d0c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8002d10:	f023 0301 	bic.w	r3, r3, #1
 8002d14:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002d18:	62a3      	str	r3, [r4, #40]	; 0x28
                      HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
                      HAL_ADC_STATE_INJ_BUSY);
    
    /* Case of independent mode or multimode (for devices with several ADCs): */
    /* Set multimode state.                                                   */
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8002d1a:	6822      	ldr	r2, [r4, #0]
 8002d1c:	4b21      	ldr	r3, [pc, #132]	; (8002da4 <HAL_ADCEx_InjectedStart+0xb4>)
 8002d1e:	429a      	cmp	r2, r3
 8002d20:	d01f      	beq.n	8002d62 <HAL_ADCEx_InjectedStart+0x72>
    {
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8002d22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d24:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8002d28:	62a3      	str	r3, [r4, #40]	; 0x28
    
    /* Check if a regular conversion is ongoing */
    /* Note: On this device, there is no ADC error code fields related to     */
    /*       conversions on group injected only. In case of conversion on     */
    /*       going on group regular, no error code is reset.                  */
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 8002d2a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d2c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002d30:	d101      	bne.n	8002d36 <HAL_ADCEx_InjectedStart+0x46>
    {
      /* Reset ADC all error code fields */
      ADC_CLEAR_ERRORCODE(hadc);
 8002d32:	2300      	movs	r3, #0
 8002d34:	62e3      	str	r3, [r4, #44]	; 0x2c
    }
    
    /* Process unlocked */
    /* Unlock before starting ADC conversions: in case of potential           */
    /* interruption, to let the process to ADC IRQ Handler.                   */
    __HAL_UNLOCK(hadc);
 8002d36:	2300      	movs	r3, #0
 8002d38:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    
    /* Clear injected group conversion flag */
    /* (To ensure of no unknown state from potential previous ADC operations) */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
 8002d3c:	f06f 0304 	mvn.w	r3, #4
 8002d40:	6013      	str	r3, [r2, #0]
    /* If automatic injected conversion is enabled, conversion will start     */
    /* after next regular group conversion.                                   */
    /* Case of multimode enabled (for devices with several ADCs): if ADC is   */
    /* slave, ADC is enabled only (conversion is not started). If ADC is      */
    /* master, ADC is enabled and conversion is started.                      */
    if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO))
 8002d42:	6823      	ldr	r3, [r4, #0]
 8002d44:	685a      	ldr	r2, [r3, #4]
 8002d46:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8002d4a:	d127      	bne.n	8002d9c <HAL_ADCEx_InjectedStart+0xac>
    {
      if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
 8002d4c:	689a      	ldr	r2, [r3, #8]
 8002d4e:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
 8002d52:	f5b2 4fe0 	cmp.w	r2, #28672	; 0x7000
 8002d56:	d00f      	beq.n	8002d78 <HAL_ADCEx_InjectedStart+0x88>
        SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
      }
      else
      {
        /* Start ADC conversion on injected group with external trigger */
        SET_BIT(hadc->Instance->CR2, ADC_CR2_JEXTTRIG);
 8002d58:	689a      	ldr	r2, [r3, #8]
 8002d5a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002d5e:	609a      	str	r2, [r3, #8]
 8002d60:	e01c      	b.n	8002d9c <HAL_ADCEx_InjectedStart+0xac>
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8002d62:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 8002d66:	685b      	ldr	r3, [r3, #4]
 8002d68:	f413 2f70 	tst.w	r3, #983040	; 0xf0000
 8002d6c:	d0d9      	beq.n	8002d22 <HAL_ADCEx_InjectedStart+0x32>
      SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8002d6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d70:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002d74:	62a3      	str	r3, [r4, #40]	; 0x28
 8002d76:	e7d8      	b.n	8002d2a <HAL_ADCEx_InjectedStart+0x3a>
      if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
 8002d78:	4a0a      	ldr	r2, [pc, #40]	; (8002da4 <HAL_ADCEx_InjectedStart+0xb4>)
 8002d7a:	4293      	cmp	r3, r2
 8002d7c:	d004      	beq.n	8002d88 <HAL_ADCEx_InjectedStart+0x98>
        SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
 8002d7e:	689a      	ldr	r2, [r3, #8]
 8002d80:	f442 1202 	orr.w	r2, r2, #2129920	; 0x208000
 8002d84:	609a      	str	r2, [r3, #8]
 8002d86:	e009      	b.n	8002d9c <HAL_ADCEx_InjectedStart+0xac>
          ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
 8002d88:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 8002d8c:	6852      	ldr	r2, [r2, #4]
      if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
 8002d8e:	f412 2f70 	tst.w	r2, #983040	; 0xf0000
 8002d92:	d1e1      	bne.n	8002d58 <HAL_ADCEx_InjectedStart+0x68>
 8002d94:	e7f3      	b.n	8002d7e <HAL_ADCEx_InjectedStart+0x8e>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8002d96:	2300      	movs	r3, #0
 8002d98:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 8002d9c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8002d9e:	2002      	movs	r0, #2
}
 8002da0:	4770      	bx	lr
 8002da2:	bf00      	nop
 8002da4:	40012800 	.word	0x40012800

08002da8 <HAL_ADCEx_InjectedStop>:
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 8002da8:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002dac:	2b01      	cmp	r3, #1
 8002dae:	d023      	beq.n	8002df8 <HAL_ADCEx_InjectedStop+0x50>
{
 8002db0:	b510      	push	{r4, lr}
 8002db2:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002db4:	2301      	movs	r3, #1
 8002db6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  /* Conditioned to:                                                          */
  /* - No conversion on the other group (regular group) is intended to        */
  /*   continue (injected and regular groups stop conversion and ADC disable  */
  /*   are common)                                                            */
  /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
  if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
 8002dba:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002dbc:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002dc0:	d104      	bne.n	8002dcc <HAL_ADCEx_InjectedStop+0x24>
     HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
 8002dc2:	6803      	ldr	r3, [r0, #0]
 8002dc4:	685b      	ldr	r3, [r3, #4]
  if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
 8002dc6:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8002dca:	d008      	beq.n	8002dde <HAL_ADCEx_InjectedStop+0x36>
    }
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002dcc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002dce:	f043 0320 	orr.w	r3, r3, #32
 8002dd2:	62a3      	str	r3, [r4, #40]	; 0x28
      
    tmp_hal_status = HAL_ERROR;
 8002dd4:	2001      	movs	r0, #1
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002dd6:	2300      	movs	r3, #0
 8002dd8:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 8002ddc:	bd10      	pop	{r4, pc}
    tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8002dde:	f7ff fd71 	bl	80028c4 <ADC_ConversionStop_Disable>
    if (tmp_hal_status == HAL_OK)
 8002de2:	2800      	cmp	r0, #0
 8002de4:	d1f7      	bne.n	8002dd6 <HAL_ADCEx_InjectedStop+0x2e>
      ADC_STATE_CLR_SET(hadc->State,
 8002de6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002de8:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8002dec:	f023 0301 	bic.w	r3, r3, #1
 8002df0:	f043 0301 	orr.w	r3, r3, #1
 8002df4:	62a3      	str	r3, [r4, #40]	; 0x28
 8002df6:	e7ee      	b.n	8002dd6 <HAL_ADCEx_InjectedStop+0x2e>
  __HAL_LOCK(hadc);
 8002df8:	2002      	movs	r0, #2
}
 8002dfa:	4770      	bx	lr

08002dfc <HAL_ADCEx_InjectedPollForConversion>:
  * @param  hadc: ADC handle
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8002dfc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002dfe:	b083      	sub	sp, #12
 8002e00:	4605      	mov	r5, r0
 8002e02:	460c      	mov	r4, r1
  uint32_t tickstart;

  /* Variables for polling in case of scan mode enabled and polling for each  */
  /* conversion.                                                              */
  __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
 8002e04:	2300      	movs	r3, #0
 8002e06:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Get timeout */
  tickstart = HAL_GetTick();  
 8002e08:	f7ff f868 	bl	8001edc <HAL_GetTick>
 8002e0c:	4606      	mov	r6, r0
  /*    from ADC conversion time (selected sampling time + conversion time of */
  /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
  /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
  /*    As flag JEOC is not set after each conversion, no timeout status can  */
  /*    be set.                                                               */
  if ((hadc->Instance->JSQR & ADC_JSQR_JL) == RESET)
 8002e0e:	682b      	ldr	r3, [r5, #0]
 8002e10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002e12:	f413 1f40 	tst.w	r3, #3145728	; 0x300000
 8002e16:	d11c      	bne.n	8002e52 <HAL_ADCEx_InjectedPollForConversion+0x56>
  {
    /* Wait until End of Conversion flag is raised */
    while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
 8002e18:	682b      	ldr	r3, [r5, #0]
 8002e1a:	681b      	ldr	r3, [r3, #0]
 8002e1c:	f013 0f04 	tst.w	r3, #4
 8002e20:	d16e      	bne.n	8002f00 <HAL_ADCEx_InjectedPollForConversion+0x104>
    {
      /* Check if timeout is disabled (set to infinite wait) */
      if(Timeout != HAL_MAX_DELAY)
 8002e22:	f1b4 3fff 	cmp.w	r4, #4294967295
 8002e26:	d0f7      	beq.n	8002e18 <HAL_ADCEx_InjectedPollForConversion+0x1c>
      {
        if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
 8002e28:	b96c      	cbnz	r4, 8002e46 <HAL_ADCEx_InjectedPollForConversion+0x4a>
        {
          /* New check to avoid false timeout detection in case of preemption */
          if(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
 8002e2a:	682b      	ldr	r3, [r5, #0]
 8002e2c:	681b      	ldr	r3, [r3, #0]
 8002e2e:	f013 0f04 	tst.w	r3, #4
 8002e32:	d1f1      	bne.n	8002e18 <HAL_ADCEx_InjectedPollForConversion+0x1c>
          {
            /* Update ADC state machine to timeout */
            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8002e34:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002e36:	f043 0304 	orr.w	r3, r3, #4
 8002e3a:	62ab      	str	r3, [r5, #40]	; 0x28

            /* Process unlocked */
            __HAL_UNLOCK(hadc);
 8002e3c:	2300      	movs	r3, #0
 8002e3e:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24

            return HAL_TIMEOUT;
 8002e42:	2003      	movs	r0, #3
 8002e44:	e088      	b.n	8002f58 <HAL_ADCEx_InjectedPollForConversion+0x15c>
        if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
 8002e46:	f7ff f849 	bl	8001edc <HAL_GetTick>
 8002e4a:	1b80      	subs	r0, r0, r6
 8002e4c:	42a0      	cmp	r0, r4
 8002e4e:	d9e3      	bls.n	8002e18 <HAL_ADCEx_InjectedPollForConversion+0x1c>
 8002e50:	e7eb      	b.n	8002e2a <HAL_ADCEx_InjectedPollForConversion+0x2e>
    /* Replace polling by wait for maximum conversion time */
    /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
    /*    and ADC maximum conversion cycles on all channels.                  */
    /*  - Wait for the expected ADC clock cycles delay                        */
    Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
                                          / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
 8002e52:	4b44      	ldr	r3, [pc, #272]	; (8002f64 <HAL_ADCEx_InjectedPollForConversion+0x168>)
 8002e54:	681f      	ldr	r7, [r3, #0]
 8002e56:	2002      	movs	r0, #2
 8002e58:	f001 fe86 	bl	8004b68 <HAL_RCCEx_GetPeriphCLKFreq>
 8002e5c:	fbb7 f0f0 	udiv	r0, r7, r0
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 8002e60:	682b      	ldr	r3, [r5, #0]
 8002e62:	6919      	ldr	r1, [r3, #16]
 8002e64:	4a40      	ldr	r2, [pc, #256]	; (8002f68 <HAL_ADCEx_InjectedPollForConversion+0x16c>)
 8002e66:	4211      	tst	r1, r2
 8002e68:	d10e      	bne.n	8002e88 <HAL_ADCEx_InjectedPollForConversion+0x8c>
 8002e6a:	68d9      	ldr	r1, [r3, #12]
 8002e6c:	f102 425c 	add.w	r2, r2, #3690987520	; 0xdc000000
 8002e70:	4211      	tst	r1, r2
 8002e72:	d109      	bne.n	8002e88 <HAL_ADCEx_InjectedPollForConversion+0x8c>
 8002e74:	6919      	ldr	r1, [r3, #16]
 8002e76:	4a3d      	ldr	r2, [pc, #244]	; (8002f6c <HAL_ADCEx_InjectedPollForConversion+0x170>)
 8002e78:	4211      	tst	r1, r2
 8002e7a:	d118      	bne.n	8002eae <HAL_ADCEx_InjectedPollForConversion+0xb2>
 8002e7c:	68da      	ldr	r2, [r3, #12]
 8002e7e:	4b3c      	ldr	r3, [pc, #240]	; (8002f70 <HAL_ADCEx_InjectedPollForConversion+0x174>)
 8002e80:	421a      	tst	r2, r3
 8002e82:	d016      	beq.n	8002eb2 <HAL_ADCEx_InjectedPollForConversion+0xb6>
 8002e84:	2729      	movs	r7, #41	; 0x29
 8002e86:	e019      	b.n	8002ebc <HAL_ADCEx_InjectedPollForConversion+0xc0>
 8002e88:	6919      	ldr	r1, [r3, #16]
 8002e8a:	4a38      	ldr	r2, [pc, #224]	; (8002f6c <HAL_ADCEx_InjectedPollForConversion+0x170>)
 8002e8c:	4211      	tst	r1, r2
 8002e8e:	d104      	bne.n	8002e9a <HAL_ADCEx_InjectedPollForConversion+0x9e>
 8002e90:	68d9      	ldr	r1, [r3, #12]
 8002e92:	f102 426e 	add.w	r2, r2, #3992977408	; 0xee000000
 8002e96:	4211      	tst	r1, r2
 8002e98:	d00d      	beq.n	8002eb6 <HAL_ADCEx_InjectedPollForConversion+0xba>
 8002e9a:	6919      	ldr	r1, [r3, #16]
 8002e9c:	4a35      	ldr	r2, [pc, #212]	; (8002f74 <HAL_ADCEx_InjectedPollForConversion+0x178>)
 8002e9e:	400a      	ands	r2, r1
 8002ea0:	b95a      	cbnz	r2, 8002eba <HAL_ADCEx_InjectedPollForConversion+0xbe>
 8002ea2:	68da      	ldr	r2, [r3, #12]
 8002ea4:	4b33      	ldr	r3, [pc, #204]	; (8002f74 <HAL_ADCEx_InjectedPollForConversion+0x178>)
 8002ea6:	4013      	ands	r3, r2
 8002ea8:	b15b      	cbz	r3, 8002ec2 <HAL_ADCEx_InjectedPollForConversion+0xc6>
 8002eaa:	27fc      	movs	r7, #252	; 0xfc
 8002eac:	e006      	b.n	8002ebc <HAL_ADCEx_InjectedPollForConversion+0xc0>
 8002eae:	2729      	movs	r7, #41	; 0x29
 8002eb0:	e004      	b.n	8002ebc <HAL_ADCEx_InjectedPollForConversion+0xc0>
 8002eb2:	2714      	movs	r7, #20
 8002eb4:	e002      	b.n	8002ebc <HAL_ADCEx_InjectedPollForConversion+0xc0>
 8002eb6:	2754      	movs	r7, #84	; 0x54
 8002eb8:	e000      	b.n	8002ebc <HAL_ADCEx_InjectedPollForConversion+0xc0>
 8002eba:	27fc      	movs	r7, #252	; 0xfc
    Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
 8002ebc:	fb07 f700 	mul.w	r7, r7, r0
    
    while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 8002ec0:	e007      	b.n	8002ed2 <HAL_ADCEx_InjectedPollForConversion+0xd6>
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 8002ec2:	2754      	movs	r7, #84	; 0x54
 8002ec4:	e7fa      	b.n	8002ebc <HAL_ADCEx_InjectedPollForConversion+0xc0>
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
        {
          /* New check to avoid false timeout detection in case of preemption */
          if(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 8002ec6:	9b01      	ldr	r3, [sp, #4]
 8002ec8:	42bb      	cmp	r3, r7
 8002eca:	d310      	bcc.n	8002eee <HAL_ADCEx_InjectedPollForConversion+0xf2>

            return HAL_TIMEOUT;
          }
        }
      }
      Conversion_Timeout_CPU_cycles ++;
 8002ecc:	9b01      	ldr	r3, [sp, #4]
 8002ece:	3301      	adds	r3, #1
 8002ed0:	9301      	str	r3, [sp, #4]
    while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 8002ed2:	9b01      	ldr	r3, [sp, #4]
 8002ed4:	42bb      	cmp	r3, r7
 8002ed6:	d213      	bcs.n	8002f00 <HAL_ADCEx_InjectedPollForConversion+0x104>
      if(Timeout != HAL_MAX_DELAY)
 8002ed8:	f1b4 3fff 	cmp.w	r4, #4294967295
 8002edc:	d0f6      	beq.n	8002ecc <HAL_ADCEx_InjectedPollForConversion+0xd0>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002ede:	2c00      	cmp	r4, #0
 8002ee0:	d0f1      	beq.n	8002ec6 <HAL_ADCEx_InjectedPollForConversion+0xca>
 8002ee2:	f7fe fffb 	bl	8001edc <HAL_GetTick>
 8002ee6:	1b80      	subs	r0, r0, r6
 8002ee8:	42a0      	cmp	r0, r4
 8002eea:	d9ef      	bls.n	8002ecc <HAL_ADCEx_InjectedPollForConversion+0xd0>
 8002eec:	e7eb      	b.n	8002ec6 <HAL_ADCEx_InjectedPollForConversion+0xca>
            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8002eee:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002ef0:	f043 0304 	orr.w	r3, r3, #4
 8002ef4:	62ab      	str	r3, [r5, #40]	; 0x28
            __HAL_UNLOCK(hadc);
 8002ef6:	2300      	movs	r3, #0
 8002ef8:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
            return HAL_TIMEOUT;
 8002efc:	2003      	movs	r0, #3
 8002efe:	e02b      	b.n	8002f58 <HAL_ADCEx_InjectedPollForConversion+0x15c>
  }

  /* Clear injected group conversion flag */
  /* Note: On STM32F1 ADC, clear regular conversion flag raised               */
  /* simultaneously.                                                          */
  __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC | ADC_FLAG_EOC);
 8002f00:	682b      	ldr	r3, [r5, #0]
 8002f02:	f06f 020e 	mvn.w	r2, #14
 8002f06:	601a      	str	r2, [r3, #0]
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8002f08:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002f0a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002f0e:	62ab      	str	r3, [r5, #40]	; 0x28
  
  /* Determine whether any further conversion upcoming on group injected      */
  /* by external trigger or by automatic injected conversion                  */
  /* from group regular.                                                      */
  if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
 8002f10:	682a      	ldr	r2, [r5, #0]
 8002f12:	6893      	ldr	r3, [r2, #8]
 8002f14:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8002f18:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
 8002f1c:	d00d      	beq.n	8002f3a <HAL_ADCEx_InjectedPollForConversion+0x13e>
     (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
 8002f1e:	6853      	ldr	r3, [r2, #4]
  if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
 8002f20:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8002f24:	d117      	bne.n	8002f56 <HAL_ADCEx_InjectedPollForConversion+0x15a>
     (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
 8002f26:	6893      	ldr	r3, [r2, #8]
 8002f28:	f403 2360 	and.w	r3, r3, #917504	; 0xe0000
     (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
 8002f2c:	f5b3 2f60 	cmp.w	r3, #917504	; 0xe0000
 8002f30:	d001      	beq.n	8002f36 <HAL_ADCEx_InjectedPollForConversion+0x13a>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
    }
  }
  
  /* Return ADC state */
  return HAL_OK;
 8002f32:	2000      	movs	r0, #0
 8002f34:	e010      	b.n	8002f58 <HAL_ADCEx_InjectedPollForConversion+0x15c>
      (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
 8002f36:	7b2b      	ldrb	r3, [r5, #12]
     (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
 8002f38:	b983      	cbnz	r3, 8002f5c <HAL_ADCEx_InjectedPollForConversion+0x160>
    CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
 8002f3a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002f3c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8002f40:	62ab      	str	r3, [r5, #40]	; 0x28
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 8002f42:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002f44:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002f48:	d10a      	bne.n	8002f60 <HAL_ADCEx_InjectedPollForConversion+0x164>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8002f4a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002f4c:	f043 0301 	orr.w	r3, r3, #1
 8002f50:	62ab      	str	r3, [r5, #40]	; 0x28
  return HAL_OK;
 8002f52:	2000      	movs	r0, #0
 8002f54:	e000      	b.n	8002f58 <HAL_ADCEx_InjectedPollForConversion+0x15c>
 8002f56:	2000      	movs	r0, #0
}
 8002f58:	b003      	add	sp, #12
 8002f5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return HAL_OK;
 8002f5c:	2000      	movs	r0, #0
 8002f5e:	e7fb      	b.n	8002f58 <HAL_ADCEx_InjectedPollForConversion+0x15c>
 8002f60:	2000      	movs	r0, #0
 8002f62:	e7f9      	b.n	8002f58 <HAL_ADCEx_InjectedPollForConversion+0x15c>
 8002f64:	20000028 	.word	0x20000028
 8002f68:	24924924 	.word	0x24924924
 8002f6c:	12492492 	.word	0x12492492
 8002f70:	00492492 	.word	0x00492492
 8002f74:	00249249 	.word	0x00249249

08002f78 <HAL_ADCEx_InjectedStart_IT>:
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8002f78:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8002f7c:	2b01      	cmp	r3, #1
 8002f7e:	d057      	beq.n	8003030 <HAL_ADCEx_InjectedStart_IT+0xb8>
{
 8002f80:	b510      	push	{r4, lr}
 8002f82:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002f84:	2301      	movs	r3, #1
 8002f86:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    
  /* Enable the ADC peripheral */
  tmp_hal_status = ADC_Enable(hadc);
 8002f8a:	f7ff fad3 	bl	8002534 <ADC_Enable>
  
  /* Start conversion if ADC is effectively enabled */
  if (tmp_hal_status == HAL_OK)
 8002f8e:	2800      	cmp	r0, #0
 8002f90:	d14a      	bne.n	8003028 <HAL_ADCEx_InjectedStart_IT+0xb0>
  {
    /* Set ADC state                                                          */
    /* - Clear state bitfield related to injected group conversion results    */
    /* - Set state bitfield related to injected operation                     */
    ADC_STATE_CLR_SET(hadc->State,
 8002f92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002f94:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8002f98:	f023 0301 	bic.w	r3, r3, #1
 8002f9c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002fa0:	62a3      	str	r3, [r4, #40]	; 0x28
                      HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
                      HAL_ADC_STATE_INJ_BUSY);
    
    /* Case of independent mode or multimode (for devices with several ADCs): */
    /* Set multimode state.                                                   */
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8002fa2:	6822      	ldr	r2, [r4, #0]
 8002fa4:	4b23      	ldr	r3, [pc, #140]	; (8003034 <HAL_ADCEx_InjectedStart_IT+0xbc>)
 8002fa6:	429a      	cmp	r2, r3
 8002fa8:	d024      	beq.n	8002ff4 <HAL_ADCEx_InjectedStart_IT+0x7c>
    {
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8002faa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002fac:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8002fb0:	62a3      	str	r3, [r4, #40]	; 0x28
    
    /* Check if a regular conversion is ongoing */
    /* Note: On this device, there is no ADC error code fields related to     */
    /*       conversions on group injected only. In case of conversion on     */
    /*       going on group regular, no error code is reset.                  */
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 8002fb2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002fb4:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002fb8:	d101      	bne.n	8002fbe <HAL_ADCEx_InjectedStart_IT+0x46>
    {
      /* Reset ADC all error code fields */
      ADC_CLEAR_ERRORCODE(hadc);
 8002fba:	2300      	movs	r3, #0
 8002fbc:	62e3      	str	r3, [r4, #44]	; 0x2c
    }
    
    /* Process unlocked */
    /* Unlock before starting ADC conversions: in case of potential           */
    /* interruption, to let the process to ADC IRQ Handler.                   */
    __HAL_UNLOCK(hadc);
 8002fbe:	2300      	movs	r3, #0
 8002fc0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    
    /* Clear injected group conversion flag */
    /* (To ensure of no unknown state from potential previous ADC operations) */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
 8002fc4:	f06f 0304 	mvn.w	r3, #4
 8002fc8:	6013      	str	r3, [r2, #0]
    
    /* Enable end of conversion interrupt for injected channels */
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
 8002fca:	6822      	ldr	r2, [r4, #0]
 8002fcc:	6853      	ldr	r3, [r2, #4]
 8002fce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002fd2:	6053      	str	r3, [r2, #4]
    /* and if automatic injected conversion is disabled.                      */
    /* If external trigger has been selected, conversion will start at next   */
    /* trigger event.                                                         */
    /* If automatic injected conversion is enabled, conversion will start     */
    /* after next regular group conversion.                                   */
    if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO))
 8002fd4:	6823      	ldr	r3, [r4, #0]
 8002fd6:	685a      	ldr	r2, [r3, #4]
 8002fd8:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8002fdc:	d127      	bne.n	800302e <HAL_ADCEx_InjectedStart_IT+0xb6>
    {
      if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
 8002fde:	689a      	ldr	r2, [r3, #8]
 8002fe0:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
 8002fe4:	f5b2 4fe0 	cmp.w	r2, #28672	; 0x7000
 8002fe8:	d00f      	beq.n	800300a <HAL_ADCEx_InjectedStart_IT+0x92>
        SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
      }
      else
      {
        /* Start ADC conversion on injected group with external trigger */
        SET_BIT(hadc->Instance->CR2, ADC_CR2_JEXTTRIG);
 8002fea:	689a      	ldr	r2, [r3, #8]
 8002fec:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002ff0:	609a      	str	r2, [r3, #8]
 8002ff2:	e01c      	b.n	800302e <HAL_ADCEx_InjectedStart_IT+0xb6>
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8002ff4:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 8002ff8:	685b      	ldr	r3, [r3, #4]
 8002ffa:	f413 2f70 	tst.w	r3, #983040	; 0xf0000
 8002ffe:	d0d4      	beq.n	8002faa <HAL_ADCEx_InjectedStart_IT+0x32>
      SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8003000:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003002:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003006:	62a3      	str	r3, [r4, #40]	; 0x28
 8003008:	e7d3      	b.n	8002fb2 <HAL_ADCEx_InjectedStart_IT+0x3a>
      if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
 800300a:	4a0a      	ldr	r2, [pc, #40]	; (8003034 <HAL_ADCEx_InjectedStart_IT+0xbc>)
 800300c:	4293      	cmp	r3, r2
 800300e:	d004      	beq.n	800301a <HAL_ADCEx_InjectedStart_IT+0xa2>
        SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
 8003010:	689a      	ldr	r2, [r3, #8]
 8003012:	f442 1202 	orr.w	r2, r2, #2129920	; 0x208000
 8003016:	609a      	str	r2, [r3, #8]
 8003018:	e009      	b.n	800302e <HAL_ADCEx_InjectedStart_IT+0xb6>
          ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
 800301a:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 800301e:	6852      	ldr	r2, [r2, #4]
      if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
 8003020:	f412 2f70 	tst.w	r2, #983040	; 0xf0000
 8003024:	d1e1      	bne.n	8002fea <HAL_ADCEx_InjectedStart_IT+0x72>
 8003026:	e7f3      	b.n	8003010 <HAL_ADCEx_InjectedStart_IT+0x98>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8003028:	2300      	movs	r3, #0
 800302a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 800302e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8003030:	2002      	movs	r0, #2
}
 8003032:	4770      	bx	lr
 8003034:	40012800 	.word	0x40012800

08003038 <HAL_ADCEx_InjectedStop_IT>:
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 8003038:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 800303c:	2b01      	cmp	r3, #1
 800303e:	d028      	beq.n	8003092 <HAL_ADCEx_InjectedStop_IT+0x5a>
{
 8003040:	b510      	push	{r4, lr}
 8003042:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8003044:	2301      	movs	r3, #1
 8003046:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  /* Conditioned to:                                                          */
  /* - No conversion on the other group (regular group) is intended to        */
  /*   continue (injected and regular groups stop conversion and ADC disable  */
  /*   are common)                                                            */
  /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
  if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
 800304a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800304c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8003050:	d104      	bne.n	800305c <HAL_ADCEx_InjectedStop_IT+0x24>
     HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
 8003052:	6803      	ldr	r3, [r0, #0]
 8003054:	685b      	ldr	r3, [r3, #4]
  if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
 8003056:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800305a:	d008      	beq.n	800306e <HAL_ADCEx_InjectedStop_IT+0x36>
    }
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800305c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800305e:	f043 0320 	orr.w	r3, r3, #32
 8003062:	62a3      	str	r3, [r4, #40]	; 0x28
      
    tmp_hal_status = HAL_ERROR;
 8003064:	2001      	movs	r0, #1
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003066:	2300      	movs	r3, #0
 8003068:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 800306c:	bd10      	pop	{r4, pc}
    tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 800306e:	f7ff fc29 	bl	80028c4 <ADC_ConversionStop_Disable>
    if (tmp_hal_status == HAL_OK)
 8003072:	2800      	cmp	r0, #0
 8003074:	d1f7      	bne.n	8003066 <HAL_ADCEx_InjectedStop_IT+0x2e>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 8003076:	6822      	ldr	r2, [r4, #0]
 8003078:	6853      	ldr	r3, [r2, #4]
 800307a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800307e:	6053      	str	r3, [r2, #4]
      ADC_STATE_CLR_SET(hadc->State,
 8003080:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003082:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8003086:	f023 0301 	bic.w	r3, r3, #1
 800308a:	f043 0301 	orr.w	r3, r3, #1
 800308e:	62a3      	str	r3, [r4, #40]	; 0x28
 8003090:	e7e9      	b.n	8003066 <HAL_ADCEx_InjectedStop_IT+0x2e>
  __HAL_LOCK(hadc);
 8003092:	2002      	movs	r0, #2
}
 8003094:	4770      	bx	lr

08003096 <HAL_ADCEx_MultiModeStart_DMA>:
  * @param  pData: The destination Buffer address.
  * @param  Length: The length of data to be transferred from ADC peripheral to memory.
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
{
 8003096:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003098:	b08d      	sub	sp, #52	; 0x34
 800309a:	4604      	mov	r4, r0
 800309c:	460d      	mov	r5, r1
 800309e:	4617      	mov	r7, r2
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  ADC_HandleTypeDef tmphadcSlave={0};
 80030a0:	2230      	movs	r2, #48	; 0x30
 80030a2:	2100      	movs	r1, #0
 80030a4:	4668      	mov	r0, sp
 80030a6:	f00c fd01 	bl	800faac <memset>
  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80030aa:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80030ae:	2b01      	cmp	r3, #1
 80030b0:	d065      	beq.n	800317e <HAL_ADCEx_MultiModeStart_DMA+0xe8>
 80030b2:	2301      	movs	r3, #1
 80030b4:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24

  /* Set a temporary handle of the ADC slave associated to the ADC master     */
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80030b8:	4b32      	ldr	r3, [pc, #200]	; (8003184 <HAL_ADCEx_MultiModeStart_DMA+0xee>)
 80030ba:	9300      	str	r3, [sp, #0]
  
  /* On STM32F1 devices, ADC slave regular group must be configured with      */
  /* conversion trigger ADC_SOFTWARE_START.                                   */
  /* Note: External trigger of ADC slave must be enabled, it is already done  */
  /*       into function "HAL_ADC_Init()".                                    */
  if(!ADC_IS_SOFTWARE_START_REGULAR(&tmphadcSlave))  
 80030bc:	689b      	ldr	r3, [r3, #8]
 80030be:	f403 2360 	and.w	r3, r3, #917504	; 0xe0000
 80030c2:	f5b3 2f60 	cmp.w	r3, #917504	; 0xe0000
 80030c6:	d00a      	beq.n	80030de <HAL_ADCEx_MultiModeStart_DMA+0x48>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80030c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80030ca:	f043 0320 	orr.w	r3, r3, #32
 80030ce:	62a3      	str	r3, [r4, #40]	; 0x28
    
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 80030d0:	2300      	movs	r3, #0
 80030d2:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    
    return HAL_ERROR;
 80030d6:	2601      	movs	r6, #1
    __HAL_UNLOCK(hadc);
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 80030d8:	4630      	mov	r0, r6
 80030da:	b00d      	add	sp, #52	; 0x34
 80030dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  tmp_hal_status = ADC_Enable(hadc);
 80030de:	4620      	mov	r0, r4
 80030e0:	f7ff fa28 	bl	8002534 <ADC_Enable>
  if (tmp_hal_status == HAL_OK)
 80030e4:	4606      	mov	r6, r0
 80030e6:	2800      	cmp	r0, #0
 80030e8:	d03b      	beq.n	8003162 <HAL_ADCEx_MultiModeStart_DMA+0xcc>
  if (tmp_hal_status == HAL_OK)
 80030ea:	2e00      	cmp	r6, #0
 80030ec:	d143      	bne.n	8003176 <HAL_ADCEx_MultiModeStart_DMA+0xe0>
    ADC_STATE_CLR_SET(hadc->State,
 80030ee:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80030f0:	4b25      	ldr	r3, [pc, #148]	; (8003188 <HAL_ADCEx_MultiModeStart_DMA+0xf2>)
 80030f2:	4013      	ands	r3, r2
 80030f4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80030f8:	62a3      	str	r3, [r4, #40]	; 0x28
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80030fa:	6823      	ldr	r3, [r4, #0]
 80030fc:	685b      	ldr	r3, [r3, #4]
 80030fe:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8003102:	d005      	beq.n	8003110 <HAL_ADCEx_MultiModeStart_DMA+0x7a>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 8003104:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003106:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800310a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800310e:	62a3      	str	r3, [r4, #40]	; 0x28
    __HAL_UNLOCK(hadc);
 8003110:	2300      	movs	r3, #0
 8003112:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    ADC_CLEAR_ERRORCODE(hadc);
 8003116:	62e3      	str	r3, [r4, #44]	; 0x2c
    hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8003118:	6a23      	ldr	r3, [r4, #32]
 800311a:	4a1c      	ldr	r2, [pc, #112]	; (800318c <HAL_ADCEx_MultiModeStart_DMA+0xf6>)
 800311c:	629a      	str	r2, [r3, #40]	; 0x28
    hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800311e:	6a23      	ldr	r3, [r4, #32]
 8003120:	4a1b      	ldr	r2, [pc, #108]	; (8003190 <HAL_ADCEx_MultiModeStart_DMA+0xfa>)
 8003122:	62da      	str	r2, [r3, #44]	; 0x2c
    hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8003124:	6a23      	ldr	r3, [r4, #32]
 8003126:	4a1b      	ldr	r2, [pc, #108]	; (8003194 <HAL_ADCEx_MultiModeStart_DMA+0xfe>)
 8003128:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
 800312a:	6823      	ldr	r3, [r4, #0]
 800312c:	f06f 0202 	mvn.w	r2, #2
 8003130:	601a      	str	r2, [r3, #0]
    SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
 8003132:	6822      	ldr	r2, [r4, #0]
 8003134:	6893      	ldr	r3, [r2, #8]
 8003136:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800313a:	6093      	str	r3, [r2, #8]
    HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 800313c:	6821      	ldr	r1, [r4, #0]
 800313e:	463b      	mov	r3, r7
 8003140:	462a      	mov	r2, r5
 8003142:	314c      	adds	r1, #76	; 0x4c
 8003144:	6a20      	ldr	r0, [r4, #32]
 8003146:	f000 fb8b 	bl	8003860 <HAL_DMA_Start_IT>
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
 800314a:	6823      	ldr	r3, [r4, #0]
 800314c:	689a      	ldr	r2, [r3, #8]
 800314e:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 8003152:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 8003156:	d009      	beq.n	800316c <HAL_ADCEx_MultiModeStart_DMA+0xd6>
      SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
 8003158:	689a      	ldr	r2, [r3, #8]
 800315a:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800315e:	609a      	str	r2, [r3, #8]
 8003160:	e7ba      	b.n	80030d8 <HAL_ADCEx_MultiModeStart_DMA+0x42>
    tmp_hal_status = ADC_Enable(&tmphadcSlave);
 8003162:	4668      	mov	r0, sp
 8003164:	f7ff f9e6 	bl	8002534 <ADC_Enable>
 8003168:	4606      	mov	r6, r0
 800316a:	e7be      	b.n	80030ea <HAL_ADCEx_MultiModeStart_DMA+0x54>
      SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
 800316c:	689a      	ldr	r2, [r3, #8]
 800316e:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
 8003172:	609a      	str	r2, [r3, #8]
 8003174:	e7b0      	b.n	80030d8 <HAL_ADCEx_MultiModeStart_DMA+0x42>
    __HAL_UNLOCK(hadc);
 8003176:	2300      	movs	r3, #0
 8003178:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 800317c:	e7ac      	b.n	80030d8 <HAL_ADCEx_MultiModeStart_DMA+0x42>
  __HAL_LOCK(hadc);
 800317e:	2602      	movs	r6, #2
 8003180:	e7aa      	b.n	80030d8 <HAL_ADCEx_MultiModeStart_DMA+0x42>
 8003182:	bf00      	nop
 8003184:	40012800 	.word	0x40012800
 8003188:	ffeffcfe 	.word	0xffeffcfe
 800318c:	0800220d 	.word	0x0800220d
 8003190:	08002261 	.word	0x08002261
 8003194:	0800237b 	.word	0x0800237b

08003198 <HAL_ADCEx_MultiModeStop_DMA>:
  *         ADC slave, to properly disable the DMA channel.
  * @param  hadc: ADC handle of ADC master (handle of ADC slave must not be used)
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
{
 8003198:	b510      	push	{r4, lr}
 800319a:	b08c      	sub	sp, #48	; 0x30
 800319c:	4604      	mov	r4, r0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  ADC_HandleTypeDef tmphadcSlave={0};
 800319e:	2230      	movs	r2, #48	; 0x30
 80031a0:	2100      	movs	r1, #0
 80031a2:	4668      	mov	r0, sp
 80031a4:	f00c fc82 	bl	800faac <memset>
  
  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80031a8:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80031ac:	2b01      	cmp	r3, #1
 80031ae:	d030      	beq.n	8003212 <HAL_ADCEx_MultiModeStop_DMA+0x7a>
 80031b0:	2301      	movs	r3, #1
 80031b2:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24

  /* Stop potential conversion on going, on regular and injected groups */
  /* Disable ADC master peripheral */
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 80031b6:	4620      	mov	r0, r4
 80031b8:	f7ff fb84 	bl	80028c4 <ADC_ConversionStop_Disable>
  
  /* Check if ADC is effectively disabled */
  if(tmp_hal_status == HAL_OK)
 80031bc:	b120      	cbz	r0, 80031c8 <HAL_ADCEx_MultiModeStop_DMA+0x30>
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_READY);
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80031be:	2300      	movs	r3, #0
 80031c0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 80031c4:	b00c      	add	sp, #48	; 0x30
 80031c6:	bd10      	pop	{r4, pc}
    ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80031c8:	4b13      	ldr	r3, [pc, #76]	; (8003218 <HAL_ADCEx_MultiModeStop_DMA+0x80>)
 80031ca:	9300      	str	r3, [sp, #0]
    tmp_hal_status = ADC_ConversionStop_Disable(&tmphadcSlave);
 80031cc:	4668      	mov	r0, sp
 80031ce:	f7ff fb79 	bl	80028c4 <ADC_ConversionStop_Disable>
    if(tmp_hal_status != HAL_OK)
 80031d2:	b140      	cbz	r0, 80031e6 <HAL_ADCEx_MultiModeStop_DMA+0x4e>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80031d4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80031d6:	f043 0310 	orr.w	r3, r3, #16
 80031da:	62a3      	str	r3, [r4, #40]	; 0x28
      __HAL_UNLOCK(hadc);
 80031dc:	2300      	movs	r3, #0
 80031de:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      return HAL_ERROR;
 80031e2:	2001      	movs	r0, #1
 80031e4:	e7ee      	b.n	80031c4 <HAL_ADCEx_MultiModeStop_DMA+0x2c>
    CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
 80031e6:	6822      	ldr	r2, [r4, #0]
 80031e8:	6893      	ldr	r3, [r2, #8]
 80031ea:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80031ee:	6093      	str	r3, [r2, #8]
    CLEAR_BIT(hadc->Instance->CR1, ADC_CR1_DUALMOD);
 80031f0:	6822      	ldr	r2, [r4, #0]
 80031f2:	6853      	ldr	r3, [r2, #4]
 80031f4:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 80031f8:	6053      	str	r3, [r2, #4]
    tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
 80031fa:	6a20      	ldr	r0, [r4, #32]
 80031fc:	f000 fb6a 	bl	80038d4 <HAL_DMA_Abort>
    ADC_STATE_CLR_SET(hadc->State,
 8003200:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003202:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8003206:	f023 0301 	bic.w	r3, r3, #1
 800320a:	f043 0301 	orr.w	r3, r3, #1
 800320e:	62a3      	str	r3, [r4, #40]	; 0x28
 8003210:	e7d5      	b.n	80031be <HAL_ADCEx_MultiModeStop_DMA+0x26>
  __HAL_LOCK(hadc);
 8003212:	2002      	movs	r0, #2
 8003214:	e7d6      	b.n	80031c4 <HAL_ADCEx_MultiModeStop_DMA+0x2c>
 8003216:	bf00      	nop
 8003218:	40012800 	.word	0x40012800

0800321c <HAL_ADCEx_InjectedGetValue>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
  
  /* Get ADC converted value */ 
  switch(InjectedRank)
 800321c:	2903      	cmp	r1, #3
 800321e:	d009      	beq.n	8003234 <HAL_ADCEx_InjectedGetValue+0x18>
 8003220:	2904      	cmp	r1, #4
 8003222:	d004      	beq.n	800322e <HAL_ADCEx_InjectedGetValue+0x12>
 8003224:	2902      	cmp	r1, #2
 8003226:	d008      	beq.n	800323a <HAL_ADCEx_InjectedGetValue+0x1e>
    case ADC_INJECTED_RANK_2: 
      tmp_jdr = hadc->Instance->JDR2;
      break;
    case ADC_INJECTED_RANK_1:
    default:
      tmp_jdr = hadc->Instance->JDR1;
 8003228:	6803      	ldr	r3, [r0, #0]
 800322a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
      break;
  }
  
  /* Return ADC converted value */ 
  return tmp_jdr;
}
 800322c:	4770      	bx	lr
      tmp_jdr = hadc->Instance->JDR4;
 800322e:	6803      	ldr	r3, [r0, #0]
 8003230:	6c98      	ldr	r0, [r3, #72]	; 0x48
      break;
 8003232:	4770      	bx	lr
      tmp_jdr = hadc->Instance->JDR3;
 8003234:	6803      	ldr	r3, [r0, #0]
 8003236:	6c58      	ldr	r0, [r3, #68]	; 0x44
      break;
 8003238:	4770      	bx	lr
      tmp_jdr = hadc->Instance->JDR2;
 800323a:	6803      	ldr	r3, [r0, #0]
 800323c:	6c18      	ldr	r0, [r3, #64]	; 0x40
      break;
 800323e:	4770      	bx	lr

08003240 <HAL_ADCEx_MultiModeGetValue>:
  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* On STM32F1 devices, ADC1 data register DR contains ADC2 conversions      */
  /* only if ADC1 DMA mode is enabled.                                        */
  tmpDR = hadc->Instance->DR;
 8003240:	6803      	ldr	r3, [r0, #0]
 8003242:	6cd8      	ldr	r0, [r3, #76]	; 0x4c

  if (HAL_IS_BIT_CLR(ADC1->CR2, ADC_CR2_DMA))
 8003244:	4b04      	ldr	r3, [pc, #16]	; (8003258 <HAL_ADCEx_MultiModeGetValue+0x18>)
 8003246:	689b      	ldr	r3, [r3, #8]
 8003248:	f413 7f80 	tst.w	r3, #256	; 0x100
 800324c:	d103      	bne.n	8003256 <HAL_ADCEx_MultiModeGetValue+0x16>
  {
    tmpDR |= (ADC2->DR << 16U);
 800324e:	4b03      	ldr	r3, [pc, #12]	; (800325c <HAL_ADCEx_MultiModeGetValue+0x1c>)
 8003250:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003252:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
  }
    
  /* Return ADC converted value */ 
  return tmpDR;
}
 8003256:	4770      	bx	lr
 8003258:	40012400 	.word	0x40012400
 800325c:	40012800 	.word	0x40012800

08003260 <HAL_ADCEx_InjectedConvCpltCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
  */
}
 8003260:	4770      	bx	lr

08003262 <HAL_ADCEx_InjectedConfigChannel>:
  * @param  sConfigInjected: Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval None
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
{
 8003262:	b4f0      	push	{r4, r5, r6, r7}
 8003264:	b082      	sub	sp, #8
 8003266:	4603      	mov	r3, r0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  __IO uint32_t wait_loop_index = 0U;
 8003268:	2200      	movs	r2, #0
 800326a:	9201      	str	r2, [sp, #4]
  assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
  assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
  assert_param(IS_ADC_EXTTRIGINJEC(sConfigInjected->ExternalTrigInjecConv));
  assert_param(IS_ADC_RANGE(sConfigInjected->InjectedOffset));
  
  if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 800326c:	6880      	ldr	r0, [r0, #8]
    assert_param(IS_ADC_INJECTED_NB_CONV(sConfigInjected->InjectedNbrOfConversion));
    assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 800326e:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8003272:	2a01      	cmp	r2, #1
 8003274:	f000 80fc 	beq.w	8003470 <HAL_ADCEx_InjectedConfigChannel+0x20e>
 8003278:	2201      	movs	r2, #1
 800327a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  /*   Note: Scan mode is present by hardware on this device and, if          */
  /*   disabled, discards automatically nb of conversions. Anyway, nb of      */
  /*   conversions is forced to 0x00 for alignment over all STM32 devices.    */
  /* - if scan mode is enabled, injected channels sequence length is set to   */
  /*   parameter "InjectedNbrOfConversion".                                   */
  if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 800327e:	2800      	cmp	r0, #0
 8003280:	d14c      	bne.n	800331c <HAL_ADCEx_InjectedConfigChannel+0xba>
  {
    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 8003282:	684a      	ldr	r2, [r1, #4]
 8003284:	2a01      	cmp	r2, #1
 8003286:	d03f      	beq.n	8003308 <HAL_ADCEx_InjectedConfigChannel+0xa6>
    /* If another injected rank than rank1 was intended to be set, and could  */
    /* not due to ScanConvMode disabled, error is reported.                   */
    else
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003288:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800328a:	f042 0220 	orr.w	r2, r2, #32
 800328e:	629a      	str	r2, [r3, #40]	; 0x28
      
      tmp_hal_status = HAL_ERROR;
 8003290:	2001      	movs	r0, #1
  /* Parameters update not conditioned to ADC state:                          */
  /*  - Automatic injected conversion                                         */
  /*  - Injected discontinuous mode                                           */
  /* Note: In case of ADC already enabled, caution to not launch an unwanted  */
  /*       conversion while modifying register CR2 by writing 1 to bit ADON.  */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8003292:	681c      	ldr	r4, [r3, #0]
 8003294:	68a2      	ldr	r2, [r4, #8]
 8003296:	f012 0f01 	tst.w	r2, #1
 800329a:	d107      	bne.n	80032ac <HAL_ADCEx_InjectedConfigChannel+0x4a>
  {    
    MODIFY_REG(hadc->Instance->CR2                                           ,
 800329c:	68a2      	ldr	r2, [r4, #8]
 800329e:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 80032a2:	f022 0201 	bic.w	r2, r2, #1
 80032a6:	698d      	ldr	r5, [r1, #24]
 80032a8:	432a      	orrs	r2, r5
 80032aa:	60a2      	str	r2, [r4, #8]
  /*  - Automatic injected conversion                                         */
  /*  - Injected discontinuous mode                                           */
  
    /* Automatic injected conversion can be enabled if injected group         */
    /* external triggers are disabled.                                        */
    if (sConfigInjected->AutoInjectedConv == ENABLE)
 80032ac:	7d4a      	ldrb	r2, [r1, #21]
 80032ae:	2a01      	cmp	r2, #1
 80032b0:	d05e      	beq.n	8003370 <HAL_ADCEx_InjectedConfigChannel+0x10e>
      }
    }
    
    /* Injected discontinuous can be enabled only if auto-injected mode is    */
    /* disabled.                                                              */  
    if (sConfigInjected->InjectedDiscontinuousConvMode == ENABLE)
 80032b2:	7d0a      	ldrb	r2, [r1, #20]
 80032b4:	2a01      	cmp	r2, #1
 80032b6:	d06b      	beq.n	8003390 <HAL_ADCEx_InjectedConfigChannel+0x12e>
    }


  /* InjectedChannel sampling time configuration */
  /* For channels 10 to 17 */
  if (sConfigInjected->InjectedChannel >= ADC_CHANNEL_10)
 80032b8:	680a      	ldr	r2, [r1, #0]
 80032ba:	2a09      	cmp	r2, #9
 80032bc:	d976      	bls.n	80033ac <HAL_ADCEx_InjectedConfigChannel+0x14a>
  {
    MODIFY_REG(hadc->Instance->SMPR1                                                             ,
 80032be:	681e      	ldr	r6, [r3, #0]
 80032c0:	68f4      	ldr	r4, [r6, #12]
 80032c2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80032c6:	3a1e      	subs	r2, #30
 80032c8:	2507      	movs	r5, #7
 80032ca:	4095      	lsls	r5, r2
 80032cc:	ea24 0405 	bic.w	r4, r4, r5
 80032d0:	688d      	ldr	r5, [r1, #8]
 80032d2:	fa05 f202 	lsl.w	r2, r5, r2
 80032d6:	4322      	orrs	r2, r4
 80032d8:	60f2      	str	r2, [r6, #12]
               ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
  }
  
  /* If ADC1 InjectedChannel_16 or InjectedChannel_17 is selected, enable Temperature sensor  */
  /* and VREFINT measurement path.                                            */
  if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
 80032da:	680a      	ldr	r2, [r1, #0]
 80032dc:	3a10      	subs	r2, #16
 80032de:	2a01      	cmp	r2, #1
 80032e0:	d972      	bls.n	80033c8 <HAL_ADCEx_InjectedConfigChannel+0x166>
    SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
  }
  
  
  /* Configure the offset: offset enable/disable, InjectedChannel, offset value */
  switch(sConfigInjected->InjectedRank)
 80032e2:	684a      	ldr	r2, [r1, #4]
 80032e4:	2a02      	cmp	r2, #2
 80032e6:	f000 8088 	beq.w	80033fa <HAL_ADCEx_InjectedConfigChannel+0x198>
 80032ea:	2a03      	cmp	r2, #3
 80032ec:	f000 808f 	beq.w	800340e <HAL_ADCEx_InjectedConfigChannel+0x1ac>
 80032f0:	2a01      	cmp	r2, #1
 80032f2:	d06f      	beq.n	80033d4 <HAL_ADCEx_InjectedConfigChannel+0x172>
                 ADC_JOFR3_JOFFSET3,
                 sConfigInjected->InjectedOffset);
      break;
    case 4:
    default:
      MODIFY_REG(hadc->Instance->JOFR4,
 80032f4:	681c      	ldr	r4, [r3, #0]
 80032f6:	6a22      	ldr	r2, [r4, #32]
 80032f8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 80032fc:	f022 020f 	bic.w	r2, r2, #15
 8003300:	68cd      	ldr	r5, [r1, #12]
 8003302:	432a      	orrs	r2, r5
 8003304:	6222      	str	r2, [r4, #32]
                 ADC_JOFR4_JOFFSET4,
                 sConfigInjected->InjectedOffset);
      break;
 8003306:	e06e      	b.n	80033e6 <HAL_ADCEx_InjectedConfigChannel+0x184>
      MODIFY_REG(hadc->Instance->JSQR                             ,
 8003308:	6818      	ldr	r0, [r3, #0]
 800330a:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800330c:	0d92      	lsrs	r2, r2, #22
 800330e:	0592      	lsls	r2, r2, #22
 8003310:	680c      	ldr	r4, [r1, #0]
 8003312:	ea42 32c4 	orr.w	r2, r2, r4, lsl #15
 8003316:	6382      	str	r2, [r0, #56]	; 0x38
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003318:	2000      	movs	r0, #0
 800331a:	e7ba      	b.n	8003292 <HAL_ADCEx_InjectedConfigChannel+0x30>
    if (sConfigInjected->InjectedRank <= sConfigInjected->InjectedNbrOfConversion)
 800331c:	684a      	ldr	r2, [r1, #4]
 800331e:	690c      	ldr	r4, [r1, #16]
 8003320:	42a2      	cmp	r2, r4
 8003322:	d815      	bhi.n	8003350 <HAL_ADCEx_InjectedConfigChannel+0xee>
      MODIFY_REG(hadc->Instance->JSQR                                         ,
 8003324:	681f      	ldr	r7, [r3, #0]
 8003326:	6bbd      	ldr	r5, [r7, #56]	; 0x38
 8003328:	1b10      	subs	r0, r2, r4
 800332a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800332e:	300f      	adds	r0, #15
 8003330:	221f      	movs	r2, #31
 8003332:	4082      	lsls	r2, r0
 8003334:	f442 1240 	orr.w	r2, r2, #3145728	; 0x300000
 8003338:	ea25 0502 	bic.w	r5, r5, r2
 800333c:	1e62      	subs	r2, r4, #1
 800333e:	680e      	ldr	r6, [r1, #0]
 8003340:	fa06 f000 	lsl.w	r0, r6, r0
 8003344:	ea40 5202 	orr.w	r2, r0, r2, lsl #20
 8003348:	432a      	orrs	r2, r5
 800334a:	63ba      	str	r2, [r7, #56]	; 0x38
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800334c:	2000      	movs	r0, #0
 800334e:	e7a0      	b.n	8003292 <HAL_ADCEx_InjectedConfigChannel+0x30>
      MODIFY_REG(hadc->Instance->JSQR                                       ,
 8003350:	681e      	ldr	r6, [r3, #0]
 8003352:	6bb5      	ldr	r5, [r6, #56]	; 0x38
 8003354:	1b12      	subs	r2, r2, r4
 8003356:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800335a:	320f      	adds	r2, #15
 800335c:	201f      	movs	r0, #31
 800335e:	fa00 f202 	lsl.w	r2, r0, r2
 8003362:	f442 1240 	orr.w	r2, r2, #3145728	; 0x300000
 8003366:	ea25 0202 	bic.w	r2, r5, r2
 800336a:	63b2      	str	r2, [r6, #56]	; 0x38
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800336c:	2000      	movs	r0, #0
 800336e:	e790      	b.n	8003292 <HAL_ADCEx_InjectedConfigChannel+0x30>
      if (sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8003370:	698c      	ldr	r4, [r1, #24]
 8003372:	f5b4 4fe0 	cmp.w	r4, #28672	; 0x7000
 8003376:	d005      	beq.n	8003384 <HAL_ADCEx_InjectedConfigChannel+0x122>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003378:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800337a:	f040 0020 	orr.w	r0, r0, #32
 800337e:	6298      	str	r0, [r3, #40]	; 0x28
        tmp_hal_status = HAL_ERROR;
 8003380:	4610      	mov	r0, r2
 8003382:	e796      	b.n	80032b2 <HAL_ADCEx_InjectedConfigChannel+0x50>
        SET_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8003384:	681c      	ldr	r4, [r3, #0]
 8003386:	6862      	ldr	r2, [r4, #4]
 8003388:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800338c:	6062      	str	r2, [r4, #4]
 800338e:	e790      	b.n	80032b2 <HAL_ADCEx_InjectedConfigChannel+0x50>
      if (sConfigInjected->AutoInjectedConv == DISABLE)
 8003390:	7d4c      	ldrb	r4, [r1, #21]
 8003392:	b92c      	cbnz	r4, 80033a0 <HAL_ADCEx_InjectedConfigChannel+0x13e>
        SET_BIT(hadc->Instance->CR1, ADC_CR1_JDISCEN);
 8003394:	681c      	ldr	r4, [r3, #0]
 8003396:	6862      	ldr	r2, [r4, #4]
 8003398:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800339c:	6062      	str	r2, [r4, #4]
 800339e:	e78b      	b.n	80032b8 <HAL_ADCEx_InjectedConfigChannel+0x56>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80033a0:	6a98      	ldr	r0, [r3, #40]	; 0x28
 80033a2:	f040 0020 	orr.w	r0, r0, #32
 80033a6:	6298      	str	r0, [r3, #40]	; 0x28
        tmp_hal_status = HAL_ERROR;
 80033a8:	4610      	mov	r0, r2
 80033aa:	e785      	b.n	80032b8 <HAL_ADCEx_InjectedConfigChannel+0x56>
    MODIFY_REG(hadc->Instance->SMPR2                                                             ,
 80033ac:	681e      	ldr	r6, [r3, #0]
 80033ae:	6934      	ldr	r4, [r6, #16]
 80033b0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80033b4:	2507      	movs	r5, #7
 80033b6:	4095      	lsls	r5, r2
 80033b8:	ea24 0405 	bic.w	r4, r4, r5
 80033bc:	688d      	ldr	r5, [r1, #8]
 80033be:	fa05 f202 	lsl.w	r2, r5, r2
 80033c2:	4322      	orrs	r2, r4
 80033c4:	6132      	str	r2, [r6, #16]
 80033c6:	e788      	b.n	80032da <HAL_ADCEx_InjectedConfigChannel+0x78>
    SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 80033c8:	681c      	ldr	r4, [r3, #0]
 80033ca:	68a2      	ldr	r2, [r4, #8]
 80033cc:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80033d0:	60a2      	str	r2, [r4, #8]
 80033d2:	e786      	b.n	80032e2 <HAL_ADCEx_InjectedConfigChannel+0x80>
      MODIFY_REG(hadc->Instance->JOFR1,
 80033d4:	681c      	ldr	r4, [r3, #0]
 80033d6:	6962      	ldr	r2, [r4, #20]
 80033d8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 80033dc:	f022 020f 	bic.w	r2, r2, #15
 80033e0:	68cd      	ldr	r5, [r1, #12]
 80033e2:	432a      	orrs	r2, r5
 80033e4:	6162      	str	r2, [r4, #20]
  }
  
  /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
  /* and VREFINT measurement path.                                            */
  if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
 80033e6:	680a      	ldr	r2, [r1, #0]
 80033e8:	3a10      	subs	r2, #16
 80033ea:	2a01      	cmp	r2, #1
 80033ec:	d919      	bls.n	8003422 <HAL_ADCEx_InjectedConfigChannel+0x1c0>
      tmp_hal_status = HAL_ERROR;
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80033ee:	2200      	movs	r2, #0
 80033f0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 80033f4:	b002      	add	sp, #8
 80033f6:	bcf0      	pop	{r4, r5, r6, r7}
 80033f8:	4770      	bx	lr
      MODIFY_REG(hadc->Instance->JOFR2,
 80033fa:	681c      	ldr	r4, [r3, #0]
 80033fc:	69a2      	ldr	r2, [r4, #24]
 80033fe:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 8003402:	f022 020f 	bic.w	r2, r2, #15
 8003406:	68cd      	ldr	r5, [r1, #12]
 8003408:	432a      	orrs	r2, r5
 800340a:	61a2      	str	r2, [r4, #24]
      break;
 800340c:	e7eb      	b.n	80033e6 <HAL_ADCEx_InjectedConfigChannel+0x184>
      MODIFY_REG(hadc->Instance->JOFR3,
 800340e:	681c      	ldr	r4, [r3, #0]
 8003410:	69e2      	ldr	r2, [r4, #28]
 8003412:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 8003416:	f022 020f 	bic.w	r2, r2, #15
 800341a:	68cd      	ldr	r5, [r1, #12]
 800341c:	432a      	orrs	r2, r5
 800341e:	61e2      	str	r2, [r4, #28]
      break;
 8003420:	e7e1      	b.n	80033e6 <HAL_ADCEx_InjectedConfigChannel+0x184>
    if (hadc->Instance == ADC1)
 8003422:	681a      	ldr	r2, [r3, #0]
 8003424:	4c13      	ldr	r4, [pc, #76]	; (8003474 <HAL_ADCEx_InjectedConfigChannel+0x212>)
 8003426:	42a2      	cmp	r2, r4
 8003428:	d005      	beq.n	8003436 <HAL_ADCEx_InjectedConfigChannel+0x1d4>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800342a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800342c:	f042 0220 	orr.w	r2, r2, #32
 8003430:	629a      	str	r2, [r3, #40]	; 0x28
      tmp_hal_status = HAL_ERROR;
 8003432:	2001      	movs	r0, #1
 8003434:	e7db      	b.n	80033ee <HAL_ADCEx_InjectedConfigChannel+0x18c>
      if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
 8003436:	6894      	ldr	r4, [r2, #8]
 8003438:	f414 0f00 	tst.w	r4, #8388608	; 0x800000
 800343c:	d1d7      	bne.n	80033ee <HAL_ADCEx_InjectedConfigChannel+0x18c>
        SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 800343e:	6894      	ldr	r4, [r2, #8]
 8003440:	f444 0400 	orr.w	r4, r4, #8388608	; 0x800000
 8003444:	6094      	str	r4, [r2, #8]
        if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR))
 8003446:	680a      	ldr	r2, [r1, #0]
 8003448:	2a10      	cmp	r2, #16
 800344a:	d1d0      	bne.n	80033ee <HAL_ADCEx_InjectedConfigChannel+0x18c>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 800344c:	4a0a      	ldr	r2, [pc, #40]	; (8003478 <HAL_ADCEx_InjectedConfigChannel+0x216>)
 800344e:	6812      	ldr	r2, [r2, #0]
 8003450:	490a      	ldr	r1, [pc, #40]	; (800347c <HAL_ADCEx_InjectedConfigChannel+0x21a>)
 8003452:	fba1 1202 	umull	r1, r2, r1, r2
 8003456:	0c92      	lsrs	r2, r2, #18
 8003458:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800345c:	0052      	lsls	r2, r2, #1
 800345e:	9201      	str	r2, [sp, #4]
          while(wait_loop_index != 0U)
 8003460:	e002      	b.n	8003468 <HAL_ADCEx_InjectedConfigChannel+0x206>
            wait_loop_index--;
 8003462:	9a01      	ldr	r2, [sp, #4]
 8003464:	3a01      	subs	r2, #1
 8003466:	9201      	str	r2, [sp, #4]
          while(wait_loop_index != 0U)
 8003468:	9a01      	ldr	r2, [sp, #4]
 800346a:	2a00      	cmp	r2, #0
 800346c:	d1f9      	bne.n	8003462 <HAL_ADCEx_InjectedConfigChannel+0x200>
 800346e:	e7be      	b.n	80033ee <HAL_ADCEx_InjectedConfigChannel+0x18c>
  __HAL_LOCK(hadc);
 8003470:	2002      	movs	r0, #2
 8003472:	e7bf      	b.n	80033f4 <HAL_ADCEx_InjectedConfigChannel+0x192>
 8003474:	40012400 	.word	0x40012400
 8003478:	20000028 	.word	0x20000028
 800347c:	431bde83 	.word	0x431bde83

08003480 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param  hadc: ADC handle
  * @param  multimode: Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
{
 8003480:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_MODE(multimode->Mode));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8003482:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8003486:	2a01      	cmp	r2, #1
 8003488:	d020      	beq.n	80034cc <HAL_ADCEx_MultiModeConfigChannel+0x4c>
 800348a:	2201      	movs	r2, #1
 800348c:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
  /*  - ADC master and ADC slave DMA configuration                            */
  /* Parameters that can be updated only when ADC is disabled:                */
  /*  - Multimode mode selection                                              */
  /* To optimize code, all multimode settings can be set when both ADCs of    */
  /* the common group are in state: disabled.                                 */
  if ((ADC_IS_ENABLE(hadc) == RESET)                     &&
 8003490:	6802      	ldr	r2, [r0, #0]
 8003492:	6890      	ldr	r0, [r2, #8]
 8003494:	f010 0f01 	tst.w	r0, #1
 8003498:	d107      	bne.n	80034aa <HAL_ADCEx_MultiModeConfigChannel+0x2a>
      (ADC_IS_ENABLE(&tmphadcSlave) == RESET)            &&
 800349a:	480d      	ldr	r0, [pc, #52]	; (80034d0 <HAL_ADCEx_MultiModeConfigChannel+0x50>)
 800349c:	6880      	ldr	r0, [r0, #8]
  if ((ADC_IS_ENABLE(hadc) == RESET)                     &&
 800349e:	f010 0f01 	tst.w	r0, #1
 80034a2:	d102      	bne.n	80034aa <HAL_ADCEx_MultiModeConfigChannel+0x2a>
      (ADC_IS_ENABLE(&tmphadcSlave) == RESET)            &&
 80034a4:	480b      	ldr	r0, [pc, #44]	; (80034d4 <HAL_ADCEx_MultiModeConfigChannel+0x54>)
 80034a6:	4282      	cmp	r2, r0
 80034a8:	d008      	beq.n	80034bc <HAL_ADCEx_MultiModeConfigChannel+0x3c>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80034aa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80034ac:	f042 0220 	orr.w	r2, r2, #32
 80034b0:	629a      	str	r2, [r3, #40]	; 0x28
    
    tmp_hal_status = HAL_ERROR;
 80034b2:	2001      	movs	r0, #1
  }
    
    
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80034b4:	2200      	movs	r2, #0
 80034b6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
 80034ba:	4770      	bx	lr
    MODIFY_REG(hadc->Instance->CR1,
 80034bc:	6850      	ldr	r0, [r2, #4]
 80034be:	f420 2070 	bic.w	r0, r0, #983040	; 0xf0000
 80034c2:	6809      	ldr	r1, [r1, #0]
 80034c4:	4301      	orrs	r1, r0
 80034c6:	6051      	str	r1, [r2, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80034c8:	2000      	movs	r0, #0
    MODIFY_REG(hadc->Instance->CR1,
 80034ca:	e7f3      	b.n	80034b4 <HAL_ADCEx_MultiModeConfigChannel+0x34>
  __HAL_LOCK(hadc);
 80034cc:	2002      	movs	r0, #2
} 
 80034ce:	4770      	bx	lr
 80034d0:	40012800 	.word	0x40012800
 80034d4:	40012400 	.word	0x40012400

080034d8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80034d8:	4a07      	ldr	r2, [pc, #28]	; (80034f8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80034da:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80034dc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80034e0:	041b      	lsls	r3, r3, #16
 80034e2:	0c1b      	lsrs	r3, r3, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 80034e4:	0200      	lsls	r0, r0, #8
 80034e6:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80034ea:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 80034ec:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80034f0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80034f4:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80034f6:	4770      	bx	lr
 80034f8:	e000ed00 	.word	0xe000ed00

080034fc <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80034fc:	b430      	push	{r4, r5}
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80034fe:	4b17      	ldr	r3, [pc, #92]	; (800355c <HAL_NVIC_SetPriority+0x60>)
 8003500:	68db      	ldr	r3, [r3, #12]
 8003502:	f3c3 2302 	ubfx	r3, r3, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8003506:	f1c3 0407 	rsb	r4, r3, #7
 800350a:	2c04      	cmp	r4, #4
 800350c:	bf28      	it	cs
 800350e:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003510:	1d1d      	adds	r5, r3, #4
 8003512:	2d06      	cmp	r5, #6
 8003514:	d918      	bls.n	8003548 <HAL_NVIC_SetPriority+0x4c>
 8003516:	3b03      	subs	r3, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003518:	f04f 35ff 	mov.w	r5, #4294967295
 800351c:	fa05 f404 	lsl.w	r4, r5, r4
 8003520:	ea21 0104 	bic.w	r1, r1, r4
 8003524:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8003526:	fa05 f303 	lsl.w	r3, r5, r3
 800352a:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800352e:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8003530:	2800      	cmp	r0, #0
 8003532:	db0b      	blt.n	800354c <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003534:	0109      	lsls	r1, r1, #4
 8003536:	b2c9      	uxtb	r1, r1
 8003538:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800353c:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8003540:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8003544:	bc30      	pop	{r4, r5}
 8003546:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003548:	2300      	movs	r3, #0
 800354a:	e7e5      	b.n	8003518 <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800354c:	f000 000f 	and.w	r0, r0, #15
 8003550:	0109      	lsls	r1, r1, #4
 8003552:	b2c9      	uxtb	r1, r1
 8003554:	4b02      	ldr	r3, [pc, #8]	; (8003560 <HAL_NVIC_SetPriority+0x64>)
 8003556:	5419      	strb	r1, [r3, r0]
 8003558:	e7f4      	b.n	8003544 <HAL_NVIC_SetPriority+0x48>
 800355a:	bf00      	nop
 800355c:	e000ed00 	.word	0xe000ed00
 8003560:	e000ed14 	.word	0xe000ed14

08003564 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003564:	2800      	cmp	r0, #0
 8003566:	db07      	blt.n	8003578 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003568:	f000 021f 	and.w	r2, r0, #31
 800356c:	0940      	lsrs	r0, r0, #5
 800356e:	2301      	movs	r3, #1
 8003570:	4093      	lsls	r3, r2
 8003572:	4a02      	ldr	r2, [pc, #8]	; (800357c <HAL_NVIC_EnableIRQ+0x18>)
 8003574:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8003578:	4770      	bx	lr
 800357a:	bf00      	nop
 800357c:	e000e100 	.word	0xe000e100

08003580 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003580:	2800      	cmp	r0, #0
 8003582:	db0c      	blt.n	800359e <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003584:	f000 021f 	and.w	r2, r0, #31
 8003588:	0940      	lsrs	r0, r0, #5
 800358a:	2301      	movs	r3, #1
 800358c:	4093      	lsls	r3, r2
 800358e:	3020      	adds	r0, #32
 8003590:	4a03      	ldr	r2, [pc, #12]	; (80035a0 <HAL_NVIC_DisableIRQ+0x20>)
 8003592:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8003596:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800359a:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800359e:	4770      	bx	lr
 80035a0:	e000e100 	.word	0xe000e100

080035a4 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 80035a4:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80035a8:	4905      	ldr	r1, [pc, #20]	; (80035c0 <HAL_NVIC_SystemReset+0x1c>)
 80035aa:	68ca      	ldr	r2, [r1, #12]
 80035ac:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80035b0:	4b04      	ldr	r3, [pc, #16]	; (80035c4 <HAL_NVIC_SystemReset+0x20>)
 80035b2:	4313      	orrs	r3, r2
 80035b4:	60cb      	str	r3, [r1, #12]
 80035b6:	f3bf 8f4f 	dsb	sy
    __NOP();
 80035ba:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 80035bc:	e7fd      	b.n	80035ba <HAL_NVIC_SystemReset+0x16>
 80035be:	bf00      	nop
 80035c0:	e000ed00 	.word	0xe000ed00
 80035c4:	05fa0004 	.word	0x05fa0004

080035c8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80035c8:	3801      	subs	r0, #1
 80035ca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80035ce:	d20a      	bcs.n	80035e6 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80035d0:	4b06      	ldr	r3, [pc, #24]	; (80035ec <HAL_SYSTICK_Config+0x24>)
 80035d2:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80035d4:	4a06      	ldr	r2, [pc, #24]	; (80035f0 <HAL_SYSTICK_Config+0x28>)
 80035d6:	21f0      	movs	r1, #240	; 0xf0
 80035d8:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80035dc:	2000      	movs	r0, #0
 80035de:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80035e0:	2207      	movs	r2, #7
 80035e2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80035e4:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80035e6:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80035e8:	4770      	bx	lr
 80035ea:	bf00      	nop
 80035ec:	e000e010 	.word	0xe000e010
 80035f0:	e000ed00 	.word	0xe000ed00

080035f4 <HAL_NVIC_GetPriorityGrouping>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80035f4:	4b02      	ldr	r3, [pc, #8]	; (8003600 <HAL_NVIC_GetPriorityGrouping+0xc>)
 80035f6:	68d8      	ldr	r0, [r3, #12]
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
}
 80035f8:	f3c0 2002 	ubfx	r0, r0, #8, #3
 80035fc:	4770      	bx	lr
 80035fe:	bf00      	nop
 8003600:	e000ed00 	.word	0xe000ed00

08003604 <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority: Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
 8003604:	b470      	push	{r4, r5, r6}
  if ((int32_t)(IRQn) >= 0)
 8003606:	2800      	cmp	r0, #0
 8003608:	db21      	blt.n	800364e <HAL_NVIC_GetPriority+0x4a>
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
 800360a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800360e:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8003612:	f890 0300 	ldrb.w	r0, [r0, #768]	; 0x300
 8003616:	0900      	lsrs	r0, r0, #4
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8003618:	f001 0107 	and.w	r1, r1, #7
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800361c:	f1c1 0407 	rsb	r4, r1, #7
 8003620:	2c04      	cmp	r4, #4
 8003622:	bf28      	it	cs
 8003624:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003626:	1d0d      	adds	r5, r1, #4
 8003628:	2d06      	cmp	r5, #6
 800362a:	d916      	bls.n	800365a <HAL_NVIC_GetPriority+0x56>
 800362c:	3903      	subs	r1, #3
  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
 800362e:	fa20 f601 	lsr.w	r6, r0, r1
 8003632:	f04f 35ff 	mov.w	r5, #4294967295
 8003636:	fa05 f404 	lsl.w	r4, r5, r4
 800363a:	ea26 0404 	bic.w	r4, r6, r4
 800363e:	6014      	str	r4, [r2, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
 8003640:	fa05 f101 	lsl.w	r1, r5, r1
 8003644:	ea20 0001 	bic.w	r0, r0, r1
 8003648:	6018      	str	r0, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}
 800364a:	bc70      	pop	{r4, r5, r6}
 800364c:	4770      	bx	lr
    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
 800364e:	f000 000f 	and.w	r0, r0, #15
 8003652:	4c03      	ldr	r4, [pc, #12]	; (8003660 <HAL_NVIC_GetPriority+0x5c>)
 8003654:	5c20      	ldrb	r0, [r4, r0]
 8003656:	0900      	lsrs	r0, r0, #4
 8003658:	e7de      	b.n	8003618 <HAL_NVIC_GetPriority+0x14>
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800365a:	2100      	movs	r1, #0
 800365c:	e7e7      	b.n	800362e <HAL_NVIC_GetPriority+0x2a>
 800365e:	bf00      	nop
 8003660:	e000ed14 	.word	0xe000ed14

08003664 <HAL_NVIC_SetPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003664:	2800      	cmp	r0, #0
 8003666:	db08      	blt.n	800367a <HAL_NVIC_SetPendingIRQ+0x16>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003668:	f000 021f 	and.w	r2, r0, #31
 800366c:	0940      	lsrs	r0, r0, #5
 800366e:	2301      	movs	r3, #1
 8003670:	4093      	lsls	r3, r2
 8003672:	3040      	adds	r0, #64	; 0x40
 8003674:	4a01      	ldr	r2, [pc, #4]	; (800367c <HAL_NVIC_SetPendingIRQ+0x18>)
 8003676:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
}
 800367a:	4770      	bx	lr
 800367c:	e000e100 	.word	0xe000e100

08003680 <HAL_NVIC_GetPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003680:	2800      	cmp	r0, #0
 8003682:	db0b      	blt.n	800369c <HAL_NVIC_GetPendingIRQ+0x1c>
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 8003684:	0943      	lsrs	r3, r0, #5
 8003686:	3340      	adds	r3, #64	; 0x40
 8003688:	4a05      	ldr	r2, [pc, #20]	; (80036a0 <HAL_NVIC_GetPendingIRQ+0x20>)
 800368a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800368e:	f000 001f 	and.w	r0, r0, #31
 8003692:	fa23 f000 	lsr.w	r0, r3, r0
 8003696:	f000 0001 	and.w	r0, r0, #1
 800369a:	4770      	bx	lr
    return(0U);
 800369c:	2000      	movs	r0, #0
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
}
 800369e:	4770      	bx	lr
 80036a0:	e000e100 	.word	0xe000e100

080036a4 <HAL_NVIC_ClearPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80036a4:	2800      	cmp	r0, #0
 80036a6:	db08      	blt.n	80036ba <HAL_NVIC_ClearPendingIRQ+0x16>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80036a8:	f000 021f 	and.w	r2, r0, #31
 80036ac:	0940      	lsrs	r0, r0, #5
 80036ae:	2301      	movs	r3, #1
 80036b0:	4093      	lsls	r3, r2
 80036b2:	3060      	adds	r0, #96	; 0x60
 80036b4:	4a01      	ldr	r2, [pc, #4]	; (80036bc <HAL_NVIC_ClearPendingIRQ+0x18>)
 80036b6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
}
 80036ba:	4770      	bx	lr
 80036bc:	e000e100 	.word	0xe000e100

080036c0 <HAL_NVIC_GetActive>:
  if ((int32_t)(IRQn) >= 0)
 80036c0:	2800      	cmp	r0, #0
 80036c2:	db0b      	blt.n	80036dc <HAL_NVIC_GetActive+0x1c>
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 80036c4:	0943      	lsrs	r3, r0, #5
 80036c6:	3380      	adds	r3, #128	; 0x80
 80036c8:	4a05      	ldr	r2, [pc, #20]	; (80036e0 <HAL_NVIC_GetActive+0x20>)
 80036ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80036ce:	f000 001f 	and.w	r0, r0, #31
 80036d2:	fa23 f000 	lsr.w	r0, r3, r0
 80036d6:	f000 0001 	and.w	r0, r0, #1
 80036da:	4770      	bx	lr
    return(0U);
 80036dc:	2000      	movs	r0, #0
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
}
 80036de:	4770      	bx	lr
 80036e0:	e000e100 	.word	0xe000e100

080036e4 <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80036e4:	2804      	cmp	r0, #4
 80036e6:	d005      	beq.n	80036f4 <HAL_SYSTICK_CLKSourceConfig+0x10>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80036e8:	4a05      	ldr	r2, [pc, #20]	; (8003700 <HAL_SYSTICK_CLKSourceConfig+0x1c>)
 80036ea:	6813      	ldr	r3, [r2, #0]
 80036ec:	f023 0304 	bic.w	r3, r3, #4
 80036f0:	6013      	str	r3, [r2, #0]
  }
}
 80036f2:	4770      	bx	lr
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80036f4:	4a02      	ldr	r2, [pc, #8]	; (8003700 <HAL_SYSTICK_CLKSourceConfig+0x1c>)
 80036f6:	6813      	ldr	r3, [r2, #0]
 80036f8:	f043 0304 	orr.w	r3, r3, #4
 80036fc:	6013      	str	r3, [r2, #0]
 80036fe:	4770      	bx	lr
 8003700:	e000e010 	.word	0xe000e010

08003704 <HAL_SYSTICK_Callback>:
__weak void HAL_SYSTICK_Callback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 8003704:	4770      	bx	lr

08003706 <HAL_SYSTICK_IRQHandler>:
{
 8003706:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8003708:	f7ff fffc 	bl	8003704 <HAL_SYSTICK_Callback>
}
 800370c:	bd08      	pop	{r3, pc}
 800370e:	bf00      	nop

08003710 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8003710:	b470      	push	{r4, r5, r6}
  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8003712:	6c06      	ldr	r6, [r0, #64]	; 0x40
 8003714:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 8003716:	2401      	movs	r4, #1
 8003718:	40b4      	lsls	r4, r6
 800371a:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 800371c:	6804      	ldr	r4, [r0, #0]
 800371e:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003720:	6843      	ldr	r3, [r0, #4]
 8003722:	2b10      	cmp	r3, #16
 8003724:	d005      	beq.n	8003732 <DMA_SetConfig+0x22>
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 8003726:	6803      	ldr	r3, [r0, #0]
 8003728:	6099      	str	r1, [r3, #8]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 800372a:	6803      	ldr	r3, [r0, #0]
 800372c:	60da      	str	r2, [r3, #12]
  }
}
 800372e:	bc70      	pop	{r4, r5, r6}
 8003730:	4770      	bx	lr
    hdma->Instance->CPAR = DstAddress;
 8003732:	6803      	ldr	r3, [r0, #0]
 8003734:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = SrcAddress;
 8003736:	6803      	ldr	r3, [r0, #0]
 8003738:	60d9      	str	r1, [r3, #12]
 800373a:	e7f8      	b.n	800372e <DMA_SetConfig+0x1e>

0800373c <HAL_DMA_Init>:
  if(hdma == NULL)
 800373c:	b360      	cbz	r0, 8003798 <HAL_DMA_Init+0x5c>
{
 800373e:	b410      	push	{r4}
 8003740:	4602      	mov	r2, r0
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8003742:	6801      	ldr	r1, [r0, #0]
 8003744:	4b15      	ldr	r3, [pc, #84]	; (800379c <HAL_DMA_Init+0x60>)
 8003746:	440b      	add	r3, r1
 8003748:	4815      	ldr	r0, [pc, #84]	; (80037a0 <HAL_DMA_Init+0x64>)
 800374a:	fba0 0303 	umull	r0, r3, r0, r3
 800374e:	091b      	lsrs	r3, r3, #4
 8003750:	009b      	lsls	r3, r3, #2
 8003752:	6413      	str	r3, [r2, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 8003754:	4b13      	ldr	r3, [pc, #76]	; (80037a4 <HAL_DMA_Init+0x68>)
 8003756:	63d3      	str	r3, [r2, #60]	; 0x3c
  hdma->State = HAL_DMA_STATE_BUSY;
 8003758:	2302      	movs	r3, #2
 800375a:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
  tmp = hdma->Instance->CCR;
 800375e:	6808      	ldr	r0, [r1, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8003760:	f420 507f 	bic.w	r0, r0, #16320	; 0x3fc0
 8003764:	f020 0030 	bic.w	r0, r0, #48	; 0x30
  tmp |=  hdma->Init.Direction        |
 8003768:	6853      	ldr	r3, [r2, #4]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800376a:	6894      	ldr	r4, [r2, #8]
  tmp |=  hdma->Init.Direction        |
 800376c:	4323      	orrs	r3, r4
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800376e:	68d4      	ldr	r4, [r2, #12]
 8003770:	4323      	orrs	r3, r4
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8003772:	6914      	ldr	r4, [r2, #16]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8003774:	4323      	orrs	r3, r4
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8003776:	6954      	ldr	r4, [r2, #20]
 8003778:	4323      	orrs	r3, r4
          hdma->Init.Mode                | hdma->Init.Priority;
 800377a:	6994      	ldr	r4, [r2, #24]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800377c:	4323      	orrs	r3, r4
          hdma->Init.Mode                | hdma->Init.Priority;
 800377e:	69d4      	ldr	r4, [r2, #28]
 8003780:	4323      	orrs	r3, r4
  tmp |=  hdma->Init.Direction        |
 8003782:	4303      	orrs	r3, r0
  hdma->Instance->CCR = tmp;
 8003784:	600b      	str	r3, [r1, #0]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003786:	2000      	movs	r0, #0
 8003788:	6390      	str	r0, [r2, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 800378a:	2301      	movs	r3, #1
 800378c:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
  hdma->Lock = HAL_UNLOCKED;
 8003790:	f882 0020 	strb.w	r0, [r2, #32]
}
 8003794:	bc10      	pop	{r4}
 8003796:	4770      	bx	lr
    return HAL_ERROR;
 8003798:	2001      	movs	r0, #1
}
 800379a:	4770      	bx	lr
 800379c:	bffdfff8 	.word	0xbffdfff8
 80037a0:	cccccccd 	.word	0xcccccccd
 80037a4:	40020000 	.word	0x40020000

080037a8 <HAL_DMA_DeInit>:
  if(hdma == NULL)
 80037a8:	2800      	cmp	r0, #0
 80037aa:	d029      	beq.n	8003800 <HAL_DMA_DeInit+0x58>
{
 80037ac:	b410      	push	{r4}
 80037ae:	4603      	mov	r3, r0
  __HAL_DMA_DISABLE(hdma);
 80037b0:	6801      	ldr	r1, [r0, #0]
 80037b2:	680a      	ldr	r2, [r1, #0]
 80037b4:	f022 0201 	bic.w	r2, r2, #1
 80037b8:	600a      	str	r2, [r1, #0]
  hdma->Instance->CCR  = 0U;
 80037ba:	6802      	ldr	r2, [r0, #0]
 80037bc:	2000      	movs	r0, #0
 80037be:	6010      	str	r0, [r2, #0]
  hdma->Instance->CNDTR = 0U;
 80037c0:	681a      	ldr	r2, [r3, #0]
 80037c2:	6050      	str	r0, [r2, #4]
  hdma->Instance->CPAR  = 0U;
 80037c4:	681a      	ldr	r2, [r3, #0]
 80037c6:	6090      	str	r0, [r2, #8]
  hdma->Instance->CMAR = 0U;
 80037c8:	681a      	ldr	r2, [r3, #0]
 80037ca:	60d0      	str	r0, [r2, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 80037cc:	6819      	ldr	r1, [r3, #0]
 80037ce:	4a0d      	ldr	r2, [pc, #52]	; (8003804 <HAL_DMA_DeInit+0x5c>)
 80037d0:	440a      	add	r2, r1
 80037d2:	490d      	ldr	r1, [pc, #52]	; (8003808 <HAL_DMA_DeInit+0x60>)
 80037d4:	fba1 1202 	umull	r1, r2, r1, r2
 80037d8:	0912      	lsrs	r2, r2, #4
 80037da:	0092      	lsls	r2, r2, #2
 80037dc:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 80037de:	4c0b      	ldr	r4, [pc, #44]	; (800380c <HAL_DMA_DeInit+0x64>)
 80037e0:	63dc      	str	r4, [r3, #60]	; 0x3c
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex));
 80037e2:	2101      	movs	r1, #1
 80037e4:	fa01 f202 	lsl.w	r2, r1, r2
 80037e8:	6062      	str	r2, [r4, #4]
  hdma->XferCpltCallback = NULL;
 80037ea:	6298      	str	r0, [r3, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 80037ec:	62d8      	str	r0, [r3, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 80037ee:	6318      	str	r0, [r3, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 80037f0:	6358      	str	r0, [r3, #52]	; 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80037f2:	6398      	str	r0, [r3, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_RESET;
 80037f4:	f883 0021 	strb.w	r0, [r3, #33]	; 0x21
  __HAL_UNLOCK(hdma);
 80037f8:	f883 0020 	strb.w	r0, [r3, #32]
}
 80037fc:	bc10      	pop	{r4}
 80037fe:	4770      	bx	lr
    return HAL_ERROR;
 8003800:	2001      	movs	r0, #1
}
 8003802:	4770      	bx	lr
 8003804:	bffdfff8 	.word	0xbffdfff8
 8003808:	cccccccd 	.word	0xcccccccd
 800380c:	40020000 	.word	0x40020000

08003810 <HAL_DMA_Start>:
{
 8003810:	b570      	push	{r4, r5, r6, lr}
 8003812:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 8003814:	f890 0020 	ldrb.w	r0, [r0, #32]
 8003818:	2801      	cmp	r0, #1
 800381a:	d01f      	beq.n	800385c <HAL_DMA_Start+0x4c>
 800381c:	2001      	movs	r0, #1
 800381e:	f884 0020 	strb.w	r0, [r4, #32]
  if(HAL_DMA_STATE_READY == hdma->State)
 8003822:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
 8003826:	2801      	cmp	r0, #1
 8003828:	d004      	beq.n	8003834 <HAL_DMA_Start+0x24>
   __HAL_UNLOCK(hdma);  
 800382a:	2300      	movs	r3, #0
 800382c:	f884 3020 	strb.w	r3, [r4, #32]
   status = HAL_BUSY;
 8003830:	2002      	movs	r0, #2
}
 8003832:	bd70      	pop	{r4, r5, r6, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 8003834:	2002      	movs	r0, #2
 8003836:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800383a:	2500      	movs	r5, #0
 800383c:	63a5      	str	r5, [r4, #56]	; 0x38
    __HAL_DMA_DISABLE(hdma);
 800383e:	6826      	ldr	r6, [r4, #0]
 8003840:	6830      	ldr	r0, [r6, #0]
 8003842:	f020 0001 	bic.w	r0, r0, #1
 8003846:	6030      	str	r0, [r6, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8003848:	4620      	mov	r0, r4
 800384a:	f7ff ff61 	bl	8003710 <DMA_SetConfig>
    __HAL_DMA_ENABLE(hdma);
 800384e:	6822      	ldr	r2, [r4, #0]
 8003850:	6813      	ldr	r3, [r2, #0]
 8003852:	f043 0301 	orr.w	r3, r3, #1
 8003856:	6013      	str	r3, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8003858:	4628      	mov	r0, r5
 800385a:	e7ea      	b.n	8003832 <HAL_DMA_Start+0x22>
  __HAL_LOCK(hdma);
 800385c:	2002      	movs	r0, #2
 800385e:	e7e8      	b.n	8003832 <HAL_DMA_Start+0x22>

08003860 <HAL_DMA_Start_IT>:
{
 8003860:	b538      	push	{r3, r4, r5, lr}
 8003862:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 8003864:	f890 0020 	ldrb.w	r0, [r0, #32]
 8003868:	2801      	cmp	r0, #1
 800386a:	d031      	beq.n	80038d0 <HAL_DMA_Start_IT+0x70>
 800386c:	2001      	movs	r0, #1
 800386e:	f884 0020 	strb.w	r0, [r4, #32]
  if(HAL_DMA_STATE_READY == hdma->State)
 8003872:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
 8003876:	2801      	cmp	r0, #1
 8003878:	d004      	beq.n	8003884 <HAL_DMA_Start_IT+0x24>
    __HAL_UNLOCK(hdma); 
 800387a:	2300      	movs	r3, #0
 800387c:	f884 3020 	strb.w	r3, [r4, #32]
    status = HAL_BUSY;
 8003880:	2002      	movs	r0, #2
}
 8003882:	bd38      	pop	{r3, r4, r5, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 8003884:	2002      	movs	r0, #2
 8003886:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800388a:	2000      	movs	r0, #0
 800388c:	63a0      	str	r0, [r4, #56]	; 0x38
    __HAL_DMA_DISABLE(hdma);
 800388e:	6825      	ldr	r5, [r4, #0]
 8003890:	6828      	ldr	r0, [r5, #0]
 8003892:	f020 0001 	bic.w	r0, r0, #1
 8003896:	6028      	str	r0, [r5, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8003898:	4620      	mov	r0, r4
 800389a:	f7ff ff39 	bl	8003710 <DMA_SetConfig>
    if(NULL != hdma->XferHalfCpltCallback)
 800389e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80038a0:	b15b      	cbz	r3, 80038ba <HAL_DMA_Start_IT+0x5a>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80038a2:	6822      	ldr	r2, [r4, #0]
 80038a4:	6813      	ldr	r3, [r2, #0]
 80038a6:	f043 030e 	orr.w	r3, r3, #14
 80038aa:	6013      	str	r3, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 80038ac:	6822      	ldr	r2, [r4, #0]
 80038ae:	6813      	ldr	r3, [r2, #0]
 80038b0:	f043 0301 	orr.w	r3, r3, #1
 80038b4:	6013      	str	r3, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80038b6:	2000      	movs	r0, #0
 80038b8:	e7e3      	b.n	8003882 <HAL_DMA_Start_IT+0x22>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80038ba:	6822      	ldr	r2, [r4, #0]
 80038bc:	6813      	ldr	r3, [r2, #0]
 80038be:	f023 0304 	bic.w	r3, r3, #4
 80038c2:	6013      	str	r3, [r2, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 80038c4:	6822      	ldr	r2, [r4, #0]
 80038c6:	6813      	ldr	r3, [r2, #0]
 80038c8:	f043 030a 	orr.w	r3, r3, #10
 80038cc:	6013      	str	r3, [r2, #0]
 80038ce:	e7ed      	b.n	80038ac <HAL_DMA_Start_IT+0x4c>
  __HAL_LOCK(hdma);
 80038d0:	2002      	movs	r0, #2
 80038d2:	e7d6      	b.n	8003882 <HAL_DMA_Start_IT+0x22>

080038d4 <HAL_DMA_Abort>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80038d4:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 80038d8:	2b02      	cmp	r3, #2
 80038da:	d006      	beq.n	80038ea <HAL_DMA_Abort+0x16>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80038dc:	2304      	movs	r3, #4
 80038de:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 80038e0:	2300      	movs	r3, #0
 80038e2:	f880 3020 	strb.w	r3, [r0, #32]
    return HAL_ERROR;
 80038e6:	2001      	movs	r0, #1
 80038e8:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80038ea:	6802      	ldr	r2, [r0, #0]
 80038ec:	6813      	ldr	r3, [r2, #0]
 80038ee:	f023 030e 	bic.w	r3, r3, #14
 80038f2:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 80038f4:	6802      	ldr	r2, [r0, #0]
 80038f6:	6813      	ldr	r3, [r2, #0]
 80038f8:	f023 0301 	bic.w	r3, r3, #1
 80038fc:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 80038fe:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003900:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8003902:	2201      	movs	r2, #1
 8003904:	fa02 f303 	lsl.w	r3, r2, r3
 8003908:	604b      	str	r3, [r1, #4]
  hdma->State = HAL_DMA_STATE_READY;
 800390a:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21
  __HAL_UNLOCK(hdma);      
 800390e:	2300      	movs	r3, #0
 8003910:	f880 3020 	strb.w	r3, [r0, #32]
  return status; 
 8003914:	4618      	mov	r0, r3
}
 8003916:	4770      	bx	lr

08003918 <HAL_DMA_Abort_IT>:
{  
 8003918:	b508      	push	{r3, lr}
  if(HAL_DMA_STATE_BUSY != hdma->State)
 800391a:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 800391e:	2b02      	cmp	r3, #2
 8003920:	d003      	beq.n	800392a <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8003922:	2304      	movs	r3, #4
 8003924:	6383      	str	r3, [r0, #56]	; 0x38
    status = HAL_ERROR;
 8003926:	2001      	movs	r0, #1
}
 8003928:	bd08      	pop	{r3, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800392a:	6802      	ldr	r2, [r0, #0]
 800392c:	6813      	ldr	r3, [r2, #0]
 800392e:	f023 030e 	bic.w	r3, r3, #14
 8003932:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 8003934:	6802      	ldr	r2, [r0, #0]
 8003936:	6813      	ldr	r3, [r2, #0]
 8003938:	f023 0301 	bic.w	r3, r3, #1
 800393c:	6013      	str	r3, [r2, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 800393e:	6803      	ldr	r3, [r0, #0]
 8003940:	4a19      	ldr	r2, [pc, #100]	; (80039a8 <HAL_DMA_Abort_IT+0x90>)
 8003942:	4293      	cmp	r3, r2
 8003944:	d014      	beq.n	8003970 <HAL_DMA_Abort_IT+0x58>
 8003946:	3214      	adds	r2, #20
 8003948:	4293      	cmp	r3, r2
 800394a:	d01f      	beq.n	800398c <HAL_DMA_Abort_IT+0x74>
 800394c:	3214      	adds	r2, #20
 800394e:	4293      	cmp	r3, r2
 8003950:	d01e      	beq.n	8003990 <HAL_DMA_Abort_IT+0x78>
 8003952:	3214      	adds	r2, #20
 8003954:	4293      	cmp	r3, r2
 8003956:	d01e      	beq.n	8003996 <HAL_DMA_Abort_IT+0x7e>
 8003958:	3214      	adds	r2, #20
 800395a:	4293      	cmp	r3, r2
 800395c:	d01e      	beq.n	800399c <HAL_DMA_Abort_IT+0x84>
 800395e:	3214      	adds	r2, #20
 8003960:	4293      	cmp	r3, r2
 8003962:	d002      	beq.n	800396a <HAL_DMA_Abort_IT+0x52>
 8003964:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003968:	e003      	b.n	8003972 <HAL_DMA_Abort_IT+0x5a>
 800396a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800396e:	e000      	b.n	8003972 <HAL_DMA_Abort_IT+0x5a>
 8003970:	2201      	movs	r2, #1
 8003972:	4b0e      	ldr	r3, [pc, #56]	; (80039ac <HAL_DMA_Abort_IT+0x94>)
 8003974:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8003976:	2301      	movs	r3, #1
 8003978:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 800397c:	2300      	movs	r3, #0
 800397e:	f880 3020 	strb.w	r3, [r0, #32]
    if(hdma->XferAbortCallback != NULL)
 8003982:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003984:	b16b      	cbz	r3, 80039a2 <HAL_DMA_Abort_IT+0x8a>
      hdma->XferAbortCallback(hdma);
 8003986:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 8003988:	2000      	movs	r0, #0
 800398a:	e7cd      	b.n	8003928 <HAL_DMA_Abort_IT+0x10>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 800398c:	2210      	movs	r2, #16
 800398e:	e7f0      	b.n	8003972 <HAL_DMA_Abort_IT+0x5a>
 8003990:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003994:	e7ed      	b.n	8003972 <HAL_DMA_Abort_IT+0x5a>
 8003996:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800399a:	e7ea      	b.n	8003972 <HAL_DMA_Abort_IT+0x5a>
 800399c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80039a0:	e7e7      	b.n	8003972 <HAL_DMA_Abort_IT+0x5a>
  HAL_StatusTypeDef status = HAL_OK;
 80039a2:	2000      	movs	r0, #0
 80039a4:	e7c0      	b.n	8003928 <HAL_DMA_Abort_IT+0x10>
 80039a6:	bf00      	nop
 80039a8:	40020008 	.word	0x40020008
 80039ac:	40020000 	.word	0x40020000

080039b0 <HAL_DMA_PollForTransfer>:
{
 80039b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80039b4:	4604      	mov	r4, r0
  if(HAL_DMA_STATE_BUSY != hdma->State)
 80039b6:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 80039ba:	2b02      	cmp	r3, #2
 80039bc:	d007      	beq.n	80039ce <HAL_DMA_PollForTransfer+0x1e>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80039be:	2304      	movs	r3, #4
 80039c0:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 80039c2:	2300      	movs	r3, #0
 80039c4:	f880 3020 	strb.w	r3, [r0, #32]
    return HAL_ERROR;
 80039c8:	2001      	movs	r0, #1
}
 80039ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80039ce:	460f      	mov	r7, r1
 80039d0:	4615      	mov	r5, r2
  if (RESET != (hdma->Instance->CCR & DMA_CCR_CIRC))
 80039d2:	6803      	ldr	r3, [r0, #0]
 80039d4:	681a      	ldr	r2, [r3, #0]
 80039d6:	f012 0f20 	tst.w	r2, #32
 80039da:	d115      	bne.n	8003a08 <HAL_DMA_PollForTransfer+0x58>
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 80039dc:	b9e1      	cbnz	r1, 8003a18 <HAL_DMA_PollForTransfer+0x68>
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 80039de:	4a7d      	ldr	r2, [pc, #500]	; (8003bd4 <HAL_DMA_PollForTransfer+0x224>)
 80039e0:	4293      	cmp	r3, r2
 80039e2:	d031      	beq.n	8003a48 <HAL_DMA_PollForTransfer+0x98>
 80039e4:	3214      	adds	r2, #20
 80039e6:	4293      	cmp	r3, r2
 80039e8:	d033      	beq.n	8003a52 <HAL_DMA_PollForTransfer+0xa2>
 80039ea:	3214      	adds	r2, #20
 80039ec:	4293      	cmp	r3, r2
 80039ee:	d032      	beq.n	8003a56 <HAL_DMA_PollForTransfer+0xa6>
 80039f0:	3214      	adds	r2, #20
 80039f2:	4293      	cmp	r3, r2
 80039f4:	d032      	beq.n	8003a5c <HAL_DMA_PollForTransfer+0xac>
 80039f6:	3214      	adds	r2, #20
 80039f8:	4293      	cmp	r3, r2
 80039fa:	d032      	beq.n	8003a62 <HAL_DMA_PollForTransfer+0xb2>
 80039fc:	3214      	adds	r2, #20
 80039fe:	4293      	cmp	r3, r2
 8003a00:	d007      	beq.n	8003a12 <HAL_DMA_PollForTransfer+0x62>
 8003a02:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
 8003a06:	e020      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
 8003a08:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003a0c:	6383      	str	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 8003a0e:	2001      	movs	r0, #1
 8003a10:	e7db      	b.n	80039ca <HAL_DMA_PollForTransfer+0x1a>
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 8003a12:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 8003a16:	e018      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 8003a18:	4a6e      	ldr	r2, [pc, #440]	; (8003bd4 <HAL_DMA_PollForTransfer+0x224>)
 8003a1a:	4293      	cmp	r3, r2
 8003a1c:	d024      	beq.n	8003a68 <HAL_DMA_PollForTransfer+0xb8>
 8003a1e:	3214      	adds	r2, #20
 8003a20:	4293      	cmp	r3, r2
 8003a22:	d023      	beq.n	8003a6c <HAL_DMA_PollForTransfer+0xbc>
 8003a24:	3214      	adds	r2, #20
 8003a26:	4293      	cmp	r3, r2
 8003a28:	d022      	beq.n	8003a70 <HAL_DMA_PollForTransfer+0xc0>
 8003a2a:	3214      	adds	r2, #20
 8003a2c:	4293      	cmp	r3, r2
 8003a2e:	d022      	beq.n	8003a76 <HAL_DMA_PollForTransfer+0xc6>
 8003a30:	3214      	adds	r2, #20
 8003a32:	4293      	cmp	r3, r2
 8003a34:	d022      	beq.n	8003a7c <HAL_DMA_PollForTransfer+0xcc>
 8003a36:	3214      	adds	r2, #20
 8003a38:	4293      	cmp	r3, r2
 8003a3a:	d002      	beq.n	8003a42 <HAL_DMA_PollForTransfer+0x92>
 8003a3c:	f04f 6680 	mov.w	r6, #67108864	; 0x4000000
 8003a40:	e003      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a42:	f44f 0680 	mov.w	r6, #4194304	; 0x400000
 8003a46:	e000      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 8003a48:	2602      	movs	r6, #2
  tickstart = HAL_GetTick();
 8003a4a:	f7fe fa47 	bl	8001edc <HAL_GetTick>
 8003a4e:	4680      	mov	r8, r0
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
 8003a50:	e020      	b.n	8003a94 <HAL_DMA_PollForTransfer+0xe4>
    temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
 8003a52:	2620      	movs	r6, #32
 8003a54:	e7f9      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a56:	f44f 7600 	mov.w	r6, #512	; 0x200
 8003a5a:	e7f6      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a5c:	f44f 5600 	mov.w	r6, #8192	; 0x2000
 8003a60:	e7f3      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a62:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 8003a66:	e7f0      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
    temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
 8003a68:	2604      	movs	r6, #4
 8003a6a:	e7ee      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a6c:	2640      	movs	r6, #64	; 0x40
 8003a6e:	e7ec      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a70:	f44f 6680 	mov.w	r6, #1024	; 0x400
 8003a74:	e7e9      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a76:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 8003a7a:	e7e6      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
 8003a7c:	f44f 2680 	mov.w	r6, #262144	; 0x40000
 8003a80:	e7e3      	b.n	8003a4a <HAL_DMA_PollForTransfer+0x9a>
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 8003a82:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 8003a86:	e000      	b.n	8003a8a <HAL_DMA_PollForTransfer+0xda>
 8003a88:	2308      	movs	r3, #8
 8003a8a:	421a      	tst	r2, r3
 8003a8c:	d129      	bne.n	8003ae2 <HAL_DMA_PollForTransfer+0x132>
    if(Timeout != HAL_MAX_DELAY)
 8003a8e:	f1b5 3fff 	cmp.w	r5, #4294967295
 8003a92:	d135      	bne.n	8003b00 <HAL_DMA_PollForTransfer+0x150>
  while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
 8003a94:	4b50      	ldr	r3, [pc, #320]	; (8003bd8 <HAL_DMA_PollForTransfer+0x228>)
 8003a96:	681b      	ldr	r3, [r3, #0]
 8003a98:	4233      	tst	r3, r6
 8003a9a:	d143      	bne.n	8003b24 <HAL_DMA_PollForTransfer+0x174>
    if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
 8003a9c:	4b4e      	ldr	r3, [pc, #312]	; (8003bd8 <HAL_DMA_PollForTransfer+0x228>)
 8003a9e:	681a      	ldr	r2, [r3, #0]
 8003aa0:	6823      	ldr	r3, [r4, #0]
 8003aa2:	494c      	ldr	r1, [pc, #304]	; (8003bd4 <HAL_DMA_PollForTransfer+0x224>)
 8003aa4:	428b      	cmp	r3, r1
 8003aa6:	d0ef      	beq.n	8003a88 <HAL_DMA_PollForTransfer+0xd8>
 8003aa8:	3114      	adds	r1, #20
 8003aaa:	428b      	cmp	r3, r1
 8003aac:	d00e      	beq.n	8003acc <HAL_DMA_PollForTransfer+0x11c>
 8003aae:	3114      	adds	r1, #20
 8003ab0:	428b      	cmp	r3, r1
 8003ab2:	d00d      	beq.n	8003ad0 <HAL_DMA_PollForTransfer+0x120>
 8003ab4:	3114      	adds	r1, #20
 8003ab6:	428b      	cmp	r3, r1
 8003ab8:	d00d      	beq.n	8003ad6 <HAL_DMA_PollForTransfer+0x126>
 8003aba:	3114      	adds	r1, #20
 8003abc:	428b      	cmp	r3, r1
 8003abe:	d00d      	beq.n	8003adc <HAL_DMA_PollForTransfer+0x12c>
 8003ac0:	3114      	adds	r1, #20
 8003ac2:	428b      	cmp	r3, r1
 8003ac4:	d0dd      	beq.n	8003a82 <HAL_DMA_PollForTransfer+0xd2>
 8003ac6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003aca:	e7de      	b.n	8003a8a <HAL_DMA_PollForTransfer+0xda>
 8003acc:	2380      	movs	r3, #128	; 0x80
 8003ace:	e7dc      	b.n	8003a8a <HAL_DMA_PollForTransfer+0xda>
 8003ad0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003ad4:	e7d9      	b.n	8003a8a <HAL_DMA_PollForTransfer+0xda>
 8003ad6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8003ada:	e7d6      	b.n	8003a8a <HAL_DMA_PollForTransfer+0xda>
 8003adc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8003ae0:	e7d3      	b.n	8003a8a <HAL_DMA_PollForTransfer+0xda>
      hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8003ae2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8003ae4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8003ae6:	2001      	movs	r0, #1
 8003ae8:	fa00 f303 	lsl.w	r3, r0, r3
 8003aec:	6053      	str	r3, [r2, #4]
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8003aee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003af0:	4303      	orrs	r3, r0
 8003af2:	63a3      	str	r3, [r4, #56]	; 0x38
      hdma->State= HAL_DMA_STATE_READY;
 8003af4:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      __HAL_UNLOCK(hdma);
 8003af8:	2300      	movs	r3, #0
 8003afa:	f884 3020 	strb.w	r3, [r4, #32]
      return HAL_ERROR;
 8003afe:	e764      	b.n	80039ca <HAL_DMA_PollForTransfer+0x1a>
      if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
 8003b00:	b12d      	cbz	r5, 8003b0e <HAL_DMA_PollForTransfer+0x15e>
 8003b02:	f7fe f9eb 	bl	8001edc <HAL_GetTick>
 8003b06:	eba0 0008 	sub.w	r0, r0, r8
 8003b0a:	42a8      	cmp	r0, r5
 8003b0c:	d9c2      	bls.n	8003a94 <HAL_DMA_PollForTransfer+0xe4>
        SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TIMEOUT);
 8003b0e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003b10:	f043 0320 	orr.w	r3, r3, #32
 8003b14:	63a3      	str	r3, [r4, #56]	; 0x38
        hdma->State = HAL_DMA_STATE_READY;
 8003b16:	2001      	movs	r0, #1
 8003b18:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
        __HAL_UNLOCK(hdma);
 8003b1c:	2300      	movs	r3, #0
 8003b1e:	f884 3020 	strb.w	r3, [r4, #32]
        return HAL_ERROR;
 8003b22:	e752      	b.n	80039ca <HAL_DMA_PollForTransfer+0x1a>
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
 8003b24:	bb6f      	cbnz	r7, 8003b82 <HAL_DMA_PollForTransfer+0x1d2>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003b26:	6823      	ldr	r3, [r4, #0]
 8003b28:	4a2a      	ldr	r2, [pc, #168]	; (8003bd4 <HAL_DMA_PollForTransfer+0x224>)
 8003b2a:	4293      	cmp	r3, r2
 8003b2c:	d014      	beq.n	8003b58 <HAL_DMA_PollForTransfer+0x1a8>
 8003b2e:	3214      	adds	r2, #20
 8003b30:	4293      	cmp	r3, r2
 8003b32:	d01b      	beq.n	8003b6c <HAL_DMA_PollForTransfer+0x1bc>
 8003b34:	3214      	adds	r2, #20
 8003b36:	4293      	cmp	r3, r2
 8003b38:	d01a      	beq.n	8003b70 <HAL_DMA_PollForTransfer+0x1c0>
 8003b3a:	3214      	adds	r2, #20
 8003b3c:	4293      	cmp	r3, r2
 8003b3e:	d01a      	beq.n	8003b76 <HAL_DMA_PollForTransfer+0x1c6>
 8003b40:	3214      	adds	r2, #20
 8003b42:	4293      	cmp	r3, r2
 8003b44:	d01a      	beq.n	8003b7c <HAL_DMA_PollForTransfer+0x1cc>
 8003b46:	3214      	adds	r2, #20
 8003b48:	4293      	cmp	r3, r2
 8003b4a:	d002      	beq.n	8003b52 <HAL_DMA_PollForTransfer+0x1a2>
 8003b4c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8003b50:	e003      	b.n	8003b5a <HAL_DMA_PollForTransfer+0x1aa>
 8003b52:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8003b56:	e000      	b.n	8003b5a <HAL_DMA_PollForTransfer+0x1aa>
 8003b58:	2202      	movs	r2, #2
 8003b5a:	4b1f      	ldr	r3, [pc, #124]	; (8003bd8 <HAL_DMA_PollForTransfer+0x228>)
 8003b5c:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8003b5e:	2301      	movs	r3, #1
 8003b60:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  __HAL_UNLOCK(hdma);
 8003b64:	2000      	movs	r0, #0
 8003b66:	f884 0020 	strb.w	r0, [r4, #32]
  return HAL_OK;
 8003b6a:	e72e      	b.n	80039ca <HAL_DMA_PollForTransfer+0x1a>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003b6c:	2220      	movs	r2, #32
 8003b6e:	e7f4      	b.n	8003b5a <HAL_DMA_PollForTransfer+0x1aa>
 8003b70:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003b74:	e7f1      	b.n	8003b5a <HAL_DMA_PollForTransfer+0x1aa>
 8003b76:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8003b7a:	e7ee      	b.n	8003b5a <HAL_DMA_PollForTransfer+0x1aa>
 8003b7c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8003b80:	e7eb      	b.n	8003b5a <HAL_DMA_PollForTransfer+0x1aa>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b82:	6823      	ldr	r3, [r4, #0]
 8003b84:	4a13      	ldr	r2, [pc, #76]	; (8003bd4 <HAL_DMA_PollForTransfer+0x224>)
 8003b86:	4293      	cmp	r3, r2
 8003b88:	d014      	beq.n	8003bb4 <HAL_DMA_PollForTransfer+0x204>
 8003b8a:	3214      	adds	r2, #20
 8003b8c:	4293      	cmp	r3, r2
 8003b8e:	d015      	beq.n	8003bbc <HAL_DMA_PollForTransfer+0x20c>
 8003b90:	3214      	adds	r2, #20
 8003b92:	4293      	cmp	r3, r2
 8003b94:	d014      	beq.n	8003bc0 <HAL_DMA_PollForTransfer+0x210>
 8003b96:	3214      	adds	r2, #20
 8003b98:	4293      	cmp	r3, r2
 8003b9a:	d014      	beq.n	8003bc6 <HAL_DMA_PollForTransfer+0x216>
 8003b9c:	3214      	adds	r2, #20
 8003b9e:	4293      	cmp	r3, r2
 8003ba0:	d014      	beq.n	8003bcc <HAL_DMA_PollForTransfer+0x21c>
 8003ba2:	3214      	adds	r2, #20
 8003ba4:	4293      	cmp	r3, r2
 8003ba6:	d002      	beq.n	8003bae <HAL_DMA_PollForTransfer+0x1fe>
 8003ba8:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8003bac:	e003      	b.n	8003bb6 <HAL_DMA_PollForTransfer+0x206>
 8003bae:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8003bb2:	e000      	b.n	8003bb6 <HAL_DMA_PollForTransfer+0x206>
 8003bb4:	2204      	movs	r2, #4
 8003bb6:	4b08      	ldr	r3, [pc, #32]	; (8003bd8 <HAL_DMA_PollForTransfer+0x228>)
 8003bb8:	605a      	str	r2, [r3, #4]
 8003bba:	e7d3      	b.n	8003b64 <HAL_DMA_PollForTransfer+0x1b4>
 8003bbc:	2240      	movs	r2, #64	; 0x40
 8003bbe:	e7fa      	b.n	8003bb6 <HAL_DMA_PollForTransfer+0x206>
 8003bc0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8003bc4:	e7f7      	b.n	8003bb6 <HAL_DMA_PollForTransfer+0x206>
 8003bc6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8003bca:	e7f4      	b.n	8003bb6 <HAL_DMA_PollForTransfer+0x206>
 8003bcc:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8003bd0:	e7f1      	b.n	8003bb6 <HAL_DMA_PollForTransfer+0x206>
 8003bd2:	bf00      	nop
 8003bd4:	40020008 	.word	0x40020008
 8003bd8:	40020000 	.word	0x40020000

08003bdc <HAL_DMA_IRQHandler>:
{
 8003bdc:	b538      	push	{r3, r4, r5, lr}
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8003bde:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8003be0:	681a      	ldr	r2, [r3, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8003be2:	6804      	ldr	r4, [r0, #0]
 8003be4:	6825      	ldr	r5, [r4, #0]
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8003be6:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8003be8:	2304      	movs	r3, #4
 8003bea:	408b      	lsls	r3, r1
 8003bec:	4213      	tst	r3, r2
 8003bee:	d035      	beq.n	8003c5c <HAL_DMA_IRQHandler+0x80>
 8003bf0:	f015 0f04 	tst.w	r5, #4
 8003bf4:	d032      	beq.n	8003c5c <HAL_DMA_IRQHandler+0x80>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8003bf6:	6823      	ldr	r3, [r4, #0]
 8003bf8:	f013 0f20 	tst.w	r3, #32
 8003bfc:	d103      	bne.n	8003c06 <HAL_DMA_IRQHandler+0x2a>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8003bfe:	6823      	ldr	r3, [r4, #0]
 8003c00:	f023 0304 	bic.w	r3, r3, #4
 8003c04:	6023      	str	r3, [r4, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003c06:	6803      	ldr	r3, [r0, #0]
 8003c08:	4a43      	ldr	r2, [pc, #268]	; (8003d18 <HAL_DMA_IRQHandler+0x13c>)
 8003c0a:	4293      	cmp	r3, r2
 8003c0c:	d014      	beq.n	8003c38 <HAL_DMA_IRQHandler+0x5c>
 8003c0e:	3214      	adds	r2, #20
 8003c10:	4293      	cmp	r3, r2
 8003c12:	d018      	beq.n	8003c46 <HAL_DMA_IRQHandler+0x6a>
 8003c14:	3214      	adds	r2, #20
 8003c16:	4293      	cmp	r3, r2
 8003c18:	d017      	beq.n	8003c4a <HAL_DMA_IRQHandler+0x6e>
 8003c1a:	3214      	adds	r2, #20
 8003c1c:	4293      	cmp	r3, r2
 8003c1e:	d017      	beq.n	8003c50 <HAL_DMA_IRQHandler+0x74>
 8003c20:	3214      	adds	r2, #20
 8003c22:	4293      	cmp	r3, r2
 8003c24:	d017      	beq.n	8003c56 <HAL_DMA_IRQHandler+0x7a>
 8003c26:	3214      	adds	r2, #20
 8003c28:	4293      	cmp	r3, r2
 8003c2a:	d002      	beq.n	8003c32 <HAL_DMA_IRQHandler+0x56>
 8003c2c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8003c30:	e003      	b.n	8003c3a <HAL_DMA_IRQHandler+0x5e>
 8003c32:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8003c36:	e000      	b.n	8003c3a <HAL_DMA_IRQHandler+0x5e>
 8003c38:	2204      	movs	r2, #4
 8003c3a:	4b38      	ldr	r3, [pc, #224]	; (8003d1c <HAL_DMA_IRQHandler+0x140>)
 8003c3c:	605a      	str	r2, [r3, #4]
    if(hdma->XferHalfCpltCallback != NULL)
 8003c3e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8003c40:	b103      	cbz	r3, 8003c44 <HAL_DMA_IRQHandler+0x68>
      hdma->XferHalfCpltCallback(hdma);
 8003c42:	4798      	blx	r3
}
 8003c44:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003c46:	2240      	movs	r2, #64	; 0x40
 8003c48:	e7f7      	b.n	8003c3a <HAL_DMA_IRQHandler+0x5e>
 8003c4a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8003c4e:	e7f4      	b.n	8003c3a <HAL_DMA_IRQHandler+0x5e>
 8003c50:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8003c54:	e7f1      	b.n	8003c3a <HAL_DMA_IRQHandler+0x5e>
 8003c56:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8003c5a:	e7ee      	b.n	8003c3a <HAL_DMA_IRQHandler+0x5e>
  else if (((flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_TC) != RESET))
 8003c5c:	2302      	movs	r3, #2
 8003c5e:	408b      	lsls	r3, r1
 8003c60:	4213      	tst	r3, r2
 8003c62:	d03c      	beq.n	8003cde <HAL_DMA_IRQHandler+0x102>
 8003c64:	f015 0f02 	tst.w	r5, #2
 8003c68:	d039      	beq.n	8003cde <HAL_DMA_IRQHandler+0x102>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8003c6a:	6823      	ldr	r3, [r4, #0]
 8003c6c:	f013 0f20 	tst.w	r3, #32
 8003c70:	d106      	bne.n	8003c80 <HAL_DMA_IRQHandler+0xa4>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  
 8003c72:	6823      	ldr	r3, [r4, #0]
 8003c74:	f023 030a 	bic.w	r3, r3, #10
 8003c78:	6023      	str	r3, [r4, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8003c7a:	2301      	movs	r3, #1
 8003c7c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003c80:	6803      	ldr	r3, [r0, #0]
 8003c82:	4a25      	ldr	r2, [pc, #148]	; (8003d18 <HAL_DMA_IRQHandler+0x13c>)
 8003c84:	4293      	cmp	r3, r2
 8003c86:	d014      	beq.n	8003cb2 <HAL_DMA_IRQHandler+0xd6>
 8003c88:	3214      	adds	r2, #20
 8003c8a:	4293      	cmp	r3, r2
 8003c8c:	d01c      	beq.n	8003cc8 <HAL_DMA_IRQHandler+0xec>
 8003c8e:	3214      	adds	r2, #20
 8003c90:	4293      	cmp	r3, r2
 8003c92:	d01b      	beq.n	8003ccc <HAL_DMA_IRQHandler+0xf0>
 8003c94:	3214      	adds	r2, #20
 8003c96:	4293      	cmp	r3, r2
 8003c98:	d01b      	beq.n	8003cd2 <HAL_DMA_IRQHandler+0xf6>
 8003c9a:	3214      	adds	r2, #20
 8003c9c:	4293      	cmp	r3, r2
 8003c9e:	d01b      	beq.n	8003cd8 <HAL_DMA_IRQHandler+0xfc>
 8003ca0:	3214      	adds	r2, #20
 8003ca2:	4293      	cmp	r3, r2
 8003ca4:	d002      	beq.n	8003cac <HAL_DMA_IRQHandler+0xd0>
 8003ca6:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8003caa:	e003      	b.n	8003cb4 <HAL_DMA_IRQHandler+0xd8>
 8003cac:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8003cb0:	e000      	b.n	8003cb4 <HAL_DMA_IRQHandler+0xd8>
 8003cb2:	2202      	movs	r2, #2
 8003cb4:	4b19      	ldr	r3, [pc, #100]	; (8003d1c <HAL_DMA_IRQHandler+0x140>)
 8003cb6:	605a      	str	r2, [r3, #4]
    __HAL_UNLOCK(hdma);
 8003cb8:	2300      	movs	r3, #0
 8003cba:	f880 3020 	strb.w	r3, [r0, #32]
    if(hdma->XferCpltCallback != NULL)
 8003cbe:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003cc0:	2b00      	cmp	r3, #0
 8003cc2:	d0bf      	beq.n	8003c44 <HAL_DMA_IRQHandler+0x68>
      hdma->XferCpltCallback(hdma);
 8003cc4:	4798      	blx	r3
 8003cc6:	e7bd      	b.n	8003c44 <HAL_DMA_IRQHandler+0x68>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003cc8:	2220      	movs	r2, #32
 8003cca:	e7f3      	b.n	8003cb4 <HAL_DMA_IRQHandler+0xd8>
 8003ccc:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003cd0:	e7f0      	b.n	8003cb4 <HAL_DMA_IRQHandler+0xd8>
 8003cd2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8003cd6:	e7ed      	b.n	8003cb4 <HAL_DMA_IRQHandler+0xd8>
 8003cd8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8003cdc:	e7ea      	b.n	8003cb4 <HAL_DMA_IRQHandler+0xd8>
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8003cde:	2308      	movs	r3, #8
 8003ce0:	fa03 f101 	lsl.w	r1, r3, r1
 8003ce4:	4211      	tst	r1, r2
 8003ce6:	d0ad      	beq.n	8003c44 <HAL_DMA_IRQHandler+0x68>
 8003ce8:	f015 0f08 	tst.w	r5, #8
 8003cec:	d0aa      	beq.n	8003c44 <HAL_DMA_IRQHandler+0x68>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8003cee:	6823      	ldr	r3, [r4, #0]
 8003cf0:	f023 030e 	bic.w	r3, r3, #14
 8003cf4:	6023      	str	r3, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8003cf6:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8003cf8:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8003cfa:	2301      	movs	r3, #1
 8003cfc:	fa03 f202 	lsl.w	r2, r3, r2
 8003d00:	604a      	str	r2, [r1, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8003d02:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;
 8003d04:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 8003d08:	2300      	movs	r3, #0
 8003d0a:	f880 3020 	strb.w	r3, [r0, #32]
    if (hdma->XferErrorCallback != NULL)
 8003d0e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8003d10:	2b00      	cmp	r3, #0
 8003d12:	d097      	beq.n	8003c44 <HAL_DMA_IRQHandler+0x68>
      hdma->XferErrorCallback(hdma);
 8003d14:	4798      	blx	r3
  return;
 8003d16:	e795      	b.n	8003c44 <HAL_DMA_IRQHandler+0x68>
 8003d18:	40020008 	.word	0x40020008
 8003d1c:	40020000 	.word	0x40020000

08003d20 <HAL_DMA_RegisterCallback>:
{
 8003d20:	4603      	mov	r3, r0
  __HAL_LOCK(hdma);
 8003d22:	f890 0020 	ldrb.w	r0, [r0, #32]
 8003d26:	2801      	cmp	r0, #1
 8003d28:	d01a      	beq.n	8003d60 <HAL_DMA_RegisterCallback+0x40>
  if(HAL_DMA_STATE_READY == hdma->State)
 8003d2a:	f893 0021 	ldrb.w	r0, [r3, #33]	; 0x21
 8003d2e:	2801      	cmp	r0, #1
 8003d30:	d004      	beq.n	8003d3c <HAL_DMA_RegisterCallback+0x1c>
    status = HAL_ERROR;
 8003d32:	2001      	movs	r0, #1
  __HAL_UNLOCK(hdma);
 8003d34:	2200      	movs	r2, #0
 8003d36:	f883 2020 	strb.w	r2, [r3, #32]
  return status;
 8003d3a:	4770      	bx	lr
    switch (CallbackID)
 8003d3c:	2903      	cmp	r1, #3
 8003d3e:	d8f9      	bhi.n	8003d34 <HAL_DMA_RegisterCallback+0x14>
 8003d40:	e8df f001 	tbb	[pc, r1]
 8003d44:	0b080502 	.word	0x0b080502
      hdma->XferCpltCallback = pCallback;
 8003d48:	629a      	str	r2, [r3, #40]	; 0x28
  HAL_StatusTypeDef status = HAL_OK;
 8003d4a:	4608      	mov	r0, r1
      break;
 8003d4c:	e7f2      	b.n	8003d34 <HAL_DMA_RegisterCallback+0x14>
      hdma->XferHalfCpltCallback = pCallback;
 8003d4e:	62da      	str	r2, [r3, #44]	; 0x2c
  HAL_StatusTypeDef status = HAL_OK;
 8003d50:	2000      	movs	r0, #0
      break;         
 8003d52:	e7ef      	b.n	8003d34 <HAL_DMA_RegisterCallback+0x14>
      hdma->XferErrorCallback = pCallback;
 8003d54:	631a      	str	r2, [r3, #48]	; 0x30
  HAL_StatusTypeDef status = HAL_OK;
 8003d56:	2000      	movs	r0, #0
      break;         
 8003d58:	e7ec      	b.n	8003d34 <HAL_DMA_RegisterCallback+0x14>
      hdma->XferAbortCallback = pCallback;
 8003d5a:	635a      	str	r2, [r3, #52]	; 0x34
  HAL_StatusTypeDef status = HAL_OK;
 8003d5c:	2000      	movs	r0, #0
      break; 
 8003d5e:	e7e9      	b.n	8003d34 <HAL_DMA_RegisterCallback+0x14>
  __HAL_LOCK(hdma);
 8003d60:	2002      	movs	r0, #2
}
 8003d62:	4770      	bx	lr

08003d64 <HAL_DMA_UnRegisterCallback>:
{
 8003d64:	4603      	mov	r3, r0
  __HAL_LOCK(hdma);
 8003d66:	f890 2020 	ldrb.w	r2, [r0, #32]
 8003d6a:	2a01      	cmp	r2, #1
 8003d6c:	d025      	beq.n	8003dba <HAL_DMA_UnRegisterCallback+0x56>
 8003d6e:	2201      	movs	r2, #1
 8003d70:	f880 2020 	strb.w	r2, [r0, #32]
  if(HAL_DMA_STATE_READY == hdma->State)
 8003d74:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
 8003d78:	4290      	cmp	r0, r2
 8003d7a:	d004      	beq.n	8003d86 <HAL_DMA_UnRegisterCallback+0x22>
    status = HAL_ERROR;
 8003d7c:	2001      	movs	r0, #1
  __HAL_UNLOCK(hdma);
 8003d7e:	2200      	movs	r2, #0
 8003d80:	f883 2020 	strb.w	r2, [r3, #32]
  return status;
 8003d84:	4770      	bx	lr
    switch (CallbackID)
 8003d86:	2904      	cmp	r1, #4
 8003d88:	d8f9      	bhi.n	8003d7e <HAL_DMA_UnRegisterCallback+0x1a>
 8003d8a:	e8df f001 	tbb	[pc, r1]
 8003d8e:	0703      	.short	0x0703
 8003d90:	0d0a      	.short	0x0d0a
 8003d92:	10          	.byte	0x10
 8003d93:	00          	.byte	0x00
      hdma->XferCpltCallback = NULL;
 8003d94:	2200      	movs	r2, #0
 8003d96:	629a      	str	r2, [r3, #40]	; 0x28
  HAL_StatusTypeDef status = HAL_OK;
 8003d98:	4608      	mov	r0, r1
      break;
 8003d9a:	e7f0      	b.n	8003d7e <HAL_DMA_UnRegisterCallback+0x1a>
      hdma->XferHalfCpltCallback = NULL;
 8003d9c:	2000      	movs	r0, #0
 8003d9e:	62d8      	str	r0, [r3, #44]	; 0x2c
      break;         
 8003da0:	e7ed      	b.n	8003d7e <HAL_DMA_UnRegisterCallback+0x1a>
      hdma->XferErrorCallback = NULL;
 8003da2:	2000      	movs	r0, #0
 8003da4:	6318      	str	r0, [r3, #48]	; 0x30
      break;         
 8003da6:	e7ea      	b.n	8003d7e <HAL_DMA_UnRegisterCallback+0x1a>
      hdma->XferAbortCallback = NULL;
 8003da8:	2000      	movs	r0, #0
 8003daa:	6358      	str	r0, [r3, #52]	; 0x34
      break; 
 8003dac:	e7e7      	b.n	8003d7e <HAL_DMA_UnRegisterCallback+0x1a>
      hdma->XferCpltCallback = NULL;
 8003dae:	2000      	movs	r0, #0
 8003db0:	6298      	str	r0, [r3, #40]	; 0x28
      hdma->XferHalfCpltCallback = NULL;
 8003db2:	62d8      	str	r0, [r3, #44]	; 0x2c
      hdma->XferErrorCallback = NULL;
 8003db4:	6318      	str	r0, [r3, #48]	; 0x30
      hdma->XferAbortCallback = NULL;
 8003db6:	6358      	str	r0, [r3, #52]	; 0x34
      break; 
 8003db8:	e7e1      	b.n	8003d7e <HAL_DMA_UnRegisterCallback+0x1a>
  __HAL_LOCK(hdma);
 8003dba:	2002      	movs	r0, #2
}
 8003dbc:	4770      	bx	lr

08003dbe <HAL_DMA_GetState>:
}
 8003dbe:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
 8003dc2:	4770      	bx	lr

08003dc4 <HAL_DMA_GetError>:
  return hdma->ErrorCode;
 8003dc4:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8003dc6:	4770      	bx	lr

08003dc8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8003dc8:	b4f0      	push	{r4, r5, r6, r7}
 8003dca:	b082      	sub	sp, #8
  uint32_t position = 0x00u;
  uint32_t ioposition;
  uint32_t iocurrent;
  uint32_t temp;
  uint32_t config = 0x00u;
 8003dcc:	2500      	movs	r5, #0
  uint32_t position = 0x00u;
 8003dce:	462c      	mov	r4, r5
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8003dd0:	e0a3      	b.n	8003f1a <HAL_GPIO_Init+0x152>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 8003dd2:	4f7f      	ldr	r7, [pc, #508]	; (8003fd0 <HAL_GPIO_Init+0x208>)
 8003dd4:	42bb      	cmp	r3, r7
 8003dd6:	d010      	beq.n	8003dfa <HAL_GPIO_Init+0x32>
 8003dd8:	d907      	bls.n	8003dea <HAL_GPIO_Init+0x22>
 8003dda:	4f7e      	ldr	r7, [pc, #504]	; (8003fd4 <HAL_GPIO_Init+0x20c>)
 8003ddc:	42bb      	cmp	r3, r7
 8003dde:	d00c      	beq.n	8003dfa <HAL_GPIO_Init+0x32>
 8003de0:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 8003de4:	42bb      	cmp	r3, r7
 8003de6:	d008      	beq.n	8003dfa <HAL_GPIO_Init+0x32>
 8003de8:	e013      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
 8003dea:	f5a7 1780 	sub.w	r7, r7, #1048576	; 0x100000
 8003dee:	42bb      	cmp	r3, r7
 8003df0:	d003      	beq.n	8003dfa <HAL_GPIO_Init+0x32>
 8003df2:	f507 2770 	add.w	r7, r7, #983040	; 0xf0000
 8003df6:	42bb      	cmp	r3, r7
 8003df8:	d107      	bne.n	8003e0a <HAL_GPIO_Init+0x42>
        case GPIO_MODE_EVT_RISING:
        case GPIO_MODE_EVT_FALLING:
        case GPIO_MODE_EVT_RISING_FALLING:
          /* Check the GPIO pull parameter */
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8003dfa:	688b      	ldr	r3, [r1, #8]
 8003dfc:	2b00      	cmp	r3, #0
 8003dfe:	d058      	beq.n	8003eb2 <HAL_GPIO_Init+0xea>
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
          }
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8003e00:	2b01      	cmp	r3, #1
 8003e02:	d051      	beq.n	8003ea8 <HAL_GPIO_Init+0xe0>
          else /* GPIO_PULLDOWN */
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;

            /* Reset the corresponding ODR bit */
            GPIOx->BRR = ioposition;
 8003e04:	6142      	str	r2, [r0, #20]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8003e06:	2508      	movs	r5, #8
 8003e08:	e003      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
      switch (GPIO_Init->Mode)
 8003e0a:	f5a7 1780 	sub.w	r7, r7, #1048576	; 0x100000
 8003e0e:	42bb      	cmp	r3, r7
 8003e10:	d0f3      	beq.n	8003dfa <HAL_GPIO_Init+0x32>
          break;
      }

      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8003e12:	2eff      	cmp	r6, #255	; 0xff
 8003e14:	d84f      	bhi.n	8003eb6 <HAL_GPIO_Init+0xee>
 8003e16:	4684      	mov	ip, r0
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8003e18:	2eff      	cmp	r6, #255	; 0xff
 8003e1a:	d84f      	bhi.n	8003ebc <HAL_GPIO_Init+0xf4>
 8003e1c:	00a2      	lsls	r2, r4, #2

      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8003e1e:	f8dc 3000 	ldr.w	r3, [ip]
 8003e22:	270f      	movs	r7, #15
 8003e24:	4097      	lsls	r7, r2
 8003e26:	ea23 0307 	bic.w	r3, r3, r7
 8003e2a:	fa05 f202 	lsl.w	r2, r5, r2
 8003e2e:	4313      	orrs	r3, r2
 8003e30:	f8cc 3000 	str.w	r3, [ip]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8003e34:	684b      	ldr	r3, [r1, #4]
 8003e36:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8003e3a:	d06d      	beq.n	8003f18 <HAL_GPIO_Init+0x150>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8003e3c:	4b66      	ldr	r3, [pc, #408]	; (8003fd8 <HAL_GPIO_Init+0x210>)
 8003e3e:	699a      	ldr	r2, [r3, #24]
 8003e40:	f042 0201 	orr.w	r2, r2, #1
 8003e44:	619a      	str	r2, [r3, #24]
 8003e46:	699b      	ldr	r3, [r3, #24]
 8003e48:	f003 0301 	and.w	r3, r3, #1
 8003e4c:	9301      	str	r3, [sp, #4]
 8003e4e:	9b01      	ldr	r3, [sp, #4]
        temp = AFIO->EXTICR[position >> 2u];
 8003e50:	08a2      	lsrs	r2, r4, #2
 8003e52:	1c97      	adds	r7, r2, #2
 8003e54:	4b61      	ldr	r3, [pc, #388]	; (8003fdc <HAL_GPIO_Init+0x214>)
 8003e56:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8003e5a:	f004 0703 	and.w	r7, r4, #3
 8003e5e:	00bf      	lsls	r7, r7, #2
 8003e60:	f04f 0c0f 	mov.w	ip, #15
 8003e64:	fa0c fc07 	lsl.w	ip, ip, r7
 8003e68:	ea23 0c0c 	bic.w	ip, r3, ip
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8003e6c:	4b5c      	ldr	r3, [pc, #368]	; (8003fe0 <HAL_GPIO_Init+0x218>)
 8003e6e:	4298      	cmp	r0, r3
 8003e70:	d02a      	beq.n	8003ec8 <HAL_GPIO_Init+0x100>
 8003e72:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003e76:	4298      	cmp	r0, r3
 8003e78:	f000 808a 	beq.w	8003f90 <HAL_GPIO_Init+0x1c8>
 8003e7c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003e80:	4298      	cmp	r0, r3
 8003e82:	f000 8087 	beq.w	8003f94 <HAL_GPIO_Init+0x1cc>
 8003e86:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003e8a:	4298      	cmp	r0, r3
 8003e8c:	d01a      	beq.n	8003ec4 <HAL_GPIO_Init+0xfc>
 8003e8e:	2304      	movs	r3, #4
 8003e90:	e01b      	b.n	8003eca <HAL_GPIO_Init+0x102>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8003e92:	68cd      	ldr	r5, [r1, #12]
          break;
 8003e94:	e7bd      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8003e96:	68cd      	ldr	r5, [r1, #12]
 8003e98:	3504      	adds	r5, #4
          break;
 8003e9a:	e7ba      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8003e9c:	68cd      	ldr	r5, [r1, #12]
 8003e9e:	3508      	adds	r5, #8
          break;
 8003ea0:	e7b7      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8003ea2:	68cd      	ldr	r5, [r1, #12]
 8003ea4:	350c      	adds	r5, #12
          break;
 8003ea6:	e7b4      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
            GPIOx->BSRR = ioposition;
 8003ea8:	6102      	str	r2, [r0, #16]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8003eaa:	2508      	movs	r5, #8
 8003eac:	e7b1      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 8003eae:	2500      	movs	r5, #0
 8003eb0:	e7af      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8003eb2:	2504      	movs	r5, #4
 8003eb4:	e7ad      	b.n	8003e12 <HAL_GPIO_Init+0x4a>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8003eb6:	f100 0c04 	add.w	ip, r0, #4
 8003eba:	e7ad      	b.n	8003e18 <HAL_GPIO_Init+0x50>
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8003ebc:	f1a4 0208 	sub.w	r2, r4, #8
 8003ec0:	0092      	lsls	r2, r2, #2
 8003ec2:	e7ac      	b.n	8003e1e <HAL_GPIO_Init+0x56>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8003ec4:	2303      	movs	r3, #3
 8003ec6:	e000      	b.n	8003eca <HAL_GPIO_Init+0x102>
 8003ec8:	2300      	movs	r3, #0
 8003eca:	40bb      	lsls	r3, r7
 8003ecc:	ea43 030c 	orr.w	r3, r3, ip
        AFIO->EXTICR[position >> 2u] = temp;
 8003ed0:	3202      	adds	r2, #2
 8003ed2:	4f42      	ldr	r7, [pc, #264]	; (8003fdc <HAL_GPIO_Init+0x214>)
 8003ed4:	f847 3022 	str.w	r3, [r7, r2, lsl #2]


        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8003ed8:	684b      	ldr	r3, [r1, #4]
 8003eda:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8003ede:	d05b      	beq.n	8003f98 <HAL_GPIO_Init+0x1d0>
        {
          SET_BIT(EXTI->IMR, iocurrent);
 8003ee0:	4a40      	ldr	r2, [pc, #256]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003ee2:	6813      	ldr	r3, [r2, #0]
 8003ee4:	4333      	orrs	r3, r6
 8003ee6:	6013      	str	r3, [r2, #0]
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8003ee8:	684b      	ldr	r3, [r1, #4]
 8003eea:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8003eee:	d059      	beq.n	8003fa4 <HAL_GPIO_Init+0x1dc>
        {
          SET_BIT(EXTI->EMR, iocurrent);
 8003ef0:	4a3c      	ldr	r2, [pc, #240]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003ef2:	6853      	ldr	r3, [r2, #4]
 8003ef4:	4333      	orrs	r3, r6
 8003ef6:	6053      	str	r3, [r2, #4]
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
        }

        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8003ef8:	684b      	ldr	r3, [r1, #4]
 8003efa:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8003efe:	d057      	beq.n	8003fb0 <HAL_GPIO_Init+0x1e8>
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 8003f00:	4a38      	ldr	r2, [pc, #224]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003f02:	6893      	ldr	r3, [r2, #8]
 8003f04:	4333      	orrs	r3, r6
 8003f06:	6093      	str	r3, [r2, #8]
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8003f08:	684b      	ldr	r3, [r1, #4]
 8003f0a:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8003f0e:	d055      	beq.n	8003fbc <HAL_GPIO_Init+0x1f4>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 8003f10:	4a34      	ldr	r2, [pc, #208]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003f12:	68d3      	ldr	r3, [r2, #12]
 8003f14:	431e      	orrs	r6, r3
 8003f16:	60d6      	str	r6, [r2, #12]
          CLEAR_BIT(EXTI->FTSR, iocurrent);
        }
      }
    }

	position++;
 8003f18:	3401      	adds	r4, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8003f1a:	680b      	ldr	r3, [r1, #0]
 8003f1c:	fa33 f204 	lsrs.w	r2, r3, r4
 8003f20:	d052      	beq.n	8003fc8 <HAL_GPIO_Init+0x200>
    ioposition = (0x01uL << position);
 8003f22:	2201      	movs	r2, #1
 8003f24:	40a2      	lsls	r2, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8003f26:	ea03 0602 	and.w	r6, r3, r2
    if (iocurrent == ioposition)
 8003f2a:	ea32 0303 	bics.w	r3, r2, r3
 8003f2e:	d1f3      	bne.n	8003f18 <HAL_GPIO_Init+0x150>
      switch (GPIO_Init->Mode)
 8003f30:	684b      	ldr	r3, [r1, #4]
 8003f32:	2b12      	cmp	r3, #18
 8003f34:	f63f af4d 	bhi.w	8003dd2 <HAL_GPIO_Init+0xa>
 8003f38:	2b12      	cmp	r3, #18
 8003f3a:	f63f af6a 	bhi.w	8003e12 <HAL_GPIO_Init+0x4a>
 8003f3e:	a701      	add	r7, pc, #4	; (adr r7, 8003f44 <HAL_GPIO_Init+0x17c>)
 8003f40:	f857 f023 	ldr.w	pc, [r7, r3, lsl #2]
 8003f44:	08003dfb 	.word	0x08003dfb
 8003f48:	08003e93 	.word	0x08003e93
 8003f4c:	08003e9d 	.word	0x08003e9d
 8003f50:	08003eaf 	.word	0x08003eaf
 8003f54:	08003e13 	.word	0x08003e13
 8003f58:	08003e13 	.word	0x08003e13
 8003f5c:	08003e13 	.word	0x08003e13
 8003f60:	08003e13 	.word	0x08003e13
 8003f64:	08003e13 	.word	0x08003e13
 8003f68:	08003e13 	.word	0x08003e13
 8003f6c:	08003e13 	.word	0x08003e13
 8003f70:	08003e13 	.word	0x08003e13
 8003f74:	08003e13 	.word	0x08003e13
 8003f78:	08003e13 	.word	0x08003e13
 8003f7c:	08003e13 	.word	0x08003e13
 8003f80:	08003e13 	.word	0x08003e13
 8003f84:	08003e13 	.word	0x08003e13
 8003f88:	08003e97 	.word	0x08003e97
 8003f8c:	08003ea3 	.word	0x08003ea3
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8003f90:	2301      	movs	r3, #1
 8003f92:	e79a      	b.n	8003eca <HAL_GPIO_Init+0x102>
 8003f94:	2302      	movs	r3, #2
 8003f96:	e798      	b.n	8003eca <HAL_GPIO_Init+0x102>
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8003f98:	4a12      	ldr	r2, [pc, #72]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003f9a:	6813      	ldr	r3, [r2, #0]
 8003f9c:	ea23 0306 	bic.w	r3, r3, r6
 8003fa0:	6013      	str	r3, [r2, #0]
 8003fa2:	e7a1      	b.n	8003ee8 <HAL_GPIO_Init+0x120>
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8003fa4:	4a0f      	ldr	r2, [pc, #60]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003fa6:	6853      	ldr	r3, [r2, #4]
 8003fa8:	ea23 0306 	bic.w	r3, r3, r6
 8003fac:	6053      	str	r3, [r2, #4]
 8003fae:	e7a3      	b.n	8003ef8 <HAL_GPIO_Init+0x130>
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 8003fb0:	4a0c      	ldr	r2, [pc, #48]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003fb2:	6893      	ldr	r3, [r2, #8]
 8003fb4:	ea23 0306 	bic.w	r3, r3, r6
 8003fb8:	6093      	str	r3, [r2, #8]
 8003fba:	e7a5      	b.n	8003f08 <HAL_GPIO_Init+0x140>
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8003fbc:	4a09      	ldr	r2, [pc, #36]	; (8003fe4 <HAL_GPIO_Init+0x21c>)
 8003fbe:	68d3      	ldr	r3, [r2, #12]
 8003fc0:	ea23 0606 	bic.w	r6, r3, r6
 8003fc4:	60d6      	str	r6, [r2, #12]
 8003fc6:	e7a7      	b.n	8003f18 <HAL_GPIO_Init+0x150>
  }
}
 8003fc8:	b002      	add	sp, #8
 8003fca:	bcf0      	pop	{r4, r5, r6, r7}
 8003fcc:	4770      	bx	lr
 8003fce:	bf00      	nop
 8003fd0:	10220000 	.word	0x10220000
 8003fd4:	10310000 	.word	0x10310000
 8003fd8:	40021000 	.word	0x40021000
 8003fdc:	40010000 	.word	0x40010000
 8003fe0:	40010800 	.word	0x40010800
 8003fe4:	40010400 	.word	0x40010400

08003fe8 <HAL_GPIO_DeInit>:
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00u;
 8003fe8:	2200      	movs	r2, #0
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0u)
 8003fea:	e06b      	b.n	80040c4 <HAL_GPIO_DeInit+0xdc>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = AFIO->EXTICR[position >> 2u];
      tmp &= 0x0FuL << (4u * (position & 0x03u));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8003fec:	2603      	movs	r6, #3
 8003fee:	e000      	b.n	8003ff2 <HAL_GPIO_DeInit+0xa>
 8003ff0:	2600      	movs	r6, #0
 8003ff2:	fa06 f404 	lsl.w	r4, r6, r4
 8003ff6:	42ac      	cmp	r4, r5
 8003ff8:	d03f      	beq.n	800407a <HAL_GPIO_DeInit+0x92>
        CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
      }
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register */
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8003ffa:	2bff      	cmp	r3, #255	; 0xff
 8003ffc:	d858      	bhi.n	80040b0 <HAL_GPIO_DeInit+0xc8>
 8003ffe:	4684      	mov	ip, r0
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8004000:	2bff      	cmp	r3, #255	; 0xff
 8004002:	d858      	bhi.n	80040b6 <HAL_GPIO_DeInit+0xce>
 8004004:	0097      	lsls	r7, r2, #2

      /* CRL/CRH default value is floating input(0x04) shifted to correct position */
      MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);
 8004006:	f8dc 4000 	ldr.w	r4, [ip]
 800400a:	260f      	movs	r6, #15
 800400c:	40be      	lsls	r6, r7
 800400e:	ea24 0406 	bic.w	r4, r4, r6
 8004012:	2504      	movs	r5, #4
 8004014:	40bd      	lsls	r5, r7
 8004016:	432c      	orrs	r4, r5
 8004018:	f8cc 4000 	str.w	r4, [ip]

      /* ODR default value is 0 */
      CLEAR_BIT(GPIOx->ODR, iocurrent);
 800401c:	68c4      	ldr	r4, [r0, #12]
 800401e:	ea24 0303 	bic.w	r3, r4, r3
 8004022:	60c3      	str	r3, [r0, #12]
    }

    position++;
 8004024:	3201      	adds	r2, #1
  while ((GPIO_Pin >> position) != 0u)
 8004026:	fa31 f302 	lsrs.w	r3, r1, r2
 800402a:	d048      	beq.n	80040be <HAL_GPIO_DeInit+0xd6>
    iocurrent = (GPIO_Pin) & (1uL << position);
 800402c:	2301      	movs	r3, #1
 800402e:	4093      	lsls	r3, r2
    if (iocurrent)
 8004030:	400b      	ands	r3, r1
 8004032:	d0f7      	beq.n	8004024 <HAL_GPIO_DeInit+0x3c>
      tmp = AFIO->EXTICR[position >> 2u];
 8004034:	ea4f 0c92 	mov.w	ip, r2, lsr #2
 8004038:	f10c 0502 	add.w	r5, ip, #2
 800403c:	4c26      	ldr	r4, [pc, #152]	; (80040d8 <HAL_GPIO_DeInit+0xf0>)
 800403e:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
      tmp &= 0x0FuL << (4u * (position & 0x03u));
 8004042:	f002 0403 	and.w	r4, r2, #3
 8004046:	00a4      	lsls	r4, r4, #2
 8004048:	260f      	movs	r6, #15
 800404a:	fa06 f704 	lsl.w	r7, r6, r4
 800404e:	403d      	ands	r5, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8004050:	4e22      	ldr	r6, [pc, #136]	; (80040dc <HAL_GPIO_DeInit+0xf4>)
 8004052:	42b0      	cmp	r0, r6
 8004054:	d0cc      	beq.n	8003ff0 <HAL_GPIO_DeInit+0x8>
 8004056:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800405a:	42b0      	cmp	r0, r6
 800405c:	d009      	beq.n	8004072 <HAL_GPIO_DeInit+0x8a>
 800405e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8004062:	42b0      	cmp	r0, r6
 8004064:	d007      	beq.n	8004076 <HAL_GPIO_DeInit+0x8e>
 8004066:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800406a:	42b0      	cmp	r0, r6
 800406c:	d0be      	beq.n	8003fec <HAL_GPIO_DeInit+0x4>
 800406e:	2604      	movs	r6, #4
 8004070:	e7bf      	b.n	8003ff2 <HAL_GPIO_DeInit+0xa>
 8004072:	2601      	movs	r6, #1
 8004074:	e7bd      	b.n	8003ff2 <HAL_GPIO_DeInit+0xa>
 8004076:	2602      	movs	r6, #2
 8004078:	e7bb      	b.n	8003ff2 <HAL_GPIO_DeInit+0xa>
        CLEAR_BIT(AFIO->EXTICR[position >> 2u], tmp);
 800407a:	4d17      	ldr	r5, [pc, #92]	; (80040d8 <HAL_GPIO_DeInit+0xf0>)
 800407c:	f10c 0402 	add.w	r4, ip, #2
 8004080:	f855 6024 	ldr.w	r6, [r5, r4, lsl #2]
 8004084:	ea26 0607 	bic.w	r6, r6, r7
 8004088:	f845 6024 	str.w	r6, [r5, r4, lsl #2]
        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
 800408c:	4c14      	ldr	r4, [pc, #80]	; (80040e0 <HAL_GPIO_DeInit+0xf8>)
 800408e:	6825      	ldr	r5, [r4, #0]
 8004090:	ea25 0503 	bic.w	r5, r5, r3
 8004094:	6025      	str	r5, [r4, #0]
        CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
 8004096:	6865      	ldr	r5, [r4, #4]
 8004098:	ea25 0503 	bic.w	r5, r5, r3
 800409c:	6065      	str	r5, [r4, #4]
        CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
 800409e:	68a5      	ldr	r5, [r4, #8]
 80040a0:	ea25 0503 	bic.w	r5, r5, r3
 80040a4:	60a5      	str	r5, [r4, #8]
        CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
 80040a6:	68e5      	ldr	r5, [r4, #12]
 80040a8:	ea25 0503 	bic.w	r5, r5, r3
 80040ac:	60e5      	str	r5, [r4, #12]
 80040ae:	e7a4      	b.n	8003ffa <HAL_GPIO_DeInit+0x12>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80040b0:	f100 0c04 	add.w	ip, r0, #4
 80040b4:	e7a4      	b.n	8004000 <HAL_GPIO_DeInit+0x18>
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80040b6:	f1a2 0508 	sub.w	r5, r2, #8
 80040ba:	00af      	lsls	r7, r5, #2
 80040bc:	e7a3      	b.n	8004006 <HAL_GPIO_DeInit+0x1e>
  }
}
 80040be:	bcf0      	pop	{r4, r5, r6, r7}
 80040c0:	4770      	bx	lr
    position++;
 80040c2:	3201      	adds	r2, #1
  while ((GPIO_Pin >> position) != 0u)
 80040c4:	fa31 f302 	lsrs.w	r3, r1, r2
 80040c8:	d005      	beq.n	80040d6 <HAL_GPIO_DeInit+0xee>
    iocurrent = (GPIO_Pin) & (1uL << position);
 80040ca:	2301      	movs	r3, #1
 80040cc:	4093      	lsls	r3, r2
    if (iocurrent)
 80040ce:	400b      	ands	r3, r1
 80040d0:	d0f7      	beq.n	80040c2 <HAL_GPIO_DeInit+0xda>
{
 80040d2:	b4f0      	push	{r4, r5, r6, r7}
 80040d4:	e7ae      	b.n	8004034 <HAL_GPIO_DeInit+0x4c>
 80040d6:	4770      	bx	lr
 80040d8:	40010000 	.word	0x40010000
 80040dc:	40010800 	.word	0x40010800
 80040e0:	40010400 	.word	0x40010400

080040e4 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80040e4:	6883      	ldr	r3, [r0, #8]
 80040e6:	4219      	tst	r1, r3
 80040e8:	d001      	beq.n	80040ee <HAL_GPIO_ReadPin+0xa>
  {
    bitstatus = GPIO_PIN_SET;
 80040ea:	2001      	movs	r0, #1
 80040ec:	4770      	bx	lr
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 80040ee:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 80040f0:	4770      	bx	lr

080040f2 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80040f2:	b10a      	cbz	r2, 80040f8 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 80040f4:	6101      	str	r1, [r0, #16]
 80040f6:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 80040f8:	0409      	lsls	r1, r1, #16
 80040fa:	6101      	str	r1, [r0, #16]
  }
}
 80040fc:	4770      	bx	lr

080040fe <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Ouput Data Register value */
  odr = GPIOx->ODR;
 80040fe:	68c3      	ldr	r3, [r0, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8004100:	ea01 0203 	and.w	r2, r1, r3
 8004104:	ea21 0103 	bic.w	r1, r1, r3
 8004108:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 800410c:	6101      	str	r1, [r0, #16]
}
 800410e:	4770      	bx	lr

08004110 <HAL_GPIO_LockPin>:
* @param  GPIO_Pin: specifies the port bit to be locked.
*         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
* @retval None
*/
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8004110:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 8004112:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004116:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  SET_BIT(tmp, GPIO_Pin);
 8004118:	9b01      	ldr	r3, [sp, #4]
 800411a:	430b      	orrs	r3, r1
 800411c:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 800411e:	9b01      	ldr	r3, [sp, #4]
 8004120:	6183      	str	r3, [r0, #24]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 8004122:	6181      	str	r1, [r0, #24]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 8004124:	9b01      	ldr	r3, [sp, #4]
 8004126:	6183      	str	r3, [r0, #24]
  /* Read LCKK register. This read is mandatory to complete key lock sequence */
  tmp = GPIOx->LCKR;
 8004128:	6983      	ldr	r3, [r0, #24]
 800412a:	9301      	str	r3, [sp, #4]

  /* read again in order to confirm lock is active */
  if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
 800412c:	6983      	ldr	r3, [r0, #24]
 800412e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8004132:	d002      	beq.n	800413a <HAL_GPIO_LockPin+0x2a>
  {
    return HAL_OK;
 8004134:	2000      	movs	r0, #0
  }
  else
  {
    return HAL_ERROR;
  }
}
 8004136:	b002      	add	sp, #8
 8004138:	4770      	bx	lr
    return HAL_ERROR;
 800413a:	2001      	movs	r0, #1
 800413c:	e7fb      	b.n	8004136 <HAL_GPIO_LockPin+0x26>
  /* Prevent unused argument(s) compilation warning */
  UNUSED(GPIO_Pin);
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 800413e:	4770      	bx	lr

08004140 <HAL_GPIO_EXTI_IRQHandler>:
{
 8004140:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8004142:	4b05      	ldr	r3, [pc, #20]	; (8004158 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 8004144:	695b      	ldr	r3, [r3, #20]
 8004146:	4203      	tst	r3, r0
 8004148:	d100      	bne.n	800414c <HAL_GPIO_EXTI_IRQHandler+0xc>
}
 800414a:	bd08      	pop	{r3, pc}
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800414c:	4b02      	ldr	r3, [pc, #8]	; (8004158 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 800414e:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8004150:	f7fc fa3c 	bl	80005cc <HAL_GPIO_EXTI_Callback>
}
 8004154:	e7f9      	b.n	800414a <HAL_GPIO_EXTI_IRQHandler+0xa>
 8004156:	bf00      	nop
 8004158:	40010400 	.word	0x40010400

0800415c <RCC_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
 800415c:	b082      	sub	sp, #8
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 800415e:	4b08      	ldr	r3, [pc, #32]	; (8004180 <RCC_Delay+0x24>)
 8004160:	681b      	ldr	r3, [r3, #0]
 8004162:	4a08      	ldr	r2, [pc, #32]	; (8004184 <RCC_Delay+0x28>)
 8004164:	fba2 2303 	umull	r2, r3, r2, r3
 8004168:	0a5b      	lsrs	r3, r3, #9
 800416a:	fb00 f303 	mul.w	r3, r0, r3
 800416e:	9301      	str	r3, [sp, #4]
  do
  {
    __NOP();
 8004170:	bf00      	nop
  }
  while (Delay --);
 8004172:	9b01      	ldr	r3, [sp, #4]
 8004174:	1e5a      	subs	r2, r3, #1
 8004176:	9201      	str	r2, [sp, #4]
 8004178:	2b00      	cmp	r3, #0
 800417a:	d1f9      	bne.n	8004170 <RCC_Delay+0x14>
}
 800417c:	b002      	add	sp, #8
 800417e:	4770      	bx	lr
 8004180:	20000028 	.word	0x20000028
 8004184:	10624dd3 	.word	0x10624dd3

08004188 <HAL_RCC_DeInit>:
{
 8004188:	b570      	push	{r4, r5, r6, lr}
  tickstart = HAL_GetTick();
 800418a:	f7fd fea7 	bl	8001edc <HAL_GetTick>
 800418e:	4604      	mov	r4, r0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8004190:	4a36      	ldr	r2, [pc, #216]	; (800426c <HAL_RCC_DeInit+0xe4>)
 8004192:	6813      	ldr	r3, [r2, #0]
 8004194:	f043 0301 	orr.w	r3, r3, #1
 8004198:	6013      	str	r3, [r2, #0]
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 800419a:	4b34      	ldr	r3, [pc, #208]	; (800426c <HAL_RCC_DeInit+0xe4>)
 800419c:	681b      	ldr	r3, [r3, #0]
 800419e:	f013 0f02 	tst.w	r3, #2
 80041a2:	d107      	bne.n	80041b4 <HAL_RCC_DeInit+0x2c>
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80041a4:	f7fd fe9a 	bl	8001edc <HAL_GetTick>
 80041a8:	1b00      	subs	r0, r0, r4
 80041aa:	2802      	cmp	r0, #2
 80041ac:	d9f5      	bls.n	800419a <HAL_RCC_DeInit+0x12>
      return HAL_TIMEOUT;
 80041ae:	2403      	movs	r4, #3
}
 80041b0:	4620      	mov	r0, r4
 80041b2:	bd70      	pop	{r4, r5, r6, pc}
  MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (0x10U << RCC_CR_HSITRIM_Pos));
 80041b4:	4d2d      	ldr	r5, [pc, #180]	; (800426c <HAL_RCC_DeInit+0xe4>)
 80041b6:	682b      	ldr	r3, [r5, #0]
 80041b8:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80041bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80041c0:	602b      	str	r3, [r5, #0]
  tickstart = HAL_GetTick();
 80041c2:	f7fd fe8b 	bl	8001edc <HAL_GetTick>
 80041c6:	4604      	mov	r4, r0
  CLEAR_REG(RCC->CFGR);
 80041c8:	2300      	movs	r3, #0
 80041ca:	606b      	str	r3, [r5, #4]
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
 80041cc:	4b27      	ldr	r3, [pc, #156]	; (800426c <HAL_RCC_DeInit+0xe4>)
 80041ce:	685b      	ldr	r3, [r3, #4]
 80041d0:	f013 0f0c 	tst.w	r3, #12
 80041d4:	d008      	beq.n	80041e8 <HAL_RCC_DeInit+0x60>
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80041d6:	f7fd fe81 	bl	8001edc <HAL_GetTick>
 80041da:	1b00      	subs	r0, r0, r4
 80041dc:	f241 3388 	movw	r3, #5000	; 0x1388
 80041e0:	4298      	cmp	r0, r3
 80041e2:	d9f3      	bls.n	80041cc <HAL_RCC_DeInit+0x44>
      return HAL_TIMEOUT;
 80041e4:	2403      	movs	r4, #3
 80041e6:	e7e3      	b.n	80041b0 <HAL_RCC_DeInit+0x28>
  SystemCoreClock = HSI_VALUE;
 80041e8:	4b21      	ldr	r3, [pc, #132]	; (8004270 <HAL_RCC_DeInit+0xe8>)
 80041ea:	4a22      	ldr	r2, [pc, #136]	; (8004274 <HAL_RCC_DeInit+0xec>)
 80041ec:	601a      	str	r2, [r3, #0]
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
 80041ee:	4b22      	ldr	r3, [pc, #136]	; (8004278 <HAL_RCC_DeInit+0xf0>)
 80041f0:	6818      	ldr	r0, [r3, #0]
 80041f2:	f7fd fd3b 	bl	8001c6c <HAL_InitTick>
 80041f6:	4604      	mov	r4, r0
 80041f8:	b108      	cbz	r0, 80041fe <HAL_RCC_DeInit+0x76>
    return HAL_ERROR;
 80041fa:	2401      	movs	r4, #1
 80041fc:	e7d8      	b.n	80041b0 <HAL_RCC_DeInit+0x28>
  tickstart = HAL_GetTick();
 80041fe:	f7fd fe6d 	bl	8001edc <HAL_GetTick>
 8004202:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8004204:	4a19      	ldr	r2, [pc, #100]	; (800426c <HAL_RCC_DeInit+0xe4>)
 8004206:	6813      	ldr	r3, [r2, #0]
 8004208:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800420c:	6013      	str	r3, [r2, #0]
  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 800420e:	4b17      	ldr	r3, [pc, #92]	; (800426c <HAL_RCC_DeInit+0xe4>)
 8004210:	681b      	ldr	r3, [r3, #0]
 8004212:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8004216:	d006      	beq.n	8004226 <HAL_RCC_DeInit+0x9e>
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004218:	f7fd fe60 	bl	8001edc <HAL_GetTick>
 800421c:	1b40      	subs	r0, r0, r5
 800421e:	2802      	cmp	r0, #2
 8004220:	d9f5      	bls.n	800420e <HAL_RCC_DeInit+0x86>
      return HAL_TIMEOUT;
 8004222:	2403      	movs	r4, #3
 8004224:	e7c4      	b.n	80041b0 <HAL_RCC_DeInit+0x28>
  CLEAR_REG(RCC->CFGR);
 8004226:	4e11      	ldr	r6, [pc, #68]	; (800426c <HAL_RCC_DeInit+0xe4>)
 8004228:	2300      	movs	r3, #0
 800422a:	6073      	str	r3, [r6, #4]
  tickstart = HAL_GetTick();
 800422c:	f7fd fe56 	bl	8001edc <HAL_GetTick>
 8004230:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON);
 8004232:	6833      	ldr	r3, [r6, #0]
 8004234:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 8004238:	6033      	str	r3, [r6, #0]
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 800423a:	4b0c      	ldr	r3, [pc, #48]	; (800426c <HAL_RCC_DeInit+0xe4>)
 800423c:	681b      	ldr	r3, [r3, #0]
 800423e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8004242:	d006      	beq.n	8004252 <HAL_RCC_DeInit+0xca>
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004244:	f7fd fe4a 	bl	8001edc <HAL_GetTick>
 8004248:	1b40      	subs	r0, r0, r5
 800424a:	2864      	cmp	r0, #100	; 0x64
 800424c:	d9f5      	bls.n	800423a <HAL_RCC_DeInit+0xb2>
      return HAL_TIMEOUT;
 800424e:	2403      	movs	r4, #3
 8004250:	e7ae      	b.n	80041b0 <HAL_RCC_DeInit+0x28>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8004252:	4b06      	ldr	r3, [pc, #24]	; (800426c <HAL_RCC_DeInit+0xe4>)
 8004254:	681a      	ldr	r2, [r3, #0]
 8004256:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800425a:	601a      	str	r2, [r3, #0]
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
 800425c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800425e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8004262:	625a      	str	r2, [r3, #36]	; 0x24
  CLEAR_REG(RCC->CIR);
 8004264:	2200      	movs	r2, #0
 8004266:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8004268:	e7a2      	b.n	80041b0 <HAL_RCC_DeInit+0x28>
 800426a:	bf00      	nop
 800426c:	40021000 	.word	0x40021000
 8004270:	20000028 	.word	0x20000028
 8004274:	007a1200 	.word	0x007a1200
 8004278:	20000030 	.word	0x20000030

0800427c <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 800427c:	2800      	cmp	r0, #0
 800427e:	f000 81f1 	beq.w	8004664 <HAL_RCC_OscConfig+0x3e8>
{
 8004282:	b570      	push	{r4, r5, r6, lr}
 8004284:	b082      	sub	sp, #8
 8004286:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004288:	6803      	ldr	r3, [r0, #0]
 800428a:	f013 0f01 	tst.w	r3, #1
 800428e:	d02c      	beq.n	80042ea <HAL_RCC_OscConfig+0x6e>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8004290:	4baa      	ldr	r3, [pc, #680]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004292:	685b      	ldr	r3, [r3, #4]
 8004294:	f003 030c 	and.w	r3, r3, #12
 8004298:	2b04      	cmp	r3, #4
 800429a:	d01d      	beq.n	80042d8 <HAL_RCC_OscConfig+0x5c>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800429c:	4ba7      	ldr	r3, [pc, #668]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 800429e:	685b      	ldr	r3, [r3, #4]
 80042a0:	f003 030c 	and.w	r3, r3, #12
 80042a4:	2b08      	cmp	r3, #8
 80042a6:	d012      	beq.n	80042ce <HAL_RCC_OscConfig+0x52>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80042a8:	6863      	ldr	r3, [r4, #4]
 80042aa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80042ae:	d041      	beq.n	8004334 <HAL_RCC_OscConfig+0xb8>
 80042b0:	2b00      	cmp	r3, #0
 80042b2:	d155      	bne.n	8004360 <HAL_RCC_OscConfig+0xe4>
 80042b4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80042b8:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80042bc:	681a      	ldr	r2, [r3, #0]
 80042be:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80042c2:	601a      	str	r2, [r3, #0]
 80042c4:	681a      	ldr	r2, [r3, #0]
 80042c6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80042ca:	601a      	str	r2, [r3, #0]
 80042cc:	e037      	b.n	800433e <HAL_RCC_OscConfig+0xc2>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80042ce:	4b9b      	ldr	r3, [pc, #620]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80042d0:	685b      	ldr	r3, [r3, #4]
 80042d2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80042d6:	d0e7      	beq.n	80042a8 <HAL_RCC_OscConfig+0x2c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80042d8:	4b98      	ldr	r3, [pc, #608]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80042da:	681b      	ldr	r3, [r3, #0]
 80042dc:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80042e0:	d003      	beq.n	80042ea <HAL_RCC_OscConfig+0x6e>
 80042e2:	6863      	ldr	r3, [r4, #4]
 80042e4:	2b00      	cmp	r3, #0
 80042e6:	f000 81bf 	beq.w	8004668 <HAL_RCC_OscConfig+0x3ec>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80042ea:	6823      	ldr	r3, [r4, #0]
 80042ec:	f013 0f02 	tst.w	r3, #2
 80042f0:	d075      	beq.n	80043de <HAL_RCC_OscConfig+0x162>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80042f2:	4b92      	ldr	r3, [pc, #584]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80042f4:	685b      	ldr	r3, [r3, #4]
 80042f6:	f013 0f0c 	tst.w	r3, #12
 80042fa:	d05f      	beq.n	80043bc <HAL_RCC_OscConfig+0x140>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80042fc:	4b8f      	ldr	r3, [pc, #572]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80042fe:	685b      	ldr	r3, [r3, #4]
 8004300:	f003 030c 	and.w	r3, r3, #12
 8004304:	2b08      	cmp	r3, #8
 8004306:	d054      	beq.n	80043b2 <HAL_RCC_OscConfig+0x136>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8004308:	6923      	ldr	r3, [r4, #16]
 800430a:	2b00      	cmp	r3, #0
 800430c:	f000 8089 	beq.w	8004422 <HAL_RCC_OscConfig+0x1a6>
        __HAL_RCC_HSI_ENABLE();
 8004310:	4b8b      	ldr	r3, [pc, #556]	; (8004540 <HAL_RCC_OscConfig+0x2c4>)
 8004312:	2201      	movs	r2, #1
 8004314:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8004316:	f7fd fde1 	bl	8001edc <HAL_GetTick>
 800431a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800431c:	4b87      	ldr	r3, [pc, #540]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 800431e:	681b      	ldr	r3, [r3, #0]
 8004320:	f013 0f02 	tst.w	r3, #2
 8004324:	d174      	bne.n	8004410 <HAL_RCC_OscConfig+0x194>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004326:	f7fd fdd9 	bl	8001edc <HAL_GetTick>
 800432a:	1b40      	subs	r0, r0, r5
 800432c:	2802      	cmp	r0, #2
 800432e:	d9f5      	bls.n	800431c <HAL_RCC_OscConfig+0xa0>
            return HAL_TIMEOUT;
 8004330:	2003      	movs	r0, #3
 8004332:	e19e      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004334:	4a81      	ldr	r2, [pc, #516]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004336:	6813      	ldr	r3, [r2, #0]
 8004338:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800433c:	6013      	str	r3, [r2, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800433e:	6863      	ldr	r3, [r4, #4]
 8004340:	b343      	cbz	r3, 8004394 <HAL_RCC_OscConfig+0x118>
        tickstart = HAL_GetTick();
 8004342:	f7fd fdcb 	bl	8001edc <HAL_GetTick>
 8004346:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004348:	4b7c      	ldr	r3, [pc, #496]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 800434a:	681b      	ldr	r3, [r3, #0]
 800434c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8004350:	d1cb      	bne.n	80042ea <HAL_RCC_OscConfig+0x6e>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004352:	f7fd fdc3 	bl	8001edc <HAL_GetTick>
 8004356:	1b40      	subs	r0, r0, r5
 8004358:	2864      	cmp	r0, #100	; 0x64
 800435a:	d9f5      	bls.n	8004348 <HAL_RCC_OscConfig+0xcc>
            return HAL_TIMEOUT;
 800435c:	2003      	movs	r0, #3
 800435e:	e188      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004360:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8004364:	d009      	beq.n	800437a <HAL_RCC_OscConfig+0xfe>
 8004366:	4b75      	ldr	r3, [pc, #468]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004368:	681a      	ldr	r2, [r3, #0]
 800436a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800436e:	601a      	str	r2, [r3, #0]
 8004370:	681a      	ldr	r2, [r3, #0]
 8004372:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004376:	601a      	str	r2, [r3, #0]
 8004378:	e7e1      	b.n	800433e <HAL_RCC_OscConfig+0xc2>
 800437a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800437e:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8004382:	681a      	ldr	r2, [r3, #0]
 8004384:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8004388:	601a      	str	r2, [r3, #0]
 800438a:	681a      	ldr	r2, [r3, #0]
 800438c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004390:	601a      	str	r2, [r3, #0]
 8004392:	e7d4      	b.n	800433e <HAL_RCC_OscConfig+0xc2>
        tickstart = HAL_GetTick();
 8004394:	f7fd fda2 	bl	8001edc <HAL_GetTick>
 8004398:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800439a:	4b68      	ldr	r3, [pc, #416]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 800439c:	681b      	ldr	r3, [r3, #0]
 800439e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80043a2:	d0a2      	beq.n	80042ea <HAL_RCC_OscConfig+0x6e>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80043a4:	f7fd fd9a 	bl	8001edc <HAL_GetTick>
 80043a8:	1b40      	subs	r0, r0, r5
 80043aa:	2864      	cmp	r0, #100	; 0x64
 80043ac:	d9f5      	bls.n	800439a <HAL_RCC_OscConfig+0x11e>
            return HAL_TIMEOUT;
 80043ae:	2003      	movs	r0, #3
 80043b0:	e15f      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80043b2:	4b62      	ldr	r3, [pc, #392]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80043b4:	685b      	ldr	r3, [r3, #4]
 80043b6:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80043ba:	d1a5      	bne.n	8004308 <HAL_RCC_OscConfig+0x8c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80043bc:	4b5f      	ldr	r3, [pc, #380]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80043be:	681b      	ldr	r3, [r3, #0]
 80043c0:	f013 0f02 	tst.w	r3, #2
 80043c4:	d003      	beq.n	80043ce <HAL_RCC_OscConfig+0x152>
 80043c6:	6923      	ldr	r3, [r4, #16]
 80043c8:	2b01      	cmp	r3, #1
 80043ca:	f040 814f 	bne.w	800466c <HAL_RCC_OscConfig+0x3f0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80043ce:	4a5b      	ldr	r2, [pc, #364]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80043d0:	6813      	ldr	r3, [r2, #0]
 80043d2:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80043d6:	6961      	ldr	r1, [r4, #20]
 80043d8:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80043dc:	6013      	str	r3, [r2, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80043de:	6823      	ldr	r3, [r4, #0]
 80043e0:	f013 0f08 	tst.w	r3, #8
 80043e4:	d032      	beq.n	800444c <HAL_RCC_OscConfig+0x1d0>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80043e6:	69a3      	ldr	r3, [r4, #24]
 80043e8:	2b00      	cmp	r3, #0
 80043ea:	d045      	beq.n	8004478 <HAL_RCC_OscConfig+0x1fc>
      __HAL_RCC_LSI_ENABLE();
 80043ec:	4b55      	ldr	r3, [pc, #340]	; (8004544 <HAL_RCC_OscConfig+0x2c8>)
 80043ee:	2201      	movs	r2, #1
 80043f0:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80043f2:	f7fd fd73 	bl	8001edc <HAL_GetTick>
 80043f6:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80043f8:	4b50      	ldr	r3, [pc, #320]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80043fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80043fc:	f013 0f02 	tst.w	r3, #2
 8004400:	d121      	bne.n	8004446 <HAL_RCC_OscConfig+0x1ca>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004402:	f7fd fd6b 	bl	8001edc <HAL_GetTick>
 8004406:	1b40      	subs	r0, r0, r5
 8004408:	2802      	cmp	r0, #2
 800440a:	d9f5      	bls.n	80043f8 <HAL_RCC_OscConfig+0x17c>
          return HAL_TIMEOUT;
 800440c:	2003      	movs	r0, #3
 800440e:	e130      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004410:	4a4a      	ldr	r2, [pc, #296]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004412:	6813      	ldr	r3, [r2, #0]
 8004414:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8004418:	6961      	ldr	r1, [r4, #20]
 800441a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800441e:	6013      	str	r3, [r2, #0]
 8004420:	e7dd      	b.n	80043de <HAL_RCC_OscConfig+0x162>
        __HAL_RCC_HSI_DISABLE();
 8004422:	4b47      	ldr	r3, [pc, #284]	; (8004540 <HAL_RCC_OscConfig+0x2c4>)
 8004424:	2200      	movs	r2, #0
 8004426:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8004428:	f7fd fd58 	bl	8001edc <HAL_GetTick>
 800442c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800442e:	4b43      	ldr	r3, [pc, #268]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004430:	681b      	ldr	r3, [r3, #0]
 8004432:	f013 0f02 	tst.w	r3, #2
 8004436:	d0d2      	beq.n	80043de <HAL_RCC_OscConfig+0x162>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004438:	f7fd fd50 	bl	8001edc <HAL_GetTick>
 800443c:	1b40      	subs	r0, r0, r5
 800443e:	2802      	cmp	r0, #2
 8004440:	d9f5      	bls.n	800442e <HAL_RCC_OscConfig+0x1b2>
            return HAL_TIMEOUT;
 8004442:	2003      	movs	r0, #3
 8004444:	e115      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
      RCC_Delay(1);
 8004446:	2001      	movs	r0, #1
 8004448:	f7ff fe88 	bl	800415c <RCC_Delay>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800444c:	6823      	ldr	r3, [r4, #0]
 800444e:	f013 0f04 	tst.w	r3, #4
 8004452:	f000 8097 	beq.w	8004584 <HAL_RCC_OscConfig+0x308>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8004456:	4b39      	ldr	r3, [pc, #228]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004458:	69db      	ldr	r3, [r3, #28]
 800445a:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800445e:	d11d      	bne.n	800449c <HAL_RCC_OscConfig+0x220>
      __HAL_RCC_PWR_CLK_ENABLE();
 8004460:	4b36      	ldr	r3, [pc, #216]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004462:	69da      	ldr	r2, [r3, #28]
 8004464:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004468:	61da      	str	r2, [r3, #28]
 800446a:	69db      	ldr	r3, [r3, #28]
 800446c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004470:	9301      	str	r3, [sp, #4]
 8004472:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8004474:	2501      	movs	r5, #1
 8004476:	e012      	b.n	800449e <HAL_RCC_OscConfig+0x222>
      __HAL_RCC_LSI_DISABLE();
 8004478:	4b32      	ldr	r3, [pc, #200]	; (8004544 <HAL_RCC_OscConfig+0x2c8>)
 800447a:	2200      	movs	r2, #0
 800447c:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 800447e:	f7fd fd2d 	bl	8001edc <HAL_GetTick>
 8004482:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004484:	4b2d      	ldr	r3, [pc, #180]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 8004486:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004488:	f013 0f02 	tst.w	r3, #2
 800448c:	d0de      	beq.n	800444c <HAL_RCC_OscConfig+0x1d0>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800448e:	f7fd fd25 	bl	8001edc <HAL_GetTick>
 8004492:	1b40      	subs	r0, r0, r5
 8004494:	2802      	cmp	r0, #2
 8004496:	d9f5      	bls.n	8004484 <HAL_RCC_OscConfig+0x208>
          return HAL_TIMEOUT;
 8004498:	2003      	movs	r0, #3
 800449a:	e0ea      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
    FlagStatus       pwrclkchanged = RESET;
 800449c:	2500      	movs	r5, #0
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800449e:	4b2a      	ldr	r3, [pc, #168]	; (8004548 <HAL_RCC_OscConfig+0x2cc>)
 80044a0:	681b      	ldr	r3, [r3, #0]
 80044a2:	f413 7f80 	tst.w	r3, #256	; 0x100
 80044a6:	d011      	beq.n	80044cc <HAL_RCC_OscConfig+0x250>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80044a8:	68e3      	ldr	r3, [r4, #12]
 80044aa:	2b01      	cmp	r3, #1
 80044ac:	d022      	beq.n	80044f4 <HAL_RCC_OscConfig+0x278>
 80044ae:	2b00      	cmp	r3, #0
 80044b0:	d138      	bne.n	8004524 <HAL_RCC_OscConfig+0x2a8>
 80044b2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80044b6:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80044ba:	6a1a      	ldr	r2, [r3, #32]
 80044bc:	f022 0201 	bic.w	r2, r2, #1
 80044c0:	621a      	str	r2, [r3, #32]
 80044c2:	6a1a      	ldr	r2, [r3, #32]
 80044c4:	f022 0204 	bic.w	r2, r2, #4
 80044c8:	621a      	str	r2, [r3, #32]
 80044ca:	e018      	b.n	80044fe <HAL_RCC_OscConfig+0x282>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80044cc:	4a1e      	ldr	r2, [pc, #120]	; (8004548 <HAL_RCC_OscConfig+0x2cc>)
 80044ce:	6813      	ldr	r3, [r2, #0]
 80044d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80044d4:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80044d6:	f7fd fd01 	bl	8001edc <HAL_GetTick>
 80044da:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80044dc:	4b1a      	ldr	r3, [pc, #104]	; (8004548 <HAL_RCC_OscConfig+0x2cc>)
 80044de:	681b      	ldr	r3, [r3, #0]
 80044e0:	f413 7f80 	tst.w	r3, #256	; 0x100
 80044e4:	d1e0      	bne.n	80044a8 <HAL_RCC_OscConfig+0x22c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80044e6:	f7fd fcf9 	bl	8001edc <HAL_GetTick>
 80044ea:	1b80      	subs	r0, r0, r6
 80044ec:	2864      	cmp	r0, #100	; 0x64
 80044ee:	d9f5      	bls.n	80044dc <HAL_RCC_OscConfig+0x260>
          return HAL_TIMEOUT;
 80044f0:	2003      	movs	r0, #3
 80044f2:	e0be      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80044f4:	4a11      	ldr	r2, [pc, #68]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 80044f6:	6a13      	ldr	r3, [r2, #32]
 80044f8:	f043 0301 	orr.w	r3, r3, #1
 80044fc:	6213      	str	r3, [r2, #32]
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80044fe:	68e3      	ldr	r3, [r4, #12]
 8004500:	b373      	cbz	r3, 8004560 <HAL_RCC_OscConfig+0x2e4>
      tickstart = HAL_GetTick();
 8004502:	f7fd fceb 	bl	8001edc <HAL_GetTick>
 8004506:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004508:	4b0c      	ldr	r3, [pc, #48]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 800450a:	6a1b      	ldr	r3, [r3, #32]
 800450c:	f013 0f02 	tst.w	r3, #2
 8004510:	d137      	bne.n	8004582 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004512:	f7fd fce3 	bl	8001edc <HAL_GetTick>
 8004516:	1b80      	subs	r0, r0, r6
 8004518:	f241 3388 	movw	r3, #5000	; 0x1388
 800451c:	4298      	cmp	r0, r3
 800451e:	d9f3      	bls.n	8004508 <HAL_RCC_OscConfig+0x28c>
          return HAL_TIMEOUT;
 8004520:	2003      	movs	r0, #3
 8004522:	e0a6      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004524:	2b05      	cmp	r3, #5
 8004526:	d011      	beq.n	800454c <HAL_RCC_OscConfig+0x2d0>
 8004528:	4b04      	ldr	r3, [pc, #16]	; (800453c <HAL_RCC_OscConfig+0x2c0>)
 800452a:	6a1a      	ldr	r2, [r3, #32]
 800452c:	f022 0201 	bic.w	r2, r2, #1
 8004530:	621a      	str	r2, [r3, #32]
 8004532:	6a1a      	ldr	r2, [r3, #32]
 8004534:	f022 0204 	bic.w	r2, r2, #4
 8004538:	621a      	str	r2, [r3, #32]
 800453a:	e7e0      	b.n	80044fe <HAL_RCC_OscConfig+0x282>
 800453c:	40021000 	.word	0x40021000
 8004540:	42420000 	.word	0x42420000
 8004544:	42420480 	.word	0x42420480
 8004548:	40007000 	.word	0x40007000
 800454c:	4b4d      	ldr	r3, [pc, #308]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 800454e:	6a1a      	ldr	r2, [r3, #32]
 8004550:	f042 0204 	orr.w	r2, r2, #4
 8004554:	621a      	str	r2, [r3, #32]
 8004556:	6a1a      	ldr	r2, [r3, #32]
 8004558:	f042 0201 	orr.w	r2, r2, #1
 800455c:	621a      	str	r2, [r3, #32]
 800455e:	e7ce      	b.n	80044fe <HAL_RCC_OscConfig+0x282>
      tickstart = HAL_GetTick();
 8004560:	f7fd fcbc 	bl	8001edc <HAL_GetTick>
 8004564:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8004566:	4b47      	ldr	r3, [pc, #284]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 8004568:	6a1b      	ldr	r3, [r3, #32]
 800456a:	f013 0f02 	tst.w	r3, #2
 800456e:	d008      	beq.n	8004582 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004570:	f7fd fcb4 	bl	8001edc <HAL_GetTick>
 8004574:	1b80      	subs	r0, r0, r6
 8004576:	f241 3388 	movw	r3, #5000	; 0x1388
 800457a:	4298      	cmp	r0, r3
 800457c:	d9f3      	bls.n	8004566 <HAL_RCC_OscConfig+0x2ea>
          return HAL_TIMEOUT;
 800457e:	2003      	movs	r0, #3
 8004580:	e077      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
    if (pwrclkchanged == SET)
 8004582:	b9e5      	cbnz	r5, 80045be <HAL_RCC_OscConfig+0x342>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8004584:	69e3      	ldr	r3, [r4, #28]
 8004586:	2b00      	cmp	r3, #0
 8004588:	d072      	beq.n	8004670 <HAL_RCC_OscConfig+0x3f4>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800458a:	4a3e      	ldr	r2, [pc, #248]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 800458c:	6852      	ldr	r2, [r2, #4]
 800458e:	f002 020c 	and.w	r2, r2, #12
 8004592:	2a08      	cmp	r2, #8
 8004594:	d056      	beq.n	8004644 <HAL_RCC_OscConfig+0x3c8>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004596:	2b02      	cmp	r3, #2
 8004598:	d017      	beq.n	80045ca <HAL_RCC_OscConfig+0x34e>
        __HAL_RCC_PLL_DISABLE();
 800459a:	4b3b      	ldr	r3, [pc, #236]	; (8004688 <HAL_RCC_OscConfig+0x40c>)
 800459c:	2200      	movs	r2, #0
 800459e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80045a0:	f7fd fc9c 	bl	8001edc <HAL_GetTick>
 80045a4:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80045a6:	4b37      	ldr	r3, [pc, #220]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 80045a8:	681b      	ldr	r3, [r3, #0]
 80045aa:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80045ae:	d047      	beq.n	8004640 <HAL_RCC_OscConfig+0x3c4>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80045b0:	f7fd fc94 	bl	8001edc <HAL_GetTick>
 80045b4:	1b00      	subs	r0, r0, r4
 80045b6:	2802      	cmp	r0, #2
 80045b8:	d9f5      	bls.n	80045a6 <HAL_RCC_OscConfig+0x32a>
            return HAL_TIMEOUT;
 80045ba:	2003      	movs	r0, #3
 80045bc:	e059      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
      __HAL_RCC_PWR_CLK_DISABLE();
 80045be:	4a31      	ldr	r2, [pc, #196]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 80045c0:	69d3      	ldr	r3, [r2, #28]
 80045c2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80045c6:	61d3      	str	r3, [r2, #28]
 80045c8:	e7dc      	b.n	8004584 <HAL_RCC_OscConfig+0x308>
        __HAL_RCC_PLL_DISABLE();
 80045ca:	4b2f      	ldr	r3, [pc, #188]	; (8004688 <HAL_RCC_OscConfig+0x40c>)
 80045cc:	2200      	movs	r2, #0
 80045ce:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80045d0:	f7fd fc84 	bl	8001edc <HAL_GetTick>
 80045d4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80045d6:	4b2b      	ldr	r3, [pc, #172]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 80045d8:	681b      	ldr	r3, [r3, #0]
 80045da:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80045de:	d006      	beq.n	80045ee <HAL_RCC_OscConfig+0x372>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80045e0:	f7fd fc7c 	bl	8001edc <HAL_GetTick>
 80045e4:	1b40      	subs	r0, r0, r5
 80045e6:	2802      	cmp	r0, #2
 80045e8:	d9f5      	bls.n	80045d6 <HAL_RCC_OscConfig+0x35a>
            return HAL_TIMEOUT;
 80045ea:	2003      	movs	r0, #3
 80045ec:	e041      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 80045ee:	6a23      	ldr	r3, [r4, #32]
 80045f0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80045f4:	d01a      	beq.n	800462c <HAL_RCC_OscConfig+0x3b0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80045f6:	4923      	ldr	r1, [pc, #140]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 80045f8:	684b      	ldr	r3, [r1, #4]
 80045fa:	f423 1374 	bic.w	r3, r3, #3997696	; 0x3d0000
 80045fe:	6a22      	ldr	r2, [r4, #32]
 8004600:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8004602:	4302      	orrs	r2, r0
 8004604:	4313      	orrs	r3, r2
 8004606:	604b      	str	r3, [r1, #4]
        __HAL_RCC_PLL_ENABLE();
 8004608:	4b1f      	ldr	r3, [pc, #124]	; (8004688 <HAL_RCC_OscConfig+0x40c>)
 800460a:	2201      	movs	r2, #1
 800460c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800460e:	f7fd fc65 	bl	8001edc <HAL_GetTick>
 8004612:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8004614:	4b1b      	ldr	r3, [pc, #108]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 8004616:	681b      	ldr	r3, [r3, #0]
 8004618:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800461c:	d10e      	bne.n	800463c <HAL_RCC_OscConfig+0x3c0>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800461e:	f7fd fc5d 	bl	8001edc <HAL_GetTick>
 8004622:	1b00      	subs	r0, r0, r4
 8004624:	2802      	cmp	r0, #2
 8004626:	d9f5      	bls.n	8004614 <HAL_RCC_OscConfig+0x398>
            return HAL_TIMEOUT;
 8004628:	2003      	movs	r0, #3
 800462a:	e022      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 800462c:	4a15      	ldr	r2, [pc, #84]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 800462e:	6853      	ldr	r3, [r2, #4]
 8004630:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8004634:	68a1      	ldr	r1, [r4, #8]
 8004636:	430b      	orrs	r3, r1
 8004638:	6053      	str	r3, [r2, #4]
 800463a:	e7dc      	b.n	80045f6 <HAL_RCC_OscConfig+0x37a>
  return HAL_OK;
 800463c:	2000      	movs	r0, #0
 800463e:	e018      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
 8004640:	2000      	movs	r0, #0
 8004642:	e016      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8004644:	2b01      	cmp	r3, #1
 8004646:	d016      	beq.n	8004676 <HAL_RCC_OscConfig+0x3fa>
        pll_config = RCC->CFGR;
 8004648:	4b0e      	ldr	r3, [pc, #56]	; (8004684 <HAL_RCC_OscConfig+0x408>)
 800464a:	685b      	ldr	r3, [r3, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800464c:	f403 3180 	and.w	r1, r3, #65536	; 0x10000
 8004650:	6a22      	ldr	r2, [r4, #32]
 8004652:	4291      	cmp	r1, r2
 8004654:	d111      	bne.n	800467a <HAL_RCC_OscConfig+0x3fe>
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 8004656:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 800465a:	6a62      	ldr	r2, [r4, #36]	; 0x24
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800465c:	4293      	cmp	r3, r2
 800465e:	d10e      	bne.n	800467e <HAL_RCC_OscConfig+0x402>
  return HAL_OK;
 8004660:	2000      	movs	r0, #0
 8004662:	e006      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
    return HAL_ERROR;
 8004664:	2001      	movs	r0, #1
}
 8004666:	4770      	bx	lr
        return HAL_ERROR;
 8004668:	2001      	movs	r0, #1
 800466a:	e002      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
        return HAL_ERROR;
 800466c:	2001      	movs	r0, #1
 800466e:	e000      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
  return HAL_OK;
 8004670:	2000      	movs	r0, #0
}
 8004672:	b002      	add	sp, #8
 8004674:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8004676:	2001      	movs	r0, #1
 8004678:	e7fb      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
          return HAL_ERROR;
 800467a:	2001      	movs	r0, #1
 800467c:	e7f9      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
 800467e:	2001      	movs	r0, #1
 8004680:	e7f7      	b.n	8004672 <HAL_RCC_OscConfig+0x3f6>
 8004682:	bf00      	nop
 8004684:	40021000 	.word	0x40021000
 8004688:	42420060 	.word	0x42420060

0800468c <HAL_RCC_MCOConfig>:
{
 800468c:	b530      	push	{r4, r5, lr}
 800468e:	b087      	sub	sp, #28
 8004690:	460d      	mov	r5, r1
  gpio.Mode      = GPIO_MODE_AF_PP;
 8004692:	2302      	movs	r3, #2
 8004694:	9303      	str	r3, [sp, #12]
  gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
 8004696:	2303      	movs	r3, #3
 8004698:	9305      	str	r3, [sp, #20]
  gpio.Pull      = GPIO_NOPULL;
 800469a:	2300      	movs	r3, #0
 800469c:	9304      	str	r3, [sp, #16]
  gpio.Pin       = MCO1_PIN;
 800469e:	f44f 7380 	mov.w	r3, #256	; 0x100
 80046a2:	9302      	str	r3, [sp, #8]
  MCO1_CLK_ENABLE();
 80046a4:	4c0a      	ldr	r4, [pc, #40]	; (80046d0 <HAL_RCC_MCOConfig+0x44>)
 80046a6:	69a3      	ldr	r3, [r4, #24]
 80046a8:	f043 0304 	orr.w	r3, r3, #4
 80046ac:	61a3      	str	r3, [r4, #24]
 80046ae:	69a3      	ldr	r3, [r4, #24]
 80046b0:	f003 0304 	and.w	r3, r3, #4
 80046b4:	9301      	str	r3, [sp, #4]
 80046b6:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
 80046b8:	a902      	add	r1, sp, #8
 80046ba:	4806      	ldr	r0, [pc, #24]	; (80046d4 <HAL_RCC_MCOConfig+0x48>)
 80046bc:	f7ff fb84 	bl	8003dc8 <HAL_GPIO_Init>
  __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
 80046c0:	6863      	ldr	r3, [r4, #4]
 80046c2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 80046c6:	432b      	orrs	r3, r5
 80046c8:	6063      	str	r3, [r4, #4]
}
 80046ca:	b007      	add	sp, #28
 80046cc:	bd30      	pop	{r4, r5, pc}
 80046ce:	bf00      	nop
 80046d0:	40021000 	.word	0x40021000
 80046d4:	40010800 	.word	0x40010800

080046d8 <HAL_RCC_EnableCSS>:
  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
 80046d8:	4b01      	ldr	r3, [pc, #4]	; (80046e0 <HAL_RCC_EnableCSS+0x8>)
 80046da:	2201      	movs	r2, #1
 80046dc:	601a      	str	r2, [r3, #0]
}
 80046de:	4770      	bx	lr
 80046e0:	4242004c 	.word	0x4242004c

080046e4 <HAL_RCC_DisableCSS>:
  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
 80046e4:	4b01      	ldr	r3, [pc, #4]	; (80046ec <HAL_RCC_DisableCSS+0x8>)
 80046e6:	2200      	movs	r2, #0
 80046e8:	601a      	str	r2, [r3, #0]
}
 80046ea:	4770      	bx	lr
 80046ec:	4242004c 	.word	0x4242004c

080046f0 <HAL_RCC_GetSysClockFreq>:
{
 80046f0:	b086      	sub	sp, #24
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 80046f2:	4b16      	ldr	r3, [pc, #88]	; (800474c <HAL_RCC_GetSysClockFreq+0x5c>)
 80046f4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80046f6:	f10d 0c18 	add.w	ip, sp, #24
 80046fa:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
  const uint8_t aPredivFactorTable[2] = {1, 2};
 80046fe:	f240 2301 	movw	r3, #513	; 0x201
 8004702:	f8ad 3004 	strh.w	r3, [sp, #4]
  tmpreg = RCC->CFGR;
 8004706:	4b12      	ldr	r3, [pc, #72]	; (8004750 <HAL_RCC_GetSysClockFreq+0x60>)
 8004708:	685b      	ldr	r3, [r3, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 800470a:	f003 020c 	and.w	r2, r3, #12
 800470e:	2a08      	cmp	r2, #8
 8004710:	d002      	beq.n	8004718 <HAL_RCC_GetSysClockFreq+0x28>
      sysclockfreq = HSE_VALUE;
 8004712:	4810      	ldr	r0, [pc, #64]	; (8004754 <HAL_RCC_GetSysClockFreq+0x64>)
}
 8004714:	b006      	add	sp, #24
 8004716:	4770      	bx	lr
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8004718:	f3c3 4283 	ubfx	r2, r3, #18, #4
 800471c:	4462      	add	r2, ip
 800471e:	f812 2c10 	ldrb.w	r2, [r2, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8004722:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8004726:	d00c      	beq.n	8004742 <HAL_RCC_GetSysClockFreq+0x52>
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8004728:	4b09      	ldr	r3, [pc, #36]	; (8004750 <HAL_RCC_GetSysClockFreq+0x60>)
 800472a:	685b      	ldr	r3, [r3, #4]
 800472c:	f3c3 4340 	ubfx	r3, r3, #17, #1
 8004730:	4463      	add	r3, ip
 8004732:	f813 3c14 	ldrb.w	r3, [r3, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8004736:	4807      	ldr	r0, [pc, #28]	; (8004754 <HAL_RCC_GetSysClockFreq+0x64>)
 8004738:	fb00 f002 	mul.w	r0, r0, r2
 800473c:	fbb0 f0f3 	udiv	r0, r0, r3
 8004740:	e7e8      	b.n	8004714 <HAL_RCC_GetSysClockFreq+0x24>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8004742:	4805      	ldr	r0, [pc, #20]	; (8004758 <HAL_RCC_GetSysClockFreq+0x68>)
 8004744:	fb00 f002 	mul.w	r0, r0, r2
 8004748:	e7e4      	b.n	8004714 <HAL_RCC_GetSysClockFreq+0x24>
 800474a:	bf00      	nop
 800474c:	0800fe80 	.word	0x0800fe80
 8004750:	40021000 	.word	0x40021000
 8004754:	007a1200 	.word	0x007a1200
 8004758:	003d0900 	.word	0x003d0900

0800475c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 800475c:	2800      	cmp	r0, #0
 800475e:	f000 80a0 	beq.w	80048a2 <HAL_RCC_ClockConfig+0x146>
{
 8004762:	b570      	push	{r4, r5, r6, lr}
 8004764:	460d      	mov	r5, r1
 8004766:	4604      	mov	r4, r0
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004768:	4b52      	ldr	r3, [pc, #328]	; (80048b4 <HAL_RCC_ClockConfig+0x158>)
 800476a:	681b      	ldr	r3, [r3, #0]
 800476c:	f003 0307 	and.w	r3, r3, #7
 8004770:	428b      	cmp	r3, r1
 8004772:	d20b      	bcs.n	800478c <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004774:	4a4f      	ldr	r2, [pc, #316]	; (80048b4 <HAL_RCC_ClockConfig+0x158>)
 8004776:	6813      	ldr	r3, [r2, #0]
 8004778:	f023 0307 	bic.w	r3, r3, #7
 800477c:	430b      	orrs	r3, r1
 800477e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004780:	6813      	ldr	r3, [r2, #0]
 8004782:	f003 0307 	and.w	r3, r3, #7
 8004786:	428b      	cmp	r3, r1
 8004788:	f040 808d 	bne.w	80048a6 <HAL_RCC_ClockConfig+0x14a>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800478c:	6823      	ldr	r3, [r4, #0]
 800478e:	f013 0f02 	tst.w	r3, #2
 8004792:	d017      	beq.n	80047c4 <HAL_RCC_ClockConfig+0x68>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004794:	f013 0f04 	tst.w	r3, #4
 8004798:	d004      	beq.n	80047a4 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800479a:	4a47      	ldr	r2, [pc, #284]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 800479c:	6853      	ldr	r3, [r2, #4]
 800479e:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 80047a2:	6053      	str	r3, [r2, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80047a4:	6823      	ldr	r3, [r4, #0]
 80047a6:	f013 0f08 	tst.w	r3, #8
 80047aa:	d004      	beq.n	80047b6 <HAL_RCC_ClockConfig+0x5a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80047ac:	4a42      	ldr	r2, [pc, #264]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 80047ae:	6853      	ldr	r3, [r2, #4]
 80047b0:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 80047b4:	6053      	str	r3, [r2, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80047b6:	4a40      	ldr	r2, [pc, #256]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 80047b8:	6853      	ldr	r3, [r2, #4]
 80047ba:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80047be:	68a1      	ldr	r1, [r4, #8]
 80047c0:	430b      	orrs	r3, r1
 80047c2:	6053      	str	r3, [r2, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80047c4:	6823      	ldr	r3, [r4, #0]
 80047c6:	f013 0f01 	tst.w	r3, #1
 80047ca:	d031      	beq.n	8004830 <HAL_RCC_ClockConfig+0xd4>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80047cc:	6863      	ldr	r3, [r4, #4]
 80047ce:	2b01      	cmp	r3, #1
 80047d0:	d020      	beq.n	8004814 <HAL_RCC_ClockConfig+0xb8>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80047d2:	2b02      	cmp	r3, #2
 80047d4:	d025      	beq.n	8004822 <HAL_RCC_ClockConfig+0xc6>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80047d6:	4a38      	ldr	r2, [pc, #224]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 80047d8:	6812      	ldr	r2, [r2, #0]
 80047da:	f012 0f02 	tst.w	r2, #2
 80047de:	d064      	beq.n	80048aa <HAL_RCC_ClockConfig+0x14e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80047e0:	4935      	ldr	r1, [pc, #212]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 80047e2:	684a      	ldr	r2, [r1, #4]
 80047e4:	f022 0203 	bic.w	r2, r2, #3
 80047e8:	4313      	orrs	r3, r2
 80047ea:	604b      	str	r3, [r1, #4]
    tickstart = HAL_GetTick();
 80047ec:	f7fd fb76 	bl	8001edc <HAL_GetTick>
 80047f0:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80047f2:	4b31      	ldr	r3, [pc, #196]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 80047f4:	685b      	ldr	r3, [r3, #4]
 80047f6:	f003 030c 	and.w	r3, r3, #12
 80047fa:	6862      	ldr	r2, [r4, #4]
 80047fc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8004800:	d016      	beq.n	8004830 <HAL_RCC_ClockConfig+0xd4>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004802:	f7fd fb6b 	bl	8001edc <HAL_GetTick>
 8004806:	1b80      	subs	r0, r0, r6
 8004808:	f241 3388 	movw	r3, #5000	; 0x1388
 800480c:	4298      	cmp	r0, r3
 800480e:	d9f0      	bls.n	80047f2 <HAL_RCC_ClockConfig+0x96>
        return HAL_TIMEOUT;
 8004810:	2003      	movs	r0, #3
 8004812:	e045      	b.n	80048a0 <HAL_RCC_ClockConfig+0x144>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004814:	4a28      	ldr	r2, [pc, #160]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 8004816:	6812      	ldr	r2, [r2, #0]
 8004818:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 800481c:	d1e0      	bne.n	80047e0 <HAL_RCC_ClockConfig+0x84>
        return HAL_ERROR;
 800481e:	2001      	movs	r0, #1
 8004820:	e03e      	b.n	80048a0 <HAL_RCC_ClockConfig+0x144>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004822:	4a25      	ldr	r2, [pc, #148]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 8004824:	6812      	ldr	r2, [r2, #0]
 8004826:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 800482a:	d1d9      	bne.n	80047e0 <HAL_RCC_ClockConfig+0x84>
        return HAL_ERROR;
 800482c:	2001      	movs	r0, #1
 800482e:	e037      	b.n	80048a0 <HAL_RCC_ClockConfig+0x144>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004830:	4b20      	ldr	r3, [pc, #128]	; (80048b4 <HAL_RCC_ClockConfig+0x158>)
 8004832:	681b      	ldr	r3, [r3, #0]
 8004834:	f003 0307 	and.w	r3, r3, #7
 8004838:	42ab      	cmp	r3, r5
 800483a:	d90a      	bls.n	8004852 <HAL_RCC_ClockConfig+0xf6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800483c:	4a1d      	ldr	r2, [pc, #116]	; (80048b4 <HAL_RCC_ClockConfig+0x158>)
 800483e:	6813      	ldr	r3, [r2, #0]
 8004840:	f023 0307 	bic.w	r3, r3, #7
 8004844:	432b      	orrs	r3, r5
 8004846:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004848:	6813      	ldr	r3, [r2, #0]
 800484a:	f003 0307 	and.w	r3, r3, #7
 800484e:	42ab      	cmp	r3, r5
 8004850:	d12d      	bne.n	80048ae <HAL_RCC_ClockConfig+0x152>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004852:	6823      	ldr	r3, [r4, #0]
 8004854:	f013 0f04 	tst.w	r3, #4
 8004858:	d006      	beq.n	8004868 <HAL_RCC_ClockConfig+0x10c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800485a:	4a17      	ldr	r2, [pc, #92]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 800485c:	6853      	ldr	r3, [r2, #4]
 800485e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8004862:	68e1      	ldr	r1, [r4, #12]
 8004864:	430b      	orrs	r3, r1
 8004866:	6053      	str	r3, [r2, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004868:	6823      	ldr	r3, [r4, #0]
 800486a:	f013 0f08 	tst.w	r3, #8
 800486e:	d007      	beq.n	8004880 <HAL_RCC_ClockConfig+0x124>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8004870:	4a11      	ldr	r2, [pc, #68]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 8004872:	6853      	ldr	r3, [r2, #4]
 8004874:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8004878:	6921      	ldr	r1, [r4, #16]
 800487a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800487e:	6053      	str	r3, [r2, #4]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8004880:	f7ff ff36 	bl	80046f0 <HAL_RCC_GetSysClockFreq>
 8004884:	4b0c      	ldr	r3, [pc, #48]	; (80048b8 <HAL_RCC_ClockConfig+0x15c>)
 8004886:	685b      	ldr	r3, [r3, #4]
 8004888:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800488c:	4a0b      	ldr	r2, [pc, #44]	; (80048bc <HAL_RCC_ClockConfig+0x160>)
 800488e:	5cd3      	ldrb	r3, [r2, r3]
 8004890:	40d8      	lsrs	r0, r3
 8004892:	4b0b      	ldr	r3, [pc, #44]	; (80048c0 <HAL_RCC_ClockConfig+0x164>)
 8004894:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
 8004896:	4b0b      	ldr	r3, [pc, #44]	; (80048c4 <HAL_RCC_ClockConfig+0x168>)
 8004898:	6818      	ldr	r0, [r3, #0]
 800489a:	f7fd f9e7 	bl	8001c6c <HAL_InitTick>
  return HAL_OK;
 800489e:	2000      	movs	r0, #0
}
 80048a0:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 80048a2:	2001      	movs	r0, #1
}
 80048a4:	4770      	bx	lr
    return HAL_ERROR;
 80048a6:	2001      	movs	r0, #1
 80048a8:	e7fa      	b.n	80048a0 <HAL_RCC_ClockConfig+0x144>
        return HAL_ERROR;
 80048aa:	2001      	movs	r0, #1
 80048ac:	e7f8      	b.n	80048a0 <HAL_RCC_ClockConfig+0x144>
    return HAL_ERROR;
 80048ae:	2001      	movs	r0, #1
 80048b0:	e7f6      	b.n	80048a0 <HAL_RCC_ClockConfig+0x144>
 80048b2:	bf00      	nop
 80048b4:	40022000 	.word	0x40022000
 80048b8:	40021000 	.word	0x40021000
 80048bc:	0800fe68 	.word	0x0800fe68
 80048c0:	20000028 	.word	0x20000028
 80048c4:	20000030 	.word	0x20000030

080048c8 <HAL_RCC_GetHCLKFreq>:
}
 80048c8:	4b01      	ldr	r3, [pc, #4]	; (80048d0 <HAL_RCC_GetHCLKFreq+0x8>)
 80048ca:	6818      	ldr	r0, [r3, #0]
 80048cc:	4770      	bx	lr
 80048ce:	bf00      	nop
 80048d0:	20000028 	.word	0x20000028

080048d4 <HAL_RCC_GetPCLK1Freq>:
{
 80048d4:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 80048d6:	f7ff fff7 	bl	80048c8 <HAL_RCC_GetHCLKFreq>
 80048da:	4b04      	ldr	r3, [pc, #16]	; (80048ec <HAL_RCC_GetPCLK1Freq+0x18>)
 80048dc:	685b      	ldr	r3, [r3, #4]
 80048de:	f3c3 2302 	ubfx	r3, r3, #8, #3
 80048e2:	4a03      	ldr	r2, [pc, #12]	; (80048f0 <HAL_RCC_GetPCLK1Freq+0x1c>)
 80048e4:	5cd3      	ldrb	r3, [r2, r3]
}
 80048e6:	40d8      	lsrs	r0, r3
 80048e8:	bd08      	pop	{r3, pc}
 80048ea:	bf00      	nop
 80048ec:	40021000 	.word	0x40021000
 80048f0:	0800fe78 	.word	0x0800fe78

080048f4 <HAL_RCC_GetPCLK2Freq>:
{
 80048f4:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 80048f6:	f7ff ffe7 	bl	80048c8 <HAL_RCC_GetHCLKFreq>
 80048fa:	4b04      	ldr	r3, [pc, #16]	; (800490c <HAL_RCC_GetPCLK2Freq+0x18>)
 80048fc:	685b      	ldr	r3, [r3, #4]
 80048fe:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8004902:	4a03      	ldr	r2, [pc, #12]	; (8004910 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8004904:	5cd3      	ldrb	r3, [r2, r3]
}
 8004906:	40d8      	lsrs	r0, r3
 8004908:	bd08      	pop	{r3, pc}
 800490a:	bf00      	nop
 800490c:	40021000 	.word	0x40021000
 8004910:	0800fe78 	.word	0x0800fe78

08004914 <HAL_RCC_GetOscConfig>:
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
 8004914:	230f      	movs	r3, #15
 8004916:	6003      	str	r3, [r0, #0]
  if ((RCC->CR & RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8004918:	4b2a      	ldr	r3, [pc, #168]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 800491a:	681b      	ldr	r3, [r3, #0]
 800491c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8004920:	d030      	beq.n	8004984 <HAL_RCC_GetOscConfig+0x70>
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 8004922:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8004926:	6043      	str	r3, [r0, #4]
  RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
 8004928:	4a26      	ldr	r2, [pc, #152]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 800492a:	6853      	ldr	r3, [r2, #4]
 800492c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004930:	6083      	str	r3, [r0, #8]
  if ((RCC->CR & RCC_CR_HSION) == RCC_CR_HSION)
 8004932:	6813      	ldr	r3, [r2, #0]
 8004934:	f013 0f01 	tst.w	r3, #1
 8004938:	d030      	beq.n	800499c <HAL_RCC_GetOscConfig+0x88>
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 800493a:	2301      	movs	r3, #1
 800493c:	6103      	str	r3, [r0, #16]
  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
 800493e:	4a21      	ldr	r2, [pc, #132]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 8004940:	6813      	ldr	r3, [r2, #0]
 8004942:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8004946:	6143      	str	r3, [r0, #20]
  if ((RCC->BDCR & RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 8004948:	6a13      	ldr	r3, [r2, #32]
 800494a:	f013 0f04 	tst.w	r3, #4
 800494e:	d028      	beq.n	80049a2 <HAL_RCC_GetOscConfig+0x8e>
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 8004950:	2305      	movs	r3, #5
 8004952:	60c3      	str	r3, [r0, #12]
  if ((RCC->CSR & RCC_CSR_LSION) == RCC_CSR_LSION)
 8004954:	4b1b      	ldr	r3, [pc, #108]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 8004956:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004958:	f013 0f01 	tst.w	r3, #1
 800495c:	d02c      	beq.n	80049b8 <HAL_RCC_GetOscConfig+0xa4>
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 800495e:	2301      	movs	r3, #1
 8004960:	6183      	str	r3, [r0, #24]
  if ((RCC->CR & RCC_CR_PLLON) == RCC_CR_PLLON)
 8004962:	4b18      	ldr	r3, [pc, #96]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 8004964:	681b      	ldr	r3, [r3, #0]
 8004966:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 800496a:	d028      	beq.n	80049be <HAL_RCC_GetOscConfig+0xaa>
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 800496c:	2302      	movs	r3, #2
 800496e:	61c3      	str	r3, [r0, #28]
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
 8004970:	4a14      	ldr	r2, [pc, #80]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 8004972:	6853      	ldr	r3, [r2, #4]
 8004974:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004978:	6203      	str	r3, [r0, #32]
  RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
 800497a:	6853      	ldr	r3, [r2, #4]
 800497c:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8004980:	6243      	str	r3, [r0, #36]	; 0x24
}
 8004982:	4770      	bx	lr
  else if ((RCC->CR & RCC_CR_HSEON) == RCC_CR_HSEON)
 8004984:	4b0f      	ldr	r3, [pc, #60]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 8004986:	681b      	ldr	r3, [r3, #0]
 8004988:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 800498c:	d003      	beq.n	8004996 <HAL_RCC_GetOscConfig+0x82>
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 800498e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004992:	6043      	str	r3, [r0, #4]
 8004994:	e7c8      	b.n	8004928 <HAL_RCC_GetOscConfig+0x14>
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 8004996:	2300      	movs	r3, #0
 8004998:	6043      	str	r3, [r0, #4]
 800499a:	e7c5      	b.n	8004928 <HAL_RCC_GetOscConfig+0x14>
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 800499c:	2300      	movs	r3, #0
 800499e:	6103      	str	r3, [r0, #16]
 80049a0:	e7cd      	b.n	800493e <HAL_RCC_GetOscConfig+0x2a>
  else if ((RCC->BDCR & RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 80049a2:	4b08      	ldr	r3, [pc, #32]	; (80049c4 <HAL_RCC_GetOscConfig+0xb0>)
 80049a4:	6a1b      	ldr	r3, [r3, #32]
 80049a6:	f013 0f01 	tst.w	r3, #1
 80049aa:	d002      	beq.n	80049b2 <HAL_RCC_GetOscConfig+0x9e>
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 80049ac:	2301      	movs	r3, #1
 80049ae:	60c3      	str	r3, [r0, #12]
 80049b0:	e7d0      	b.n	8004954 <HAL_RCC_GetOscConfig+0x40>
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 80049b2:	2300      	movs	r3, #0
 80049b4:	60c3      	str	r3, [r0, #12]
 80049b6:	e7cd      	b.n	8004954 <HAL_RCC_GetOscConfig+0x40>
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 80049b8:	2300      	movs	r3, #0
 80049ba:	6183      	str	r3, [r0, #24]
 80049bc:	e7d1      	b.n	8004962 <HAL_RCC_GetOscConfig+0x4e>
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 80049be:	2301      	movs	r3, #1
 80049c0:	61c3      	str	r3, [r0, #28]
 80049c2:	e7d5      	b.n	8004970 <HAL_RCC_GetOscConfig+0x5c>
 80049c4:	40021000 	.word	0x40021000

080049c8 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80049c8:	230f      	movs	r3, #15
 80049ca:	6003      	str	r3, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80049cc:	4b0b      	ldr	r3, [pc, #44]	; (80049fc <HAL_RCC_GetClockConfig+0x34>)
 80049ce:	685a      	ldr	r2, [r3, #4]
 80049d0:	f002 0203 	and.w	r2, r2, #3
 80049d4:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80049d6:	685a      	ldr	r2, [r3, #4]
 80049d8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80049dc:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80049de:	685a      	ldr	r2, [r3, #4]
 80049e0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80049e4:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 80049e6:	685b      	ldr	r3, [r3, #4]
 80049e8:	08db      	lsrs	r3, r3, #3
 80049ea:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80049ee:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80049f0:	4b03      	ldr	r3, [pc, #12]	; (8004a00 <HAL_RCC_GetClockConfig+0x38>)
 80049f2:	681b      	ldr	r3, [r3, #0]
 80049f4:	f003 0307 	and.w	r3, r3, #7
 80049f8:	600b      	str	r3, [r1, #0]
}
 80049fa:	4770      	bx	lr
 80049fc:	40021000 	.word	0x40021000
 8004a00:	40022000 	.word	0x40022000

08004a04 <HAL_RCC_CSSCallback>:
__weak void HAL_RCC_CSSCallback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
    the HAL_RCC_CSSCallback could be implemented in the user file
    */
}
 8004a04:	4770      	bx	lr

08004a06 <HAL_RCC_NMI_IRQHandler>:
{
 8004a06:	b508      	push	{r3, lr}
  if (__HAL_RCC_GET_IT(RCC_IT_CSS))
 8004a08:	4b05      	ldr	r3, [pc, #20]	; (8004a20 <HAL_RCC_NMI_IRQHandler+0x1a>)
 8004a0a:	689b      	ldr	r3, [r3, #8]
 8004a0c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8004a10:	d100      	bne.n	8004a14 <HAL_RCC_NMI_IRQHandler+0xe>
}
 8004a12:	bd08      	pop	{r3, pc}
    HAL_RCC_CSSCallback();
 8004a14:	f7ff fff6 	bl	8004a04 <HAL_RCC_CSSCallback>
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8004a18:	4b02      	ldr	r3, [pc, #8]	; (8004a24 <HAL_RCC_NMI_IRQHandler+0x1e>)
 8004a1a:	2280      	movs	r2, #128	; 0x80
 8004a1c:	701a      	strb	r2, [r3, #0]
}
 8004a1e:	e7f8      	b.n	8004a12 <HAL_RCC_NMI_IRQHandler+0xc>
 8004a20:	40021000 	.word	0x40021000
 8004a24:	4002100a 	.word	0x4002100a

08004a28 <HAL_RCCEx_PeriphCLKConfig>:
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004a28:	b570      	push	{r4, r5, r6, lr}
 8004a2a:	b082      	sub	sp, #8
 8004a2c:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8004a2e:	6803      	ldr	r3, [r0, #0]
 8004a30:	f013 0f01 	tst.w	r3, #1
 8004a34:	d034      	beq.n	8004aa0 <HAL_RCCEx_PeriphCLKConfig+0x78>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8004a36:	4b3e      	ldr	r3, [pc, #248]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004a38:	69db      	ldr	r3, [r3, #28]
 8004a3a:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8004a3e:	d147      	bne.n	8004ad0 <HAL_RCCEx_PeriphCLKConfig+0xa8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8004a40:	4b3b      	ldr	r3, [pc, #236]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004a42:	69da      	ldr	r2, [r3, #28]
 8004a44:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004a48:	61da      	str	r2, [r3, #28]
 8004a4a:	69db      	ldr	r3, [r3, #28]
 8004a4c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004a50:	9301      	str	r3, [sp, #4]
 8004a52:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8004a54:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8004a56:	4b37      	ldr	r3, [pc, #220]	; (8004b34 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	f413 7f80 	tst.w	r3, #256	; 0x100
 8004a5e:	d039      	beq.n	8004ad4 <HAL_RCCEx_PeriphCLKConfig+0xac>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004a60:	4b33      	ldr	r3, [pc, #204]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004a62:	6a1b      	ldr	r3, [r3, #32]
    if ((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004a64:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8004a68:	d011      	beq.n	8004a8e <HAL_RCCEx_PeriphCLKConfig+0x66>
 8004a6a:	6862      	ldr	r2, [r4, #4]
 8004a6c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8004a70:	429a      	cmp	r2, r3
 8004a72:	d00c      	beq.n	8004a8e <HAL_RCCEx_PeriphCLKConfig+0x66>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004a74:	4a2e      	ldr	r2, [pc, #184]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004a76:	6a13      	ldr	r3, [r2, #32]
 8004a78:	f423 7040 	bic.w	r0, r3, #768	; 0x300
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8004a7c:	492e      	ldr	r1, [pc, #184]	; (8004b38 <HAL_RCCEx_PeriphCLKConfig+0x110>)
 8004a7e:	2601      	movs	r6, #1
 8004a80:	600e      	str	r6, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8004a82:	2600      	movs	r6, #0
 8004a84:	600e      	str	r6, [r1, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 8004a86:	6210      	str	r0, [r2, #32]

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8004a88:	f013 0f01 	tst.w	r3, #1
 8004a8c:	d136      	bne.n	8004afc <HAL_RCCEx_PeriphCLKConfig+0xd4>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004a8e:	4a28      	ldr	r2, [pc, #160]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004a90:	6a13      	ldr	r3, [r2, #32]
 8004a92:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004a96:	6861      	ldr	r1, [r4, #4]
 8004a98:	430b      	orrs	r3, r1
 8004a9a:	6213      	str	r3, [r2, #32]

    /* Require to disable power clock if necessary */
    if (pwrclkchanged == SET)
 8004a9c:	2d00      	cmp	r5, #0
 8004a9e:	d13e      	bne.n	8004b1e <HAL_RCCEx_PeriphCLKConfig+0xf6>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*------------------------------ ADC clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8004aa0:	6823      	ldr	r3, [r4, #0]
 8004aa2:	f013 0f02 	tst.w	r3, #2
 8004aa6:	d006      	beq.n	8004ab6 <HAL_RCCEx_PeriphCLKConfig+0x8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8004aa8:	4a21      	ldr	r2, [pc, #132]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004aaa:	6853      	ldr	r3, [r2, #4]
 8004aac:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8004ab0:	68a1      	ldr	r1, [r4, #8]
 8004ab2:	430b      	orrs	r3, r1
 8004ab4:	6053      	str	r3, [r2, #4]

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /*------------------------------ USB clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8004ab6:	6823      	ldr	r3, [r4, #0]
 8004ab8:	f013 0f10 	tst.w	r3, #16
 8004abc:	d034      	beq.n	8004b28 <HAL_RCCEx_PeriphCLKConfig+0x100>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));

    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8004abe:	4a1c      	ldr	r2, [pc, #112]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004ac0:	6853      	ldr	r3, [r2, #4]
 8004ac2:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8004ac6:	68e1      	ldr	r1, [r4, #12]
 8004ac8:	430b      	orrs	r3, r1
 8004aca:	6053      	str	r3, [r2, #4]
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
 8004acc:	2000      	movs	r0, #0
 8004ace:	e02c      	b.n	8004b2a <HAL_RCCEx_PeriphCLKConfig+0x102>
    FlagStatus pwrclkchanged = RESET;
 8004ad0:	2500      	movs	r5, #0
 8004ad2:	e7c0      	b.n	8004a56 <HAL_RCCEx_PeriphCLKConfig+0x2e>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8004ad4:	4a17      	ldr	r2, [pc, #92]	; (8004b34 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8004ad6:	6813      	ldr	r3, [r2, #0]
 8004ad8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004adc:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8004ade:	f7fd f9fd 	bl	8001edc <HAL_GetTick>
 8004ae2:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8004ae4:	4b13      	ldr	r3, [pc, #76]	; (8004b34 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8004ae6:	681b      	ldr	r3, [r3, #0]
 8004ae8:	f413 7f80 	tst.w	r3, #256	; 0x100
 8004aec:	d1b8      	bne.n	8004a60 <HAL_RCCEx_PeriphCLKConfig+0x38>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004aee:	f7fd f9f5 	bl	8001edc <HAL_GetTick>
 8004af2:	1b80      	subs	r0, r0, r6
 8004af4:	2864      	cmp	r0, #100	; 0x64
 8004af6:	d9f5      	bls.n	8004ae4 <HAL_RCCEx_PeriphCLKConfig+0xbc>
          return HAL_TIMEOUT;
 8004af8:	2003      	movs	r0, #3
 8004afa:	e016      	b.n	8004b2a <HAL_RCCEx_PeriphCLKConfig+0x102>
        tickstart = HAL_GetTick();
 8004afc:	f7fd f9ee 	bl	8001edc <HAL_GetTick>
 8004b00:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004b02:	4b0b      	ldr	r3, [pc, #44]	; (8004b30 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8004b04:	6a1b      	ldr	r3, [r3, #32]
 8004b06:	f013 0f02 	tst.w	r3, #2
 8004b0a:	d1c0      	bne.n	8004a8e <HAL_RCCEx_PeriphCLKConfig+0x66>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004b0c:	f7fd f9e6 	bl	8001edc <HAL_GetTick>
 8004b10:	1b80      	subs	r0, r0, r6
 8004b12:	f241 3388 	movw	r3, #5000	; 0x1388
 8004b16:	4298      	cmp	r0, r3
 8004b18:	d9f3      	bls.n	8004b02 <HAL_RCCEx_PeriphCLKConfig+0xda>
            return HAL_TIMEOUT;
 8004b1a:	2003      	movs	r0, #3
 8004b1c:	e005      	b.n	8004b2a <HAL_RCCEx_PeriphCLKConfig+0x102>
      __HAL_RCC_PWR_CLK_DISABLE();
 8004b1e:	69d3      	ldr	r3, [r2, #28]
 8004b20:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004b24:	61d3      	str	r3, [r2, #28]
 8004b26:	e7bb      	b.n	8004aa0 <HAL_RCCEx_PeriphCLKConfig+0x78>
  return HAL_OK;
 8004b28:	2000      	movs	r0, #0
}
 8004b2a:	b002      	add	sp, #8
 8004b2c:	bd70      	pop	{r4, r5, r6, pc}
 8004b2e:	bf00      	nop
 8004b30:	40021000 	.word	0x40021000
 8004b34:	40007000 	.word	0x40007000
 8004b38:	42420440 	.word	0x42420440

08004b3c <HAL_RCCEx_GetPeriphCLKConfig>:
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
  uint32_t srcclk = 0U;

  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8004b3c:	2301      	movs	r3, #1
 8004b3e:	6003      	str	r3, [r0, #0]

  /* Get the RTC configuration -----------------------------------------------*/
  srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8004b40:	4b08      	ldr	r3, [pc, #32]	; (8004b64 <HAL_RCCEx_GetPeriphCLKConfig+0x28>)
 8004b42:	6a1a      	ldr	r2, [r3, #32]
 8004b44:	f402 7240 	and.w	r2, r2, #768	; 0x300
  /* Source clock is LSE or LSI*/
  PeriphClkInit->RTCClockSelection = srcclk;
 8004b48:	6042      	str	r2, [r0, #4]

  /* Get the ADC clock configuration -----------------------------------------*/
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
 8004b4a:	2203      	movs	r2, #3
 8004b4c:	6002      	str	r2, [r0, #0]
  PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
 8004b4e:	685a      	ldr	r2, [r3, #4]
 8004b50:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 8004b54:	6082      	str	r2, [r0, #8]

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /* Get the USB clock configuration -----------------------------------------*/
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
 8004b56:	2213      	movs	r2, #19
 8004b58:	6002      	str	r2, [r0, #0]
  PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
 8004b5a:	685b      	ldr	r3, [r3, #4]
 8004b5c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8004b60:	60c3      	str	r3, [r0, #12]
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
}
 8004b62:	4770      	bx	lr
 8004b64:	40021000 	.word	0x40021000

08004b68 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_USB  USB peripheral clock
  @endif
  * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8004b68:	b510      	push	{r4, lr}
 8004b6a:	b086      	sub	sp, #24
 8004b6c:	4604      	mov	r4, r0
  uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
  uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
#endif /* STM32F105xC || STM32F107xC */
#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
    defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8004b6e:	4b36      	ldr	r3, [pc, #216]	; (8004c48 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>)
 8004b70:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8004b72:	f10d 0c18 	add.w	ip, sp, #24
 8004b76:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8004b7a:	f240 2301 	movw	r3, #513	; 0x201
 8004b7e:	f8ad 3004 	strh.w	r3, [sp, #4]
  uint32_t temp_reg = 0U, frequency = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  switch (PeriphClk)
 8004b82:	2c02      	cmp	r4, #2
 8004b84:	d052      	beq.n	8004c2c <HAL_RCCEx_GetPeriphCLKFreq+0xc4>
 8004b86:	2c10      	cmp	r4, #16
 8004b88:	d004      	beq.n	8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0x2c>
 8004b8a:	2c01      	cmp	r4, #1
 8004b8c:	d02c      	beq.n	8004be8 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
 8004b8e:	2000      	movs	r0, #0
    {
      break;
    }
  }
  return (frequency);
}
 8004b90:	b006      	add	sp, #24
 8004b92:	bd10      	pop	{r4, pc}
      temp_reg = RCC->CFGR;
 8004b94:	4b2d      	ldr	r3, [pc, #180]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004b96:	685a      	ldr	r2, [r3, #4]
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLON))
 8004b98:	6818      	ldr	r0, [r3, #0]
 8004b9a:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
 8004b9e:	d0f7      	beq.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
        pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8004ba0:	f3c2 4383 	ubfx	r3, r2, #18, #4
 8004ba4:	a906      	add	r1, sp, #24
 8004ba6:	440b      	add	r3, r1
 8004ba8:	f813 0c10 	ldrb.w	r0, [r3, #-16]
        if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8004bac:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 8004bb0:	d016      	beq.n	8004be0 <HAL_RCCEx_GetPeriphCLKFreq+0x78>
          prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8004bb2:	4b26      	ldr	r3, [pc, #152]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004bb4:	685b      	ldr	r3, [r3, #4]
 8004bb6:	f3c3 4340 	ubfx	r3, r3, #17, #1
 8004bba:	440b      	add	r3, r1
 8004bbc:	f813 2c14 	ldrb.w	r2, [r3, #-20]
            pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
 8004bc0:	4b23      	ldr	r3, [pc, #140]	; (8004c50 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>)
 8004bc2:	fbb3 f3f2 	udiv	r3, r3, r2
 8004bc6:	fb00 f003 	mul.w	r0, r0, r3
        if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
 8004bca:	4b20      	ldr	r3, [pc, #128]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004bcc:	685b      	ldr	r3, [r3, #4]
 8004bce:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8004bd2:	d1dd      	bne.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
          frequency = (pllclk * 2) / 3;
 8004bd4:	0040      	lsls	r0, r0, #1
 8004bd6:	4b1f      	ldr	r3, [pc, #124]	; (8004c54 <HAL_RCCEx_GetPeriphCLKFreq+0xec>)
 8004bd8:	fba3 3000 	umull	r3, r0, r3, r0
 8004bdc:	0840      	lsrs	r0, r0, #1
 8004bde:	e7d7      	b.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
          pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8004be0:	4b1d      	ldr	r3, [pc, #116]	; (8004c58 <HAL_RCCEx_GetPeriphCLKFreq+0xf0>)
 8004be2:	fb03 f000 	mul.w	r0, r3, r0
 8004be6:	e7f0      	b.n	8004bca <HAL_RCCEx_GetPeriphCLKFreq+0x62>
      temp_reg = RCC->BDCR;
 8004be8:	4b18      	ldr	r3, [pc, #96]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004bea:	6a1b      	ldr	r3, [r3, #32]
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
 8004bec:	f240 3202 	movw	r2, #770	; 0x302
 8004bf0:	401a      	ands	r2, r3
 8004bf2:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 8004bf6:	d024      	beq.n	8004c42 <HAL_RCCEx_GetPeriphCLKFreq+0xda>
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 8004bf8:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004bfc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004c00:	d004      	beq.n	8004c0c <HAL_RCCEx_GetPeriphCLKFreq+0xa4>
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 8004c02:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004c06:	d009      	beq.n	8004c1c <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
  uint32_t temp_reg = 0U, frequency = 0U;
 8004c08:	2000      	movs	r0, #0
 8004c0a:	e7c1      	b.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 8004c0c:	4a0f      	ldr	r2, [pc, #60]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004c0e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8004c10:	f012 0f02 	tst.w	r2, #2
 8004c14:	d0f5      	beq.n	8004c02 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
        frequency = LSI_VALUE;
 8004c16:	f649 4040 	movw	r0, #40000	; 0x9c40
 8004c1a:	e7b9      	b.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 8004c1c:	4b0b      	ldr	r3, [pc, #44]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004c1e:	6818      	ldr	r0, [r3, #0]
 8004c20:	f410 3000 	ands.w	r0, r0, #131072	; 0x20000
 8004c24:	d0b4      	beq.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
        frequency = HSE_VALUE / 128U;
 8004c26:	f24f 4024 	movw	r0, #62500	; 0xf424
  return (frequency);
 8004c2a:	e7b1      	b.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
      frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
 8004c2c:	f7ff fe62 	bl	80048f4 <HAL_RCC_GetPCLK2Freq>
 8004c30:	4b06      	ldr	r3, [pc, #24]	; (8004c4c <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
 8004c32:	685b      	ldr	r3, [r3, #4]
 8004c34:	f3c3 3381 	ubfx	r3, r3, #14, #2
 8004c38:	3301      	adds	r3, #1
 8004c3a:	005b      	lsls	r3, r3, #1
 8004c3c:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 8004c40:	e7a6      	b.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
        frequency = LSE_VALUE;
 8004c42:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004c46:	e7a3      	b.n	8004b90 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
 8004c48:	0800fe80 	.word	0x0800fe80
 8004c4c:	40021000 	.word	0x40021000
 8004c50:	007a1200 	.word	0x007a1200
 8004c54:	aaaaaaab 	.word	0xaaaaaaab
 8004c58:	003d0900 	.word	0x003d0900

08004c5c <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8004c5c:	b470      	push	{r4, r5, r6}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004c5e:	6a03      	ldr	r3, [r0, #32]
 8004c60:	f023 0301 	bic.w	r3, r3, #1
 8004c64:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004c66:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004c68:	6846      	ldr	r6, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004c6a:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8004c6c:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8004c70:	680c      	ldr	r4, [r1, #0]
 8004c72:	ea44 0502 	orr.w	r5, r4, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8004c76:	f023 0202 	bic.w	r2, r3, #2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8004c7a:	688b      	ldr	r3, [r1, #8]
 8004c7c:	4313      	orrs	r3, r2

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8004c7e:	4c0d      	ldr	r4, [pc, #52]	; (8004cb4 <TIM_OC1_SetConfig+0x58>)
 8004c80:	42a0      	cmp	r0, r4
 8004c82:	d009      	beq.n	8004c98 <TIM_OC1_SetConfig+0x3c>
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004c84:	4c0b      	ldr	r4, [pc, #44]	; (8004cb4 <TIM_OC1_SetConfig+0x58>)
 8004c86:	42a0      	cmp	r0, r4
 8004c88:	d00d      	beq.n	8004ca6 <TIM_OC1_SetConfig+0x4a>
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004c8a:	6046      	str	r6, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004c8c:	6185      	str	r5, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8004c8e:	684a      	ldr	r2, [r1, #4]
 8004c90:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004c92:	6203      	str	r3, [r0, #32]
}
 8004c94:	bc70      	pop	{r4, r5, r6}
 8004c96:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC1NP;
 8004c98:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 8004c9c:	68ca      	ldr	r2, [r1, #12]
 8004c9e:	4313      	orrs	r3, r2
    tmpccer &= ~TIM_CCER_CC1NE;
 8004ca0:	f023 0304 	bic.w	r3, r3, #4
 8004ca4:	e7ee      	b.n	8004c84 <TIM_OC1_SetConfig+0x28>
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8004ca6:	f426 7640 	bic.w	r6, r6, #768	; 0x300
    tmpcr2 |= OC_Config->OCIdleState;
 8004caa:	694a      	ldr	r2, [r1, #20]
 8004cac:	4332      	orrs	r2, r6
    tmpcr2 |= OC_Config->OCNIdleState;
 8004cae:	698e      	ldr	r6, [r1, #24]
 8004cb0:	4316      	orrs	r6, r2
 8004cb2:	e7ea      	b.n	8004c8a <TIM_OC1_SetConfig+0x2e>
 8004cb4:	40012c00 	.word	0x40012c00

08004cb8 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8004cb8:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004cba:	6a03      	ldr	r3, [r0, #32]
 8004cbc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004cc0:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004cc2:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004cc4:	6845      	ldr	r5, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004cc6:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8004cc8:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8004ccc:	680c      	ldr	r4, [r1, #0]
 8004cce:	4322      	orrs	r2, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8004cd0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8004cd4:	688c      	ldr	r4, [r1, #8]
 8004cd6:	ea43 2304 	orr.w	r3, r3, r4, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8004cda:	4c0f      	ldr	r4, [pc, #60]	; (8004d18 <TIM_OC3_SetConfig+0x60>)
 8004cdc:	42a0      	cmp	r0, r4
 8004cde:	d009      	beq.n	8004cf4 <TIM_OC3_SetConfig+0x3c>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004ce0:	4c0d      	ldr	r4, [pc, #52]	; (8004d18 <TIM_OC3_SetConfig+0x60>)
 8004ce2:	42a0      	cmp	r0, r4
 8004ce4:	d00e      	beq.n	8004d04 <TIM_OC3_SetConfig+0x4c>
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004ce6:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004ce8:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8004cea:	684a      	ldr	r2, [r1, #4]
 8004cec:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004cee:	6203      	str	r3, [r0, #32]
}
 8004cf0:	bc30      	pop	{r4, r5}
 8004cf2:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC3NP;
 8004cf4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004cf8:	68cc      	ldr	r4, [r1, #12]
 8004cfa:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 8004cfe:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8004d02:	e7ed      	b.n	8004ce0 <TIM_OC3_SetConfig+0x28>
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8004d04:	f425 5540 	bic.w	r5, r5, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8004d08:	694c      	ldr	r4, [r1, #20]
 8004d0a:	ea45 1504 	orr.w	r5, r5, r4, lsl #4
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8004d0e:	698c      	ldr	r4, [r1, #24]
 8004d10:	ea45 1504 	orr.w	r5, r5, r4, lsl #4
 8004d14:	e7e7      	b.n	8004ce6 <TIM_OC3_SetConfig+0x2e>
 8004d16:	bf00      	nop
 8004d18:	40012c00 	.word	0x40012c00

08004d1c <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8004d1c:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8004d1e:	6a03      	ldr	r3, [r0, #32]
 8004d20:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004d24:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004d26:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004d28:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004d2a:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8004d2c:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004d30:	680d      	ldr	r5, [r1, #0]
 8004d32:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8004d36:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8004d3a:	688d      	ldr	r5, [r1, #8]
 8004d3c:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004d40:	4d07      	ldr	r5, [pc, #28]	; (8004d60 <TIM_OC4_SetConfig+0x44>)
 8004d42:	42a8      	cmp	r0, r5
 8004d44:	d006      	beq.n	8004d54 <TIM_OC4_SetConfig+0x38>
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004d46:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004d48:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8004d4a:	684a      	ldr	r2, [r1, #4]
 8004d4c:	6402      	str	r2, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004d4e:	6203      	str	r3, [r0, #32]
}
 8004d50:	bc30      	pop	{r4, r5}
 8004d52:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_OIS4;
 8004d54:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8004d58:	694d      	ldr	r5, [r1, #20]
 8004d5a:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 8004d5e:	e7f2      	b.n	8004d46 <TIM_OC4_SetConfig+0x2a>
 8004d60:	40012c00 	.word	0x40012c00

08004d64 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8004d64:	b430      	push	{r4, r5}
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8004d66:	6a03      	ldr	r3, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004d68:	6a05      	ldr	r5, [r0, #32]
 8004d6a:	f025 0501 	bic.w	r5, r5, #1
 8004d6e:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004d70:	6984      	ldr	r4, [r0, #24]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8004d72:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8004d76:	ea44 1402 	orr.w	r4, r4, r2, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004d7a:	f023 030a 	bic.w	r3, r3, #10
  tmpccer |= TIM_ICPolarity;
 8004d7e:	430b      	orrs	r3, r1

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8004d80:	6184      	str	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8004d82:	6203      	str	r3, [r0, #32]
}
 8004d84:	bc30      	pop	{r4, r5}
 8004d86:	4770      	bx	lr

08004d88 <TIM_TI2_SetConfig>:
  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */
static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
 8004d88:	b430      	push	{r4, r5}
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004d8a:	6a05      	ldr	r5, [r0, #32]
 8004d8c:	f025 0510 	bic.w	r5, r5, #16
 8004d90:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004d92:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8004d94:	6a05      	ldr	r5, [r0, #32]

  /* Select the Input */
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 8004d96:	f424 7440 	bic.w	r4, r4, #768	; 0x300
  tmpccmr1 |= (TIM_ICSelection << 8U);
 8004d9a:	ea44 2402 	orr.w	r4, r4, r2, lsl #8

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8004d9e:	f424 4470 	bic.w	r4, r4, #61440	; 0xf000
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 8004da2:	031b      	lsls	r3, r3, #12
 8004da4:	b29b      	uxth	r3, r3
 8004da6:	4323      	orrs	r3, r4

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004da8:	f025 05a0 	bic.w	r5, r5, #160	; 0xa0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8004dac:	0109      	lsls	r1, r1, #4
 8004dae:	f001 01a0 	and.w	r1, r1, #160	; 0xa0
 8004db2:	4329      	orrs	r1, r5

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8004db4:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004db6:	6201      	str	r1, [r0, #32]
}
 8004db8:	bc30      	pop	{r4, r5}
 8004dba:	4770      	bx	lr

08004dbc <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8004dbc:	b430      	push	{r4, r5}
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004dbe:	6a05      	ldr	r5, [r0, #32]
 8004dc0:	f025 0510 	bic.w	r5, r5, #16
 8004dc4:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004dc6:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8004dc8:	6a03      	ldr	r3, [r0, #32]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8004dca:	f424 4470 	bic.w	r4, r4, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8004dce:	ea44 3402 	orr.w	r4, r4, r2, lsl #12

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004dd2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 8004dd6:	ea43 1301 	orr.w	r3, r3, r1, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8004dda:	6184      	str	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8004ddc:	6203      	str	r3, [r0, #32]
}
 8004dde:	bc30      	pop	{r4, r5}
 8004de0:	4770      	bx	lr

08004de2 <TIM_TI3_SetConfig>:
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  */
static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
 8004de2:	b430      	push	{r4, r5}
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004de4:	6a05      	ldr	r5, [r0, #32]
 8004de6:	f425 7580 	bic.w	r5, r5, #256	; 0x100
 8004dea:	6205      	str	r5, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8004dec:	69c4      	ldr	r4, [r0, #28]
  tmpccer = TIMx->CCER;
 8004dee:	6a05      	ldr	r5, [r0, #32]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
 8004df0:	f024 0403 	bic.w	r4, r4, #3
  tmpccmr2 |= TIM_ICSelection;
 8004df4:	4314      	orrs	r4, r2

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 8004df6:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8004dfa:	011b      	lsls	r3, r3, #4
 8004dfc:	b2db      	uxtb	r3, r3
 8004dfe:	4323      	orrs	r3, r4

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= ~(TIM_CCER_CC3P);
 8004e00:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  tmpccer |= ((TIM_ICPolarity << 8U) & TIM_CCER_CC3P);
 8004e04:	0209      	lsls	r1, r1, #8
 8004e06:	f401 7100 	and.w	r1, r1, #512	; 0x200
 8004e0a:	4329      	orrs	r1, r5

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8004e0c:	61c3      	str	r3, [r0, #28]
  TIMx->CCER = tmpccer;
 8004e0e:	6201      	str	r1, [r0, #32]
}
 8004e10:	bc30      	pop	{r4, r5}
 8004e12:	4770      	bx	lr

08004e14 <TIM_TI4_SetConfig>:
  *        protected against un-initialized filter and polarity values.
  * @retval None
  */
static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
 8004e14:	b430      	push	{r4, r5}
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8004e16:	6a05      	ldr	r5, [r0, #32]
 8004e18:	f425 5580 	bic.w	r5, r5, #4096	; 0x1000
 8004e1c:	6205      	str	r5, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8004e1e:	69c4      	ldr	r4, [r0, #28]
  tmpccer = TIMx->CCER;
 8004e20:	6a05      	ldr	r5, [r0, #32]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 8004e22:	f424 7440 	bic.w	r4, r4, #768	; 0x300
  tmpccmr2 |= (TIM_ICSelection << 8U);
 8004e26:	ea44 2402 	orr.w	r4, r4, r2, lsl #8

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 8004e2a:	f424 4470 	bic.w	r4, r4, #61440	; 0xf000
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8004e2e:	031b      	lsls	r3, r3, #12
 8004e30:	b29b      	uxth	r3, r3
 8004e32:	4323      	orrs	r3, r4

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= ~(TIM_CCER_CC4P);
 8004e34:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
  tmpccer |= ((TIM_ICPolarity << 12U) & TIM_CCER_CC4P);
 8004e38:	0309      	lsls	r1, r1, #12
 8004e3a:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
 8004e3e:	4329      	orrs	r1, r5

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8004e40:	61c3      	str	r3, [r0, #28]
  TIMx->CCER = tmpccer ;
 8004e42:	6201      	str	r1, [r0, #32]
}
 8004e44:	bc30      	pop	{r4, r5}
 8004e46:	4770      	bx	lr

08004e48 <TIM_ITRx_SetConfig>:
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8004e48:	6883      	ldr	r3, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8004e4a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8004e4e:	430b      	orrs	r3, r1
 8004e50:	f043 0307 	orr.w	r3, r3, #7
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8004e54:	6083      	str	r3, [r0, #8]
}
 8004e56:	4770      	bx	lr
}
 8004e58:	4770      	bx	lr
}
 8004e5a:	4770      	bx	lr

08004e5c <HAL_TIM_Base_DeInit>:
{
 8004e5c:	b510      	push	{r4, lr}
 8004e5e:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8004e60:	2302      	movs	r3, #2
 8004e62:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 8004e66:	6803      	ldr	r3, [r0, #0]
 8004e68:	6a19      	ldr	r1, [r3, #32]
 8004e6a:	f241 1211 	movw	r2, #4369	; 0x1111
 8004e6e:	4211      	tst	r1, r2
 8004e70:	d108      	bne.n	8004e84 <HAL_TIM_Base_DeInit+0x28>
 8004e72:	6a19      	ldr	r1, [r3, #32]
 8004e74:	f240 4244 	movw	r2, #1092	; 0x444
 8004e78:	4211      	tst	r1, r2
 8004e7a:	d103      	bne.n	8004e84 <HAL_TIM_Base_DeInit+0x28>
 8004e7c:	681a      	ldr	r2, [r3, #0]
 8004e7e:	f022 0201 	bic.w	r2, r2, #1
 8004e82:	601a      	str	r2, [r3, #0]
  HAL_TIM_Base_MspDeInit(htim);
 8004e84:	4620      	mov	r0, r4
 8004e86:	f7fc fe2d 	bl	8001ae4 <HAL_TIM_Base_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 8004e8a:	2000      	movs	r0, #0
 8004e8c:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8004e90:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
 8004e94:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
 8004e98:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 8004e9c:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8004ea0:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
 8004ea4:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8004ea8:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
 8004eac:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_RESET;
 8004eb0:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8004eb4:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8004eb8:	bd10      	pop	{r4, pc}

08004eba <HAL_TIM_Base_Start>:
  if (htim->State != HAL_TIM_STATE_READY)
 8004eba:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8004ebe:	b2db      	uxtb	r3, r3
 8004ec0:	2b01      	cmp	r3, #1
 8004ec2:	d122      	bne.n	8004f0a <HAL_TIM_Base_Start+0x50>
  htim->State = HAL_TIM_STATE_BUSY;
 8004ec4:	2302      	movs	r3, #2
 8004ec6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004eca:	6803      	ldr	r3, [r0, #0]
 8004ecc:	4a11      	ldr	r2, [pc, #68]	; (8004f14 <HAL_TIM_Base_Start+0x5a>)
 8004ece:	4293      	cmp	r3, r2
 8004ed0:	d010      	beq.n	8004ef4 <HAL_TIM_Base_Start+0x3a>
 8004ed2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004ed6:	d00d      	beq.n	8004ef4 <HAL_TIM_Base_Start+0x3a>
 8004ed8:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8004edc:	4293      	cmp	r3, r2
 8004ede:	d009      	beq.n	8004ef4 <HAL_TIM_Base_Start+0x3a>
 8004ee0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004ee4:	4293      	cmp	r3, r2
 8004ee6:	d005      	beq.n	8004ef4 <HAL_TIM_Base_Start+0x3a>
    __HAL_TIM_ENABLE(htim);
 8004ee8:	681a      	ldr	r2, [r3, #0]
 8004eea:	f042 0201 	orr.w	r2, r2, #1
 8004eee:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8004ef0:	2000      	movs	r0, #0
 8004ef2:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8004ef4:	689a      	ldr	r2, [r3, #8]
 8004ef6:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004efa:	2a06      	cmp	r2, #6
 8004efc:	d007      	beq.n	8004f0e <HAL_TIM_Base_Start+0x54>
      __HAL_TIM_ENABLE(htim);
 8004efe:	681a      	ldr	r2, [r3, #0]
 8004f00:	f042 0201 	orr.w	r2, r2, #1
 8004f04:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8004f06:	2000      	movs	r0, #0
 8004f08:	4770      	bx	lr
    return HAL_ERROR;
 8004f0a:	2001      	movs	r0, #1
 8004f0c:	4770      	bx	lr
  return HAL_OK;
 8004f0e:	2000      	movs	r0, #0
}
 8004f10:	4770      	bx	lr
 8004f12:	bf00      	nop
 8004f14:	40012c00 	.word	0x40012c00

08004f18 <HAL_TIM_Base_Stop>:
  __HAL_TIM_DISABLE(htim);
 8004f18:	6803      	ldr	r3, [r0, #0]
 8004f1a:	6a19      	ldr	r1, [r3, #32]
 8004f1c:	f241 1211 	movw	r2, #4369	; 0x1111
 8004f20:	4211      	tst	r1, r2
 8004f22:	d108      	bne.n	8004f36 <HAL_TIM_Base_Stop+0x1e>
 8004f24:	6a19      	ldr	r1, [r3, #32]
 8004f26:	f240 4244 	movw	r2, #1092	; 0x444
 8004f2a:	4211      	tst	r1, r2
 8004f2c:	d103      	bne.n	8004f36 <HAL_TIM_Base_Stop+0x1e>
 8004f2e:	681a      	ldr	r2, [r3, #0]
 8004f30:	f022 0201 	bic.w	r2, r2, #1
 8004f34:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 8004f36:	2301      	movs	r3, #1
 8004f38:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8004f3c:	2000      	movs	r0, #0
 8004f3e:	4770      	bx	lr

08004f40 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8004f40:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8004f44:	b2db      	uxtb	r3, r3
 8004f46:	2b01      	cmp	r3, #1
 8004f48:	d127      	bne.n	8004f9a <HAL_TIM_Base_Start_IT+0x5a>
  htim->State = HAL_TIM_STATE_BUSY;
 8004f4a:	2302      	movs	r3, #2
 8004f4c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8004f50:	6802      	ldr	r2, [r0, #0]
 8004f52:	68d3      	ldr	r3, [r2, #12]
 8004f54:	f043 0301 	orr.w	r3, r3, #1
 8004f58:	60d3      	str	r3, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004f5a:	6803      	ldr	r3, [r0, #0]
 8004f5c:	4a11      	ldr	r2, [pc, #68]	; (8004fa4 <HAL_TIM_Base_Start_IT+0x64>)
 8004f5e:	4293      	cmp	r3, r2
 8004f60:	d010      	beq.n	8004f84 <HAL_TIM_Base_Start_IT+0x44>
 8004f62:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004f66:	d00d      	beq.n	8004f84 <HAL_TIM_Base_Start_IT+0x44>
 8004f68:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8004f6c:	4293      	cmp	r3, r2
 8004f6e:	d009      	beq.n	8004f84 <HAL_TIM_Base_Start_IT+0x44>
 8004f70:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004f74:	4293      	cmp	r3, r2
 8004f76:	d005      	beq.n	8004f84 <HAL_TIM_Base_Start_IT+0x44>
    __HAL_TIM_ENABLE(htim);
 8004f78:	681a      	ldr	r2, [r3, #0]
 8004f7a:	f042 0201 	orr.w	r2, r2, #1
 8004f7e:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8004f80:	2000      	movs	r0, #0
 8004f82:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8004f84:	689a      	ldr	r2, [r3, #8]
 8004f86:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004f8a:	2a06      	cmp	r2, #6
 8004f8c:	d007      	beq.n	8004f9e <HAL_TIM_Base_Start_IT+0x5e>
      __HAL_TIM_ENABLE(htim);
 8004f8e:	681a      	ldr	r2, [r3, #0]
 8004f90:	f042 0201 	orr.w	r2, r2, #1
 8004f94:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8004f96:	2000      	movs	r0, #0
 8004f98:	4770      	bx	lr
    return HAL_ERROR;
 8004f9a:	2001      	movs	r0, #1
 8004f9c:	4770      	bx	lr
  return HAL_OK;
 8004f9e:	2000      	movs	r0, #0
}
 8004fa0:	4770      	bx	lr
 8004fa2:	bf00      	nop
 8004fa4:	40012c00 	.word	0x40012c00

08004fa8 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8004fa8:	6802      	ldr	r2, [r0, #0]
 8004faa:	68d3      	ldr	r3, [r2, #12]
 8004fac:	f023 0301 	bic.w	r3, r3, #1
 8004fb0:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE(htim);
 8004fb2:	6803      	ldr	r3, [r0, #0]
 8004fb4:	6a19      	ldr	r1, [r3, #32]
 8004fb6:	f241 1211 	movw	r2, #4369	; 0x1111
 8004fba:	4211      	tst	r1, r2
 8004fbc:	d108      	bne.n	8004fd0 <HAL_TIM_Base_Stop_IT+0x28>
 8004fbe:	6a19      	ldr	r1, [r3, #32]
 8004fc0:	f240 4244 	movw	r2, #1092	; 0x444
 8004fc4:	4211      	tst	r1, r2
 8004fc6:	d103      	bne.n	8004fd0 <HAL_TIM_Base_Stop_IT+0x28>
 8004fc8:	681a      	ldr	r2, [r3, #0]
 8004fca:	f022 0201 	bic.w	r2, r2, #1
 8004fce:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 8004fd0:	2301      	movs	r3, #1
 8004fd2:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8004fd6:	2000      	movs	r0, #0
 8004fd8:	4770      	bx	lr

08004fda <HAL_TIM_Base_Start_DMA>:
{
 8004fda:	b538      	push	{r3, r4, r5, lr}
  if (htim->State == HAL_TIM_STATE_BUSY)
 8004fdc:	f890 403d 	ldrb.w	r4, [r0, #61]	; 0x3d
 8004fe0:	b2e4      	uxtb	r4, r4
 8004fe2:	2c02      	cmp	r4, #2
 8004fe4:	d045      	beq.n	8005072 <HAL_TIM_Base_Start_DMA+0x98>
 8004fe6:	4605      	mov	r5, r0
  else if (htim->State == HAL_TIM_STATE_READY)
 8004fe8:	f890 403d 	ldrb.w	r4, [r0, #61]	; 0x3d
 8004fec:	b2e4      	uxtb	r4, r4
 8004fee:	2c01      	cmp	r4, #1
 8004ff0:	d13e      	bne.n	8005070 <HAL_TIM_Base_Start_DMA+0x96>
    if ((pData == NULL) && (Length > 0U))
 8004ff2:	2900      	cmp	r1, #0
 8004ff4:	d02e      	beq.n	8005054 <HAL_TIM_Base_Start_DMA+0x7a>
      htim->State = HAL_TIM_STATE_BUSY;
 8004ff6:	2302      	movs	r3, #2
 8004ff8:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
  htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
 8004ffc:	6a2b      	ldr	r3, [r5, #32]
 8004ffe:	481f      	ldr	r0, [pc, #124]	; (800507c <HAL_TIM_Base_Start_DMA+0xa2>)
 8005000:	6298      	str	r0, [r3, #40]	; 0x28
  htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
 8005002:	6a2b      	ldr	r3, [r5, #32]
 8005004:	481e      	ldr	r0, [pc, #120]	; (8005080 <HAL_TIM_Base_Start_DMA+0xa6>)
 8005006:	62d8      	str	r0, [r3, #44]	; 0x2c
  htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
 8005008:	6a2b      	ldr	r3, [r5, #32]
 800500a:	481e      	ldr	r0, [pc, #120]	; (8005084 <HAL_TIM_Base_Start_DMA+0xaa>)
 800500c:	6318      	str	r0, [r3, #48]	; 0x30
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR,
 800500e:	6828      	ldr	r0, [r5, #0]
 8005010:	4613      	mov	r3, r2
 8005012:	f100 022c 	add.w	r2, r0, #44	; 0x2c
 8005016:	6a28      	ldr	r0, [r5, #32]
 8005018:	f7fe fc22 	bl	8003860 <HAL_DMA_Start_IT>
 800501c:	4601      	mov	r1, r0
 800501e:	bb40      	cbnz	r0, 8005072 <HAL_TIM_Base_Start_DMA+0x98>
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
 8005020:	682a      	ldr	r2, [r5, #0]
 8005022:	68d3      	ldr	r3, [r2, #12]
 8005024:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005028:	60d3      	str	r3, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800502a:	682b      	ldr	r3, [r5, #0]
 800502c:	4a16      	ldr	r2, [pc, #88]	; (8005088 <HAL_TIM_Base_Start_DMA+0xae>)
 800502e:	4293      	cmp	r3, r2
 8005030:	d013      	beq.n	800505a <HAL_TIM_Base_Start_DMA+0x80>
 8005032:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005036:	d010      	beq.n	800505a <HAL_TIM_Base_Start_DMA+0x80>
 8005038:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 800503c:	4293      	cmp	r3, r2
 800503e:	d00c      	beq.n	800505a <HAL_TIM_Base_Start_DMA+0x80>
 8005040:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005044:	4293      	cmp	r3, r2
 8005046:	d008      	beq.n	800505a <HAL_TIM_Base_Start_DMA+0x80>
    __HAL_TIM_ENABLE(htim);
 8005048:	681a      	ldr	r2, [r3, #0]
 800504a:	f042 0201 	orr.w	r2, r2, #1
 800504e:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8005050:	4604      	mov	r4, r0
 8005052:	e00e      	b.n	8005072 <HAL_TIM_Base_Start_DMA+0x98>
    if ((pData == NULL) && (Length > 0U))
 8005054:	2a00      	cmp	r2, #0
 8005056:	d0ce      	beq.n	8004ff6 <HAL_TIM_Base_Start_DMA+0x1c>
 8005058:	e00b      	b.n	8005072 <HAL_TIM_Base_Start_DMA+0x98>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800505a:	689a      	ldr	r2, [r3, #8]
 800505c:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005060:	2a06      	cmp	r2, #6
 8005062:	d008      	beq.n	8005076 <HAL_TIM_Base_Start_DMA+0x9c>
      __HAL_TIM_ENABLE(htim);
 8005064:	681a      	ldr	r2, [r3, #0]
 8005066:	f042 0201 	orr.w	r2, r2, #1
 800506a:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800506c:	460c      	mov	r4, r1
 800506e:	e000      	b.n	8005072 <HAL_TIM_Base_Start_DMA+0x98>
    return HAL_ERROR;
 8005070:	2401      	movs	r4, #1
}
 8005072:	4620      	mov	r0, r4
 8005074:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 8005076:	460c      	mov	r4, r1
 8005078:	e7fb      	b.n	8005072 <HAL_TIM_Base_Start_DMA+0x98>
 800507a:	bf00      	nop
 800507c:	0800575d 	.word	0x0800575d
 8005080:	08005775 	.word	0x08005775
 8005084:	08005a95 	.word	0x08005a95
 8005088:	40012c00 	.word	0x40012c00

0800508c <HAL_TIM_Base_Stop_DMA>:
{
 800508c:	b510      	push	{r4, lr}
 800508e:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
 8005090:	6802      	ldr	r2, [r0, #0]
 8005092:	68d3      	ldr	r3, [r2, #12]
 8005094:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005098:	60d3      	str	r3, [r2, #12]
  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
 800509a:	6a00      	ldr	r0, [r0, #32]
 800509c:	f7fe fc3c 	bl	8003918 <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
 80050a0:	6823      	ldr	r3, [r4, #0]
 80050a2:	6a19      	ldr	r1, [r3, #32]
 80050a4:	f241 1211 	movw	r2, #4369	; 0x1111
 80050a8:	4211      	tst	r1, r2
 80050aa:	d108      	bne.n	80050be <HAL_TIM_Base_Stop_DMA+0x32>
 80050ac:	6a19      	ldr	r1, [r3, #32]
 80050ae:	f240 4244 	movw	r2, #1092	; 0x444
 80050b2:	4211      	tst	r1, r2
 80050b4:	d103      	bne.n	80050be <HAL_TIM_Base_Stop_DMA+0x32>
 80050b6:	681a      	ldr	r2, [r3, #0]
 80050b8:	f022 0201 	bic.w	r2, r2, #1
 80050bc:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 80050be:	2301      	movs	r3, #1
 80050c0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 80050c4:	2000      	movs	r0, #0
 80050c6:	bd10      	pop	{r4, pc}

080050c8 <HAL_TIM_OC_MspInit>:
}
 80050c8:	4770      	bx	lr

080050ca <HAL_TIM_OC_MspDeInit>:
}
 80050ca:	4770      	bx	lr

080050cc <HAL_TIM_OC_DeInit>:
{
 80050cc:	b510      	push	{r4, lr}
 80050ce:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 80050d0:	2302      	movs	r3, #2
 80050d2:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 80050d6:	6803      	ldr	r3, [r0, #0]
 80050d8:	6a19      	ldr	r1, [r3, #32]
 80050da:	f241 1211 	movw	r2, #4369	; 0x1111
 80050de:	4211      	tst	r1, r2
 80050e0:	d108      	bne.n	80050f4 <HAL_TIM_OC_DeInit+0x28>
 80050e2:	6a19      	ldr	r1, [r3, #32]
 80050e4:	f240 4244 	movw	r2, #1092	; 0x444
 80050e8:	4211      	tst	r1, r2
 80050ea:	d103      	bne.n	80050f4 <HAL_TIM_OC_DeInit+0x28>
 80050ec:	681a      	ldr	r2, [r3, #0]
 80050ee:	f022 0201 	bic.w	r2, r2, #1
 80050f2:	601a      	str	r2, [r3, #0]
  HAL_TIM_OC_MspDeInit(htim);
 80050f4:	4620      	mov	r0, r4
 80050f6:	f7ff ffe8 	bl	80050ca <HAL_TIM_OC_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 80050fa:	2000      	movs	r0, #0
 80050fc:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8005100:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
 8005104:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
 8005108:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 800510c:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8005110:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
 8005114:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8005118:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
 800511c:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_RESET;
 8005120:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8005124:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8005128:	bd10      	pop	{r4, pc}

0800512a <HAL_TIM_PWM_MspInit>:
}
 800512a:	4770      	bx	lr

0800512c <HAL_TIM_PWM_MspDeInit>:
}
 800512c:	4770      	bx	lr

0800512e <HAL_TIM_PWM_DeInit>:
{
 800512e:	b510      	push	{r4, lr}
 8005130:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8005132:	2302      	movs	r3, #2
 8005134:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 8005138:	6803      	ldr	r3, [r0, #0]
 800513a:	6a19      	ldr	r1, [r3, #32]
 800513c:	f241 1211 	movw	r2, #4369	; 0x1111
 8005140:	4211      	tst	r1, r2
 8005142:	d108      	bne.n	8005156 <HAL_TIM_PWM_DeInit+0x28>
 8005144:	6a19      	ldr	r1, [r3, #32]
 8005146:	f240 4244 	movw	r2, #1092	; 0x444
 800514a:	4211      	tst	r1, r2
 800514c:	d103      	bne.n	8005156 <HAL_TIM_PWM_DeInit+0x28>
 800514e:	681a      	ldr	r2, [r3, #0]
 8005150:	f022 0201 	bic.w	r2, r2, #1
 8005154:	601a      	str	r2, [r3, #0]
  HAL_TIM_PWM_MspDeInit(htim);
 8005156:	4620      	mov	r0, r4
 8005158:	f7ff ffe8 	bl	800512c <HAL_TIM_PWM_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 800515c:	2000      	movs	r0, #0
 800515e:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8005162:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
 8005166:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
 800516a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 800516e:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8005172:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
 8005176:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 800517a:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
 800517e:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_RESET;
 8005182:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8005186:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 800518a:	bd10      	pop	{r4, pc}

0800518c <HAL_TIM_IC_MspInit>:
}
 800518c:	4770      	bx	lr

0800518e <HAL_TIM_IC_MspDeInit>:
}
 800518e:	4770      	bx	lr

08005190 <HAL_TIM_IC_DeInit>:
{
 8005190:	b510      	push	{r4, lr}
 8005192:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8005194:	2302      	movs	r3, #2
 8005196:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 800519a:	6803      	ldr	r3, [r0, #0]
 800519c:	6a19      	ldr	r1, [r3, #32]
 800519e:	f241 1211 	movw	r2, #4369	; 0x1111
 80051a2:	4211      	tst	r1, r2
 80051a4:	d108      	bne.n	80051b8 <HAL_TIM_IC_DeInit+0x28>
 80051a6:	6a19      	ldr	r1, [r3, #32]
 80051a8:	f240 4244 	movw	r2, #1092	; 0x444
 80051ac:	4211      	tst	r1, r2
 80051ae:	d103      	bne.n	80051b8 <HAL_TIM_IC_DeInit+0x28>
 80051b0:	681a      	ldr	r2, [r3, #0]
 80051b2:	f022 0201 	bic.w	r2, r2, #1
 80051b6:	601a      	str	r2, [r3, #0]
  HAL_TIM_IC_MspDeInit(htim);
 80051b8:	4620      	mov	r0, r4
 80051ba:	f7ff ffe8 	bl	800518e <HAL_TIM_IC_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 80051be:	2000      	movs	r0, #0
 80051c0:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 80051c4:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
 80051c8:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
 80051cc:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 80051d0:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 80051d4:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
 80051d8:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 80051dc:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
 80051e0:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_RESET;
 80051e4:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 80051e8:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 80051ec:	bd10      	pop	{r4, pc}

080051ee <HAL_TIM_OnePulse_MspInit>:
}
 80051ee:	4770      	bx	lr

080051f0 <HAL_TIM_OnePulse_MspDeInit>:
}
 80051f0:	4770      	bx	lr

080051f2 <HAL_TIM_OnePulse_DeInit>:
{
 80051f2:	b510      	push	{r4, lr}
 80051f4:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 80051f6:	2302      	movs	r3, #2
 80051f8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 80051fc:	6803      	ldr	r3, [r0, #0]
 80051fe:	6a19      	ldr	r1, [r3, #32]
 8005200:	f241 1211 	movw	r2, #4369	; 0x1111
 8005204:	4211      	tst	r1, r2
 8005206:	d108      	bne.n	800521a <HAL_TIM_OnePulse_DeInit+0x28>
 8005208:	6a19      	ldr	r1, [r3, #32]
 800520a:	f240 4244 	movw	r2, #1092	; 0x444
 800520e:	4211      	tst	r1, r2
 8005210:	d103      	bne.n	800521a <HAL_TIM_OnePulse_DeInit+0x28>
 8005212:	681a      	ldr	r2, [r3, #0]
 8005214:	f022 0201 	bic.w	r2, r2, #1
 8005218:	601a      	str	r2, [r3, #0]
  HAL_TIM_OnePulse_MspDeInit(htim);
 800521a:	4620      	mov	r0, r4
 800521c:	f7ff ffe8 	bl	80051f0 <HAL_TIM_OnePulse_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 8005220:	2000      	movs	r0, #0
 8005222:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
 8005226:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
 800522a:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
 800522e:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
 8005232:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  htim->State = HAL_TIM_STATE_RESET;
 8005236:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800523a:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 800523e:	bd10      	pop	{r4, pc}

08005240 <HAL_TIM_Encoder_MspInit>:
}
 8005240:	4770      	bx	lr

08005242 <HAL_TIM_Encoder_MspDeInit>:
}
 8005242:	4770      	bx	lr

08005244 <HAL_TIM_Encoder_DeInit>:
{
 8005244:	b510      	push	{r4, lr}
 8005246:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8005248:	2302      	movs	r3, #2
 800524a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 800524e:	6803      	ldr	r3, [r0, #0]
 8005250:	6a19      	ldr	r1, [r3, #32]
 8005252:	f241 1211 	movw	r2, #4369	; 0x1111
 8005256:	4211      	tst	r1, r2
 8005258:	d108      	bne.n	800526c <HAL_TIM_Encoder_DeInit+0x28>
 800525a:	6a19      	ldr	r1, [r3, #32]
 800525c:	f240 4244 	movw	r2, #1092	; 0x444
 8005260:	4211      	tst	r1, r2
 8005262:	d103      	bne.n	800526c <HAL_TIM_Encoder_DeInit+0x28>
 8005264:	681a      	ldr	r2, [r3, #0]
 8005266:	f022 0201 	bic.w	r2, r2, #1
 800526a:	601a      	str	r2, [r3, #0]
  HAL_TIM_Encoder_MspDeInit(htim);
 800526c:	4620      	mov	r0, r4
 800526e:	f7ff ffe8 	bl	8005242 <HAL_TIM_Encoder_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 8005272:	2000      	movs	r0, #0
 8005274:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
 8005278:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
 800527c:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
 8005280:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
 8005284:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  htim->State = HAL_TIM_STATE_RESET;
 8005288:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800528c:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8005290:	bd10      	pop	{r4, pc}

08005292 <HAL_TIM_DMABurst_MultiWriteStart>:
{
 8005292:	b570      	push	{r4, r5, r6, lr}
 8005294:	4605      	mov	r5, r0
  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
 8005296:	f890 0046 	ldrb.w	r0, [r0, #70]	; 0x46
 800529a:	b2c0      	uxtb	r0, r0
 800529c:	2802      	cmp	r0, #2
 800529e:	d04a      	beq.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
 80052a0:	460e      	mov	r6, r1
 80052a2:	4614      	mov	r4, r2
 80052a4:	4619      	mov	r1, r3
  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
 80052a6:	f895 0046 	ldrb.w	r0, [r5, #70]	; 0x46
 80052aa:	b2c0      	uxtb	r0, r0
 80052ac:	2801      	cmp	r0, #1
 80052ae:	d01c      	beq.n	80052ea <HAL_TIM_DMABurst_MultiWriteStart+0x58>
  switch (BurstRequestSrc)
 80052b0:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 80052b4:	f000 8082 	beq.w	80053bc <HAL_TIM_DMABurst_MultiWriteStart+0x12a>
 80052b8:	d83e      	bhi.n	8005338 <HAL_TIM_DMABurst_MultiWriteStart+0xa6>
 80052ba:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 80052be:	d06a      	beq.n	8005396 <HAL_TIM_DMABurst_MultiWriteStart+0x104>
 80052c0:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 80052c4:	d11a      	bne.n	80052fc <HAL_TIM_DMABurst_MultiWriteStart+0x6a>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
 80052c6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80052c8:	4a50      	ldr	r2, [pc, #320]	; (800540c <HAL_TIM_DMABurst_MultiWriteStart+0x17a>)
 80052ca:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 80052cc:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80052ce:	4a50      	ldr	r2, [pc, #320]	; (8005410 <HAL_TIM_DMABurst_MultiWriteStart+0x17e>)
 80052d0:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 80052d2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80052d4:	4a4f      	ldr	r2, [pc, #316]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 80052d6:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 80052d8:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
 80052da:	9b05      	ldr	r3, [sp, #20]
 80052dc:	324c      	adds	r2, #76	; 0x4c
 80052de:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 80052e0:	f7fe fabe 	bl	8003860 <HAL_DMA_Start_IT>
 80052e4:	b1f0      	cbz	r0, 8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
        return HAL_ERROR;
 80052e6:	2001      	movs	r0, #1
 80052e8:	e025      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
 80052ea:	b11b      	cbz	r3, 80052f4 <HAL_TIM_DMABurst_MultiWriteStart+0x62>
      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
 80052ec:	2302      	movs	r3, #2
 80052ee:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 80052f2:	e7dd      	b.n	80052b0 <HAL_TIM_DMABurst_MultiWriteStart+0x1e>
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
 80052f4:	9b04      	ldr	r3, [sp, #16]
 80052f6:	2b00      	cmp	r3, #0
 80052f8:	d0f8      	beq.n	80052ec <HAL_TIM_DMABurst_MultiWriteStart+0x5a>
 80052fa:	e01c      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
  switch (BurstRequestSrc)
 80052fc:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8005300:	d110      	bne.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
 8005302:	6a2b      	ldr	r3, [r5, #32]
 8005304:	4a44      	ldr	r2, [pc, #272]	; (8005418 <HAL_TIM_DMABurst_MultiWriteStart+0x186>)
 8005306:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
 8005308:	6a2b      	ldr	r3, [r5, #32]
 800530a:	4a44      	ldr	r2, [pc, #272]	; (800541c <HAL_TIM_DMABurst_MultiWriteStart+0x18a>)
 800530c:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
 800530e:	6a2b      	ldr	r3, [r5, #32]
 8005310:	4a40      	ldr	r2, [pc, #256]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 8005312:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 8005314:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,
 8005316:	9b05      	ldr	r3, [sp, #20]
 8005318:	324c      	adds	r2, #76	; 0x4c
 800531a:	6a28      	ldr	r0, [r5, #32]
 800531c:	f7fe faa0 	bl	8003860 <HAL_DMA_Start_IT>
 8005320:	2800      	cmp	r0, #0
 8005322:	d171      	bne.n	8005408 <HAL_TIM_DMABurst_MultiWriteStart+0x176>
  htim->Instance->DCR = (BurstBaseAddress | BurstLength);
 8005324:	682b      	ldr	r3, [r5, #0]
 8005326:	9a04      	ldr	r2, [sp, #16]
 8005328:	4316      	orrs	r6, r2
 800532a:	649e      	str	r6, [r3, #72]	; 0x48
  __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
 800532c:	682b      	ldr	r3, [r5, #0]
 800532e:	68da      	ldr	r2, [r3, #12]
 8005330:	4314      	orrs	r4, r2
 8005332:	60dc      	str	r4, [r3, #12]
  return HAL_OK;
 8005334:	2000      	movs	r0, #0
}
 8005336:	bd70      	pop	{r4, r5, r6, pc}
  switch (BurstRequestSrc)
 8005338:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 800533c:	d051      	beq.n	80053e2 <HAL_TIM_DMABurst_MultiWriteStart+0x150>
 800533e:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
 8005342:	d112      	bne.n	800536a <HAL_TIM_DMABurst_MultiWriteStart+0xd8>
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
 8005344:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005346:	4a36      	ldr	r2, [pc, #216]	; (8005420 <HAL_TIM_DMABurst_MultiWriteStart+0x18e>)
 8005348:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
 800534a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800534c:	4a35      	ldr	r2, [pc, #212]	; (8005424 <HAL_TIM_DMABurst_MultiWriteStart+0x192>)
 800534e:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
 8005350:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005352:	4a30      	ldr	r2, [pc, #192]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 8005354:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 8005356:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
 8005358:	9b05      	ldr	r3, [sp, #20]
 800535a:	324c      	adds	r2, #76	; 0x4c
 800535c:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 800535e:	f7fe fa7f 	bl	8003860 <HAL_DMA_Start_IT>
 8005362:	2800      	cmp	r0, #0
 8005364:	d0de      	beq.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
        return HAL_ERROR;
 8005366:	2001      	movs	r0, #1
 8005368:	e7e5      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
  switch (BurstRequestSrc)
 800536a:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800536e:	d1d9      	bne.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8005370:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005372:	4a26      	ldr	r2, [pc, #152]	; (800540c <HAL_TIM_DMABurst_MultiWriteStart+0x17a>)
 8005374:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8005376:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005378:	4a25      	ldr	r2, [pc, #148]	; (8005410 <HAL_TIM_DMABurst_MultiWriteStart+0x17e>)
 800537a:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
 800537c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800537e:	4a25      	ldr	r2, [pc, #148]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 8005380:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 8005382:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
 8005384:	9b05      	ldr	r3, [sp, #20]
 8005386:	324c      	adds	r2, #76	; 0x4c
 8005388:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800538a:	f7fe fa69 	bl	8003860 <HAL_DMA_Start_IT>
 800538e:	2800      	cmp	r0, #0
 8005390:	d0c8      	beq.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
        return HAL_ERROR;
 8005392:	2001      	movs	r0, #1
 8005394:	e7cf      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8005396:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8005398:	4a1c      	ldr	r2, [pc, #112]	; (800540c <HAL_TIM_DMABurst_MultiWriteStart+0x17a>)
 800539a:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 800539c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800539e:	4a1c      	ldr	r2, [pc, #112]	; (8005410 <HAL_TIM_DMABurst_MultiWriteStart+0x17e>)
 80053a0:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 80053a2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80053a4:	4a1b      	ldr	r2, [pc, #108]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 80053a6:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 80053a8:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
 80053aa:	9b05      	ldr	r3, [sp, #20]
 80053ac:	324c      	adds	r2, #76	; 0x4c
 80053ae:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80053b0:	f7fe fa56 	bl	8003860 <HAL_DMA_Start_IT>
 80053b4:	2800      	cmp	r0, #0
 80053b6:	d0b5      	beq.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
        return HAL_ERROR;
 80053b8:	2001      	movs	r0, #1
 80053ba:	e7bc      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
 80053bc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80053be:	4a13      	ldr	r2, [pc, #76]	; (800540c <HAL_TIM_DMABurst_MultiWriteStart+0x17a>)
 80053c0:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 80053c2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80053c4:	4a12      	ldr	r2, [pc, #72]	; (8005410 <HAL_TIM_DMABurst_MultiWriteStart+0x17e>)
 80053c6:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
 80053c8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80053ca:	4a12      	ldr	r2, [pc, #72]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 80053cc:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 80053ce:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
 80053d0:	9b05      	ldr	r3, [sp, #20]
 80053d2:	324c      	adds	r2, #76	; 0x4c
 80053d4:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80053d6:	f7fe fa43 	bl	8003860 <HAL_DMA_Start_IT>
 80053da:	2800      	cmp	r0, #0
 80053dc:	d0a2      	beq.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
        return HAL_ERROR;
 80053de:	2001      	movs	r0, #1
 80053e0:	e7a9      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
 80053e2:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80053e4:	4a10      	ldr	r2, [pc, #64]	; (8005428 <HAL_TIM_DMABurst_MultiWriteStart+0x196>)
 80053e6:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
 80053e8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80053ea:	4a10      	ldr	r2, [pc, #64]	; (800542c <HAL_TIM_DMABurst_MultiWriteStart+0x19a>)
 80053ec:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
 80053ee:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80053f0:	4a08      	ldr	r2, [pc, #32]	; (8005414 <HAL_TIM_DMABurst_MultiWriteStart+0x182>)
 80053f2:	631a      	str	r2, [r3, #48]	; 0x30
                         (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
 80053f4:	682a      	ldr	r2, [r5, #0]
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
 80053f6:	9b05      	ldr	r3, [sp, #20]
 80053f8:	324c      	adds	r2, #76	; 0x4c
 80053fa:	6b68      	ldr	r0, [r5, #52]	; 0x34
 80053fc:	f7fe fa30 	bl	8003860 <HAL_DMA_Start_IT>
 8005400:	2800      	cmp	r0, #0
 8005402:	d08f      	beq.n	8005324 <HAL_TIM_DMABurst_MultiWriteStart+0x92>
        return HAL_ERROR;
 8005404:	2001      	movs	r0, #1
 8005406:	e796      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
        return HAL_ERROR;
 8005408:	2001      	movs	r0, #1
 800540a:	e794      	b.n	8005336 <HAL_TIM_DMABurst_MultiWriteStart+0xa4>
 800540c:	08005845 	.word	0x08005845
 8005410:	080058b7 	.word	0x080058b7
 8005414:	08005a95 	.word	0x08005a95
 8005418:	0800575d 	.word	0x0800575d
 800541c:	08005775 	.word	0x08005775
 8005420:	08005a71 	.word	0x08005a71
 8005424:	08005a89 	.word	0x08005a89
 8005428:	080095ad 	.word	0x080095ad
 800542c:	080095bf 	.word	0x080095bf

08005430 <HAL_TIM_DMABurst_WriteStart>:
{
 8005430:	b530      	push	{r4, r5, lr}
 8005432:	b083      	sub	sp, #12
 8005434:	9d06      	ldr	r5, [sp, #24]
                                          ((BurstLength) >> 8U) + 1U);
 8005436:	0a2c      	lsrs	r4, r5, #8
  return HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
 8005438:	3401      	adds	r4, #1
 800543a:	9401      	str	r4, [sp, #4]
 800543c:	9500      	str	r5, [sp, #0]
 800543e:	f7ff ff28 	bl	8005292 <HAL_TIM_DMABurst_MultiWriteStart>
}
 8005442:	b003      	add	sp, #12
 8005444:	bd30      	pop	{r4, r5, pc}

08005446 <HAL_TIM_DMABurst_WriteStop>:
{
 8005446:	b538      	push	{r3, r4, r5, lr}
 8005448:	4605      	mov	r5, r0
 800544a:	460c      	mov	r4, r1
  switch (BurstRequestSrc)
 800544c:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8005450:	d02f      	beq.n	80054b2 <HAL_TIM_DMABurst_WriteStop+0x6c>
 8005452:	d819      	bhi.n	8005488 <HAL_TIM_DMABurst_WriteStop+0x42>
 8005454:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8005458:	d027      	beq.n	80054aa <HAL_TIM_DMABurst_WriteStop+0x64>
 800545a:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 800545e:	d103      	bne.n	8005468 <HAL_TIM_DMABurst_WriteStop+0x22>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 8005460:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8005462:	f7fe fa59 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8005466:	e005      	b.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
  switch (BurstRequestSrc)
 8005468:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800546c:	d102      	bne.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
 800546e:	6a00      	ldr	r0, [r0, #32]
 8005470:	f7fe fa52 	bl	8003918 <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
 8005474:	682b      	ldr	r3, [r5, #0]
 8005476:	68d9      	ldr	r1, [r3, #12]
 8005478:	ea21 0404 	bic.w	r4, r1, r4
 800547c:	60dc      	str	r4, [r3, #12]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800547e:	2301      	movs	r3, #1
 8005480:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
}
 8005484:	2000      	movs	r0, #0
 8005486:	bd38      	pop	{r3, r4, r5, pc}
  switch (BurstRequestSrc)
 8005488:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 800548c:	d015      	beq.n	80054ba <HAL_TIM_DMABurst_WriteStop+0x74>
 800548e:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8005492:	d103      	bne.n	800549c <HAL_TIM_DMABurst_WriteStop+0x56>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
 8005494:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8005496:	f7fe fa3f 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 800549a:	e7eb      	b.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
  switch (BurstRequestSrc)
 800549c:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80054a0:	d1e8      	bne.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
 80054a2:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80054a4:	f7fe fa38 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80054a8:	e7e4      	b.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 80054aa:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80054ac:	f7fe fa34 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80054b0:	e7e0      	b.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 80054b2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80054b4:	f7fe fa30 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80054b8:	e7dc      	b.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
 80054ba:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80054bc:	f7fe fa2c 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80054c0:	e7d8      	b.n	8005474 <HAL_TIM_DMABurst_WriteStop+0x2e>

080054c2 <HAL_TIM_DMABurst_MultiReadStart>:
{
 80054c2:	b570      	push	{r4, r5, r6, lr}
 80054c4:	4605      	mov	r5, r0
  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)
 80054c6:	f890 0046 	ldrb.w	r0, [r0, #70]	; 0x46
 80054ca:	b2c0      	uxtb	r0, r0
 80054cc:	2802      	cmp	r0, #2
 80054ce:	d04a      	beq.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
 80054d0:	460e      	mov	r6, r1
 80054d2:	4614      	mov	r4, r2
 80054d4:	461a      	mov	r2, r3
  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)
 80054d6:	f895 0046 	ldrb.w	r0, [r5, #70]	; 0x46
 80054da:	b2c0      	uxtb	r0, r0
 80054dc:	2801      	cmp	r0, #1
 80054de:	d01c      	beq.n	800551a <HAL_TIM_DMABurst_MultiReadStart+0x58>
  switch (BurstRequestSrc)
 80054e0:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 80054e4:	f000 8082 	beq.w	80055ec <HAL_TIM_DMABurst_MultiReadStart+0x12a>
 80054e8:	d83e      	bhi.n	8005568 <HAL_TIM_DMABurst_MultiReadStart+0xa6>
 80054ea:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 80054ee:	d06a      	beq.n	80055c6 <HAL_TIM_DMABurst_MultiReadStart+0x104>
 80054f0:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 80054f4:	d11a      	bne.n	800552c <HAL_TIM_DMABurst_MultiReadStart+0x6a>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
 80054f6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80054f8:	4950      	ldr	r1, [pc, #320]	; (800563c <HAL_TIM_DMABurst_MultiReadStart+0x17a>)
 80054fa:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 80054fc:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80054fe:	4950      	ldr	r1, [pc, #320]	; (8005640 <HAL_TIM_DMABurst_MultiReadStart+0x17e>)
 8005500:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 8005502:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8005504:	494f      	ldr	r1, [pc, #316]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 8005506:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 8005508:	6829      	ldr	r1, [r5, #0]
 800550a:	9b05      	ldr	r3, [sp, #20]
 800550c:	314c      	adds	r1, #76	; 0x4c
 800550e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8005510:	f7fe f9a6 	bl	8003860 <HAL_DMA_Start_IT>
 8005514:	b1f0      	cbz	r0, 8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
        return HAL_ERROR;
 8005516:	2001      	movs	r0, #1
 8005518:	e025      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
 800551a:	b11b      	cbz	r3, 8005524 <HAL_TIM_DMABurst_MultiReadStart+0x62>
      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;
 800551c:	2302      	movs	r3, #2
 800551e:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 8005522:	e7dd      	b.n	80054e0 <HAL_TIM_DMABurst_MultiReadStart+0x1e>
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
 8005524:	9b04      	ldr	r3, [sp, #16]
 8005526:	2b00      	cmp	r3, #0
 8005528:	d0f8      	beq.n	800551c <HAL_TIM_DMABurst_MultiReadStart+0x5a>
 800552a:	e01c      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
  switch (BurstRequestSrc)
 800552c:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8005530:	d110      	bne.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
 8005532:	6a2b      	ldr	r3, [r5, #32]
 8005534:	4944      	ldr	r1, [pc, #272]	; (8005648 <HAL_TIM_DMABurst_MultiReadStart+0x186>)
 8005536:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
 8005538:	6a2b      	ldr	r3, [r5, #32]
 800553a:	4944      	ldr	r1, [pc, #272]	; (800564c <HAL_TIM_DMABurst_MultiReadStart+0x18a>)
 800553c:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
 800553e:	6a2b      	ldr	r3, [r5, #32]
 8005540:	4940      	ldr	r1, [pc, #256]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 8005542:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 8005544:	6829      	ldr	r1, [r5, #0]
 8005546:	9b05      	ldr	r3, [sp, #20]
 8005548:	314c      	adds	r1, #76	; 0x4c
 800554a:	6a28      	ldr	r0, [r5, #32]
 800554c:	f7fe f988 	bl	8003860 <HAL_DMA_Start_IT>
 8005550:	2800      	cmp	r0, #0
 8005552:	d171      	bne.n	8005638 <HAL_TIM_DMABurst_MultiReadStart+0x176>
  htim->Instance->DCR = (BurstBaseAddress | BurstLength);
 8005554:	682b      	ldr	r3, [r5, #0]
 8005556:	9a04      	ldr	r2, [sp, #16]
 8005558:	4316      	orrs	r6, r2
 800555a:	649e      	str	r6, [r3, #72]	; 0x48
  __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
 800555c:	682b      	ldr	r3, [r5, #0]
 800555e:	68da      	ldr	r2, [r3, #12]
 8005560:	4314      	orrs	r4, r2
 8005562:	60dc      	str	r4, [r3, #12]
  return HAL_OK;
 8005564:	2000      	movs	r0, #0
}
 8005566:	bd70      	pop	{r4, r5, r6, pc}
  switch (BurstRequestSrc)
 8005568:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 800556c:	d051      	beq.n	8005612 <HAL_TIM_DMABurst_MultiReadStart+0x150>
 800556e:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
 8005572:	d112      	bne.n	800559a <HAL_TIM_DMABurst_MultiReadStart+0xd8>
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
 8005574:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005576:	4936      	ldr	r1, [pc, #216]	; (8005650 <HAL_TIM_DMABurst_MultiReadStart+0x18e>)
 8005578:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
 800557a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800557c:	4935      	ldr	r1, [pc, #212]	; (8005654 <HAL_TIM_DMABurst_MultiReadStart+0x192>)
 800557e:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
 8005580:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005582:	4930      	ldr	r1, [pc, #192]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 8005584:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 8005586:	6829      	ldr	r1, [r5, #0]
 8005588:	9b05      	ldr	r3, [sp, #20]
 800558a:	314c      	adds	r1, #76	; 0x4c
 800558c:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 800558e:	f7fe f967 	bl	8003860 <HAL_DMA_Start_IT>
 8005592:	2800      	cmp	r0, #0
 8005594:	d0de      	beq.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
        return HAL_ERROR;
 8005596:	2001      	movs	r0, #1
 8005598:	e7e5      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
  switch (BurstRequestSrc)
 800559a:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800559e:	d1d9      	bne.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
 80055a0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80055a2:	4926      	ldr	r1, [pc, #152]	; (800563c <HAL_TIM_DMABurst_MultiReadStart+0x17a>)
 80055a4:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 80055a6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80055a8:	4925      	ldr	r1, [pc, #148]	; (8005640 <HAL_TIM_DMABurst_MultiReadStart+0x17e>)
 80055aa:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
 80055ac:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80055ae:	4925      	ldr	r1, [pc, #148]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 80055b0:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 80055b2:	6829      	ldr	r1, [r5, #0]
 80055b4:	9b05      	ldr	r3, [sp, #20]
 80055b6:	314c      	adds	r1, #76	; 0x4c
 80055b8:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80055ba:	f7fe f951 	bl	8003860 <HAL_DMA_Start_IT>
 80055be:	2800      	cmp	r0, #0
 80055c0:	d0c8      	beq.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
        return HAL_ERROR;
 80055c2:	2001      	movs	r0, #1
 80055c4:	e7cf      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
 80055c6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80055c8:	491c      	ldr	r1, [pc, #112]	; (800563c <HAL_TIM_DMABurst_MultiReadStart+0x17a>)
 80055ca:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 80055cc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80055ce:	491c      	ldr	r1, [pc, #112]	; (8005640 <HAL_TIM_DMABurst_MultiReadStart+0x17e>)
 80055d0:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 80055d2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80055d4:	491b      	ldr	r1, [pc, #108]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 80055d6:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 80055d8:	6829      	ldr	r1, [r5, #0]
 80055da:	9b05      	ldr	r3, [sp, #20]
 80055dc:	314c      	adds	r1, #76	; 0x4c
 80055de:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80055e0:	f7fe f93e 	bl	8003860 <HAL_DMA_Start_IT>
 80055e4:	2800      	cmp	r0, #0
 80055e6:	d0b5      	beq.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
        return HAL_ERROR;
 80055e8:	2001      	movs	r0, #1
 80055ea:	e7bc      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
 80055ec:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80055ee:	4913      	ldr	r1, [pc, #76]	; (800563c <HAL_TIM_DMABurst_MultiReadStart+0x17a>)
 80055f0:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 80055f2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80055f4:	4912      	ldr	r1, [pc, #72]	; (8005640 <HAL_TIM_DMABurst_MultiReadStart+0x17e>)
 80055f6:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
 80055f8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80055fa:	4912      	ldr	r1, [pc, #72]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 80055fc:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 80055fe:	6829      	ldr	r1, [r5, #0]
 8005600:	9b05      	ldr	r3, [sp, #20]
 8005602:	314c      	adds	r1, #76	; 0x4c
 8005604:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8005606:	f7fe f92b 	bl	8003860 <HAL_DMA_Start_IT>
 800560a:	2800      	cmp	r0, #0
 800560c:	d0a2      	beq.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
        return HAL_ERROR;
 800560e:	2001      	movs	r0, #1
 8005610:	e7a9      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
 8005612:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8005614:	4910      	ldr	r1, [pc, #64]	; (8005658 <HAL_TIM_DMABurst_MultiReadStart+0x196>)
 8005616:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
 8005618:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800561a:	4910      	ldr	r1, [pc, #64]	; (800565c <HAL_TIM_DMABurst_MultiReadStart+0x19a>)
 800561c:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
 800561e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8005620:	4908      	ldr	r1, [pc, #32]	; (8005644 <HAL_TIM_DMABurst_MultiReadStart+0x182>)
 8005622:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
 8005624:	6829      	ldr	r1, [r5, #0]
 8005626:	9b05      	ldr	r3, [sp, #20]
 8005628:	314c      	adds	r1, #76	; 0x4c
 800562a:	6b68      	ldr	r0, [r5, #52]	; 0x34
 800562c:	f7fe f918 	bl	8003860 <HAL_DMA_Start_IT>
 8005630:	2800      	cmp	r0, #0
 8005632:	d08f      	beq.n	8005554 <HAL_TIM_DMABurst_MultiReadStart+0x92>
        return HAL_ERROR;
 8005634:	2001      	movs	r0, #1
 8005636:	e796      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
        return HAL_ERROR;
 8005638:	2001      	movs	r0, #1
 800563a:	e794      	b.n	8005566 <HAL_TIM_DMABurst_MultiReadStart+0xa4>
 800563c:	08005783 	.word	0x08005783
 8005640:	08005805 	.word	0x08005805
 8005644:	08005a95 	.word	0x08005a95
 8005648:	0800575d 	.word	0x0800575d
 800564c:	08005775 	.word	0x08005775
 8005650:	08005a71 	.word	0x08005a71
 8005654:	08005a89 	.word	0x08005a89
 8005658:	080095ad 	.word	0x080095ad
 800565c:	080095bf 	.word	0x080095bf

08005660 <HAL_TIM_DMABurst_ReadStart>:
{
 8005660:	b530      	push	{r4, r5, lr}
 8005662:	b083      	sub	sp, #12
 8005664:	9d06      	ldr	r5, [sp, #24]
                                         ((BurstLength) >> 8U) + 1U);
 8005666:	0a2c      	lsrs	r4, r5, #8
  return HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
 8005668:	3401      	adds	r4, #1
 800566a:	9401      	str	r4, [sp, #4]
 800566c:	9500      	str	r5, [sp, #0]
 800566e:	f7ff ff28 	bl	80054c2 <HAL_TIM_DMABurst_MultiReadStart>
}
 8005672:	b003      	add	sp, #12
 8005674:	bd30      	pop	{r4, r5, pc}

08005676 <HAL_TIM_DMABurst_ReadStop>:
{
 8005676:	b538      	push	{r3, r4, r5, lr}
 8005678:	4605      	mov	r5, r0
 800567a:	460c      	mov	r4, r1
  switch (BurstRequestSrc)
 800567c:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8005680:	d02f      	beq.n	80056e2 <HAL_TIM_DMABurst_ReadStop+0x6c>
 8005682:	d819      	bhi.n	80056b8 <HAL_TIM_DMABurst_ReadStop+0x42>
 8005684:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8005688:	d027      	beq.n	80056da <HAL_TIM_DMABurst_ReadStop+0x64>
 800568a:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 800568e:	d103      	bne.n	8005698 <HAL_TIM_DMABurst_ReadStop+0x22>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 8005690:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8005692:	f7fe f941 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8005696:	e005      	b.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
  switch (BurstRequestSrc)
 8005698:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800569c:	d102      	bne.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
 800569e:	6a00      	ldr	r0, [r0, #32]
 80056a0:	f7fe f93a 	bl	8003918 <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
 80056a4:	682b      	ldr	r3, [r5, #0]
 80056a6:	68d9      	ldr	r1, [r3, #12]
 80056a8:	ea21 0404 	bic.w	r4, r1, r4
 80056ac:	60dc      	str	r4, [r3, #12]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80056ae:	2301      	movs	r3, #1
 80056b0:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
}
 80056b4:	2000      	movs	r0, #0
 80056b6:	bd38      	pop	{r3, r4, r5, pc}
  switch (BurstRequestSrc)
 80056b8:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 80056bc:	d015      	beq.n	80056ea <HAL_TIM_DMABurst_ReadStop+0x74>
 80056be:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 80056c2:	d103      	bne.n	80056cc <HAL_TIM_DMABurst_ReadStop+0x56>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
 80056c4:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80056c6:	f7fe f927 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80056ca:	e7eb      	b.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
  switch (BurstRequestSrc)
 80056cc:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80056d0:	d1e8      	bne.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
 80056d2:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80056d4:	f7fe f920 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80056d8:	e7e4      	b.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 80056da:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80056dc:	f7fe f91c 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80056e0:	e7e0      	b.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 80056e2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80056e4:	f7fe f918 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80056e8:	e7dc      	b.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
 80056ea:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80056ec:	f7fe f914 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80056f0:	e7d8      	b.n	80056a4 <HAL_TIM_DMABurst_ReadStop+0x2e>

080056f2 <HAL_TIM_GenerateEvent>:
  __HAL_LOCK(htim);
 80056f2:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80056f6:	2b01      	cmp	r3, #1
 80056f8:	d00c      	beq.n	8005714 <HAL_TIM_GenerateEvent+0x22>
  htim->State = HAL_TIM_STATE_BUSY;
 80056fa:	2302      	movs	r3, #2
 80056fc:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  htim->Instance->EGR = EventSource;
 8005700:	6803      	ldr	r3, [r0, #0]
 8005702:	6159      	str	r1, [r3, #20]
  htim->State = HAL_TIM_STATE_READY;
 8005704:	2301      	movs	r3, #1
 8005706:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800570a:	2300      	movs	r3, #0
 800570c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8005710:	4618      	mov	r0, r3
 8005712:	4770      	bx	lr
  __HAL_LOCK(htim);
 8005714:	2002      	movs	r0, #2
}
 8005716:	4770      	bx	lr

08005718 <HAL_TIM_ConfigTI1Input>:
  tmpcr2 = htim->Instance->CR2;
 8005718:	6802      	ldr	r2, [r0, #0]
 800571a:	6853      	ldr	r3, [r2, #4]
  tmpcr2 &= ~TIM_CR2_TI1S;
 800571c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpcr2 |= TI1_Selection;
 8005720:	430b      	orrs	r3, r1
  htim->Instance->CR2 = tmpcr2;
 8005722:	6053      	str	r3, [r2, #4]
}
 8005724:	2000      	movs	r0, #0
 8005726:	4770      	bx	lr

08005728 <HAL_TIM_ReadCapturedValue>:
  switch (Channel)
 8005728:	290c      	cmp	r1, #12
 800572a:	d814      	bhi.n	8005756 <HAL_TIM_ReadCapturedValue+0x2e>
 800572c:	e8df f001 	tbb	[pc, r1]
 8005730:	13131307 	.word	0x13131307
 8005734:	1313130a 	.word	0x1313130a
 8005738:	1313130d 	.word	0x1313130d
 800573c:	10          	.byte	0x10
 800573d:	00          	.byte	0x00
      tmpreg =  htim->Instance->CCR1;
 800573e:	6803      	ldr	r3, [r0, #0]
 8005740:	6b58      	ldr	r0, [r3, #52]	; 0x34
      break;
 8005742:	4770      	bx	lr
      tmpreg =   htim->Instance->CCR2;
 8005744:	6803      	ldr	r3, [r0, #0]
 8005746:	6b98      	ldr	r0, [r3, #56]	; 0x38
      break;
 8005748:	4770      	bx	lr
      tmpreg =   htim->Instance->CCR3;
 800574a:	6803      	ldr	r3, [r0, #0]
 800574c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
      break;
 800574e:	4770      	bx	lr
      tmpreg =   htim->Instance->CCR4;
 8005750:	6803      	ldr	r3, [r0, #0]
 8005752:	6c18      	ldr	r0, [r3, #64]	; 0x40
      break;
 8005754:	4770      	bx	lr
{
 8005756:	2000      	movs	r0, #0
}
 8005758:	4770      	bx	lr
}
 800575a:	4770      	bx	lr

0800575c <TIM_DMAPeriodElapsedCplt>:
{
 800575c:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800575e:	6a40      	ldr	r0, [r0, #36]	; 0x24
  if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)
 8005760:	6a03      	ldr	r3, [r0, #32]
 8005762:	699b      	ldr	r3, [r3, #24]
 8005764:	b913      	cbnz	r3, 800576c <TIM_DMAPeriodElapsedCplt+0x10>
    htim->State = HAL_TIM_STATE_READY;
 8005766:	2301      	movs	r3, #1
 8005768:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  HAL_TIM_PeriodElapsedCallback(htim);
 800576c:	f7fa ff4a 	bl	8000604 <HAL_TIM_PeriodElapsedCallback>
}
 8005770:	bd08      	pop	{r3, pc}

08005772 <HAL_TIM_PeriodElapsedHalfCpltCallback>:
}
 8005772:	4770      	bx	lr

08005774 <TIM_DMAPeriodElapsedHalfCplt>:
{
 8005774:	b508      	push	{r3, lr}
  HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
 8005776:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8005778:	f7ff fffb 	bl	8005772 <HAL_TIM_PeriodElapsedHalfCpltCallback>
}
 800577c:	bd08      	pop	{r3, pc}

0800577e <HAL_TIM_OC_DelayElapsedCallback>:
}
 800577e:	4770      	bx	lr

08005780 <HAL_TIM_IC_CaptureCallback>:
}
 8005780:	4770      	bx	lr

08005782 <TIM_DMACaptureCplt>:
{
 8005782:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8005784:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8005786:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005788:	4283      	cmp	r3, r0
 800578a:	d00e      	beq.n	80057aa <TIM_DMACaptureCplt+0x28>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 800578c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800578e:	4283      	cmp	r3, r0
 8005790:	d016      	beq.n	80057c0 <TIM_DMACaptureCplt+0x3e>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 8005792:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005794:	4283      	cmp	r3, r0
 8005796:	d01e      	beq.n	80057d6 <TIM_DMACaptureCplt+0x54>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 8005798:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800579a:	4283      	cmp	r3, r0
 800579c:	d026      	beq.n	80057ec <TIM_DMACaptureCplt+0x6a>
  HAL_TIM_IC_CaptureCallback(htim);
 800579e:	4620      	mov	r0, r4
 80057a0:	f7ff ffee 	bl	8005780 <HAL_TIM_IC_CaptureCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80057a4:	2300      	movs	r3, #0
 80057a6:	7723      	strb	r3, [r4, #28]
}
 80057a8:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80057aa:	2301      	movs	r3, #1
 80057ac:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80057ae:	6983      	ldr	r3, [r0, #24]
 80057b0:	2b00      	cmp	r3, #0
 80057b2:	d1f4      	bne.n	800579e <TIM_DMACaptureCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80057b4:	2301      	movs	r3, #1
 80057b6:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80057ba:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80057be:	e7ee      	b.n	800579e <TIM_DMACaptureCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80057c0:	2302      	movs	r3, #2
 80057c2:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80057c4:	6983      	ldr	r3, [r0, #24]
 80057c6:	2b00      	cmp	r3, #0
 80057c8:	d1e9      	bne.n	800579e <TIM_DMACaptureCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80057ca:	2301      	movs	r3, #1
 80057cc:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80057d0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80057d4:	e7e3      	b.n	800579e <TIM_DMACaptureCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80057d6:	2304      	movs	r3, #4
 80057d8:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80057da:	6983      	ldr	r3, [r0, #24]
 80057dc:	2b00      	cmp	r3, #0
 80057de:	d1de      	bne.n	800579e <TIM_DMACaptureCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
 80057e0:	2301      	movs	r3, #1
 80057e2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
 80057e6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80057ea:	e7d8      	b.n	800579e <TIM_DMACaptureCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80057ec:	2308      	movs	r3, #8
 80057ee:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80057f0:	6983      	ldr	r3, [r0, #24]
 80057f2:	2b00      	cmp	r3, #0
 80057f4:	d1d3      	bne.n	800579e <TIM_DMACaptureCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
 80057f6:	2301      	movs	r3, #1
 80057f8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
 80057fc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8005800:	e7cd      	b.n	800579e <TIM_DMACaptureCplt+0x1c>

08005802 <HAL_TIM_IC_CaptureHalfCpltCallback>:
}
 8005802:	4770      	bx	lr

08005804 <TIM_DMACaptureHalfCplt>:
{
 8005804:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8005806:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8005808:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800580a:	4283      	cmp	r3, r0
 800580c:	d00b      	beq.n	8005826 <TIM_DMACaptureHalfCplt+0x22>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 800580e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005810:	4283      	cmp	r3, r0
 8005812:	d010      	beq.n	8005836 <TIM_DMACaptureHalfCplt+0x32>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 8005814:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005816:	4283      	cmp	r3, r0
 8005818:	d010      	beq.n	800583c <TIM_DMACaptureHalfCplt+0x38>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 800581a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800581c:	4283      	cmp	r3, r0
 800581e:	d104      	bne.n	800582a <TIM_DMACaptureHalfCplt+0x26>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8005820:	2308      	movs	r3, #8
 8005822:	7723      	strb	r3, [r4, #28]
 8005824:	e001      	b.n	800582a <TIM_DMACaptureHalfCplt+0x26>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8005826:	2301      	movs	r3, #1
 8005828:	7723      	strb	r3, [r4, #28]
  HAL_TIM_IC_CaptureHalfCpltCallback(htim);
 800582a:	4620      	mov	r0, r4
 800582c:	f7ff ffe9 	bl	8005802 <HAL_TIM_IC_CaptureHalfCpltCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005830:	2300      	movs	r3, #0
 8005832:	7723      	strb	r3, [r4, #28]
}
 8005834:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8005836:	2302      	movs	r3, #2
 8005838:	7723      	strb	r3, [r4, #28]
 800583a:	e7f6      	b.n	800582a <TIM_DMACaptureHalfCplt+0x26>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800583c:	2304      	movs	r3, #4
 800583e:	7723      	strb	r3, [r4, #28]
 8005840:	e7f3      	b.n	800582a <TIM_DMACaptureHalfCplt+0x26>

08005842 <HAL_TIM_PWM_PulseFinishedCallback>:
}
 8005842:	4770      	bx	lr

08005844 <TIM_DMADelayPulseCplt>:
{
 8005844:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8005846:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8005848:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800584a:	4283      	cmp	r3, r0
 800584c:	d00e      	beq.n	800586c <TIM_DMADelayPulseCplt+0x28>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 800584e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005850:	4283      	cmp	r3, r0
 8005852:	d014      	beq.n	800587e <TIM_DMADelayPulseCplt+0x3a>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 8005854:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005856:	4283      	cmp	r3, r0
 8005858:	d01a      	beq.n	8005890 <TIM_DMADelayPulseCplt+0x4c>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 800585a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800585c:	4283      	cmp	r3, r0
 800585e:	d020      	beq.n	80058a2 <TIM_DMADelayPulseCplt+0x5e>
  HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005860:	4620      	mov	r0, r4
 8005862:	f7ff ffee 	bl	8005842 <HAL_TIM_PWM_PulseFinishedCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005866:	2300      	movs	r3, #0
 8005868:	7723      	strb	r3, [r4, #28]
}
 800586a:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800586c:	2301      	movs	r3, #1
 800586e:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 8005870:	6983      	ldr	r3, [r0, #24]
 8005872:	2b00      	cmp	r3, #0
 8005874:	d1f4      	bne.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8005876:	2301      	movs	r3, #1
 8005878:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 800587c:	e7f0      	b.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800587e:	2302      	movs	r3, #2
 8005880:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 8005882:	6983      	ldr	r3, [r0, #24]
 8005884:	2b00      	cmp	r3, #0
 8005886:	d1eb      	bne.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8005888:	2301      	movs	r3, #1
 800588a:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 800588e:	e7e7      	b.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8005890:	2304      	movs	r3, #4
 8005892:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 8005894:	6983      	ldr	r3, [r0, #24]
 8005896:	2b00      	cmp	r3, #0
 8005898:	d1e2      	bne.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
 800589a:	2301      	movs	r3, #1
 800589c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80058a0:	e7de      	b.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80058a2:	2308      	movs	r3, #8
 80058a4:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80058a6:	6983      	ldr	r3, [r0, #24]
 80058a8:	2b00      	cmp	r3, #0
 80058aa:	d1d9      	bne.n	8005860 <TIM_DMADelayPulseCplt+0x1c>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
 80058ac:	2301      	movs	r3, #1
 80058ae:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80058b2:	e7d5      	b.n	8005860 <TIM_DMADelayPulseCplt+0x1c>

080058b4 <HAL_TIM_PWM_PulseFinishedHalfCpltCallback>:
}
 80058b4:	4770      	bx	lr

080058b6 <TIM_DMADelayPulseHalfCplt>:
{
 80058b6:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80058b8:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 80058ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80058bc:	4283      	cmp	r3, r0
 80058be:	d00b      	beq.n	80058d8 <TIM_DMADelayPulseHalfCplt+0x22>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 80058c0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80058c2:	4283      	cmp	r3, r0
 80058c4:	d010      	beq.n	80058e8 <TIM_DMADelayPulseHalfCplt+0x32>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 80058c6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80058c8:	4283      	cmp	r3, r0
 80058ca:	d010      	beq.n	80058ee <TIM_DMADelayPulseHalfCplt+0x38>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 80058cc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80058ce:	4283      	cmp	r3, r0
 80058d0:	d104      	bne.n	80058dc <TIM_DMADelayPulseHalfCplt+0x26>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80058d2:	2308      	movs	r3, #8
 80058d4:	7723      	strb	r3, [r4, #28]
 80058d6:	e001      	b.n	80058dc <TIM_DMADelayPulseHalfCplt+0x26>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80058d8:	2301      	movs	r3, #1
 80058da:	7723      	strb	r3, [r4, #28]
  HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
 80058dc:	4620      	mov	r0, r4
 80058de:	f7ff ffe9 	bl	80058b4 <HAL_TIM_PWM_PulseFinishedHalfCpltCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80058e2:	2300      	movs	r3, #0
 80058e4:	7723      	strb	r3, [r4, #28]
}
 80058e6:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80058e8:	2302      	movs	r3, #2
 80058ea:	7723      	strb	r3, [r4, #28]
 80058ec:	e7f6      	b.n	80058dc <TIM_DMADelayPulseHalfCplt+0x26>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80058ee:	2304      	movs	r3, #4
 80058f0:	7723      	strb	r3, [r4, #28]
 80058f2:	e7f3      	b.n	80058dc <TIM_DMADelayPulseHalfCplt+0x26>

080058f4 <HAL_TIM_TriggerCallback>:
}
 80058f4:	4770      	bx	lr

080058f6 <HAL_TIM_IRQHandler>:
{
 80058f6:	b510      	push	{r4, lr}
 80058f8:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80058fa:	6803      	ldr	r3, [r0, #0]
 80058fc:	691a      	ldr	r2, [r3, #16]
 80058fe:	f012 0f02 	tst.w	r2, #2
 8005902:	d011      	beq.n	8005928 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8005904:	68da      	ldr	r2, [r3, #12]
 8005906:	f012 0f02 	tst.w	r2, #2
 800590a:	d00d      	beq.n	8005928 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800590c:	f06f 0202 	mvn.w	r2, #2
 8005910:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8005912:	2301      	movs	r3, #1
 8005914:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8005916:	6803      	ldr	r3, [r0, #0]
 8005918:	699b      	ldr	r3, [r3, #24]
 800591a:	f013 0f03 	tst.w	r3, #3
 800591e:	d070      	beq.n	8005a02 <HAL_TIM_IRQHandler+0x10c>
          HAL_TIM_IC_CaptureCallback(htim);
 8005920:	f7ff ff2e 	bl	8005780 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005924:	2300      	movs	r3, #0
 8005926:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8005928:	6823      	ldr	r3, [r4, #0]
 800592a:	691a      	ldr	r2, [r3, #16]
 800592c:	f012 0f04 	tst.w	r2, #4
 8005930:	d012      	beq.n	8005958 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8005932:	68da      	ldr	r2, [r3, #12]
 8005934:	f012 0f04 	tst.w	r2, #4
 8005938:	d00e      	beq.n	8005958 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800593a:	f06f 0204 	mvn.w	r2, #4
 800593e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8005940:	2302      	movs	r3, #2
 8005942:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8005944:	6823      	ldr	r3, [r4, #0]
 8005946:	699b      	ldr	r3, [r3, #24]
 8005948:	f413 7f40 	tst.w	r3, #768	; 0x300
 800594c:	d05f      	beq.n	8005a0e <HAL_TIM_IRQHandler+0x118>
        HAL_TIM_IC_CaptureCallback(htim);
 800594e:	4620      	mov	r0, r4
 8005950:	f7ff ff16 	bl	8005780 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005954:	2300      	movs	r3, #0
 8005956:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8005958:	6823      	ldr	r3, [r4, #0]
 800595a:	691a      	ldr	r2, [r3, #16]
 800595c:	f012 0f08 	tst.w	r2, #8
 8005960:	d012      	beq.n	8005988 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8005962:	68da      	ldr	r2, [r3, #12]
 8005964:	f012 0f08 	tst.w	r2, #8
 8005968:	d00e      	beq.n	8005988 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800596a:	f06f 0208 	mvn.w	r2, #8
 800596e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8005970:	2304      	movs	r3, #4
 8005972:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8005974:	6823      	ldr	r3, [r4, #0]
 8005976:	69db      	ldr	r3, [r3, #28]
 8005978:	f013 0f03 	tst.w	r3, #3
 800597c:	d04e      	beq.n	8005a1c <HAL_TIM_IRQHandler+0x126>
        HAL_TIM_IC_CaptureCallback(htim);
 800597e:	4620      	mov	r0, r4
 8005980:	f7ff fefe 	bl	8005780 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005984:	2300      	movs	r3, #0
 8005986:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8005988:	6823      	ldr	r3, [r4, #0]
 800598a:	691a      	ldr	r2, [r3, #16]
 800598c:	f012 0f10 	tst.w	r2, #16
 8005990:	d012      	beq.n	80059b8 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8005992:	68da      	ldr	r2, [r3, #12]
 8005994:	f012 0f10 	tst.w	r2, #16
 8005998:	d00e      	beq.n	80059b8 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800599a:	f06f 0210 	mvn.w	r2, #16
 800599e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80059a0:	2308      	movs	r3, #8
 80059a2:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80059a4:	6823      	ldr	r3, [r4, #0]
 80059a6:	69db      	ldr	r3, [r3, #28]
 80059a8:	f413 7f40 	tst.w	r3, #768	; 0x300
 80059ac:	d03d      	beq.n	8005a2a <HAL_TIM_IRQHandler+0x134>
        HAL_TIM_IC_CaptureCallback(htim);
 80059ae:	4620      	mov	r0, r4
 80059b0:	f7ff fee6 	bl	8005780 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80059b4:	2300      	movs	r3, #0
 80059b6:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 80059b8:	6823      	ldr	r3, [r4, #0]
 80059ba:	691a      	ldr	r2, [r3, #16]
 80059bc:	f012 0f01 	tst.w	r2, #1
 80059c0:	d003      	beq.n	80059ca <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 80059c2:	68da      	ldr	r2, [r3, #12]
 80059c4:	f012 0f01 	tst.w	r2, #1
 80059c8:	d136      	bne.n	8005a38 <HAL_TIM_IRQHandler+0x142>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80059ca:	6823      	ldr	r3, [r4, #0]
 80059cc:	691a      	ldr	r2, [r3, #16]
 80059ce:	f012 0f80 	tst.w	r2, #128	; 0x80
 80059d2:	d003      	beq.n	80059dc <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80059d4:	68da      	ldr	r2, [r3, #12]
 80059d6:	f012 0f80 	tst.w	r2, #128	; 0x80
 80059da:	d134      	bne.n	8005a46 <HAL_TIM_IRQHandler+0x150>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80059dc:	6823      	ldr	r3, [r4, #0]
 80059de:	691a      	ldr	r2, [r3, #16]
 80059e0:	f012 0f40 	tst.w	r2, #64	; 0x40
 80059e4:	d003      	beq.n	80059ee <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80059e6:	68da      	ldr	r2, [r3, #12]
 80059e8:	f012 0f40 	tst.w	r2, #64	; 0x40
 80059ec:	d132      	bne.n	8005a54 <HAL_TIM_IRQHandler+0x15e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80059ee:	6823      	ldr	r3, [r4, #0]
 80059f0:	691a      	ldr	r2, [r3, #16]
 80059f2:	f012 0f20 	tst.w	r2, #32
 80059f6:	d003      	beq.n	8005a00 <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80059f8:	68da      	ldr	r2, [r3, #12]
 80059fa:	f012 0f20 	tst.w	r2, #32
 80059fe:	d130      	bne.n	8005a62 <HAL_TIM_IRQHandler+0x16c>
}
 8005a00:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a02:	f7ff febc 	bl	800577e <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a06:	4620      	mov	r0, r4
 8005a08:	f7ff ff1b 	bl	8005842 <HAL_TIM_PWM_PulseFinishedCallback>
 8005a0c:	e78a      	b.n	8005924 <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a0e:	4620      	mov	r0, r4
 8005a10:	f7ff feb5 	bl	800577e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a14:	4620      	mov	r0, r4
 8005a16:	f7ff ff14 	bl	8005842 <HAL_TIM_PWM_PulseFinishedCallback>
 8005a1a:	e79b      	b.n	8005954 <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a1c:	4620      	mov	r0, r4
 8005a1e:	f7ff feae 	bl	800577e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a22:	4620      	mov	r0, r4
 8005a24:	f7ff ff0d 	bl	8005842 <HAL_TIM_PWM_PulseFinishedCallback>
 8005a28:	e7ac      	b.n	8005984 <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a2a:	4620      	mov	r0, r4
 8005a2c:	f7ff fea7 	bl	800577e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a30:	4620      	mov	r0, r4
 8005a32:	f7ff ff06 	bl	8005842 <HAL_TIM_PWM_PulseFinishedCallback>
 8005a36:	e7bd      	b.n	80059b4 <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8005a38:	f06f 0201 	mvn.w	r2, #1
 8005a3c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8005a3e:	4620      	mov	r0, r4
 8005a40:	f7fa fde0 	bl	8000604 <HAL_TIM_PeriodElapsedCallback>
 8005a44:	e7c1      	b.n	80059ca <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8005a46:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8005a4a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8005a4c:	4620      	mov	r0, r4
 8005a4e:	f003 fdbe 	bl	80095ce <HAL_TIMEx_BreakCallback>
 8005a52:	e7c3      	b.n	80059dc <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8005a54:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8005a58:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8005a5a:	4620      	mov	r0, r4
 8005a5c:	f7ff ff4a 	bl	80058f4 <HAL_TIM_TriggerCallback>
 8005a60:	e7c5      	b.n	80059ee <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8005a62:	f06f 0220 	mvn.w	r2, #32
 8005a66:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8005a68:	4620      	mov	r0, r4
 8005a6a:	f003 fd9e 	bl	80095aa <HAL_TIMEx_CommutCallback>
}
 8005a6e:	e7c7      	b.n	8005a00 <HAL_TIM_IRQHandler+0x10a>

08005a70 <TIM_DMATriggerCplt>:
{
 8005a70:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8005a72:	6a40      	ldr	r0, [r0, #36]	; 0x24
  if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)
 8005a74:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8005a76:	699b      	ldr	r3, [r3, #24]
 8005a78:	b913      	cbnz	r3, 8005a80 <TIM_DMATriggerCplt+0x10>
    htim->State = HAL_TIM_STATE_READY;
 8005a7a:	2301      	movs	r3, #1
 8005a7c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  HAL_TIM_TriggerCallback(htim);
 8005a80:	f7ff ff38 	bl	80058f4 <HAL_TIM_TriggerCallback>
}
 8005a84:	bd08      	pop	{r3, pc}

08005a86 <HAL_TIM_TriggerHalfCpltCallback>:
}
 8005a86:	4770      	bx	lr

08005a88 <TIM_DMATriggerHalfCplt>:
{
 8005a88:	b508      	push	{r3, lr}
  HAL_TIM_TriggerHalfCpltCallback(htim);
 8005a8a:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8005a8c:	f7ff fffb 	bl	8005a86 <HAL_TIM_TriggerHalfCpltCallback>
}
 8005a90:	bd08      	pop	{r3, pc}

08005a92 <HAL_TIM_ErrorCallback>:
}
 8005a92:	4770      	bx	lr

08005a94 <TIM_DMAError>:
{
 8005a94:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8005a96:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8005a98:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005a9a:	4283      	cmp	r3, r0
 8005a9c:	d00c      	beq.n	8005ab8 <TIM_DMAError+0x24>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 8005a9e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005aa0:	4283      	cmp	r3, r0
 8005aa2:	d013      	beq.n	8005acc <TIM_DMAError+0x38>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 8005aa4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005aa6:	4283      	cmp	r3, r0
 8005aa8:	d016      	beq.n	8005ad8 <TIM_DMAError+0x44>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 8005aaa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005aac:	4283      	cmp	r3, r0
 8005aae:	d019      	beq.n	8005ae4 <TIM_DMAError+0x50>
    htim->State = HAL_TIM_STATE_READY;
 8005ab0:	2301      	movs	r3, #1
 8005ab2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 8005ab6:	e003      	b.n	8005ac0 <TIM_DMAError+0x2c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8005ab8:	2301      	movs	r3, #1
 8005aba:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8005abc:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  HAL_TIM_ErrorCallback(htim);
 8005ac0:	4620      	mov	r0, r4
 8005ac2:	f7ff ffe6 	bl	8005a92 <HAL_TIM_ErrorCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005ac6:	2300      	movs	r3, #0
 8005ac8:	7723      	strb	r3, [r4, #28]
}
 8005aca:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8005acc:	2302      	movs	r3, #2
 8005ace:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8005ad0:	2301      	movs	r3, #1
 8005ad2:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8005ad6:	e7f3      	b.n	8005ac0 <TIM_DMAError+0x2c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8005ad8:	2304      	movs	r3, #4
 8005ada:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
 8005adc:	2301      	movs	r3, #1
 8005ade:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8005ae2:	e7ed      	b.n	8005ac0 <TIM_DMAError+0x2c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8005ae4:	2308      	movs	r3, #8
 8005ae6:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
 8005ae8:	2301      	movs	r3, #1
 8005aea:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8005aee:	e7e7      	b.n	8005ac0 <TIM_DMAError+0x2c>

08005af0 <HAL_TIM_Base_GetState>:
  return htim->State;
 8005af0:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8005af4:	4770      	bx	lr

08005af6 <HAL_TIM_OC_GetState>:
  return htim->State;
 8005af6:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8005afa:	4770      	bx	lr

08005afc <HAL_TIM_PWM_GetState>:
  return htim->State;
 8005afc:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8005b00:	4770      	bx	lr

08005b02 <HAL_TIM_IC_GetState>:
  return htim->State;
 8005b02:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8005b06:	4770      	bx	lr

08005b08 <HAL_TIM_OnePulse_GetState>:
  return htim->State;
 8005b08:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8005b0c:	4770      	bx	lr

08005b0e <HAL_TIM_Encoder_GetState>:
  return htim->State;
 8005b0e:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8005b12:	4770      	bx	lr

08005b14 <HAL_TIM_GetActiveChannel>:
}
 8005b14:	7f00      	ldrb	r0, [r0, #28]
 8005b16:	4770      	bx	lr

08005b18 <HAL_TIM_GetChannelState>:
  channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8005b18:	b919      	cbnz	r1, 8005b22 <HAL_TIM_GetChannelState+0xa>
 8005b1a:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8005b1e:	b2c0      	uxtb	r0, r0
 8005b20:	4770      	bx	lr
 8005b22:	2904      	cmp	r1, #4
 8005b24:	d005      	beq.n	8005b32 <HAL_TIM_GetChannelState+0x1a>
 8005b26:	2908      	cmp	r1, #8
 8005b28:	d007      	beq.n	8005b3a <HAL_TIM_GetChannelState+0x22>
 8005b2a:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
 8005b2e:	b2c0      	uxtb	r0, r0
}
 8005b30:	4770      	bx	lr
  channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8005b32:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 8005b36:	b2c0      	uxtb	r0, r0
 8005b38:	4770      	bx	lr
 8005b3a:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
 8005b3e:	b2c0      	uxtb	r0, r0
 8005b40:	4770      	bx	lr

08005b42 <HAL_TIM_DMABurstState>:
  return htim->DMABurstState;
 8005b42:	f890 0046 	ldrb.w	r0, [r0, #70]	; 0x46
}
 8005b46:	4770      	bx	lr

08005b48 <TIM_Base_SetConfig>:
  tmpcr1 = TIMx->CR1;
 8005b48:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005b4a:	4a1b      	ldr	r2, [pc, #108]	; (8005bb8 <TIM_Base_SetConfig+0x70>)
 8005b4c:	4290      	cmp	r0, r2
 8005b4e:	d00a      	beq.n	8005b66 <TIM_Base_SetConfig+0x1e>
 8005b50:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8005b54:	d007      	beq.n	8005b66 <TIM_Base_SetConfig+0x1e>
 8005b56:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8005b5a:	4290      	cmp	r0, r2
 8005b5c:	d003      	beq.n	8005b66 <TIM_Base_SetConfig+0x1e>
 8005b5e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005b62:	4290      	cmp	r0, r2
 8005b64:	d103      	bne.n	8005b6e <TIM_Base_SetConfig+0x26>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005b66:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8005b6a:	684a      	ldr	r2, [r1, #4]
 8005b6c:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8005b6e:	4a12      	ldr	r2, [pc, #72]	; (8005bb8 <TIM_Base_SetConfig+0x70>)
 8005b70:	4290      	cmp	r0, r2
 8005b72:	d00a      	beq.n	8005b8a <TIM_Base_SetConfig+0x42>
 8005b74:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8005b78:	d007      	beq.n	8005b8a <TIM_Base_SetConfig+0x42>
 8005b7a:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8005b7e:	4290      	cmp	r0, r2
 8005b80:	d003      	beq.n	8005b8a <TIM_Base_SetConfig+0x42>
 8005b82:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005b86:	4290      	cmp	r0, r2
 8005b88:	d103      	bne.n	8005b92 <TIM_Base_SetConfig+0x4a>
    tmpcr1 &= ~TIM_CR1_CKD;
 8005b8a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8005b8e:	68ca      	ldr	r2, [r1, #12]
 8005b90:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8005b92:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005b96:	694a      	ldr	r2, [r1, #20]
 8005b98:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8005b9a:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005b9c:	688b      	ldr	r3, [r1, #8]
 8005b9e:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8005ba0:	680b      	ldr	r3, [r1, #0]
 8005ba2:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8005ba4:	4b04      	ldr	r3, [pc, #16]	; (8005bb8 <TIM_Base_SetConfig+0x70>)
 8005ba6:	4298      	cmp	r0, r3
 8005ba8:	d002      	beq.n	8005bb0 <TIM_Base_SetConfig+0x68>
  TIMx->EGR = TIM_EGR_UG;
 8005baa:	2301      	movs	r3, #1
 8005bac:	6143      	str	r3, [r0, #20]
}
 8005bae:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
 8005bb0:	690b      	ldr	r3, [r1, #16]
 8005bb2:	6303      	str	r3, [r0, #48]	; 0x30
 8005bb4:	e7f9      	b.n	8005baa <TIM_Base_SetConfig+0x62>
 8005bb6:	bf00      	nop
 8005bb8:	40012c00 	.word	0x40012c00

08005bbc <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8005bbc:	b340      	cbz	r0, 8005c10 <HAL_TIM_Base_Init+0x54>
{
 8005bbe:	b510      	push	{r4, lr}
 8005bc0:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8005bc2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8005bc6:	b1f3      	cbz	r3, 8005c06 <HAL_TIM_Base_Init+0x4a>
  htim->State = HAL_TIM_STATE_BUSY;
 8005bc8:	2302      	movs	r3, #2
 8005bca:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005bce:	4621      	mov	r1, r4
 8005bd0:	f851 0b04 	ldr.w	r0, [r1], #4
 8005bd4:	f7ff ffb8 	bl	8005b48 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005bd8:	2301      	movs	r3, #1
 8005bda:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005bde:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8005be2:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8005be6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8005bea:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005bee:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8005bf2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8005bf6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8005bfa:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8005bfe:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8005c02:	2000      	movs	r0, #0
}
 8005c04:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8005c06:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8005c0a:	f7fb feb5 	bl	8001978 <HAL_TIM_Base_MspInit>
 8005c0e:	e7db      	b.n	8005bc8 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8005c10:	2001      	movs	r0, #1
}
 8005c12:	4770      	bx	lr

08005c14 <HAL_TIM_OC_Init>:
  if (htim == NULL)
 8005c14:	b340      	cbz	r0, 8005c68 <HAL_TIM_OC_Init+0x54>
{
 8005c16:	b510      	push	{r4, lr}
 8005c18:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8005c1a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8005c1e:	b1f3      	cbz	r3, 8005c5e <HAL_TIM_OC_Init+0x4a>
  htim->State = HAL_TIM_STATE_BUSY;
 8005c20:	2302      	movs	r3, #2
 8005c22:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8005c26:	4621      	mov	r1, r4
 8005c28:	f851 0b04 	ldr.w	r0, [r1], #4
 8005c2c:	f7ff ff8c 	bl	8005b48 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005c30:	2301      	movs	r3, #1
 8005c32:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005c36:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8005c3a:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8005c3e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8005c42:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005c46:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8005c4a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8005c4e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8005c52:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8005c56:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8005c5a:	2000      	movs	r0, #0
}
 8005c5c:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8005c5e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_OC_MspInit(htim);
 8005c62:	f7ff fa31 	bl	80050c8 <HAL_TIM_OC_MspInit>
 8005c66:	e7db      	b.n	8005c20 <HAL_TIM_OC_Init+0xc>
    return HAL_ERROR;
 8005c68:	2001      	movs	r0, #1
}
 8005c6a:	4770      	bx	lr

08005c6c <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8005c6c:	b340      	cbz	r0, 8005cc0 <HAL_TIM_PWM_Init+0x54>
{
 8005c6e:	b510      	push	{r4, lr}
 8005c70:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8005c72:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8005c76:	b1f3      	cbz	r3, 8005cb6 <HAL_TIM_PWM_Init+0x4a>
  htim->State = HAL_TIM_STATE_BUSY;
 8005c78:	2302      	movs	r3, #2
 8005c7a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005c7e:	4621      	mov	r1, r4
 8005c80:	f851 0b04 	ldr.w	r0, [r1], #4
 8005c84:	f7ff ff60 	bl	8005b48 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005c88:	2301      	movs	r3, #1
 8005c8a:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005c8e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8005c92:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8005c96:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8005c9a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005c9e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8005ca2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8005ca6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8005caa:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8005cae:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8005cb2:	2000      	movs	r0, #0
}
 8005cb4:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8005cb6:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8005cba:	f7ff fa36 	bl	800512a <HAL_TIM_PWM_MspInit>
 8005cbe:	e7db      	b.n	8005c78 <HAL_TIM_PWM_Init+0xc>
    return HAL_ERROR;
 8005cc0:	2001      	movs	r0, #1
}
 8005cc2:	4770      	bx	lr

08005cc4 <HAL_TIM_IC_Init>:
  if (htim == NULL)
 8005cc4:	b340      	cbz	r0, 8005d18 <HAL_TIM_IC_Init+0x54>
{
 8005cc6:	b510      	push	{r4, lr}
 8005cc8:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8005cca:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8005cce:	b1f3      	cbz	r3, 8005d0e <HAL_TIM_IC_Init+0x4a>
  htim->State = HAL_TIM_STATE_BUSY;
 8005cd0:	2302      	movs	r3, #2
 8005cd2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005cd6:	4621      	mov	r1, r4
 8005cd8:	f851 0b04 	ldr.w	r0, [r1], #4
 8005cdc:	f7ff ff34 	bl	8005b48 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005ce0:	2301      	movs	r3, #1
 8005ce2:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005ce6:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8005cea:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8005cee:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8005cf2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005cf6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8005cfa:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8005cfe:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8005d02:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8005d06:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8005d0a:	2000      	movs	r0, #0
}
 8005d0c:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8005d0e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_IC_MspInit(htim);
 8005d12:	f7ff fa3b 	bl	800518c <HAL_TIM_IC_MspInit>
 8005d16:	e7db      	b.n	8005cd0 <HAL_TIM_IC_Init+0xc>
    return HAL_ERROR;
 8005d18:	2001      	movs	r0, #1
}
 8005d1a:	4770      	bx	lr

08005d1c <HAL_TIM_OnePulse_Init>:
  if (htim == NULL)
 8005d1c:	b350      	cbz	r0, 8005d74 <HAL_TIM_OnePulse_Init+0x58>
{
 8005d1e:	b538      	push	{r3, r4, r5, lr}
 8005d20:	460d      	mov	r5, r1
 8005d22:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8005d24:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8005d28:	b1fb      	cbz	r3, 8005d6a <HAL_TIM_OnePulse_Init+0x4e>
  htim->State = HAL_TIM_STATE_BUSY;
 8005d2a:	2302      	movs	r3, #2
 8005d2c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005d30:	4621      	mov	r1, r4
 8005d32:	f851 0b04 	ldr.w	r0, [r1], #4
 8005d36:	f7ff ff07 	bl	8005b48 <TIM_Base_SetConfig>
  htim->Instance->CR1 &= ~TIM_CR1_OPM;
 8005d3a:	6822      	ldr	r2, [r4, #0]
 8005d3c:	6813      	ldr	r3, [r2, #0]
 8005d3e:	f023 0308 	bic.w	r3, r3, #8
 8005d42:	6013      	str	r3, [r2, #0]
  htim->Instance->CR1 |= OnePulseMode;
 8005d44:	6823      	ldr	r3, [r4, #0]
 8005d46:	6819      	ldr	r1, [r3, #0]
 8005d48:	430d      	orrs	r5, r1
 8005d4a:	601d      	str	r5, [r3, #0]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005d4c:	2301      	movs	r3, #1
 8005d4e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8005d52:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8005d56:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8005d5a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8005d5e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  htim->State = HAL_TIM_STATE_READY;
 8005d62:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8005d66:	2000      	movs	r0, #0
}
 8005d68:	bd38      	pop	{r3, r4, r5, pc}
    htim->Lock = HAL_UNLOCKED;
 8005d6a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_OnePulse_MspInit(htim);
 8005d6e:	f7ff fa3e 	bl	80051ee <HAL_TIM_OnePulse_MspInit>
 8005d72:	e7da      	b.n	8005d2a <HAL_TIM_OnePulse_Init+0xe>
    return HAL_ERROR;
 8005d74:	2001      	movs	r0, #1
}
 8005d76:	4770      	bx	lr

08005d78 <HAL_TIM_Encoder_Init>:
  if (htim == NULL)
 8005d78:	2800      	cmp	r0, #0
 8005d7a:	d053      	beq.n	8005e24 <HAL_TIM_Encoder_Init+0xac>
{
 8005d7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005d7e:	460d      	mov	r5, r1
 8005d80:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8005d82:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8005d86:	2b00      	cmp	r3, #0
 8005d88:	d047      	beq.n	8005e1a <HAL_TIM_Encoder_Init+0xa2>
  htim->State = HAL_TIM_STATE_BUSY;
 8005d8a:	2302      	movs	r3, #2
 8005d8c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 8005d90:	6822      	ldr	r2, [r4, #0]
 8005d92:	6893      	ldr	r3, [r2, #8]
 8005d94:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005d98:	f023 0307 	bic.w	r3, r3, #7
 8005d9c:	6093      	str	r3, [r2, #8]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005d9e:	4621      	mov	r1, r4
 8005da0:	f851 0b04 	ldr.w	r0, [r1], #4
 8005da4:	f7ff fed0 	bl	8005b48 <TIM_Base_SetConfig>
  tmpsmcr = htim->Instance->SMCR;
 8005da8:	6821      	ldr	r1, [r4, #0]
 8005daa:	688a      	ldr	r2, [r1, #8]
  tmpccmr1 = htim->Instance->CCMR1;
 8005dac:	698e      	ldr	r6, [r1, #24]
  tmpccer = htim->Instance->CCER;
 8005dae:	6a0f      	ldr	r7, [r1, #32]
  tmpsmcr |= sConfig->EncoderMode;
 8005db0:	6828      	ldr	r0, [r5, #0]
 8005db2:	4310      	orrs	r0, r2
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 8005db4:	f426 7640 	bic.w	r6, r6, #768	; 0x300
 8005db8:	f026 0603 	bic.w	r6, r6, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8005dbc:	68aa      	ldr	r2, [r5, #8]
 8005dbe:	69ab      	ldr	r3, [r5, #24]
 8005dc0:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8005dc4:	4333      	orrs	r3, r6
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 8005dc6:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
 8005dca:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
 8005dce:	68ee      	ldr	r6, [r5, #12]
 8005dd0:	69ea      	ldr	r2, [r5, #28]
 8005dd2:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
 8005dd6:	431e      	orrs	r6, r3
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8005dd8:	6a2a      	ldr	r2, [r5, #32]
 8005dda:	0313      	lsls	r3, r2, #12
 8005ddc:	692a      	ldr	r2, [r5, #16]
 8005dde:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8005de2:	4333      	orrs	r3, r6
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
 8005de4:	f027 0722 	bic.w	r7, r7, #34	; 0x22
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8005de8:	686a      	ldr	r2, [r5, #4]
 8005dea:	696d      	ldr	r5, [r5, #20]
 8005dec:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
 8005df0:	433a      	orrs	r2, r7
  htim->Instance->SMCR = tmpsmcr;
 8005df2:	6088      	str	r0, [r1, #8]
  htim->Instance->CCMR1 = tmpccmr1;
 8005df4:	6821      	ldr	r1, [r4, #0]
 8005df6:	618b      	str	r3, [r1, #24]
  htim->Instance->CCER = tmpccer;
 8005df8:	6823      	ldr	r3, [r4, #0]
 8005dfa:	621a      	str	r2, [r3, #32]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005dfc:	2301      	movs	r3, #1
 8005dfe:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8005e02:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8005e06:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8005e0a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8005e0e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  htim->State = HAL_TIM_STATE_READY;
 8005e12:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8005e16:	2000      	movs	r0, #0
}
 8005e18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    htim->Lock = HAL_UNLOCKED;
 8005e1a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Encoder_MspInit(htim);
 8005e1e:	f7ff fa0f 	bl	8005240 <HAL_TIM_Encoder_MspInit>
 8005e22:	e7b2      	b.n	8005d8a <HAL_TIM_Encoder_Init+0x12>
    return HAL_ERROR;
 8005e24:	2001      	movs	r0, #1
}
 8005e26:	4770      	bx	lr

08005e28 <TIM_OC2_SetConfig>:
{
 8005e28:	b430      	push	{r4, r5}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8005e2a:	6a03      	ldr	r3, [r0, #32]
 8005e2c:	f023 0310 	bic.w	r3, r3, #16
 8005e30:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8005e32:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8005e34:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8005e36:	6982      	ldr	r2, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8005e38:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8005e3c:	680d      	ldr	r5, [r1, #0]
 8005e3e:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer &= ~TIM_CCER_CC2P;
 8005e42:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8005e46:	688d      	ldr	r5, [r1, #8]
 8005e48:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8005e4c:	4d0e      	ldr	r5, [pc, #56]	; (8005e88 <TIM_OC2_SetConfig+0x60>)
 8005e4e:	42a8      	cmp	r0, r5
 8005e50:	d009      	beq.n	8005e66 <TIM_OC2_SetConfig+0x3e>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8005e52:	4d0d      	ldr	r5, [pc, #52]	; (8005e88 <TIM_OC2_SetConfig+0x60>)
 8005e54:	42a8      	cmp	r0, r5
 8005e56:	d00e      	beq.n	8005e76 <TIM_OC2_SetConfig+0x4e>
  TIMx->CR2 = tmpcr2;
 8005e58:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8005e5a:	6182      	str	r2, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8005e5c:	684a      	ldr	r2, [r1, #4]
 8005e5e:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8005e60:	6203      	str	r3, [r0, #32]
}
 8005e62:	bc30      	pop	{r4, r5}
 8005e64:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC2NP;
 8005e66:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8005e6a:	68cd      	ldr	r5, [r1, #12]
 8005e6c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8005e70:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005e74:	e7ed      	b.n	8005e52 <TIM_OC2_SetConfig+0x2a>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8005e76:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8005e7a:	694d      	ldr	r5, [r1, #20]
 8005e7c:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8005e80:	698d      	ldr	r5, [r1, #24]
 8005e82:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
 8005e86:	e7e7      	b.n	8005e58 <TIM_OC2_SetConfig+0x30>
 8005e88:	40012c00 	.word	0x40012c00

08005e8c <HAL_TIM_OC_ConfigChannel>:
  __HAL_LOCK(htim);
 8005e8c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8005e90:	2b01      	cmp	r3, #1
 8005e92:	d022      	beq.n	8005eda <HAL_TIM_OC_ConfigChannel+0x4e>
{
 8005e94:	b510      	push	{r4, lr}
 8005e96:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
 8005e98:	2301      	movs	r3, #1
 8005e9a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 8005e9e:	2a0c      	cmp	r2, #12
 8005ea0:	d80b      	bhi.n	8005eba <HAL_TIM_OC_ConfigChannel+0x2e>
 8005ea2:	e8df f002 	tbb	[pc, r2]
 8005ea6:	0a07      	.short	0x0a07
 8005ea8:	0a0e0a0a 	.word	0x0a0e0a0a
 8005eac:	0a120a0a 	.word	0x0a120a0a
 8005eb0:	0a0a      	.short	0x0a0a
 8005eb2:	16          	.byte	0x16
 8005eb3:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8005eb4:	6800      	ldr	r0, [r0, #0]
 8005eb6:	f7fe fed1 	bl	8004c5c <TIM_OC1_SetConfig>
  __HAL_UNLOCK(htim);
 8005eba:	2000      	movs	r0, #0
 8005ebc:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8005ec0:	bd10      	pop	{r4, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8005ec2:	6800      	ldr	r0, [r0, #0]
 8005ec4:	f7ff ffb0 	bl	8005e28 <TIM_OC2_SetConfig>
      break;
 8005ec8:	e7f7      	b.n	8005eba <HAL_TIM_OC_ConfigChannel+0x2e>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8005eca:	6800      	ldr	r0, [r0, #0]
 8005ecc:	f7fe fef4 	bl	8004cb8 <TIM_OC3_SetConfig>
      break;
 8005ed0:	e7f3      	b.n	8005eba <HAL_TIM_OC_ConfigChannel+0x2e>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8005ed2:	6800      	ldr	r0, [r0, #0]
 8005ed4:	f7fe ff22 	bl	8004d1c <TIM_OC4_SetConfig>
      break;
 8005ed8:	e7ef      	b.n	8005eba <HAL_TIM_OC_ConfigChannel+0x2e>
  __HAL_LOCK(htim);
 8005eda:	2002      	movs	r0, #2
}
 8005edc:	4770      	bx	lr

08005ede <HAL_TIM_PWM_ConfigChannel>:
{
 8005ede:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 8005ee0:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8005ee4:	2b01      	cmp	r3, #1
 8005ee6:	d060      	beq.n	8005faa <HAL_TIM_PWM_ConfigChannel+0xcc>
 8005ee8:	4604      	mov	r4, r0
 8005eea:	460d      	mov	r5, r1
 8005eec:	2301      	movs	r3, #1
 8005eee:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 8005ef2:	2a0c      	cmp	r2, #12
 8005ef4:	d81a      	bhi.n	8005f2c <HAL_TIM_PWM_ConfigChannel+0x4e>
 8005ef6:	e8df f002 	tbb	[pc, r2]
 8005efa:	1907      	.short	0x1907
 8005efc:	191d1919 	.word	0x191d1919
 8005f00:	19311919 	.word	0x19311919
 8005f04:	1919      	.short	0x1919
 8005f06:	44          	.byte	0x44
 8005f07:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8005f08:	6800      	ldr	r0, [r0, #0]
 8005f0a:	f7fe fea7 	bl	8004c5c <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8005f0e:	6822      	ldr	r2, [r4, #0]
 8005f10:	6993      	ldr	r3, [r2, #24]
 8005f12:	f043 0308 	orr.w	r3, r3, #8
 8005f16:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8005f18:	6822      	ldr	r2, [r4, #0]
 8005f1a:	6993      	ldr	r3, [r2, #24]
 8005f1c:	f023 0304 	bic.w	r3, r3, #4
 8005f20:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8005f22:	6822      	ldr	r2, [r4, #0]
 8005f24:	6993      	ldr	r3, [r2, #24]
 8005f26:	6929      	ldr	r1, [r5, #16]
 8005f28:	430b      	orrs	r3, r1
 8005f2a:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
 8005f2c:	2000      	movs	r0, #0
 8005f2e:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8005f32:	bd38      	pop	{r3, r4, r5, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8005f34:	6800      	ldr	r0, [r0, #0]
 8005f36:	f7ff ff77 	bl	8005e28 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8005f3a:	6822      	ldr	r2, [r4, #0]
 8005f3c:	6993      	ldr	r3, [r2, #24]
 8005f3e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8005f42:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8005f44:	6822      	ldr	r2, [r4, #0]
 8005f46:	6993      	ldr	r3, [r2, #24]
 8005f48:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005f4c:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8005f4e:	6822      	ldr	r2, [r4, #0]
 8005f50:	6993      	ldr	r3, [r2, #24]
 8005f52:	6929      	ldr	r1, [r5, #16]
 8005f54:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8005f58:	6193      	str	r3, [r2, #24]
      break;
 8005f5a:	e7e7      	b.n	8005f2c <HAL_TIM_PWM_ConfigChannel+0x4e>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8005f5c:	6800      	ldr	r0, [r0, #0]
 8005f5e:	f7fe feab 	bl	8004cb8 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8005f62:	6822      	ldr	r2, [r4, #0]
 8005f64:	69d3      	ldr	r3, [r2, #28]
 8005f66:	f043 0308 	orr.w	r3, r3, #8
 8005f6a:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8005f6c:	6822      	ldr	r2, [r4, #0]
 8005f6e:	69d3      	ldr	r3, [r2, #28]
 8005f70:	f023 0304 	bic.w	r3, r3, #4
 8005f74:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8005f76:	6822      	ldr	r2, [r4, #0]
 8005f78:	69d3      	ldr	r3, [r2, #28]
 8005f7a:	6929      	ldr	r1, [r5, #16]
 8005f7c:	430b      	orrs	r3, r1
 8005f7e:	61d3      	str	r3, [r2, #28]
      break;
 8005f80:	e7d4      	b.n	8005f2c <HAL_TIM_PWM_ConfigChannel+0x4e>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8005f82:	6800      	ldr	r0, [r0, #0]
 8005f84:	f7fe feca 	bl	8004d1c <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8005f88:	6822      	ldr	r2, [r4, #0]
 8005f8a:	69d3      	ldr	r3, [r2, #28]
 8005f8c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8005f90:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8005f92:	6822      	ldr	r2, [r4, #0]
 8005f94:	69d3      	ldr	r3, [r2, #28]
 8005f96:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005f9a:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8005f9c:	6822      	ldr	r2, [r4, #0]
 8005f9e:	69d3      	ldr	r3, [r2, #28]
 8005fa0:	6929      	ldr	r1, [r5, #16]
 8005fa2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8005fa6:	61d3      	str	r3, [r2, #28]
      break;
 8005fa8:	e7c0      	b.n	8005f2c <HAL_TIM_PWM_ConfigChannel+0x4e>
  __HAL_LOCK(htim);
 8005faa:	2002      	movs	r0, #2
 8005fac:	e7c1      	b.n	8005f32 <HAL_TIM_PWM_ConfigChannel+0x54>

08005fae <TIM_TI1_SetConfig>:
{
 8005fae:	b470      	push	{r4, r5, r6}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005fb0:	6a04      	ldr	r4, [r0, #32]
 8005fb2:	f024 0401 	bic.w	r4, r4, #1
 8005fb6:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005fb8:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8005fba:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8005fbc:	4e10      	ldr	r6, [pc, #64]	; (8006000 <TIM_TI1_SetConfig+0x52>)
 8005fbe:	42b0      	cmp	r0, r6
 8005fc0:	d00d      	beq.n	8005fde <TIM_TI1_SetConfig+0x30>
 8005fc2:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8005fc6:	d00a      	beq.n	8005fde <TIM_TI1_SetConfig+0x30>
 8005fc8:	f5a6 3694 	sub.w	r6, r6, #75776	; 0x12800
 8005fcc:	42b0      	cmp	r0, r6
 8005fce:	d006      	beq.n	8005fde <TIM_TI1_SetConfig+0x30>
 8005fd0:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8005fd4:	42b0      	cmp	r0, r6
 8005fd6:	d002      	beq.n	8005fde <TIM_TI1_SetConfig+0x30>
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
 8005fd8:	f044 0201 	orr.w	r2, r4, #1
 8005fdc:	e002      	b.n	8005fe4 <TIM_TI1_SetConfig+0x36>
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
 8005fde:	f024 0403 	bic.w	r4, r4, #3
    tmpccmr1 |= TIM_ICSelection;
 8005fe2:	4322      	orrs	r2, r4
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8005fe4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8005fe8:	011b      	lsls	r3, r3, #4
 8005fea:	b2db      	uxtb	r3, r3
 8005fec:	4313      	orrs	r3, r2
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005fee:	f025 020a 	bic.w	r2, r5, #10
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8005ff2:	f001 010a 	and.w	r1, r1, #10
 8005ff6:	4311      	orrs	r1, r2
  TIMx->CCMR1 = tmpccmr1;
 8005ff8:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8005ffa:	6201      	str	r1, [r0, #32]
}
 8005ffc:	bc70      	pop	{r4, r5, r6}
 8005ffe:	4770      	bx	lr
 8006000:	40012c00 	.word	0x40012c00

08006004 <HAL_TIM_IC_ConfigChannel>:
{
 8006004:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 8006006:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800600a:	2b01      	cmp	r3, #1
 800600c:	d052      	beq.n	80060b4 <HAL_TIM_IC_ConfigChannel+0xb0>
 800600e:	4604      	mov	r4, r0
 8006010:	460d      	mov	r5, r1
 8006012:	2301      	movs	r3, #1
 8006014:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if (Channel == TIM_CHANNEL_1)
 8006018:	b1c2      	cbz	r2, 800604c <HAL_TIM_IC_ConfigChannel+0x48>
  else if (Channel == TIM_CHANNEL_2)
 800601a:	2a04      	cmp	r2, #4
 800601c:	d027      	beq.n	800606e <HAL_TIM_IC_ConfigChannel+0x6a>
  else if (Channel == TIM_CHANNEL_3)
 800601e:	2a08      	cmp	r2, #8
 8006020:	d037      	beq.n	8006092 <HAL_TIM_IC_ConfigChannel+0x8e>
    TIM_TI4_SetConfig(htim->Instance,
 8006022:	68cb      	ldr	r3, [r1, #12]
 8006024:	684a      	ldr	r2, [r1, #4]
 8006026:	6809      	ldr	r1, [r1, #0]
 8006028:	6800      	ldr	r0, [r0, #0]
 800602a:	f7fe fef3 	bl	8004e14 <TIM_TI4_SetConfig>
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
 800602e:	6822      	ldr	r2, [r4, #0]
 8006030:	69d3      	ldr	r3, [r2, #28]
 8006032:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8006036:	61d3      	str	r3, [r2, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8006038:	6822      	ldr	r2, [r4, #0]
 800603a:	69d3      	ldr	r3, [r2, #28]
 800603c:	68a9      	ldr	r1, [r5, #8]
 800603e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8006042:	61d3      	str	r3, [r2, #28]
  __HAL_UNLOCK(htim);
 8006044:	2000      	movs	r0, #0
 8006046:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 800604a:	bd38      	pop	{r3, r4, r5, pc}
    TIM_TI1_SetConfig(htim->Instance,
 800604c:	68cb      	ldr	r3, [r1, #12]
 800604e:	684a      	ldr	r2, [r1, #4]
 8006050:	6809      	ldr	r1, [r1, #0]
 8006052:	6800      	ldr	r0, [r0, #0]
 8006054:	f7ff ffab 	bl	8005fae <TIM_TI1_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8006058:	6822      	ldr	r2, [r4, #0]
 800605a:	6993      	ldr	r3, [r2, #24]
 800605c:	f023 030c 	bic.w	r3, r3, #12
 8006060:	6193      	str	r3, [r2, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 8006062:	6822      	ldr	r2, [r4, #0]
 8006064:	6993      	ldr	r3, [r2, #24]
 8006066:	68a9      	ldr	r1, [r5, #8]
 8006068:	430b      	orrs	r3, r1
 800606a:	6193      	str	r3, [r2, #24]
 800606c:	e7ea      	b.n	8006044 <HAL_TIM_IC_ConfigChannel+0x40>
    TIM_TI2_SetConfig(htim->Instance,
 800606e:	68cb      	ldr	r3, [r1, #12]
 8006070:	684a      	ldr	r2, [r1, #4]
 8006072:	6809      	ldr	r1, [r1, #0]
 8006074:	6800      	ldr	r0, [r0, #0]
 8006076:	f7fe fe87 	bl	8004d88 <TIM_TI2_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 800607a:	6822      	ldr	r2, [r4, #0]
 800607c:	6993      	ldr	r3, [r2, #24]
 800607e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8006082:	6193      	str	r3, [r2, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 8006084:	6822      	ldr	r2, [r4, #0]
 8006086:	6993      	ldr	r3, [r2, #24]
 8006088:	68a9      	ldr	r1, [r5, #8]
 800608a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800608e:	6193      	str	r3, [r2, #24]
 8006090:	e7d8      	b.n	8006044 <HAL_TIM_IC_ConfigChannel+0x40>
    TIM_TI3_SetConfig(htim->Instance,
 8006092:	68cb      	ldr	r3, [r1, #12]
 8006094:	684a      	ldr	r2, [r1, #4]
 8006096:	6809      	ldr	r1, [r1, #0]
 8006098:	6800      	ldr	r0, [r0, #0]
 800609a:	f7fe fea2 	bl	8004de2 <TIM_TI3_SetConfig>
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 800609e:	6822      	ldr	r2, [r4, #0]
 80060a0:	69d3      	ldr	r3, [r2, #28]
 80060a2:	f023 030c 	bic.w	r3, r3, #12
 80060a6:	61d3      	str	r3, [r2, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 80060a8:	6822      	ldr	r2, [r4, #0]
 80060aa:	69d3      	ldr	r3, [r2, #28]
 80060ac:	68a9      	ldr	r1, [r5, #8]
 80060ae:	430b      	orrs	r3, r1
 80060b0:	61d3      	str	r3, [r2, #28]
 80060b2:	e7c7      	b.n	8006044 <HAL_TIM_IC_ConfigChannel+0x40>
  __HAL_LOCK(htim);
 80060b4:	2002      	movs	r0, #2
 80060b6:	e7c8      	b.n	800604a <HAL_TIM_IC_ConfigChannel+0x46>

080060b8 <HAL_TIM_OnePulse_ConfigChannel>:
  if (OutputChannel != InputChannel)
 80060b8:	429a      	cmp	r2, r3
 80060ba:	d072      	beq.n	80061a2 <HAL_TIM_OnePulse_ConfigChannel+0xea>
{
 80060bc:	b570      	push	{r4, r5, r6, lr}
 80060be:	b088      	sub	sp, #32
 80060c0:	4604      	mov	r4, r0
 80060c2:	460d      	mov	r5, r1
 80060c4:	461e      	mov	r6, r3
    __HAL_LOCK(htim);
 80060c6:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80060ca:	2b01      	cmp	r3, #1
 80060cc:	d06b      	beq.n	80061a6 <HAL_TIM_OnePulse_ConfigChannel+0xee>
 80060ce:	2301      	movs	r3, #1
 80060d0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    htim->State = HAL_TIM_STATE_BUSY;
 80060d4:	2302      	movs	r3, #2
 80060d6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    temp1.OCMode = sConfig->OCMode;
 80060da:	680b      	ldr	r3, [r1, #0]
 80060dc:	9301      	str	r3, [sp, #4]
    temp1.Pulse = sConfig->Pulse;
 80060de:	684b      	ldr	r3, [r1, #4]
 80060e0:	9302      	str	r3, [sp, #8]
    temp1.OCPolarity = sConfig->OCPolarity;
 80060e2:	688b      	ldr	r3, [r1, #8]
 80060e4:	9303      	str	r3, [sp, #12]
    temp1.OCNPolarity = sConfig->OCNPolarity;
 80060e6:	68cb      	ldr	r3, [r1, #12]
 80060e8:	9304      	str	r3, [sp, #16]
    temp1.OCIdleState = sConfig->OCIdleState;
 80060ea:	690b      	ldr	r3, [r1, #16]
 80060ec:	9306      	str	r3, [sp, #24]
    temp1.OCNIdleState = sConfig->OCNIdleState;
 80060ee:	694b      	ldr	r3, [r1, #20]
 80060f0:	9307      	str	r3, [sp, #28]
    switch (OutputChannel)
 80060f2:	b162      	cbz	r2, 800610e <HAL_TIM_OnePulse_ConfigChannel+0x56>
 80060f4:	2a04      	cmp	r2, #4
 80060f6:	d00f      	beq.n	8006118 <HAL_TIM_OnePulse_ConfigChannel+0x60>
    switch (InputChannel)
 80060f8:	b19e      	cbz	r6, 8006122 <HAL_TIM_OnePulse_ConfigChannel+0x6a>
 80060fa:	2e04      	cmp	r6, #4
 80060fc:	d031      	beq.n	8006162 <HAL_TIM_OnePulse_ConfigChannel+0xaa>
    htim->State = HAL_TIM_STATE_READY;
 80060fe:	2301      	movs	r3, #1
 8006100:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 8006104:	2000      	movs	r0, #0
 8006106:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 800610a:	b008      	add	sp, #32
 800610c:	bd70      	pop	{r4, r5, r6, pc}
        TIM_OC1_SetConfig(htim->Instance, &temp1);
 800610e:	a901      	add	r1, sp, #4
 8006110:	6800      	ldr	r0, [r0, #0]
 8006112:	f7fe fda3 	bl	8004c5c <TIM_OC1_SetConfig>
        break;
 8006116:	e7ef      	b.n	80060f8 <HAL_TIM_OnePulse_ConfigChannel+0x40>
        TIM_OC2_SetConfig(htim->Instance, &temp1);
 8006118:	a901      	add	r1, sp, #4
 800611a:	6800      	ldr	r0, [r0, #0]
 800611c:	f7ff fe84 	bl	8005e28 <TIM_OC2_SetConfig>
        break;
 8006120:	e7ea      	b.n	80060f8 <HAL_TIM_OnePulse_ConfigChannel+0x40>
        TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
 8006122:	6a2b      	ldr	r3, [r5, #32]
 8006124:	69ea      	ldr	r2, [r5, #28]
 8006126:	69a9      	ldr	r1, [r5, #24]
 8006128:	6820      	ldr	r0, [r4, #0]
 800612a:	f7ff ff40 	bl	8005fae <TIM_TI1_SetConfig>
        htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 800612e:	6822      	ldr	r2, [r4, #0]
 8006130:	6993      	ldr	r3, [r2, #24]
 8006132:	f023 030c 	bic.w	r3, r3, #12
 8006136:	6193      	str	r3, [r2, #24]
        htim->Instance->SMCR &= ~TIM_SMCR_TS;
 8006138:	6822      	ldr	r2, [r4, #0]
 800613a:	6893      	ldr	r3, [r2, #8]
 800613c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006140:	6093      	str	r3, [r2, #8]
        htim->Instance->SMCR |= TIM_TS_TI1FP1;
 8006142:	6822      	ldr	r2, [r4, #0]
 8006144:	6893      	ldr	r3, [r2, #8]
 8006146:	f043 0350 	orr.w	r3, r3, #80	; 0x50
 800614a:	6093      	str	r3, [r2, #8]
        htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 800614c:	6822      	ldr	r2, [r4, #0]
 800614e:	6893      	ldr	r3, [r2, #8]
 8006150:	f023 0307 	bic.w	r3, r3, #7
 8006154:	6093      	str	r3, [r2, #8]
        htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
 8006156:	6822      	ldr	r2, [r4, #0]
 8006158:	6893      	ldr	r3, [r2, #8]
 800615a:	f043 0306 	orr.w	r3, r3, #6
 800615e:	6093      	str	r3, [r2, #8]
        break;
 8006160:	e7cd      	b.n	80060fe <HAL_TIM_OnePulse_ConfigChannel+0x46>
        TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
 8006162:	6a2b      	ldr	r3, [r5, #32]
 8006164:	69ea      	ldr	r2, [r5, #28]
 8006166:	69a9      	ldr	r1, [r5, #24]
 8006168:	6820      	ldr	r0, [r4, #0]
 800616a:	f7fe fe0d 	bl	8004d88 <TIM_TI2_SetConfig>
        htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 800616e:	6822      	ldr	r2, [r4, #0]
 8006170:	6993      	ldr	r3, [r2, #24]
 8006172:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8006176:	6193      	str	r3, [r2, #24]
        htim->Instance->SMCR &= ~TIM_SMCR_TS;
 8006178:	6822      	ldr	r2, [r4, #0]
 800617a:	6893      	ldr	r3, [r2, #8]
 800617c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006180:	6093      	str	r3, [r2, #8]
        htim->Instance->SMCR |= TIM_TS_TI2FP2;
 8006182:	6822      	ldr	r2, [r4, #0]
 8006184:	6893      	ldr	r3, [r2, #8]
 8006186:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800618a:	6093      	str	r3, [r2, #8]
        htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 800618c:	6822      	ldr	r2, [r4, #0]
 800618e:	6893      	ldr	r3, [r2, #8]
 8006190:	f023 0307 	bic.w	r3, r3, #7
 8006194:	6093      	str	r3, [r2, #8]
        htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
 8006196:	6822      	ldr	r2, [r4, #0]
 8006198:	6893      	ldr	r3, [r2, #8]
 800619a:	f043 0306 	orr.w	r3, r3, #6
 800619e:	6093      	str	r3, [r2, #8]
        break;
 80061a0:	e7ad      	b.n	80060fe <HAL_TIM_OnePulse_ConfigChannel+0x46>
    return HAL_ERROR;
 80061a2:	2001      	movs	r0, #1
}
 80061a4:	4770      	bx	lr
    __HAL_LOCK(htim);
 80061a6:	2002      	movs	r0, #2
 80061a8:	e7af      	b.n	800610a <HAL_TIM_OnePulse_ConfigChannel+0x52>

080061aa <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 80061aa:	b410      	push	{r4}
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 80061ac:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80061ae:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80061b2:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 80061b6:	430a      	orrs	r2, r1
 80061b8:	4322      	orrs	r2, r4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80061ba:	6082      	str	r2, [r0, #8]
}
 80061bc:	bc10      	pop	{r4}
 80061be:	4770      	bx	lr

080061c0 <HAL_TIM_ConfigOCrefClear>:
  __HAL_LOCK(htim);
 80061c0:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80061c4:	2b01      	cmp	r3, #1
 80061c6:	d06b      	beq.n	80062a0 <HAL_TIM_ConfigOCrefClear+0xe0>
{
 80061c8:	b570      	push	{r4, r5, r6, lr}
 80061ca:	4604      	mov	r4, r0
 80061cc:	460d      	mov	r5, r1
 80061ce:	4616      	mov	r6, r2
  __HAL_LOCK(htim);
 80061d0:	2301      	movs	r3, #1
 80061d2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 80061d6:	2302      	movs	r3, #2
 80061d8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  switch (sClearInputConfig->ClearInputSource)
 80061dc:	684b      	ldr	r3, [r1, #4]
 80061de:	b163      	cbz	r3, 80061fa <HAL_TIM_ConfigOCrefClear+0x3a>
 80061e0:	2b01      	cmp	r3, #1
 80061e2:	d010      	beq.n	8006206 <HAL_TIM_ConfigOCrefClear+0x46>
  switch (Channel)
 80061e4:	2e0c      	cmp	r6, #12
 80061e6:	d824      	bhi.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
 80061e8:	e8df f006 	tbb	[pc, r6]
 80061ec:	2323231c 	.word	0x2323231c
 80061f0:	23232330 	.word	0x23232330
 80061f4:	2323233e 	.word	0x2323233e
 80061f8:	4c          	.byte	0x4c
 80061f9:	00          	.byte	0x00
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
 80061fa:	6802      	ldr	r2, [r0, #0]
 80061fc:	6893      	ldr	r3, [r2, #8]
 80061fe:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8006202:	6093      	str	r3, [r2, #8]
      break;
 8006204:	e7ee      	b.n	80061e4 <HAL_TIM_ConfigOCrefClear+0x24>
      if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
 8006206:	68c9      	ldr	r1, [r1, #12]
 8006208:	b131      	cbz	r1, 8006218 <HAL_TIM_ConfigOCrefClear+0x58>
        htim->State = HAL_TIM_STATE_READY;
 800620a:	2001      	movs	r0, #1
 800620c:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
        __HAL_UNLOCK(htim);
 8006210:	2300      	movs	r3, #0
 8006212:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        return HAL_ERROR;
 8006216:	e012      	b.n	800623e <HAL_TIM_ConfigOCrefClear+0x7e>
      TIM_ETR_SetConfig(htim->Instance,
 8006218:	692b      	ldr	r3, [r5, #16]
 800621a:	68aa      	ldr	r2, [r5, #8]
 800621c:	6800      	ldr	r0, [r0, #0]
 800621e:	f7ff ffc4 	bl	80061aa <TIM_ETR_SetConfig>
      break;
 8006222:	e7df      	b.n	80061e4 <HAL_TIM_ConfigOCrefClear+0x24>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
 8006224:	682b      	ldr	r3, [r5, #0]
 8006226:	b15b      	cbz	r3, 8006240 <HAL_TIM_ConfigOCrefClear+0x80>
        SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
 8006228:	6822      	ldr	r2, [r4, #0]
 800622a:	6993      	ldr	r3, [r2, #24]
 800622c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006230:	6193      	str	r3, [r2, #24]
  htim->State = HAL_TIM_STATE_READY;
 8006232:	2301      	movs	r3, #1
 8006234:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8006238:	2000      	movs	r0, #0
 800623a:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 800623e:	bd70      	pop	{r4, r5, r6, pc}
        CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
 8006240:	6822      	ldr	r2, [r4, #0]
 8006242:	6993      	ldr	r3, [r2, #24]
 8006244:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006248:	6193      	str	r3, [r2, #24]
 800624a:	e7f2      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
 800624c:	682b      	ldr	r3, [r5, #0]
 800624e:	b12b      	cbz	r3, 800625c <HAL_TIM_ConfigOCrefClear+0x9c>
        SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
 8006250:	6822      	ldr	r2, [r4, #0]
 8006252:	6993      	ldr	r3, [r2, #24]
 8006254:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8006258:	6193      	str	r3, [r2, #24]
 800625a:	e7ea      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
        CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
 800625c:	6822      	ldr	r2, [r4, #0]
 800625e:	6993      	ldr	r3, [r2, #24]
 8006260:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8006264:	6193      	str	r3, [r2, #24]
 8006266:	e7e4      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
 8006268:	682b      	ldr	r3, [r5, #0]
 800626a:	b12b      	cbz	r3, 8006278 <HAL_TIM_ConfigOCrefClear+0xb8>
        SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
 800626c:	6822      	ldr	r2, [r4, #0]
 800626e:	69d3      	ldr	r3, [r2, #28]
 8006270:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006274:	61d3      	str	r3, [r2, #28]
 8006276:	e7dc      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
        CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
 8006278:	6822      	ldr	r2, [r4, #0]
 800627a:	69d3      	ldr	r3, [r2, #28]
 800627c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006280:	61d3      	str	r3, [r2, #28]
 8006282:	e7d6      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
 8006284:	682b      	ldr	r3, [r5, #0]
 8006286:	b12b      	cbz	r3, 8006294 <HAL_TIM_ConfigOCrefClear+0xd4>
        SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
 8006288:	6822      	ldr	r2, [r4, #0]
 800628a:	69d3      	ldr	r3, [r2, #28]
 800628c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8006290:	61d3      	str	r3, [r2, #28]
 8006292:	e7ce      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
        CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
 8006294:	6822      	ldr	r2, [r4, #0]
 8006296:	69d3      	ldr	r3, [r2, #28]
 8006298:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800629c:	61d3      	str	r3, [r2, #28]
 800629e:	e7c8      	b.n	8006232 <HAL_TIM_ConfigOCrefClear+0x72>
  __HAL_LOCK(htim);
 80062a0:	2002      	movs	r0, #2
}
 80062a2:	4770      	bx	lr

080062a4 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 80062a4:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80062a8:	2b01      	cmp	r3, #1
 80062aa:	d066      	beq.n	800637a <HAL_TIM_ConfigClockSource+0xd6>
{
 80062ac:	b510      	push	{r4, lr}
 80062ae:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
 80062b0:	2301      	movs	r3, #1
 80062b2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 80062b6:	2302      	movs	r3, #2
 80062b8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 80062bc:	6802      	ldr	r2, [r0, #0]
 80062be:	6893      	ldr	r3, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80062c0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80062c4:	f023 0377 	bic.w	r3, r3, #119	; 0x77
  htim->Instance->SMCR = tmpsmcr;
 80062c8:	6093      	str	r3, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
 80062ca:	680b      	ldr	r3, [r1, #0]
 80062cc:	2b60      	cmp	r3, #96	; 0x60
 80062ce:	d040      	beq.n	8006352 <HAL_TIM_ConfigClockSource+0xae>
 80062d0:	d822      	bhi.n	8006318 <HAL_TIM_ConfigClockSource+0x74>
 80062d2:	2b40      	cmp	r3, #64	; 0x40
 80062d4:	d047      	beq.n	8006366 <HAL_TIM_ConfigClockSource+0xc2>
 80062d6:	d90b      	bls.n	80062f0 <HAL_TIM_ConfigClockSource+0x4c>
 80062d8:	2b50      	cmp	r3, #80	; 0x50
 80062da:	d10e      	bne.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
      TIM_TI1_ConfigInputStage(htim->Instance,
 80062dc:	68ca      	ldr	r2, [r1, #12]
 80062de:	6849      	ldr	r1, [r1, #4]
 80062e0:	6800      	ldr	r0, [r0, #0]
 80062e2:	f7fe fd3f 	bl	8004d64 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 80062e6:	2150      	movs	r1, #80	; 0x50
 80062e8:	6820      	ldr	r0, [r4, #0]
 80062ea:	f7fe fdad 	bl	8004e48 <TIM_ITRx_SetConfig>
      break;
 80062ee:	e004      	b.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
  switch (sClockSourceConfig->ClockSource)
 80062f0:	2b20      	cmp	r3, #32
 80062f2:	d00c      	beq.n	800630e <HAL_TIM_ConfigClockSource+0x6a>
 80062f4:	d908      	bls.n	8006308 <HAL_TIM_ConfigClockSource+0x64>
 80062f6:	2b30      	cmp	r3, #48	; 0x30
 80062f8:	d009      	beq.n	800630e <HAL_TIM_ConfigClockSource+0x6a>
  htim->State = HAL_TIM_STATE_READY;
 80062fa:	2301      	movs	r3, #1
 80062fc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8006300:	2000      	movs	r0, #0
 8006302:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8006306:	bd10      	pop	{r4, pc}
  switch (sClockSourceConfig->ClockSource)
 8006308:	b10b      	cbz	r3, 800630e <HAL_TIM_ConfigClockSource+0x6a>
 800630a:	2b10      	cmp	r3, #16
 800630c:	d1f5      	bne.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800630e:	4619      	mov	r1, r3
 8006310:	6820      	ldr	r0, [r4, #0]
 8006312:	f7fe fd99 	bl	8004e48 <TIM_ITRx_SetConfig>
        break;
 8006316:	e7f0      	b.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
  switch (sClockSourceConfig->ClockSource)
 8006318:	2b70      	cmp	r3, #112	; 0x70
 800631a:	d00e      	beq.n	800633a <HAL_TIM_ConfigClockSource+0x96>
 800631c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8006320:	d1eb      	bne.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
      TIM_ETR_SetConfig(htim->Instance,
 8006322:	68cb      	ldr	r3, [r1, #12]
 8006324:	684a      	ldr	r2, [r1, #4]
 8006326:	6889      	ldr	r1, [r1, #8]
 8006328:	6800      	ldr	r0, [r0, #0]
 800632a:	f7ff ff3e 	bl	80061aa <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800632e:	6822      	ldr	r2, [r4, #0]
 8006330:	6893      	ldr	r3, [r2, #8]
 8006332:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8006336:	6093      	str	r3, [r2, #8]
      break;
 8006338:	e7df      	b.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
      TIM_ETR_SetConfig(htim->Instance,
 800633a:	68cb      	ldr	r3, [r1, #12]
 800633c:	684a      	ldr	r2, [r1, #4]
 800633e:	6889      	ldr	r1, [r1, #8]
 8006340:	6800      	ldr	r0, [r0, #0]
 8006342:	f7ff ff32 	bl	80061aa <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 8006346:	6822      	ldr	r2, [r4, #0]
 8006348:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800634a:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 800634e:	6093      	str	r3, [r2, #8]
      break;
 8006350:	e7d3      	b.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
      TIM_TI2_ConfigInputStage(htim->Instance,
 8006352:	68ca      	ldr	r2, [r1, #12]
 8006354:	6849      	ldr	r1, [r1, #4]
 8006356:	6800      	ldr	r0, [r0, #0]
 8006358:	f7fe fd30 	bl	8004dbc <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800635c:	2160      	movs	r1, #96	; 0x60
 800635e:	6820      	ldr	r0, [r4, #0]
 8006360:	f7fe fd72 	bl	8004e48 <TIM_ITRx_SetConfig>
      break;
 8006364:	e7c9      	b.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8006366:	68ca      	ldr	r2, [r1, #12]
 8006368:	6849      	ldr	r1, [r1, #4]
 800636a:	6800      	ldr	r0, [r0, #0]
 800636c:	f7fe fcfa 	bl	8004d64 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 8006370:	2140      	movs	r1, #64	; 0x40
 8006372:	6820      	ldr	r0, [r4, #0]
 8006374:	f7fe fd68 	bl	8004e48 <TIM_ITRx_SetConfig>
      break;
 8006378:	e7bf      	b.n	80062fa <HAL_TIM_ConfigClockSource+0x56>
  __HAL_LOCK(htim);
 800637a:	2002      	movs	r0, #2
}
 800637c:	4770      	bx	lr

0800637e <TIM_SlaveTimer_SetConfig>:
{
 800637e:	b510      	push	{r4, lr}
  tmpsmcr = htim->Instance->SMCR;
 8006380:	6804      	ldr	r4, [r0, #0]
 8006382:	68a2      	ldr	r2, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8006384:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= sSlaveConfig->InputTrigger;
 8006388:	684b      	ldr	r3, [r1, #4]
 800638a:	4313      	orrs	r3, r2
  tmpsmcr &= ~TIM_SMCR_SMS;
 800638c:	f023 0307 	bic.w	r3, r3, #7
  tmpsmcr |= sSlaveConfig->SlaveMode;
 8006390:	680a      	ldr	r2, [r1, #0]
 8006392:	4313      	orrs	r3, r2
  htim->Instance->SMCR = tmpsmcr;
 8006394:	60a3      	str	r3, [r4, #8]
  switch (sSlaveConfig->InputTrigger)
 8006396:	684b      	ldr	r3, [r1, #4]
 8006398:	2b60      	cmp	r3, #96	; 0x60
 800639a:	d02c      	beq.n	80063f6 <TIM_SlaveTimer_SetConfig+0x78>
 800639c:	d80c      	bhi.n	80063b8 <TIM_SlaveTimer_SetConfig+0x3a>
 800639e:	2b40      	cmp	r3, #64	; 0x40
 80063a0:	d014      	beq.n	80063cc <TIM_SlaveTimer_SetConfig+0x4e>
 80063a2:	2b50      	cmp	r3, #80	; 0x50
 80063a4:	d106      	bne.n	80063b4 <TIM_SlaveTimer_SetConfig+0x36>
      TIM_TI1_ConfigInputStage(htim->Instance,
 80063a6:	690a      	ldr	r2, [r1, #16]
 80063a8:	6889      	ldr	r1, [r1, #8]
 80063aa:	6800      	ldr	r0, [r0, #0]
 80063ac:	f7fe fcda 	bl	8004d64 <TIM_TI1_ConfigInputStage>
  return HAL_OK;
 80063b0:	2000      	movs	r0, #0
      break;
 80063b2:	e028      	b.n	8006406 <TIM_SlaveTimer_SetConfig+0x88>
  switch (sSlaveConfig->InputTrigger)
 80063b4:	2000      	movs	r0, #0
 80063b6:	e026      	b.n	8006406 <TIM_SlaveTimer_SetConfig+0x88>
 80063b8:	2b70      	cmp	r3, #112	; 0x70
 80063ba:	d123      	bne.n	8006404 <TIM_SlaveTimer_SetConfig+0x86>
      TIM_ETR_SetConfig(htim->Instance,
 80063bc:	690b      	ldr	r3, [r1, #16]
 80063be:	688a      	ldr	r2, [r1, #8]
 80063c0:	68c9      	ldr	r1, [r1, #12]
 80063c2:	6800      	ldr	r0, [r0, #0]
 80063c4:	f7ff fef1 	bl	80061aa <TIM_ETR_SetConfig>
  return HAL_OK;
 80063c8:	2000      	movs	r0, #0
      break;
 80063ca:	e01c      	b.n	8006406 <TIM_SlaveTimer_SetConfig+0x88>
      if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
 80063cc:	680b      	ldr	r3, [r1, #0]
 80063ce:	2b05      	cmp	r3, #5
 80063d0:	d01a      	beq.n	8006408 <TIM_SlaveTimer_SetConfig+0x8a>
      tmpccer = htim->Instance->CCER;
 80063d2:	6803      	ldr	r3, [r0, #0]
 80063d4:	6a1c      	ldr	r4, [r3, #32]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 80063d6:	6a1a      	ldr	r2, [r3, #32]
 80063d8:	f022 0201 	bic.w	r2, r2, #1
 80063dc:	621a      	str	r2, [r3, #32]
      tmpccmr1 = htim->Instance->CCMR1;
 80063de:	6802      	ldr	r2, [r0, #0]
 80063e0:	6993      	ldr	r3, [r2, #24]
      tmpccmr1 &= ~TIM_CCMR1_IC1F;
 80063e2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 80063e6:	6909      	ldr	r1, [r1, #16]
 80063e8:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
      htim->Instance->CCMR1 = tmpccmr1;
 80063ec:	6193      	str	r3, [r2, #24]
      htim->Instance->CCER = tmpccer;
 80063ee:	6803      	ldr	r3, [r0, #0]
 80063f0:	621c      	str	r4, [r3, #32]
  return HAL_OK;
 80063f2:	2000      	movs	r0, #0
      break;
 80063f4:	e007      	b.n	8006406 <TIM_SlaveTimer_SetConfig+0x88>
      TIM_TI2_ConfigInputStage(htim->Instance,
 80063f6:	690a      	ldr	r2, [r1, #16]
 80063f8:	6889      	ldr	r1, [r1, #8]
 80063fa:	6800      	ldr	r0, [r0, #0]
 80063fc:	f7fe fcde 	bl	8004dbc <TIM_TI2_ConfigInputStage>
  return HAL_OK;
 8006400:	2000      	movs	r0, #0
      break;
 8006402:	e000      	b.n	8006406 <TIM_SlaveTimer_SetConfig+0x88>
  switch (sSlaveConfig->InputTrigger)
 8006404:	2000      	movs	r0, #0
}
 8006406:	bd10      	pop	{r4, pc}
        return HAL_ERROR;
 8006408:	2001      	movs	r0, #1
 800640a:	e7fc      	b.n	8006406 <TIM_SlaveTimer_SetConfig+0x88>

0800640c <HAL_TIM_SlaveConfigSynchro>:
  __HAL_LOCK(htim);
 800640c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8006410:	2b01      	cmp	r3, #1
 8006412:	d022      	beq.n	800645a <HAL_TIM_SlaveConfigSynchro+0x4e>
{
 8006414:	b510      	push	{r4, lr}
 8006416:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
 8006418:	2301      	movs	r3, #1
 800641a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 800641e:	2302      	movs	r3, #2
 8006420:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
 8006424:	f7ff ffab 	bl	800637e <TIM_SlaveTimer_SetConfig>
 8006428:	b980      	cbnz	r0, 800644c <HAL_TIM_SlaveConfigSynchro+0x40>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
 800642a:	6822      	ldr	r2, [r4, #0]
 800642c:	68d3      	ldr	r3, [r2, #12]
 800642e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006432:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8006434:	6822      	ldr	r2, [r4, #0]
 8006436:	68d3      	ldr	r3, [r2, #12]
 8006438:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800643c:	60d3      	str	r3, [r2, #12]
  htim->State = HAL_TIM_STATE_READY;
 800643e:	2301      	movs	r3, #1
 8006440:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8006444:	2300      	movs	r3, #0
 8006446:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800644a:	bd10      	pop	{r4, pc}
    htim->State = HAL_TIM_STATE_READY;
 800644c:	2001      	movs	r0, #1
 800644e:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 8006452:	2300      	movs	r3, #0
 8006454:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    return HAL_ERROR;
 8006458:	e7f7      	b.n	800644a <HAL_TIM_SlaveConfigSynchro+0x3e>
  __HAL_LOCK(htim);
 800645a:	2002      	movs	r0, #2
}
 800645c:	4770      	bx	lr

0800645e <HAL_TIM_SlaveConfigSynchro_IT>:
  __HAL_LOCK(htim);
 800645e:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8006462:	2b01      	cmp	r3, #1
 8006464:	d022      	beq.n	80064ac <HAL_TIM_SlaveConfigSynchro_IT+0x4e>
{
 8006466:	b510      	push	{r4, lr}
 8006468:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
 800646a:	2301      	movs	r3, #1
 800646c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 8006470:	2302      	movs	r3, #2
 8006472:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
 8006476:	f7ff ff82 	bl	800637e <TIM_SlaveTimer_SetConfig>
 800647a:	b980      	cbnz	r0, 800649e <HAL_TIM_SlaveConfigSynchro_IT+0x40>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
 800647c:	6822      	ldr	r2, [r4, #0]
 800647e:	68d3      	ldr	r3, [r2, #12]
 8006480:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006484:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8006486:	6822      	ldr	r2, [r4, #0]
 8006488:	68d3      	ldr	r3, [r2, #12]
 800648a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800648e:	60d3      	str	r3, [r2, #12]
  htim->State = HAL_TIM_STATE_READY;
 8006490:	2301      	movs	r3, #1
 8006492:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8006496:	2300      	movs	r3, #0
 8006498:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800649c:	bd10      	pop	{r4, pc}
    htim->State = HAL_TIM_STATE_READY;
 800649e:	2001      	movs	r0, #1
 80064a0:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 80064a4:	2300      	movs	r3, #0
 80064a6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    return HAL_ERROR;
 80064aa:	e7f7      	b.n	800649c <HAL_TIM_SlaveConfigSynchro_IT+0x3e>
  __HAL_LOCK(htim);
 80064ac:	2002      	movs	r0, #2
}
 80064ae:	4770      	bx	lr

080064b0 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 80064b0:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 80064b2:	f001 011f 	and.w	r1, r1, #31
 80064b6:	2301      	movs	r3, #1
 80064b8:	fa03 f401 	lsl.w	r4, r3, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 80064bc:	6a03      	ldr	r3, [r0, #32]
 80064be:	ea23 0304 	bic.w	r3, r3, r4
 80064c2:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 80064c4:	6a03      	ldr	r3, [r0, #32]
 80064c6:	fa02 f101 	lsl.w	r1, r2, r1
 80064ca:	430b      	orrs	r3, r1
 80064cc:	6203      	str	r3, [r0, #32]
}
 80064ce:	bc10      	pop	{r4}
 80064d0:	4770      	bx	lr

080064d2 <HAL_TIM_OC_Start>:
{
 80064d2:	b510      	push	{r4, lr}
 80064d4:	4604      	mov	r4, r0
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80064d6:	4608      	mov	r0, r1
 80064d8:	bb51      	cbnz	r1, 8006530 <HAL_TIM_OC_Start+0x5e>
 80064da:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 80064de:	b2db      	uxtb	r3, r3
 80064e0:	3b01      	subs	r3, #1
 80064e2:	bf18      	it	ne
 80064e4:	2301      	movne	r3, #1
 80064e6:	2b00      	cmp	r3, #0
 80064e8:	d15b      	bne.n	80065a2 <HAL_TIM_OC_Start+0xd0>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80064ea:	2800      	cmp	r0, #0
 80064ec:	d139      	bne.n	8006562 <HAL_TIM_OC_Start+0x90>
 80064ee:	2302      	movs	r3, #2
 80064f0:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80064f4:	2201      	movs	r2, #1
 80064f6:	4601      	mov	r1, r0
 80064f8:	6820      	ldr	r0, [r4, #0]
 80064fa:	f7ff ffd9 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80064fe:	6823      	ldr	r3, [r4, #0]
 8006500:	4a2a      	ldr	r2, [pc, #168]	; (80065ac <HAL_TIM_OC_Start+0xda>)
 8006502:	4293      	cmp	r3, r2
 8006504:	d03d      	beq.n	8006582 <HAL_TIM_OC_Start+0xb0>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006506:	6823      	ldr	r3, [r4, #0]
 8006508:	4a28      	ldr	r2, [pc, #160]	; (80065ac <HAL_TIM_OC_Start+0xda>)
 800650a:	4293      	cmp	r3, r2
 800650c:	d03e      	beq.n	800658c <HAL_TIM_OC_Start+0xba>
 800650e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006512:	d03b      	beq.n	800658c <HAL_TIM_OC_Start+0xba>
 8006514:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8006518:	4293      	cmp	r3, r2
 800651a:	d037      	beq.n	800658c <HAL_TIM_OC_Start+0xba>
 800651c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8006520:	4293      	cmp	r3, r2
 8006522:	d033      	beq.n	800658c <HAL_TIM_OC_Start+0xba>
    __HAL_TIM_ENABLE(htim);
 8006524:	681a      	ldr	r2, [r3, #0]
 8006526:	f042 0201 	orr.w	r2, r2, #1
 800652a:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800652c:	2000      	movs	r0, #0
 800652e:	e039      	b.n	80065a4 <HAL_TIM_OC_Start+0xd2>
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8006530:	2904      	cmp	r1, #4
 8006532:	d008      	beq.n	8006546 <HAL_TIM_OC_Start+0x74>
 8006534:	2908      	cmp	r1, #8
 8006536:	d00d      	beq.n	8006554 <HAL_TIM_OC_Start+0x82>
 8006538:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800653c:	b2db      	uxtb	r3, r3
 800653e:	3b01      	subs	r3, #1
 8006540:	bf18      	it	ne
 8006542:	2301      	movne	r3, #1
 8006544:	e7cf      	b.n	80064e6 <HAL_TIM_OC_Start+0x14>
 8006546:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 800654a:	b2db      	uxtb	r3, r3
 800654c:	3b01      	subs	r3, #1
 800654e:	bf18      	it	ne
 8006550:	2301      	movne	r3, #1
 8006552:	e7c8      	b.n	80064e6 <HAL_TIM_OC_Start+0x14>
 8006554:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006558:	b2db      	uxtb	r3, r3
 800655a:	3b01      	subs	r3, #1
 800655c:	bf18      	it	ne
 800655e:	2301      	movne	r3, #1
 8006560:	e7c1      	b.n	80064e6 <HAL_TIM_OC_Start+0x14>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006562:	2804      	cmp	r0, #4
 8006564:	d005      	beq.n	8006572 <HAL_TIM_OC_Start+0xa0>
 8006566:	2808      	cmp	r0, #8
 8006568:	d007      	beq.n	800657a <HAL_TIM_OC_Start+0xa8>
 800656a:	2302      	movs	r3, #2
 800656c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006570:	e7c0      	b.n	80064f4 <HAL_TIM_OC_Start+0x22>
 8006572:	2302      	movs	r3, #2
 8006574:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8006578:	e7bc      	b.n	80064f4 <HAL_TIM_OC_Start+0x22>
 800657a:	2302      	movs	r3, #2
 800657c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8006580:	e7b8      	b.n	80064f4 <HAL_TIM_OC_Start+0x22>
    __HAL_TIM_MOE_ENABLE(htim);
 8006582:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006584:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006588:	645a      	str	r2, [r3, #68]	; 0x44
 800658a:	e7bc      	b.n	8006506 <HAL_TIM_OC_Start+0x34>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800658c:	689a      	ldr	r2, [r3, #8]
 800658e:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8006592:	2a06      	cmp	r2, #6
 8006594:	d007      	beq.n	80065a6 <HAL_TIM_OC_Start+0xd4>
      __HAL_TIM_ENABLE(htim);
 8006596:	681a      	ldr	r2, [r3, #0]
 8006598:	f042 0201 	orr.w	r2, r2, #1
 800659c:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800659e:	2000      	movs	r0, #0
 80065a0:	e000      	b.n	80065a4 <HAL_TIM_OC_Start+0xd2>
    return HAL_ERROR;
 80065a2:	2001      	movs	r0, #1
}
 80065a4:	bd10      	pop	{r4, pc}
  return HAL_OK;
 80065a6:	2000      	movs	r0, #0
 80065a8:	e7fc      	b.n	80065a4 <HAL_TIM_OC_Start+0xd2>
 80065aa:	bf00      	nop
 80065ac:	40012c00 	.word	0x40012c00

080065b0 <HAL_TIM_OC_Stop>:
{
 80065b0:	b538      	push	{r3, r4, r5, lr}
 80065b2:	4604      	mov	r4, r0
 80065b4:	460d      	mov	r5, r1
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 80065b6:	2200      	movs	r2, #0
 80065b8:	6800      	ldr	r0, [r0, #0]
 80065ba:	f7ff ff79 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80065be:	6823      	ldr	r3, [r4, #0]
 80065c0:	4a1b      	ldr	r2, [pc, #108]	; (8006630 <HAL_TIM_OC_Stop+0x80>)
 80065c2:	4293      	cmp	r3, r2
 80065c4:	d014      	beq.n	80065f0 <HAL_TIM_OC_Stop+0x40>
  __HAL_TIM_DISABLE(htim);
 80065c6:	6823      	ldr	r3, [r4, #0]
 80065c8:	6a19      	ldr	r1, [r3, #32]
 80065ca:	f241 1211 	movw	r2, #4369	; 0x1111
 80065ce:	4211      	tst	r1, r2
 80065d0:	d108      	bne.n	80065e4 <HAL_TIM_OC_Stop+0x34>
 80065d2:	6a19      	ldr	r1, [r3, #32]
 80065d4:	f240 4244 	movw	r2, #1092	; 0x444
 80065d8:	4211      	tst	r1, r2
 80065da:	d103      	bne.n	80065e4 <HAL_TIM_OC_Stop+0x34>
 80065dc:	681a      	ldr	r2, [r3, #0]
 80065de:	f022 0201 	bic.w	r2, r2, #1
 80065e2:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80065e4:	b99d      	cbnz	r5, 800660e <HAL_TIM_OC_Stop+0x5e>
 80065e6:	2301      	movs	r3, #1
 80065e8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 80065ec:	2000      	movs	r0, #0
 80065ee:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_TIM_MOE_DISABLE(htim);
 80065f0:	6a19      	ldr	r1, [r3, #32]
 80065f2:	f241 1211 	movw	r2, #4369	; 0x1111
 80065f6:	4211      	tst	r1, r2
 80065f8:	d1e5      	bne.n	80065c6 <HAL_TIM_OC_Stop+0x16>
 80065fa:	6a19      	ldr	r1, [r3, #32]
 80065fc:	f240 4244 	movw	r2, #1092	; 0x444
 8006600:	4211      	tst	r1, r2
 8006602:	d1e0      	bne.n	80065c6 <HAL_TIM_OC_Stop+0x16>
 8006604:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006606:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800660a:	645a      	str	r2, [r3, #68]	; 0x44
 800660c:	e7db      	b.n	80065c6 <HAL_TIM_OC_Stop+0x16>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 800660e:	2d04      	cmp	r5, #4
 8006610:	d005      	beq.n	800661e <HAL_TIM_OC_Stop+0x6e>
 8006612:	2d08      	cmp	r5, #8
 8006614:	d007      	beq.n	8006626 <HAL_TIM_OC_Stop+0x76>
 8006616:	2301      	movs	r3, #1
 8006618:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 800661c:	e7e6      	b.n	80065ec <HAL_TIM_OC_Stop+0x3c>
 800661e:	2301      	movs	r3, #1
 8006620:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8006624:	e7e2      	b.n	80065ec <HAL_TIM_OC_Stop+0x3c>
 8006626:	2301      	movs	r3, #1
 8006628:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800662c:	e7de      	b.n	80065ec <HAL_TIM_OC_Stop+0x3c>
 800662e:	bf00      	nop
 8006630:	40012c00 	.word	0x40012c00

08006634 <HAL_TIM_OC_Start_IT>:
{
 8006634:	b510      	push	{r4, lr}
 8006636:	4604      	mov	r4, r0
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8006638:	4608      	mov	r0, r1
 800663a:	b9b1      	cbnz	r1, 800666a <HAL_TIM_OC_Start_IT+0x36>
 800663c:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8006640:	b2db      	uxtb	r3, r3
 8006642:	3b01      	subs	r3, #1
 8006644:	bf18      	it	ne
 8006646:	2301      	movne	r3, #1
 8006648:	2b00      	cmp	r3, #0
 800664a:	d17c      	bne.n	8006746 <HAL_TIM_OC_Start_IT+0x112>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800664c:	bb30      	cbnz	r0, 800669c <HAL_TIM_OC_Start_IT+0x68>
 800664e:	2302      	movs	r3, #2
 8006650:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  switch (Channel)
 8006654:	280c      	cmp	r0, #12
 8006656:	d836      	bhi.n	80066c6 <HAL_TIM_OC_Start_IT+0x92>
 8006658:	e8df f000 	tbb	[pc, r0]
 800665c:	35353530 	.word	0x35353530
 8006660:	35353553 	.word	0x35353553
 8006664:	35353559 	.word	0x35353559
 8006668:	5f          	.byte	0x5f
 8006669:	00          	.byte	0x00
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 800666a:	2904      	cmp	r1, #4
 800666c:	d008      	beq.n	8006680 <HAL_TIM_OC_Start_IT+0x4c>
 800666e:	2908      	cmp	r1, #8
 8006670:	d00d      	beq.n	800668e <HAL_TIM_OC_Start_IT+0x5a>
 8006672:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006676:	b2db      	uxtb	r3, r3
 8006678:	3b01      	subs	r3, #1
 800667a:	bf18      	it	ne
 800667c:	2301      	movne	r3, #1
 800667e:	e7e3      	b.n	8006648 <HAL_TIM_OC_Start_IT+0x14>
 8006680:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8006684:	b2db      	uxtb	r3, r3
 8006686:	3b01      	subs	r3, #1
 8006688:	bf18      	it	ne
 800668a:	2301      	movne	r3, #1
 800668c:	e7dc      	b.n	8006648 <HAL_TIM_OC_Start_IT+0x14>
 800668e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006692:	b2db      	uxtb	r3, r3
 8006694:	3b01      	subs	r3, #1
 8006696:	bf18      	it	ne
 8006698:	2301      	movne	r3, #1
 800669a:	e7d5      	b.n	8006648 <HAL_TIM_OC_Start_IT+0x14>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800669c:	2804      	cmp	r0, #4
 800669e:	d005      	beq.n	80066ac <HAL_TIM_OC_Start_IT+0x78>
 80066a0:	2808      	cmp	r0, #8
 80066a2:	d007      	beq.n	80066b4 <HAL_TIM_OC_Start_IT+0x80>
 80066a4:	2302      	movs	r3, #2
 80066a6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80066aa:	e7d3      	b.n	8006654 <HAL_TIM_OC_Start_IT+0x20>
 80066ac:	2302      	movs	r3, #2
 80066ae:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 80066b2:	e7cf      	b.n	8006654 <HAL_TIM_OC_Start_IT+0x20>
 80066b4:	2302      	movs	r3, #2
 80066b6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80066ba:	e7cb      	b.n	8006654 <HAL_TIM_OC_Start_IT+0x20>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 80066bc:	6822      	ldr	r2, [r4, #0]
 80066be:	68d3      	ldr	r3, [r2, #12]
 80066c0:	f043 0302 	orr.w	r3, r3, #2
 80066c4:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80066c6:	2201      	movs	r2, #1
 80066c8:	4601      	mov	r1, r0
 80066ca:	6820      	ldr	r0, [r4, #0]
 80066cc:	f7ff fef0 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80066d0:	6823      	ldr	r3, [r4, #0]
 80066d2:	4a1f      	ldr	r2, [pc, #124]	; (8006750 <HAL_TIM_OC_Start_IT+0x11c>)
 80066d4:	4293      	cmp	r3, r2
 80066d6:	d026      	beq.n	8006726 <HAL_TIM_OC_Start_IT+0xf2>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80066d8:	6823      	ldr	r3, [r4, #0]
 80066da:	4a1d      	ldr	r2, [pc, #116]	; (8006750 <HAL_TIM_OC_Start_IT+0x11c>)
 80066dc:	4293      	cmp	r3, r2
 80066de:	d027      	beq.n	8006730 <HAL_TIM_OC_Start_IT+0xfc>
 80066e0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80066e4:	d024      	beq.n	8006730 <HAL_TIM_OC_Start_IT+0xfc>
 80066e6:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80066ea:	4293      	cmp	r3, r2
 80066ec:	d020      	beq.n	8006730 <HAL_TIM_OC_Start_IT+0xfc>
 80066ee:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80066f2:	4293      	cmp	r3, r2
 80066f4:	d01c      	beq.n	8006730 <HAL_TIM_OC_Start_IT+0xfc>
    __HAL_TIM_ENABLE(htim);
 80066f6:	681a      	ldr	r2, [r3, #0]
 80066f8:	f042 0201 	orr.w	r2, r2, #1
 80066fc:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80066fe:	2000      	movs	r0, #0
 8006700:	e022      	b.n	8006748 <HAL_TIM_OC_Start_IT+0x114>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8006702:	6822      	ldr	r2, [r4, #0]
 8006704:	68d3      	ldr	r3, [r2, #12]
 8006706:	f043 0304 	orr.w	r3, r3, #4
 800670a:	60d3      	str	r3, [r2, #12]
      break;
 800670c:	e7db      	b.n	80066c6 <HAL_TIM_OC_Start_IT+0x92>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 800670e:	6822      	ldr	r2, [r4, #0]
 8006710:	68d3      	ldr	r3, [r2, #12]
 8006712:	f043 0308 	orr.w	r3, r3, #8
 8006716:	60d3      	str	r3, [r2, #12]
      break;
 8006718:	e7d5      	b.n	80066c6 <HAL_TIM_OC_Start_IT+0x92>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 800671a:	6822      	ldr	r2, [r4, #0]
 800671c:	68d3      	ldr	r3, [r2, #12]
 800671e:	f043 0310 	orr.w	r3, r3, #16
 8006722:	60d3      	str	r3, [r2, #12]
      break;
 8006724:	e7cf      	b.n	80066c6 <HAL_TIM_OC_Start_IT+0x92>
    __HAL_TIM_MOE_ENABLE(htim);
 8006726:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006728:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800672c:	645a      	str	r2, [r3, #68]	; 0x44
 800672e:	e7d3      	b.n	80066d8 <HAL_TIM_OC_Start_IT+0xa4>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006730:	689a      	ldr	r2, [r3, #8]
 8006732:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8006736:	2a06      	cmp	r2, #6
 8006738:	d007      	beq.n	800674a <HAL_TIM_OC_Start_IT+0x116>
      __HAL_TIM_ENABLE(htim);
 800673a:	681a      	ldr	r2, [r3, #0]
 800673c:	f042 0201 	orr.w	r2, r2, #1
 8006740:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006742:	2000      	movs	r0, #0
 8006744:	e000      	b.n	8006748 <HAL_TIM_OC_Start_IT+0x114>
    return HAL_ERROR;
 8006746:	2001      	movs	r0, #1
}
 8006748:	bd10      	pop	{r4, pc}
  return HAL_OK;
 800674a:	2000      	movs	r0, #0
 800674c:	e7fc      	b.n	8006748 <HAL_TIM_OC_Start_IT+0x114>
 800674e:	bf00      	nop
 8006750:	40012c00 	.word	0x40012c00

08006754 <HAL_TIM_OC_Stop_IT>:
{
 8006754:	b538      	push	{r3, r4, r5, lr}
 8006756:	4605      	mov	r5, r0
 8006758:	460c      	mov	r4, r1
  switch (Channel)
 800675a:	290c      	cmp	r1, #12
 800675c:	d80d      	bhi.n	800677a <HAL_TIM_OC_Stop_IT+0x26>
 800675e:	e8df f001 	tbb	[pc, r1]
 8006762:	0c07      	.short	0x0c07
 8006764:	0c2a0c0c 	.word	0x0c2a0c0c
 8006768:	0c300c0c 	.word	0x0c300c0c
 800676c:	0c0c      	.short	0x0c0c
 800676e:	36          	.byte	0x36
 800676f:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8006770:	6802      	ldr	r2, [r0, #0]
 8006772:	68d3      	ldr	r3, [r2, #12]
 8006774:	f023 0302 	bic.w	r3, r3, #2
 8006778:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800677a:	2200      	movs	r2, #0
 800677c:	4621      	mov	r1, r4
 800677e:	6828      	ldr	r0, [r5, #0]
 8006780:	f7ff fe96 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006784:	682b      	ldr	r3, [r5, #0]
 8006786:	4a24      	ldr	r2, [pc, #144]	; (8006818 <HAL_TIM_OC_Stop_IT+0xc4>)
 8006788:	4293      	cmp	r3, r2
 800678a:	d026      	beq.n	80067da <HAL_TIM_OC_Stop_IT+0x86>
  __HAL_TIM_DISABLE(htim);
 800678c:	682b      	ldr	r3, [r5, #0]
 800678e:	6a19      	ldr	r1, [r3, #32]
 8006790:	f241 1211 	movw	r2, #4369	; 0x1111
 8006794:	4211      	tst	r1, r2
 8006796:	d108      	bne.n	80067aa <HAL_TIM_OC_Stop_IT+0x56>
 8006798:	6a19      	ldr	r1, [r3, #32]
 800679a:	f240 4244 	movw	r2, #1092	; 0x444
 800679e:	4211      	tst	r1, r2
 80067a0:	d103      	bne.n	80067aa <HAL_TIM_OC_Stop_IT+0x56>
 80067a2:	681a      	ldr	r2, [r3, #0]
 80067a4:	f022 0201 	bic.w	r2, r2, #1
 80067a8:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80067aa:	bb2c      	cbnz	r4, 80067f8 <HAL_TIM_OC_Stop_IT+0xa4>
 80067ac:	2301      	movs	r3, #1
 80067ae:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
}
 80067b2:	2000      	movs	r0, #0
 80067b4:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 80067b6:	6802      	ldr	r2, [r0, #0]
 80067b8:	68d3      	ldr	r3, [r2, #12]
 80067ba:	f023 0304 	bic.w	r3, r3, #4
 80067be:	60d3      	str	r3, [r2, #12]
      break;
 80067c0:	e7db      	b.n	800677a <HAL_TIM_OC_Stop_IT+0x26>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 80067c2:	6802      	ldr	r2, [r0, #0]
 80067c4:	68d3      	ldr	r3, [r2, #12]
 80067c6:	f023 0308 	bic.w	r3, r3, #8
 80067ca:	60d3      	str	r3, [r2, #12]
      break;
 80067cc:	e7d5      	b.n	800677a <HAL_TIM_OC_Stop_IT+0x26>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 80067ce:	6802      	ldr	r2, [r0, #0]
 80067d0:	68d3      	ldr	r3, [r2, #12]
 80067d2:	f023 0310 	bic.w	r3, r3, #16
 80067d6:	60d3      	str	r3, [r2, #12]
      break;
 80067d8:	e7cf      	b.n	800677a <HAL_TIM_OC_Stop_IT+0x26>
    __HAL_TIM_MOE_DISABLE(htim);
 80067da:	6a19      	ldr	r1, [r3, #32]
 80067dc:	f241 1211 	movw	r2, #4369	; 0x1111
 80067e0:	4211      	tst	r1, r2
 80067e2:	d1d3      	bne.n	800678c <HAL_TIM_OC_Stop_IT+0x38>
 80067e4:	6a19      	ldr	r1, [r3, #32]
 80067e6:	f240 4244 	movw	r2, #1092	; 0x444
 80067ea:	4211      	tst	r1, r2
 80067ec:	d1ce      	bne.n	800678c <HAL_TIM_OC_Stop_IT+0x38>
 80067ee:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80067f0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80067f4:	645a      	str	r2, [r3, #68]	; 0x44
 80067f6:	e7c9      	b.n	800678c <HAL_TIM_OC_Stop_IT+0x38>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80067f8:	2c04      	cmp	r4, #4
 80067fa:	d005      	beq.n	8006808 <HAL_TIM_OC_Stop_IT+0xb4>
 80067fc:	2c08      	cmp	r4, #8
 80067fe:	d007      	beq.n	8006810 <HAL_TIM_OC_Stop_IT+0xbc>
 8006800:	2301      	movs	r3, #1
 8006802:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 8006806:	e7d4      	b.n	80067b2 <HAL_TIM_OC_Stop_IT+0x5e>
 8006808:	2301      	movs	r3, #1
 800680a:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
 800680e:	e7d0      	b.n	80067b2 <HAL_TIM_OC_Stop_IT+0x5e>
 8006810:	2301      	movs	r3, #1
 8006812:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
 8006816:	e7cc      	b.n	80067b2 <HAL_TIM_OC_Stop_IT+0x5e>
 8006818:	40012c00 	.word	0x40012c00

0800681c <HAL_TIM_OC_Start_DMA>:
{
 800681c:	b570      	push	{r4, r5, r6, lr}
 800681e:	4604      	mov	r4, r0
 8006820:	4616      	mov	r6, r2
  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 8006822:	460d      	mov	r5, r1
 8006824:	2900      	cmp	r1, #0
 8006826:	d12d      	bne.n	8006884 <HAL_TIM_OC_Start_DMA+0x68>
 8006828:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 800682c:	b2c0      	uxtb	r0, r0
 800682e:	2802      	cmp	r0, #2
 8006830:	bf14      	ite	ne
 8006832:	2000      	movne	r0, #0
 8006834:	2001      	moveq	r0, #1
 8006836:	2800      	cmp	r0, #0
 8006838:	f040 80f8 	bne.w	8006a2c <HAL_TIM_OC_Start_DMA+0x210>
  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 800683c:	2d00      	cmp	r5, #0
 800683e:	d13d      	bne.n	80068bc <HAL_TIM_OC_Start_DMA+0xa0>
 8006840:	f894 203e 	ldrb.w	r2, [r4, #62]	; 0x3e
 8006844:	b2d2      	uxtb	r2, r2
 8006846:	2a01      	cmp	r2, #1
 8006848:	bf14      	ite	ne
 800684a:	2200      	movne	r2, #0
 800684c:	2201      	moveq	r2, #1
 800684e:	2a00      	cmp	r2, #0
 8006850:	f000 80ee 	beq.w	8006a30 <HAL_TIM_OC_Start_DMA+0x214>
    if ((pData == NULL) && (Length > 0U))
 8006854:	2e00      	cmp	r6, #0
 8006856:	d04d      	beq.n	80068f4 <HAL_TIM_OC_Start_DMA+0xd8>
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006858:	2d00      	cmp	r5, #0
 800685a:	d14f      	bne.n	80068fc <HAL_TIM_OC_Start_DMA+0xe0>
 800685c:	2202      	movs	r2, #2
 800685e:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
  switch (Channel)
 8006862:	2d0c      	cmp	r5, #12
 8006864:	d870      	bhi.n	8006948 <HAL_TIM_OC_Start_DMA+0x12c>
 8006866:	e8df f015 	tbh	[pc, r5, lsl #1]
 800686a:	0059      	.short	0x0059
 800686c:	006f006f 	.word	0x006f006f
 8006870:	008d006f 	.word	0x008d006f
 8006874:	006f006f 	.word	0x006f006f
 8006878:	00a4006f 	.word	0x00a4006f
 800687c:	006f006f 	.word	0x006f006f
 8006880:	00bb006f 	.word	0x00bb006f
  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 8006884:	2904      	cmp	r1, #4
 8006886:	d009      	beq.n	800689c <HAL_TIM_OC_Start_DMA+0x80>
 8006888:	2908      	cmp	r1, #8
 800688a:	d00f      	beq.n	80068ac <HAL_TIM_OC_Start_DMA+0x90>
 800688c:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
 8006890:	b2c0      	uxtb	r0, r0
 8006892:	2802      	cmp	r0, #2
 8006894:	bf14      	ite	ne
 8006896:	2000      	movne	r0, #0
 8006898:	2001      	moveq	r0, #1
 800689a:	e7cc      	b.n	8006836 <HAL_TIM_OC_Start_DMA+0x1a>
 800689c:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 80068a0:	b2c0      	uxtb	r0, r0
 80068a2:	2802      	cmp	r0, #2
 80068a4:	bf14      	ite	ne
 80068a6:	2000      	movne	r0, #0
 80068a8:	2001      	moveq	r0, #1
 80068aa:	e7c4      	b.n	8006836 <HAL_TIM_OC_Start_DMA+0x1a>
 80068ac:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
 80068b0:	b2c0      	uxtb	r0, r0
 80068b2:	2802      	cmp	r0, #2
 80068b4:	bf14      	ite	ne
 80068b6:	2000      	movne	r0, #0
 80068b8:	2001      	moveq	r0, #1
 80068ba:	e7bc      	b.n	8006836 <HAL_TIM_OC_Start_DMA+0x1a>
  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 80068bc:	2d04      	cmp	r5, #4
 80068be:	d009      	beq.n	80068d4 <HAL_TIM_OC_Start_DMA+0xb8>
 80068c0:	2d08      	cmp	r5, #8
 80068c2:	d00f      	beq.n	80068e4 <HAL_TIM_OC_Start_DMA+0xc8>
 80068c4:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80068c8:	b2d2      	uxtb	r2, r2
 80068ca:	2a01      	cmp	r2, #1
 80068cc:	bf14      	ite	ne
 80068ce:	2200      	movne	r2, #0
 80068d0:	2201      	moveq	r2, #1
 80068d2:	e7bc      	b.n	800684e <HAL_TIM_OC_Start_DMA+0x32>
 80068d4:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
 80068d8:	b2d2      	uxtb	r2, r2
 80068da:	2a01      	cmp	r2, #1
 80068dc:	bf14      	ite	ne
 80068de:	2200      	movne	r2, #0
 80068e0:	2201      	moveq	r2, #1
 80068e2:	e7b4      	b.n	800684e <HAL_TIM_OC_Start_DMA+0x32>
 80068e4:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 80068e8:	b2d2      	uxtb	r2, r2
 80068ea:	2a01      	cmp	r2, #1
 80068ec:	bf14      	ite	ne
 80068ee:	2200      	movne	r2, #0
 80068f0:	2201      	moveq	r2, #1
 80068f2:	e7ac      	b.n	800684e <HAL_TIM_OC_Start_DMA+0x32>
    if ((pData == NULL) && (Length > 0U))
 80068f4:	2b00      	cmp	r3, #0
 80068f6:	d0af      	beq.n	8006858 <HAL_TIM_OC_Start_DMA+0x3c>
      return HAL_ERROR;
 80068f8:	2001      	movs	r0, #1
 80068fa:	e09a      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80068fc:	2d04      	cmp	r5, #4
 80068fe:	d005      	beq.n	800690c <HAL_TIM_OC_Start_DMA+0xf0>
 8006900:	2d08      	cmp	r5, #8
 8006902:	d007      	beq.n	8006914 <HAL_TIM_OC_Start_DMA+0xf8>
 8006904:	2202      	movs	r2, #2
 8006906:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
 800690a:	e7aa      	b.n	8006862 <HAL_TIM_OC_Start_DMA+0x46>
 800690c:	2202      	movs	r2, #2
 800690e:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
 8006912:	e7a6      	b.n	8006862 <HAL_TIM_OC_Start_DMA+0x46>
 8006914:	2202      	movs	r2, #2
 8006916:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 800691a:	e7a2      	b.n	8006862 <HAL_TIM_OC_Start_DMA+0x46>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
 800691c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800691e:	494a      	ldr	r1, [pc, #296]	; (8006a48 <HAL_TIM_OC_Start_DMA+0x22c>)
 8006920:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8006922:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006924:	4949      	ldr	r1, [pc, #292]	; (8006a4c <HAL_TIM_OC_Start_DMA+0x230>)
 8006926:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 8006928:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800692a:	4949      	ldr	r1, [pc, #292]	; (8006a50 <HAL_TIM_OC_Start_DMA+0x234>)
 800692c:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
 800692e:	6822      	ldr	r2, [r4, #0]
 8006930:	3234      	adds	r2, #52	; 0x34
 8006932:	4631      	mov	r1, r6
 8006934:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006936:	f7fc ff93 	bl	8003860 <HAL_DMA_Start_IT>
 800693a:	2800      	cmp	r0, #0
 800693c:	d17a      	bne.n	8006a34 <HAL_TIM_OC_Start_DMA+0x218>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 800693e:	6822      	ldr	r2, [r4, #0]
 8006940:	68d3      	ldr	r3, [r2, #12]
 8006942:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8006946:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8006948:	2201      	movs	r2, #1
 800694a:	4629      	mov	r1, r5
 800694c:	6820      	ldr	r0, [r4, #0]
 800694e:	f7ff fdaf 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006952:	6823      	ldr	r3, [r4, #0]
 8006954:	4a3f      	ldr	r2, [pc, #252]	; (8006a54 <HAL_TIM_OC_Start_DMA+0x238>)
 8006956:	4293      	cmp	r3, r2
 8006958:	d058      	beq.n	8006a0c <HAL_TIM_OC_Start_DMA+0x1f0>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800695a:	6823      	ldr	r3, [r4, #0]
 800695c:	4a3d      	ldr	r2, [pc, #244]	; (8006a54 <HAL_TIM_OC_Start_DMA+0x238>)
 800695e:	4293      	cmp	r3, r2
 8006960:	d059      	beq.n	8006a16 <HAL_TIM_OC_Start_DMA+0x1fa>
 8006962:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006966:	d056      	beq.n	8006a16 <HAL_TIM_OC_Start_DMA+0x1fa>
 8006968:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 800696c:	4293      	cmp	r3, r2
 800696e:	d052      	beq.n	8006a16 <HAL_TIM_OC_Start_DMA+0x1fa>
 8006970:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8006974:	4293      	cmp	r3, r2
 8006976:	d04e      	beq.n	8006a16 <HAL_TIM_OC_Start_DMA+0x1fa>
    __HAL_TIM_ENABLE(htim);
 8006978:	681a      	ldr	r2, [r3, #0]
 800697a:	f042 0201 	orr.w	r2, r2, #1
 800697e:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006980:	2000      	movs	r0, #0
 8006982:	e056      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8006984:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006986:	4930      	ldr	r1, [pc, #192]	; (8006a48 <HAL_TIM_OC_Start_DMA+0x22c>)
 8006988:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 800698a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800698c:	492f      	ldr	r1, [pc, #188]	; (8006a4c <HAL_TIM_OC_Start_DMA+0x230>)
 800698e:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 8006990:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006992:	492f      	ldr	r1, [pc, #188]	; (8006a50 <HAL_TIM_OC_Start_DMA+0x234>)
 8006994:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
 8006996:	6822      	ldr	r2, [r4, #0]
 8006998:	3238      	adds	r2, #56	; 0x38
 800699a:	4631      	mov	r1, r6
 800699c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800699e:	f7fc ff5f 	bl	8003860 <HAL_DMA_Start_IT>
 80069a2:	2800      	cmp	r0, #0
 80069a4:	d148      	bne.n	8006a38 <HAL_TIM_OC_Start_DMA+0x21c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 80069a6:	6822      	ldr	r2, [r4, #0]
 80069a8:	68d3      	ldr	r3, [r2, #12]
 80069aa:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80069ae:	60d3      	str	r3, [r2, #12]
      break;
 80069b0:	e7ca      	b.n	8006948 <HAL_TIM_OC_Start_DMA+0x12c>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
 80069b2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80069b4:	4924      	ldr	r1, [pc, #144]	; (8006a48 <HAL_TIM_OC_Start_DMA+0x22c>)
 80069b6:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 80069b8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80069ba:	4924      	ldr	r1, [pc, #144]	; (8006a4c <HAL_TIM_OC_Start_DMA+0x230>)
 80069bc:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
 80069be:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80069c0:	4923      	ldr	r1, [pc, #140]	; (8006a50 <HAL_TIM_OC_Start_DMA+0x234>)
 80069c2:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
 80069c4:	6822      	ldr	r2, [r4, #0]
 80069c6:	323c      	adds	r2, #60	; 0x3c
 80069c8:	4631      	mov	r1, r6
 80069ca:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80069cc:	f7fc ff48 	bl	8003860 <HAL_DMA_Start_IT>
 80069d0:	2800      	cmp	r0, #0
 80069d2:	d133      	bne.n	8006a3c <HAL_TIM_OC_Start_DMA+0x220>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
 80069d4:	6822      	ldr	r2, [r4, #0]
 80069d6:	68d3      	ldr	r3, [r2, #12]
 80069d8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80069dc:	60d3      	str	r3, [r2, #12]
      break;
 80069de:	e7b3      	b.n	8006948 <HAL_TIM_OC_Start_DMA+0x12c>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
 80069e0:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80069e2:	4919      	ldr	r1, [pc, #100]	; (8006a48 <HAL_TIM_OC_Start_DMA+0x22c>)
 80069e4:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 80069e6:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80069e8:	4918      	ldr	r1, [pc, #96]	; (8006a4c <HAL_TIM_OC_Start_DMA+0x230>)
 80069ea:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
 80069ec:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80069ee:	4918      	ldr	r1, [pc, #96]	; (8006a50 <HAL_TIM_OC_Start_DMA+0x234>)
 80069f0:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,
 80069f2:	6822      	ldr	r2, [r4, #0]
 80069f4:	3240      	adds	r2, #64	; 0x40
 80069f6:	4631      	mov	r1, r6
 80069f8:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80069fa:	f7fc ff31 	bl	8003860 <HAL_DMA_Start_IT>
 80069fe:	b9f8      	cbnz	r0, 8006a40 <HAL_TIM_OC_Start_DMA+0x224>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
 8006a00:	6822      	ldr	r2, [r4, #0]
 8006a02:	68d3      	ldr	r3, [r2, #12]
 8006a04:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8006a08:	60d3      	str	r3, [r2, #12]
      break;
 8006a0a:	e79d      	b.n	8006948 <HAL_TIM_OC_Start_DMA+0x12c>
    __HAL_TIM_MOE_ENABLE(htim);
 8006a0c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006a0e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006a12:	645a      	str	r2, [r3, #68]	; 0x44
 8006a14:	e7a1      	b.n	800695a <HAL_TIM_OC_Start_DMA+0x13e>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006a16:	689a      	ldr	r2, [r3, #8]
 8006a18:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8006a1c:	2a06      	cmp	r2, #6
 8006a1e:	d011      	beq.n	8006a44 <HAL_TIM_OC_Start_DMA+0x228>
      __HAL_TIM_ENABLE(htim);
 8006a20:	681a      	ldr	r2, [r3, #0]
 8006a22:	f042 0201 	orr.w	r2, r2, #1
 8006a26:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006a28:	2000      	movs	r0, #0
 8006a2a:	e002      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
    return HAL_BUSY;
 8006a2c:	2002      	movs	r0, #2
 8006a2e:	e000      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
    return HAL_ERROR;
 8006a30:	2001      	movs	r0, #1
}
 8006a32:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8006a34:	2001      	movs	r0, #1
 8006a36:	e7fc      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
        return HAL_ERROR;
 8006a38:	2001      	movs	r0, #1
 8006a3a:	e7fa      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
        return HAL_ERROR;
 8006a3c:	2001      	movs	r0, #1
 8006a3e:	e7f8      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
        return HAL_ERROR;
 8006a40:	2001      	movs	r0, #1
 8006a42:	e7f6      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
  return HAL_OK;
 8006a44:	2000      	movs	r0, #0
 8006a46:	e7f4      	b.n	8006a32 <HAL_TIM_OC_Start_DMA+0x216>
 8006a48:	08005845 	.word	0x08005845
 8006a4c:	080058b7 	.word	0x080058b7
 8006a50:	08005a95 	.word	0x08005a95
 8006a54:	40012c00 	.word	0x40012c00

08006a58 <HAL_TIM_OC_Stop_DMA>:
{
 8006a58:	b538      	push	{r3, r4, r5, lr}
 8006a5a:	4604      	mov	r4, r0
 8006a5c:	460d      	mov	r5, r1
  switch (Channel)
 8006a5e:	290c      	cmp	r1, #12
 8006a60:	d810      	bhi.n	8006a84 <HAL_TIM_OC_Stop_DMA+0x2c>
 8006a62:	e8df f001 	tbb	[pc, r1]
 8006a66:	0f07      	.short	0x0f07
 8006a68:	0f2e0f0f 	.word	0x0f2e0f0f
 8006a6c:	0f370f0f 	.word	0x0f370f0f
 8006a70:	0f0f      	.short	0x0f0f
 8006a72:	40          	.byte	0x40
 8006a73:	00          	.byte	0x00
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 8006a74:	6802      	ldr	r2, [r0, #0]
 8006a76:	68d3      	ldr	r3, [r2, #12]
 8006a78:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8006a7c:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 8006a7e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8006a80:	f7fc ff4a 	bl	8003918 <HAL_DMA_Abort_IT>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8006a84:	2200      	movs	r2, #0
 8006a86:	4629      	mov	r1, r5
 8006a88:	6820      	ldr	r0, [r4, #0]
 8006a8a:	f7ff fd11 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006a8e:	6823      	ldr	r3, [r4, #0]
 8006a90:	4a29      	ldr	r2, [pc, #164]	; (8006b38 <HAL_TIM_OC_Stop_DMA+0xe0>)
 8006a92:	4293      	cmp	r3, r2
 8006a94:	d030      	beq.n	8006af8 <HAL_TIM_OC_Stop_DMA+0xa0>
  __HAL_TIM_DISABLE(htim);
 8006a96:	6823      	ldr	r3, [r4, #0]
 8006a98:	6a19      	ldr	r1, [r3, #32]
 8006a9a:	f241 1211 	movw	r2, #4369	; 0x1111
 8006a9e:	4211      	tst	r1, r2
 8006aa0:	d108      	bne.n	8006ab4 <HAL_TIM_OC_Stop_DMA+0x5c>
 8006aa2:	6a19      	ldr	r1, [r3, #32]
 8006aa4:	f240 4244 	movw	r2, #1092	; 0x444
 8006aa8:	4211      	tst	r1, r2
 8006aaa:	d103      	bne.n	8006ab4 <HAL_TIM_OC_Stop_DMA+0x5c>
 8006aac:	681a      	ldr	r2, [r3, #0]
 8006aae:	f022 0201 	bic.w	r2, r2, #1
 8006ab2:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8006ab4:	2d00      	cmp	r5, #0
 8006ab6:	d12e      	bne.n	8006b16 <HAL_TIM_OC_Stop_DMA+0xbe>
 8006ab8:	2301      	movs	r3, #1
 8006aba:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 8006abe:	2000      	movs	r0, #0
 8006ac0:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 8006ac2:	6802      	ldr	r2, [r0, #0]
 8006ac4:	68d3      	ldr	r3, [r2, #12]
 8006ac6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8006aca:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 8006acc:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8006ace:	f7fc ff23 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8006ad2:	e7d7      	b.n	8006a84 <HAL_TIM_OC_Stop_DMA+0x2c>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
 8006ad4:	6802      	ldr	r2, [r0, #0]
 8006ad6:	68d3      	ldr	r3, [r2, #12]
 8006ad8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8006adc:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 8006ade:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8006ae0:	f7fc ff1a 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8006ae4:	e7ce      	b.n	8006a84 <HAL_TIM_OC_Stop_DMA+0x2c>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
 8006ae6:	6802      	ldr	r2, [r0, #0]
 8006ae8:	68d3      	ldr	r3, [r2, #12]
 8006aea:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8006aee:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
 8006af0:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8006af2:	f7fc ff11 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8006af6:	e7c5      	b.n	8006a84 <HAL_TIM_OC_Stop_DMA+0x2c>
    __HAL_TIM_MOE_DISABLE(htim);
 8006af8:	6a19      	ldr	r1, [r3, #32]
 8006afa:	f241 1211 	movw	r2, #4369	; 0x1111
 8006afe:	4211      	tst	r1, r2
 8006b00:	d1c9      	bne.n	8006a96 <HAL_TIM_OC_Stop_DMA+0x3e>
 8006b02:	6a19      	ldr	r1, [r3, #32]
 8006b04:	f240 4244 	movw	r2, #1092	; 0x444
 8006b08:	4211      	tst	r1, r2
 8006b0a:	d1c4      	bne.n	8006a96 <HAL_TIM_OC_Stop_DMA+0x3e>
 8006b0c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006b0e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8006b12:	645a      	str	r2, [r3, #68]	; 0x44
 8006b14:	e7bf      	b.n	8006a96 <HAL_TIM_OC_Stop_DMA+0x3e>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8006b16:	2d04      	cmp	r5, #4
 8006b18:	d005      	beq.n	8006b26 <HAL_TIM_OC_Stop_DMA+0xce>
 8006b1a:	2d08      	cmp	r5, #8
 8006b1c:	d007      	beq.n	8006b2e <HAL_TIM_OC_Stop_DMA+0xd6>
 8006b1e:	2301      	movs	r3, #1
 8006b20:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006b24:	e7cb      	b.n	8006abe <HAL_TIM_OC_Stop_DMA+0x66>
 8006b26:	2301      	movs	r3, #1
 8006b28:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8006b2c:	e7c7      	b.n	8006abe <HAL_TIM_OC_Stop_DMA+0x66>
 8006b2e:	2301      	movs	r3, #1
 8006b30:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8006b34:	e7c3      	b.n	8006abe <HAL_TIM_OC_Stop_DMA+0x66>
 8006b36:	bf00      	nop
 8006b38:	40012c00 	.word	0x40012c00

08006b3c <HAL_TIM_PWM_Start>:
{
 8006b3c:	b510      	push	{r4, lr}
 8006b3e:	4604      	mov	r4, r0
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8006b40:	4608      	mov	r0, r1
 8006b42:	bb51      	cbnz	r1, 8006b9a <HAL_TIM_PWM_Start+0x5e>
 8006b44:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8006b48:	b2db      	uxtb	r3, r3
 8006b4a:	3b01      	subs	r3, #1
 8006b4c:	bf18      	it	ne
 8006b4e:	2301      	movne	r3, #1
 8006b50:	2b00      	cmp	r3, #0
 8006b52:	d15b      	bne.n	8006c0c <HAL_TIM_PWM_Start+0xd0>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006b54:	2800      	cmp	r0, #0
 8006b56:	d139      	bne.n	8006bcc <HAL_TIM_PWM_Start+0x90>
 8006b58:	2302      	movs	r3, #2
 8006b5a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8006b5e:	2201      	movs	r2, #1
 8006b60:	4601      	mov	r1, r0
 8006b62:	6820      	ldr	r0, [r4, #0]
 8006b64:	f7ff fca4 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006b68:	6823      	ldr	r3, [r4, #0]
 8006b6a:	4a2a      	ldr	r2, [pc, #168]	; (8006c14 <HAL_TIM_PWM_Start+0xd8>)
 8006b6c:	4293      	cmp	r3, r2
 8006b6e:	d03d      	beq.n	8006bec <HAL_TIM_PWM_Start+0xb0>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006b70:	6823      	ldr	r3, [r4, #0]
 8006b72:	4a28      	ldr	r2, [pc, #160]	; (8006c14 <HAL_TIM_PWM_Start+0xd8>)
 8006b74:	4293      	cmp	r3, r2
 8006b76:	d03e      	beq.n	8006bf6 <HAL_TIM_PWM_Start+0xba>
 8006b78:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006b7c:	d03b      	beq.n	8006bf6 <HAL_TIM_PWM_Start+0xba>
 8006b7e:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8006b82:	4293      	cmp	r3, r2
 8006b84:	d037      	beq.n	8006bf6 <HAL_TIM_PWM_Start+0xba>
 8006b86:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8006b8a:	4293      	cmp	r3, r2
 8006b8c:	d033      	beq.n	8006bf6 <HAL_TIM_PWM_Start+0xba>
    __HAL_TIM_ENABLE(htim);
 8006b8e:	681a      	ldr	r2, [r3, #0]
 8006b90:	f042 0201 	orr.w	r2, r2, #1
 8006b94:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006b96:	2000      	movs	r0, #0
 8006b98:	e039      	b.n	8006c0e <HAL_TIM_PWM_Start+0xd2>
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8006b9a:	2904      	cmp	r1, #4
 8006b9c:	d008      	beq.n	8006bb0 <HAL_TIM_PWM_Start+0x74>
 8006b9e:	2908      	cmp	r1, #8
 8006ba0:	d00d      	beq.n	8006bbe <HAL_TIM_PWM_Start+0x82>
 8006ba2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006ba6:	b2db      	uxtb	r3, r3
 8006ba8:	3b01      	subs	r3, #1
 8006baa:	bf18      	it	ne
 8006bac:	2301      	movne	r3, #1
 8006bae:	e7cf      	b.n	8006b50 <HAL_TIM_PWM_Start+0x14>
 8006bb0:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8006bb4:	b2db      	uxtb	r3, r3
 8006bb6:	3b01      	subs	r3, #1
 8006bb8:	bf18      	it	ne
 8006bba:	2301      	movne	r3, #1
 8006bbc:	e7c8      	b.n	8006b50 <HAL_TIM_PWM_Start+0x14>
 8006bbe:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006bc2:	b2db      	uxtb	r3, r3
 8006bc4:	3b01      	subs	r3, #1
 8006bc6:	bf18      	it	ne
 8006bc8:	2301      	movne	r3, #1
 8006bca:	e7c1      	b.n	8006b50 <HAL_TIM_PWM_Start+0x14>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006bcc:	2804      	cmp	r0, #4
 8006bce:	d005      	beq.n	8006bdc <HAL_TIM_PWM_Start+0xa0>
 8006bd0:	2808      	cmp	r0, #8
 8006bd2:	d007      	beq.n	8006be4 <HAL_TIM_PWM_Start+0xa8>
 8006bd4:	2302      	movs	r3, #2
 8006bd6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006bda:	e7c0      	b.n	8006b5e <HAL_TIM_PWM_Start+0x22>
 8006bdc:	2302      	movs	r3, #2
 8006bde:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8006be2:	e7bc      	b.n	8006b5e <HAL_TIM_PWM_Start+0x22>
 8006be4:	2302      	movs	r3, #2
 8006be6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8006bea:	e7b8      	b.n	8006b5e <HAL_TIM_PWM_Start+0x22>
    __HAL_TIM_MOE_ENABLE(htim);
 8006bec:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006bee:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006bf2:	645a      	str	r2, [r3, #68]	; 0x44
 8006bf4:	e7bc      	b.n	8006b70 <HAL_TIM_PWM_Start+0x34>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006bf6:	689a      	ldr	r2, [r3, #8]
 8006bf8:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8006bfc:	2a06      	cmp	r2, #6
 8006bfe:	d007      	beq.n	8006c10 <HAL_TIM_PWM_Start+0xd4>
      __HAL_TIM_ENABLE(htim);
 8006c00:	681a      	ldr	r2, [r3, #0]
 8006c02:	f042 0201 	orr.w	r2, r2, #1
 8006c06:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006c08:	2000      	movs	r0, #0
 8006c0a:	e000      	b.n	8006c0e <HAL_TIM_PWM_Start+0xd2>
    return HAL_ERROR;
 8006c0c:	2001      	movs	r0, #1
}
 8006c0e:	bd10      	pop	{r4, pc}
  return HAL_OK;
 8006c10:	2000      	movs	r0, #0
 8006c12:	e7fc      	b.n	8006c0e <HAL_TIM_PWM_Start+0xd2>
 8006c14:	40012c00 	.word	0x40012c00

08006c18 <HAL_TIM_PWM_Stop>:
{
 8006c18:	b538      	push	{r3, r4, r5, lr}
 8006c1a:	4604      	mov	r4, r0
 8006c1c:	460d      	mov	r5, r1
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8006c1e:	2200      	movs	r2, #0
 8006c20:	6800      	ldr	r0, [r0, #0]
 8006c22:	f7ff fc45 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006c26:	6823      	ldr	r3, [r4, #0]
 8006c28:	4a1b      	ldr	r2, [pc, #108]	; (8006c98 <HAL_TIM_PWM_Stop+0x80>)
 8006c2a:	4293      	cmp	r3, r2
 8006c2c:	d014      	beq.n	8006c58 <HAL_TIM_PWM_Stop+0x40>
  __HAL_TIM_DISABLE(htim);
 8006c2e:	6823      	ldr	r3, [r4, #0]
 8006c30:	6a19      	ldr	r1, [r3, #32]
 8006c32:	f241 1211 	movw	r2, #4369	; 0x1111
 8006c36:	4211      	tst	r1, r2
 8006c38:	d108      	bne.n	8006c4c <HAL_TIM_PWM_Stop+0x34>
 8006c3a:	6a19      	ldr	r1, [r3, #32]
 8006c3c:	f240 4244 	movw	r2, #1092	; 0x444
 8006c40:	4211      	tst	r1, r2
 8006c42:	d103      	bne.n	8006c4c <HAL_TIM_PWM_Stop+0x34>
 8006c44:	681a      	ldr	r2, [r3, #0]
 8006c46:	f022 0201 	bic.w	r2, r2, #1
 8006c4a:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8006c4c:	b99d      	cbnz	r5, 8006c76 <HAL_TIM_PWM_Stop+0x5e>
 8006c4e:	2301      	movs	r3, #1
 8006c50:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 8006c54:	2000      	movs	r0, #0
 8006c56:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_TIM_MOE_DISABLE(htim);
 8006c58:	6a19      	ldr	r1, [r3, #32]
 8006c5a:	f241 1211 	movw	r2, #4369	; 0x1111
 8006c5e:	4211      	tst	r1, r2
 8006c60:	d1e5      	bne.n	8006c2e <HAL_TIM_PWM_Stop+0x16>
 8006c62:	6a19      	ldr	r1, [r3, #32]
 8006c64:	f240 4244 	movw	r2, #1092	; 0x444
 8006c68:	4211      	tst	r1, r2
 8006c6a:	d1e0      	bne.n	8006c2e <HAL_TIM_PWM_Stop+0x16>
 8006c6c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006c6e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8006c72:	645a      	str	r2, [r3, #68]	; 0x44
 8006c74:	e7db      	b.n	8006c2e <HAL_TIM_PWM_Stop+0x16>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8006c76:	2d04      	cmp	r5, #4
 8006c78:	d005      	beq.n	8006c86 <HAL_TIM_PWM_Stop+0x6e>
 8006c7a:	2d08      	cmp	r5, #8
 8006c7c:	d007      	beq.n	8006c8e <HAL_TIM_PWM_Stop+0x76>
 8006c7e:	2301      	movs	r3, #1
 8006c80:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006c84:	e7e6      	b.n	8006c54 <HAL_TIM_PWM_Stop+0x3c>
 8006c86:	2301      	movs	r3, #1
 8006c88:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8006c8c:	e7e2      	b.n	8006c54 <HAL_TIM_PWM_Stop+0x3c>
 8006c8e:	2301      	movs	r3, #1
 8006c90:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8006c94:	e7de      	b.n	8006c54 <HAL_TIM_PWM_Stop+0x3c>
 8006c96:	bf00      	nop
 8006c98:	40012c00 	.word	0x40012c00

08006c9c <HAL_TIM_PWM_Start_IT>:
{
 8006c9c:	b510      	push	{r4, lr}
 8006c9e:	4604      	mov	r4, r0
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8006ca0:	4608      	mov	r0, r1
 8006ca2:	b9b1      	cbnz	r1, 8006cd2 <HAL_TIM_PWM_Start_IT+0x36>
 8006ca4:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8006ca8:	b2db      	uxtb	r3, r3
 8006caa:	3b01      	subs	r3, #1
 8006cac:	bf18      	it	ne
 8006cae:	2301      	movne	r3, #1
 8006cb0:	2b00      	cmp	r3, #0
 8006cb2:	d17c      	bne.n	8006dae <HAL_TIM_PWM_Start_IT+0x112>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006cb4:	bb30      	cbnz	r0, 8006d04 <HAL_TIM_PWM_Start_IT+0x68>
 8006cb6:	2302      	movs	r3, #2
 8006cb8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  switch (Channel)
 8006cbc:	280c      	cmp	r0, #12
 8006cbe:	d836      	bhi.n	8006d2e <HAL_TIM_PWM_Start_IT+0x92>
 8006cc0:	e8df f000 	tbb	[pc, r0]
 8006cc4:	35353530 	.word	0x35353530
 8006cc8:	35353553 	.word	0x35353553
 8006ccc:	35353559 	.word	0x35353559
 8006cd0:	5f          	.byte	0x5f
 8006cd1:	00          	.byte	0x00
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8006cd2:	2904      	cmp	r1, #4
 8006cd4:	d008      	beq.n	8006ce8 <HAL_TIM_PWM_Start_IT+0x4c>
 8006cd6:	2908      	cmp	r1, #8
 8006cd8:	d00d      	beq.n	8006cf6 <HAL_TIM_PWM_Start_IT+0x5a>
 8006cda:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006cde:	b2db      	uxtb	r3, r3
 8006ce0:	3b01      	subs	r3, #1
 8006ce2:	bf18      	it	ne
 8006ce4:	2301      	movne	r3, #1
 8006ce6:	e7e3      	b.n	8006cb0 <HAL_TIM_PWM_Start_IT+0x14>
 8006ce8:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8006cec:	b2db      	uxtb	r3, r3
 8006cee:	3b01      	subs	r3, #1
 8006cf0:	bf18      	it	ne
 8006cf2:	2301      	movne	r3, #1
 8006cf4:	e7dc      	b.n	8006cb0 <HAL_TIM_PWM_Start_IT+0x14>
 8006cf6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006cfa:	b2db      	uxtb	r3, r3
 8006cfc:	3b01      	subs	r3, #1
 8006cfe:	bf18      	it	ne
 8006d00:	2301      	movne	r3, #1
 8006d02:	e7d5      	b.n	8006cb0 <HAL_TIM_PWM_Start_IT+0x14>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006d04:	2804      	cmp	r0, #4
 8006d06:	d005      	beq.n	8006d14 <HAL_TIM_PWM_Start_IT+0x78>
 8006d08:	2808      	cmp	r0, #8
 8006d0a:	d007      	beq.n	8006d1c <HAL_TIM_PWM_Start_IT+0x80>
 8006d0c:	2302      	movs	r3, #2
 8006d0e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006d12:	e7d3      	b.n	8006cbc <HAL_TIM_PWM_Start_IT+0x20>
 8006d14:	2302      	movs	r3, #2
 8006d16:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8006d1a:	e7cf      	b.n	8006cbc <HAL_TIM_PWM_Start_IT+0x20>
 8006d1c:	2302      	movs	r3, #2
 8006d1e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8006d22:	e7cb      	b.n	8006cbc <HAL_TIM_PWM_Start_IT+0x20>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8006d24:	6822      	ldr	r2, [r4, #0]
 8006d26:	68d3      	ldr	r3, [r2, #12]
 8006d28:	f043 0302 	orr.w	r3, r3, #2
 8006d2c:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8006d2e:	2201      	movs	r2, #1
 8006d30:	4601      	mov	r1, r0
 8006d32:	6820      	ldr	r0, [r4, #0]
 8006d34:	f7ff fbbc 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006d38:	6823      	ldr	r3, [r4, #0]
 8006d3a:	4a1f      	ldr	r2, [pc, #124]	; (8006db8 <HAL_TIM_PWM_Start_IT+0x11c>)
 8006d3c:	4293      	cmp	r3, r2
 8006d3e:	d026      	beq.n	8006d8e <HAL_TIM_PWM_Start_IT+0xf2>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006d40:	6823      	ldr	r3, [r4, #0]
 8006d42:	4a1d      	ldr	r2, [pc, #116]	; (8006db8 <HAL_TIM_PWM_Start_IT+0x11c>)
 8006d44:	4293      	cmp	r3, r2
 8006d46:	d027      	beq.n	8006d98 <HAL_TIM_PWM_Start_IT+0xfc>
 8006d48:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006d4c:	d024      	beq.n	8006d98 <HAL_TIM_PWM_Start_IT+0xfc>
 8006d4e:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8006d52:	4293      	cmp	r3, r2
 8006d54:	d020      	beq.n	8006d98 <HAL_TIM_PWM_Start_IT+0xfc>
 8006d56:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8006d5a:	4293      	cmp	r3, r2
 8006d5c:	d01c      	beq.n	8006d98 <HAL_TIM_PWM_Start_IT+0xfc>
    __HAL_TIM_ENABLE(htim);
 8006d5e:	681a      	ldr	r2, [r3, #0]
 8006d60:	f042 0201 	orr.w	r2, r2, #1
 8006d64:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006d66:	2000      	movs	r0, #0
 8006d68:	e022      	b.n	8006db0 <HAL_TIM_PWM_Start_IT+0x114>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8006d6a:	6822      	ldr	r2, [r4, #0]
 8006d6c:	68d3      	ldr	r3, [r2, #12]
 8006d6e:	f043 0304 	orr.w	r3, r3, #4
 8006d72:	60d3      	str	r3, [r2, #12]
      break;
 8006d74:	e7db      	b.n	8006d2e <HAL_TIM_PWM_Start_IT+0x92>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8006d76:	6822      	ldr	r2, [r4, #0]
 8006d78:	68d3      	ldr	r3, [r2, #12]
 8006d7a:	f043 0308 	orr.w	r3, r3, #8
 8006d7e:	60d3      	str	r3, [r2, #12]
      break;
 8006d80:	e7d5      	b.n	8006d2e <HAL_TIM_PWM_Start_IT+0x92>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8006d82:	6822      	ldr	r2, [r4, #0]
 8006d84:	68d3      	ldr	r3, [r2, #12]
 8006d86:	f043 0310 	orr.w	r3, r3, #16
 8006d8a:	60d3      	str	r3, [r2, #12]
      break;
 8006d8c:	e7cf      	b.n	8006d2e <HAL_TIM_PWM_Start_IT+0x92>
    __HAL_TIM_MOE_ENABLE(htim);
 8006d8e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006d90:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006d94:	645a      	str	r2, [r3, #68]	; 0x44
 8006d96:	e7d3      	b.n	8006d40 <HAL_TIM_PWM_Start_IT+0xa4>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006d98:	689a      	ldr	r2, [r3, #8]
 8006d9a:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8006d9e:	2a06      	cmp	r2, #6
 8006da0:	d007      	beq.n	8006db2 <HAL_TIM_PWM_Start_IT+0x116>
      __HAL_TIM_ENABLE(htim);
 8006da2:	681a      	ldr	r2, [r3, #0]
 8006da4:	f042 0201 	orr.w	r2, r2, #1
 8006da8:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006daa:	2000      	movs	r0, #0
 8006dac:	e000      	b.n	8006db0 <HAL_TIM_PWM_Start_IT+0x114>
    return HAL_ERROR;
 8006dae:	2001      	movs	r0, #1
}
 8006db0:	bd10      	pop	{r4, pc}
  return HAL_OK;
 8006db2:	2000      	movs	r0, #0
 8006db4:	e7fc      	b.n	8006db0 <HAL_TIM_PWM_Start_IT+0x114>
 8006db6:	bf00      	nop
 8006db8:	40012c00 	.word	0x40012c00

08006dbc <HAL_TIM_PWM_Stop_IT>:
{
 8006dbc:	b538      	push	{r3, r4, r5, lr}
 8006dbe:	4605      	mov	r5, r0
 8006dc0:	460c      	mov	r4, r1
  switch (Channel)
 8006dc2:	290c      	cmp	r1, #12
 8006dc4:	d80d      	bhi.n	8006de2 <HAL_TIM_PWM_Stop_IT+0x26>
 8006dc6:	e8df f001 	tbb	[pc, r1]
 8006dca:	0c07      	.short	0x0c07
 8006dcc:	0c2a0c0c 	.word	0x0c2a0c0c
 8006dd0:	0c300c0c 	.word	0x0c300c0c
 8006dd4:	0c0c      	.short	0x0c0c
 8006dd6:	36          	.byte	0x36
 8006dd7:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8006dd8:	6802      	ldr	r2, [r0, #0]
 8006dda:	68d3      	ldr	r3, [r2, #12]
 8006ddc:	f023 0302 	bic.w	r3, r3, #2
 8006de0:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8006de2:	2200      	movs	r2, #0
 8006de4:	4621      	mov	r1, r4
 8006de6:	6828      	ldr	r0, [r5, #0]
 8006de8:	f7ff fb62 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006dec:	682b      	ldr	r3, [r5, #0]
 8006dee:	4a24      	ldr	r2, [pc, #144]	; (8006e80 <HAL_TIM_PWM_Stop_IT+0xc4>)
 8006df0:	4293      	cmp	r3, r2
 8006df2:	d026      	beq.n	8006e42 <HAL_TIM_PWM_Stop_IT+0x86>
  __HAL_TIM_DISABLE(htim);
 8006df4:	682b      	ldr	r3, [r5, #0]
 8006df6:	6a19      	ldr	r1, [r3, #32]
 8006df8:	f241 1211 	movw	r2, #4369	; 0x1111
 8006dfc:	4211      	tst	r1, r2
 8006dfe:	d108      	bne.n	8006e12 <HAL_TIM_PWM_Stop_IT+0x56>
 8006e00:	6a19      	ldr	r1, [r3, #32]
 8006e02:	f240 4244 	movw	r2, #1092	; 0x444
 8006e06:	4211      	tst	r1, r2
 8006e08:	d103      	bne.n	8006e12 <HAL_TIM_PWM_Stop_IT+0x56>
 8006e0a:	681a      	ldr	r2, [r3, #0]
 8006e0c:	f022 0201 	bic.w	r2, r2, #1
 8006e10:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8006e12:	bb2c      	cbnz	r4, 8006e60 <HAL_TIM_PWM_Stop_IT+0xa4>
 8006e14:	2301      	movs	r3, #1
 8006e16:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
}
 8006e1a:	2000      	movs	r0, #0
 8006e1c:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8006e1e:	6802      	ldr	r2, [r0, #0]
 8006e20:	68d3      	ldr	r3, [r2, #12]
 8006e22:	f023 0304 	bic.w	r3, r3, #4
 8006e26:	60d3      	str	r3, [r2, #12]
      break;
 8006e28:	e7db      	b.n	8006de2 <HAL_TIM_PWM_Stop_IT+0x26>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8006e2a:	6802      	ldr	r2, [r0, #0]
 8006e2c:	68d3      	ldr	r3, [r2, #12]
 8006e2e:	f023 0308 	bic.w	r3, r3, #8
 8006e32:	60d3      	str	r3, [r2, #12]
      break;
 8006e34:	e7d5      	b.n	8006de2 <HAL_TIM_PWM_Stop_IT+0x26>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8006e36:	6802      	ldr	r2, [r0, #0]
 8006e38:	68d3      	ldr	r3, [r2, #12]
 8006e3a:	f023 0310 	bic.w	r3, r3, #16
 8006e3e:	60d3      	str	r3, [r2, #12]
      break;
 8006e40:	e7cf      	b.n	8006de2 <HAL_TIM_PWM_Stop_IT+0x26>
    __HAL_TIM_MOE_DISABLE(htim);
 8006e42:	6a19      	ldr	r1, [r3, #32]
 8006e44:	f241 1211 	movw	r2, #4369	; 0x1111
 8006e48:	4211      	tst	r1, r2
 8006e4a:	d1d3      	bne.n	8006df4 <HAL_TIM_PWM_Stop_IT+0x38>
 8006e4c:	6a19      	ldr	r1, [r3, #32]
 8006e4e:	f240 4244 	movw	r2, #1092	; 0x444
 8006e52:	4211      	tst	r1, r2
 8006e54:	d1ce      	bne.n	8006df4 <HAL_TIM_PWM_Stop_IT+0x38>
 8006e56:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006e58:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8006e5c:	645a      	str	r2, [r3, #68]	; 0x44
 8006e5e:	e7c9      	b.n	8006df4 <HAL_TIM_PWM_Stop_IT+0x38>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8006e60:	2c04      	cmp	r4, #4
 8006e62:	d005      	beq.n	8006e70 <HAL_TIM_PWM_Stop_IT+0xb4>
 8006e64:	2c08      	cmp	r4, #8
 8006e66:	d007      	beq.n	8006e78 <HAL_TIM_PWM_Stop_IT+0xbc>
 8006e68:	2301      	movs	r3, #1
 8006e6a:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 8006e6e:	e7d4      	b.n	8006e1a <HAL_TIM_PWM_Stop_IT+0x5e>
 8006e70:	2301      	movs	r3, #1
 8006e72:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
 8006e76:	e7d0      	b.n	8006e1a <HAL_TIM_PWM_Stop_IT+0x5e>
 8006e78:	2301      	movs	r3, #1
 8006e7a:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
 8006e7e:	e7cc      	b.n	8006e1a <HAL_TIM_PWM_Stop_IT+0x5e>
 8006e80:	40012c00 	.word	0x40012c00

08006e84 <HAL_TIM_PWM_Start_DMA>:
{
 8006e84:	b570      	push	{r4, r5, r6, lr}
 8006e86:	4604      	mov	r4, r0
 8006e88:	4616      	mov	r6, r2
  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 8006e8a:	460d      	mov	r5, r1
 8006e8c:	2900      	cmp	r1, #0
 8006e8e:	d12d      	bne.n	8006eec <HAL_TIM_PWM_Start_DMA+0x68>
 8006e90:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8006e94:	b2c0      	uxtb	r0, r0
 8006e96:	2802      	cmp	r0, #2
 8006e98:	bf14      	ite	ne
 8006e9a:	2000      	movne	r0, #0
 8006e9c:	2001      	moveq	r0, #1
 8006e9e:	2800      	cmp	r0, #0
 8006ea0:	f040 80f8 	bne.w	8007094 <HAL_TIM_PWM_Start_DMA+0x210>
  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 8006ea4:	2d00      	cmp	r5, #0
 8006ea6:	d13d      	bne.n	8006f24 <HAL_TIM_PWM_Start_DMA+0xa0>
 8006ea8:	f894 203e 	ldrb.w	r2, [r4, #62]	; 0x3e
 8006eac:	b2d2      	uxtb	r2, r2
 8006eae:	2a01      	cmp	r2, #1
 8006eb0:	bf14      	ite	ne
 8006eb2:	2200      	movne	r2, #0
 8006eb4:	2201      	moveq	r2, #1
 8006eb6:	2a00      	cmp	r2, #0
 8006eb8:	f000 80ee 	beq.w	8007098 <HAL_TIM_PWM_Start_DMA+0x214>
    if ((pData == NULL) && (Length > 0U))
 8006ebc:	2e00      	cmp	r6, #0
 8006ebe:	d04d      	beq.n	8006f5c <HAL_TIM_PWM_Start_DMA+0xd8>
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006ec0:	2d00      	cmp	r5, #0
 8006ec2:	d14f      	bne.n	8006f64 <HAL_TIM_PWM_Start_DMA+0xe0>
 8006ec4:	2202      	movs	r2, #2
 8006ec6:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
  switch (Channel)
 8006eca:	2d0c      	cmp	r5, #12
 8006ecc:	d870      	bhi.n	8006fb0 <HAL_TIM_PWM_Start_DMA+0x12c>
 8006ece:	e8df f015 	tbh	[pc, r5, lsl #1]
 8006ed2:	0059      	.short	0x0059
 8006ed4:	006f006f 	.word	0x006f006f
 8006ed8:	008d006f 	.word	0x008d006f
 8006edc:	006f006f 	.word	0x006f006f
 8006ee0:	00a4006f 	.word	0x00a4006f
 8006ee4:	006f006f 	.word	0x006f006f
 8006ee8:	00bb006f 	.word	0x00bb006f
  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 8006eec:	2904      	cmp	r1, #4
 8006eee:	d009      	beq.n	8006f04 <HAL_TIM_PWM_Start_DMA+0x80>
 8006ef0:	2908      	cmp	r1, #8
 8006ef2:	d00f      	beq.n	8006f14 <HAL_TIM_PWM_Start_DMA+0x90>
 8006ef4:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
 8006ef8:	b2c0      	uxtb	r0, r0
 8006efa:	2802      	cmp	r0, #2
 8006efc:	bf14      	ite	ne
 8006efe:	2000      	movne	r0, #0
 8006f00:	2001      	moveq	r0, #1
 8006f02:	e7cc      	b.n	8006e9e <HAL_TIM_PWM_Start_DMA+0x1a>
 8006f04:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 8006f08:	b2c0      	uxtb	r0, r0
 8006f0a:	2802      	cmp	r0, #2
 8006f0c:	bf14      	ite	ne
 8006f0e:	2000      	movne	r0, #0
 8006f10:	2001      	moveq	r0, #1
 8006f12:	e7c4      	b.n	8006e9e <HAL_TIM_PWM_Start_DMA+0x1a>
 8006f14:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
 8006f18:	b2c0      	uxtb	r0, r0
 8006f1a:	2802      	cmp	r0, #2
 8006f1c:	bf14      	ite	ne
 8006f1e:	2000      	movne	r0, #0
 8006f20:	2001      	moveq	r0, #1
 8006f22:	e7bc      	b.n	8006e9e <HAL_TIM_PWM_Start_DMA+0x1a>
  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 8006f24:	2d04      	cmp	r5, #4
 8006f26:	d009      	beq.n	8006f3c <HAL_TIM_PWM_Start_DMA+0xb8>
 8006f28:	2d08      	cmp	r5, #8
 8006f2a:	d00f      	beq.n	8006f4c <HAL_TIM_PWM_Start_DMA+0xc8>
 8006f2c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8006f30:	b2d2      	uxtb	r2, r2
 8006f32:	2a01      	cmp	r2, #1
 8006f34:	bf14      	ite	ne
 8006f36:	2200      	movne	r2, #0
 8006f38:	2201      	moveq	r2, #1
 8006f3a:	e7bc      	b.n	8006eb6 <HAL_TIM_PWM_Start_DMA+0x32>
 8006f3c:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
 8006f40:	b2d2      	uxtb	r2, r2
 8006f42:	2a01      	cmp	r2, #1
 8006f44:	bf14      	ite	ne
 8006f46:	2200      	movne	r2, #0
 8006f48:	2201      	moveq	r2, #1
 8006f4a:	e7b4      	b.n	8006eb6 <HAL_TIM_PWM_Start_DMA+0x32>
 8006f4c:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8006f50:	b2d2      	uxtb	r2, r2
 8006f52:	2a01      	cmp	r2, #1
 8006f54:	bf14      	ite	ne
 8006f56:	2200      	movne	r2, #0
 8006f58:	2201      	moveq	r2, #1
 8006f5a:	e7ac      	b.n	8006eb6 <HAL_TIM_PWM_Start_DMA+0x32>
    if ((pData == NULL) && (Length > 0U))
 8006f5c:	2b00      	cmp	r3, #0
 8006f5e:	d0af      	beq.n	8006ec0 <HAL_TIM_PWM_Start_DMA+0x3c>
      return HAL_ERROR;
 8006f60:	2001      	movs	r0, #1
 8006f62:	e09a      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8006f64:	2d04      	cmp	r5, #4
 8006f66:	d005      	beq.n	8006f74 <HAL_TIM_PWM_Start_DMA+0xf0>
 8006f68:	2d08      	cmp	r5, #8
 8006f6a:	d007      	beq.n	8006f7c <HAL_TIM_PWM_Start_DMA+0xf8>
 8006f6c:	2202      	movs	r2, #2
 8006f6e:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
 8006f72:	e7aa      	b.n	8006eca <HAL_TIM_PWM_Start_DMA+0x46>
 8006f74:	2202      	movs	r2, #2
 8006f76:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
 8006f7a:	e7a6      	b.n	8006eca <HAL_TIM_PWM_Start_DMA+0x46>
 8006f7c:	2202      	movs	r2, #2
 8006f7e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 8006f82:	e7a2      	b.n	8006eca <HAL_TIM_PWM_Start_DMA+0x46>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8006f84:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006f86:	494a      	ldr	r1, [pc, #296]	; (80070b0 <HAL_TIM_PWM_Start_DMA+0x22c>)
 8006f88:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8006f8a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006f8c:	4949      	ldr	r1, [pc, #292]	; (80070b4 <HAL_TIM_PWM_Start_DMA+0x230>)
 8006f8e:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 8006f90:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006f92:	4949      	ldr	r1, [pc, #292]	; (80070b8 <HAL_TIM_PWM_Start_DMA+0x234>)
 8006f94:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
 8006f96:	6822      	ldr	r2, [r4, #0]
 8006f98:	3234      	adds	r2, #52	; 0x34
 8006f9a:	4631      	mov	r1, r6
 8006f9c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006f9e:	f7fc fc5f 	bl	8003860 <HAL_DMA_Start_IT>
 8006fa2:	2800      	cmp	r0, #0
 8006fa4:	d17a      	bne.n	800709c <HAL_TIM_PWM_Start_DMA+0x218>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 8006fa6:	6822      	ldr	r2, [r4, #0]
 8006fa8:	68d3      	ldr	r3, [r2, #12]
 8006faa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8006fae:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8006fb0:	2201      	movs	r2, #1
 8006fb2:	4629      	mov	r1, r5
 8006fb4:	6820      	ldr	r0, [r4, #0]
 8006fb6:	f7ff fa7b 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8006fba:	6823      	ldr	r3, [r4, #0]
 8006fbc:	4a3f      	ldr	r2, [pc, #252]	; (80070bc <HAL_TIM_PWM_Start_DMA+0x238>)
 8006fbe:	4293      	cmp	r3, r2
 8006fc0:	d058      	beq.n	8007074 <HAL_TIM_PWM_Start_DMA+0x1f0>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006fc2:	6823      	ldr	r3, [r4, #0]
 8006fc4:	4a3d      	ldr	r2, [pc, #244]	; (80070bc <HAL_TIM_PWM_Start_DMA+0x238>)
 8006fc6:	4293      	cmp	r3, r2
 8006fc8:	d059      	beq.n	800707e <HAL_TIM_PWM_Start_DMA+0x1fa>
 8006fca:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006fce:	d056      	beq.n	800707e <HAL_TIM_PWM_Start_DMA+0x1fa>
 8006fd0:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8006fd4:	4293      	cmp	r3, r2
 8006fd6:	d052      	beq.n	800707e <HAL_TIM_PWM_Start_DMA+0x1fa>
 8006fd8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8006fdc:	4293      	cmp	r3, r2
 8006fde:	d04e      	beq.n	800707e <HAL_TIM_PWM_Start_DMA+0x1fa>
    __HAL_TIM_ENABLE(htim);
 8006fe0:	681a      	ldr	r2, [r3, #0]
 8006fe2:	f042 0201 	orr.w	r2, r2, #1
 8006fe6:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8006fe8:	2000      	movs	r0, #0
 8006fea:	e056      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8006fec:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006fee:	4930      	ldr	r1, [pc, #192]	; (80070b0 <HAL_TIM_PWM_Start_DMA+0x22c>)
 8006ff0:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8006ff2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006ff4:	492f      	ldr	r1, [pc, #188]	; (80070b4 <HAL_TIM_PWM_Start_DMA+0x230>)
 8006ff6:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 8006ff8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006ffa:	492f      	ldr	r1, [pc, #188]	; (80070b8 <HAL_TIM_PWM_Start_DMA+0x234>)
 8006ffc:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
 8006ffe:	6822      	ldr	r2, [r4, #0]
 8007000:	3238      	adds	r2, #56	; 0x38
 8007002:	4631      	mov	r1, r6
 8007004:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8007006:	f7fc fc2b 	bl	8003860 <HAL_DMA_Start_IT>
 800700a:	2800      	cmp	r0, #0
 800700c:	d148      	bne.n	80070a0 <HAL_TIM_PWM_Start_DMA+0x21c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 800700e:	6822      	ldr	r2, [r4, #0]
 8007010:	68d3      	ldr	r3, [r2, #12]
 8007012:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8007016:	60d3      	str	r3, [r2, #12]
      break;
 8007018:	e7ca      	b.n	8006fb0 <HAL_TIM_PWM_Start_DMA+0x12c>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
 800701a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800701c:	4924      	ldr	r1, [pc, #144]	; (80070b0 <HAL_TIM_PWM_Start_DMA+0x22c>)
 800701e:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8007020:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007022:	4924      	ldr	r1, [pc, #144]	; (80070b4 <HAL_TIM_PWM_Start_DMA+0x230>)
 8007024:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
 8007026:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007028:	4923      	ldr	r1, [pc, #140]	; (80070b8 <HAL_TIM_PWM_Start_DMA+0x234>)
 800702a:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
 800702c:	6822      	ldr	r2, [r4, #0]
 800702e:	323c      	adds	r2, #60	; 0x3c
 8007030:	4631      	mov	r1, r6
 8007032:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8007034:	f7fc fc14 	bl	8003860 <HAL_DMA_Start_IT>
 8007038:	2800      	cmp	r0, #0
 800703a:	d133      	bne.n	80070a4 <HAL_TIM_PWM_Start_DMA+0x220>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
 800703c:	6822      	ldr	r2, [r4, #0]
 800703e:	68d3      	ldr	r3, [r2, #12]
 8007040:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8007044:	60d3      	str	r3, [r2, #12]
      break;
 8007046:	e7b3      	b.n	8006fb0 <HAL_TIM_PWM_Start_DMA+0x12c>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
 8007048:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800704a:	4919      	ldr	r1, [pc, #100]	; (80070b0 <HAL_TIM_PWM_Start_DMA+0x22c>)
 800704c:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 800704e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8007050:	4918      	ldr	r1, [pc, #96]	; (80070b4 <HAL_TIM_PWM_Start_DMA+0x230>)
 8007052:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
 8007054:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8007056:	4918      	ldr	r1, [pc, #96]	; (80070b8 <HAL_TIM_PWM_Start_DMA+0x234>)
 8007058:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,
 800705a:	6822      	ldr	r2, [r4, #0]
 800705c:	3240      	adds	r2, #64	; 0x40
 800705e:	4631      	mov	r1, r6
 8007060:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8007062:	f7fc fbfd 	bl	8003860 <HAL_DMA_Start_IT>
 8007066:	b9f8      	cbnz	r0, 80070a8 <HAL_TIM_PWM_Start_DMA+0x224>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
 8007068:	6822      	ldr	r2, [r4, #0]
 800706a:	68d3      	ldr	r3, [r2, #12]
 800706c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8007070:	60d3      	str	r3, [r2, #12]
      break;
 8007072:	e79d      	b.n	8006fb0 <HAL_TIM_PWM_Start_DMA+0x12c>
    __HAL_TIM_MOE_ENABLE(htim);
 8007074:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8007076:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800707a:	645a      	str	r2, [r3, #68]	; 0x44
 800707c:	e7a1      	b.n	8006fc2 <HAL_TIM_PWM_Start_DMA+0x13e>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800707e:	689a      	ldr	r2, [r3, #8]
 8007080:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007084:	2a06      	cmp	r2, #6
 8007086:	d011      	beq.n	80070ac <HAL_TIM_PWM_Start_DMA+0x228>
      __HAL_TIM_ENABLE(htim);
 8007088:	681a      	ldr	r2, [r3, #0]
 800708a:	f042 0201 	orr.w	r2, r2, #1
 800708e:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8007090:	2000      	movs	r0, #0
 8007092:	e002      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
    return HAL_BUSY;
 8007094:	2002      	movs	r0, #2
 8007096:	e000      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
    return HAL_ERROR;
 8007098:	2001      	movs	r0, #1
}
 800709a:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 800709c:	2001      	movs	r0, #1
 800709e:	e7fc      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
        return HAL_ERROR;
 80070a0:	2001      	movs	r0, #1
 80070a2:	e7fa      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
        return HAL_ERROR;
 80070a4:	2001      	movs	r0, #1
 80070a6:	e7f8      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
        return HAL_ERROR;
 80070a8:	2001      	movs	r0, #1
 80070aa:	e7f6      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
  return HAL_OK;
 80070ac:	2000      	movs	r0, #0
 80070ae:	e7f4      	b.n	800709a <HAL_TIM_PWM_Start_DMA+0x216>
 80070b0:	08005845 	.word	0x08005845
 80070b4:	080058b7 	.word	0x080058b7
 80070b8:	08005a95 	.word	0x08005a95
 80070bc:	40012c00 	.word	0x40012c00

080070c0 <HAL_TIM_PWM_Stop_DMA>:
{
 80070c0:	b538      	push	{r3, r4, r5, lr}
 80070c2:	4604      	mov	r4, r0
 80070c4:	460d      	mov	r5, r1
  switch (Channel)
 80070c6:	290c      	cmp	r1, #12
 80070c8:	d810      	bhi.n	80070ec <HAL_TIM_PWM_Stop_DMA+0x2c>
 80070ca:	e8df f001 	tbb	[pc, r1]
 80070ce:	0f07      	.short	0x0f07
 80070d0:	0f2e0f0f 	.word	0x0f2e0f0f
 80070d4:	0f370f0f 	.word	0x0f370f0f
 80070d8:	0f0f      	.short	0x0f0f
 80070da:	40          	.byte	0x40
 80070db:	00          	.byte	0x00
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 80070dc:	6802      	ldr	r2, [r0, #0]
 80070de:	68d3      	ldr	r3, [r2, #12]
 80070e0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80070e4:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 80070e6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80070e8:	f7fc fc16 	bl	8003918 <HAL_DMA_Abort_IT>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 80070ec:	2200      	movs	r2, #0
 80070ee:	4629      	mov	r1, r5
 80070f0:	6820      	ldr	r0, [r4, #0]
 80070f2:	f7ff f9dd 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80070f6:	6823      	ldr	r3, [r4, #0]
 80070f8:	4a29      	ldr	r2, [pc, #164]	; (80071a0 <HAL_TIM_PWM_Stop_DMA+0xe0>)
 80070fa:	4293      	cmp	r3, r2
 80070fc:	d030      	beq.n	8007160 <HAL_TIM_PWM_Stop_DMA+0xa0>
  __HAL_TIM_DISABLE(htim);
 80070fe:	6823      	ldr	r3, [r4, #0]
 8007100:	6a19      	ldr	r1, [r3, #32]
 8007102:	f241 1211 	movw	r2, #4369	; 0x1111
 8007106:	4211      	tst	r1, r2
 8007108:	d108      	bne.n	800711c <HAL_TIM_PWM_Stop_DMA+0x5c>
 800710a:	6a19      	ldr	r1, [r3, #32]
 800710c:	f240 4244 	movw	r2, #1092	; 0x444
 8007110:	4211      	tst	r1, r2
 8007112:	d103      	bne.n	800711c <HAL_TIM_PWM_Stop_DMA+0x5c>
 8007114:	681a      	ldr	r2, [r3, #0]
 8007116:	f022 0201 	bic.w	r2, r2, #1
 800711a:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 800711c:	2d00      	cmp	r5, #0
 800711e:	d12e      	bne.n	800717e <HAL_TIM_PWM_Stop_DMA+0xbe>
 8007120:	2301      	movs	r3, #1
 8007122:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 8007126:	2000      	movs	r0, #0
 8007128:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 800712a:	6802      	ldr	r2, [r0, #0]
 800712c:	68d3      	ldr	r3, [r2, #12]
 800712e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007132:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 8007134:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8007136:	f7fc fbef 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 800713a:	e7d7      	b.n	80070ec <HAL_TIM_PWM_Stop_DMA+0x2c>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
 800713c:	6802      	ldr	r2, [r0, #0]
 800713e:	68d3      	ldr	r3, [r2, #12]
 8007140:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8007144:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 8007146:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8007148:	f7fc fbe6 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 800714c:	e7ce      	b.n	80070ec <HAL_TIM_PWM_Stop_DMA+0x2c>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
 800714e:	6802      	ldr	r2, [r0, #0]
 8007150:	68d3      	ldr	r3, [r2, #12]
 8007152:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8007156:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
 8007158:	6b00      	ldr	r0, [r0, #48]	; 0x30
 800715a:	f7fc fbdd 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 800715e:	e7c5      	b.n	80070ec <HAL_TIM_PWM_Stop_DMA+0x2c>
    __HAL_TIM_MOE_DISABLE(htim);
 8007160:	6a19      	ldr	r1, [r3, #32]
 8007162:	f241 1211 	movw	r2, #4369	; 0x1111
 8007166:	4211      	tst	r1, r2
 8007168:	d1c9      	bne.n	80070fe <HAL_TIM_PWM_Stop_DMA+0x3e>
 800716a:	6a19      	ldr	r1, [r3, #32]
 800716c:	f240 4244 	movw	r2, #1092	; 0x444
 8007170:	4211      	tst	r1, r2
 8007172:	d1c4      	bne.n	80070fe <HAL_TIM_PWM_Stop_DMA+0x3e>
 8007174:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8007176:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800717a:	645a      	str	r2, [r3, #68]	; 0x44
 800717c:	e7bf      	b.n	80070fe <HAL_TIM_PWM_Stop_DMA+0x3e>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 800717e:	2d04      	cmp	r5, #4
 8007180:	d005      	beq.n	800718e <HAL_TIM_PWM_Stop_DMA+0xce>
 8007182:	2d08      	cmp	r5, #8
 8007184:	d007      	beq.n	8007196 <HAL_TIM_PWM_Stop_DMA+0xd6>
 8007186:	2301      	movs	r3, #1
 8007188:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 800718c:	e7cb      	b.n	8007126 <HAL_TIM_PWM_Stop_DMA+0x66>
 800718e:	2301      	movs	r3, #1
 8007190:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007194:	e7c7      	b.n	8007126 <HAL_TIM_PWM_Stop_DMA+0x66>
 8007196:	2301      	movs	r3, #1
 8007198:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800719c:	e7c3      	b.n	8007126 <HAL_TIM_PWM_Stop_DMA+0x66>
 800719e:	bf00      	nop
 80071a0:	40012c00 	.word	0x40012c00

080071a4 <HAL_TIM_IC_Start>:
{
 80071a4:	b510      	push	{r4, lr}
 80071a6:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 80071a8:	460b      	mov	r3, r1
 80071aa:	bb79      	cbnz	r1, 800720c <HAL_TIM_IC_Start+0x68>
 80071ac:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 80071b0:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 80071b2:	2b00      	cmp	r3, #0
 80071b4:	d13a      	bne.n	800722c <HAL_TIM_IC_Start+0x88>
 80071b6:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 80071ba:	b2d2      	uxtb	r2, r2
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
 80071bc:	2801      	cmp	r0, #1
 80071be:	d170      	bne.n	80072a2 <HAL_TIM_IC_Start+0xfe>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
 80071c0:	2a01      	cmp	r2, #1
 80071c2:	d16f      	bne.n	80072a4 <HAL_TIM_IC_Start+0x100>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80071c4:	2b00      	cmp	r3, #0
 80071c6:	d141      	bne.n	800724c <HAL_TIM_IC_Start+0xa8>
 80071c8:	2202      	movs	r2, #2
 80071ca:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80071ce:	2b00      	cmp	r3, #0
 80071d0:	d14c      	bne.n	800726c <HAL_TIM_IC_Start+0xc8>
 80071d2:	2202      	movs	r2, #2
 80071d4:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80071d8:	2201      	movs	r2, #1
 80071da:	4619      	mov	r1, r3
 80071dc:	6820      	ldr	r0, [r4, #0]
 80071de:	f7ff f967 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80071e2:	6823      	ldr	r3, [r4, #0]
 80071e4:	4a31      	ldr	r2, [pc, #196]	; (80072ac <HAL_TIM_IC_Start+0x108>)
 80071e6:	4293      	cmp	r3, r2
 80071e8:	d050      	beq.n	800728c <HAL_TIM_IC_Start+0xe8>
 80071ea:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80071ee:	d04d      	beq.n	800728c <HAL_TIM_IC_Start+0xe8>
 80071f0:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80071f4:	4293      	cmp	r3, r2
 80071f6:	d049      	beq.n	800728c <HAL_TIM_IC_Start+0xe8>
 80071f8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80071fc:	4293      	cmp	r3, r2
 80071fe:	d045      	beq.n	800728c <HAL_TIM_IC_Start+0xe8>
    __HAL_TIM_ENABLE(htim);
 8007200:	681a      	ldr	r2, [r3, #0]
 8007202:	f042 0201 	orr.w	r2, r2, #1
 8007206:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8007208:	2000      	movs	r0, #0
 800720a:	e04b      	b.n	80072a4 <HAL_TIM_IC_Start+0x100>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 800720c:	2904      	cmp	r1, #4
 800720e:	d005      	beq.n	800721c <HAL_TIM_IC_Start+0x78>
 8007210:	2908      	cmp	r1, #8
 8007212:	d007      	beq.n	8007224 <HAL_TIM_IC_Start+0x80>
 8007214:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
 8007218:	b2c0      	uxtb	r0, r0
 800721a:	e7ca      	b.n	80071b2 <HAL_TIM_IC_Start+0xe>
 800721c:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 8007220:	b2c0      	uxtb	r0, r0
 8007222:	e7c6      	b.n	80071b2 <HAL_TIM_IC_Start+0xe>
 8007224:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
 8007228:	b2c0      	uxtb	r0, r0
 800722a:	e7c2      	b.n	80071b2 <HAL_TIM_IC_Start+0xe>
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 800722c:	2b04      	cmp	r3, #4
 800722e:	d005      	beq.n	800723c <HAL_TIM_IC_Start+0x98>
 8007230:	2b08      	cmp	r3, #8
 8007232:	d007      	beq.n	8007244 <HAL_TIM_IC_Start+0xa0>
 8007234:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 8007238:	b2d2      	uxtb	r2, r2
 800723a:	e7bf      	b.n	80071bc <HAL_TIM_IC_Start+0x18>
 800723c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8007240:	b2d2      	uxtb	r2, r2
 8007242:	e7bb      	b.n	80071bc <HAL_TIM_IC_Start+0x18>
 8007244:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8007248:	b2d2      	uxtb	r2, r2
 800724a:	e7b7      	b.n	80071bc <HAL_TIM_IC_Start+0x18>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800724c:	2b04      	cmp	r3, #4
 800724e:	d005      	beq.n	800725c <HAL_TIM_IC_Start+0xb8>
 8007250:	2b08      	cmp	r3, #8
 8007252:	d007      	beq.n	8007264 <HAL_TIM_IC_Start+0xc0>
 8007254:	2202      	movs	r2, #2
 8007256:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
 800725a:	e7b8      	b.n	80071ce <HAL_TIM_IC_Start+0x2a>
 800725c:	2202      	movs	r2, #2
 800725e:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
 8007262:	e7b4      	b.n	80071ce <HAL_TIM_IC_Start+0x2a>
 8007264:	2202      	movs	r2, #2
 8007266:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 800726a:	e7b0      	b.n	80071ce <HAL_TIM_IC_Start+0x2a>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800726c:	2b04      	cmp	r3, #4
 800726e:	d005      	beq.n	800727c <HAL_TIM_IC_Start+0xd8>
 8007270:	2b08      	cmp	r3, #8
 8007272:	d007      	beq.n	8007284 <HAL_TIM_IC_Start+0xe0>
 8007274:	2202      	movs	r2, #2
 8007276:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 800727a:	e7ad      	b.n	80071d8 <HAL_TIM_IC_Start+0x34>
 800727c:	2202      	movs	r2, #2
 800727e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8007282:	e7a9      	b.n	80071d8 <HAL_TIM_IC_Start+0x34>
 8007284:	2202      	movs	r2, #2
 8007286:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
 800728a:	e7a5      	b.n	80071d8 <HAL_TIM_IC_Start+0x34>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800728c:	689a      	ldr	r2, [r3, #8]
 800728e:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007292:	2a06      	cmp	r2, #6
 8007294:	d007      	beq.n	80072a6 <HAL_TIM_IC_Start+0x102>
      __HAL_TIM_ENABLE(htim);
 8007296:	681a      	ldr	r2, [r3, #0]
 8007298:	f042 0201 	orr.w	r2, r2, #1
 800729c:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800729e:	2000      	movs	r0, #0
 80072a0:	e000      	b.n	80072a4 <HAL_TIM_IC_Start+0x100>
    return HAL_ERROR;
 80072a2:	2001      	movs	r0, #1
}
 80072a4:	bd10      	pop	{r4, pc}
  return HAL_OK;
 80072a6:	2000      	movs	r0, #0
 80072a8:	e7fc      	b.n	80072a4 <HAL_TIM_IC_Start+0x100>
 80072aa:	bf00      	nop
 80072ac:	40012c00 	.word	0x40012c00

080072b0 <HAL_TIM_IC_Stop>:
{
 80072b0:	b538      	push	{r3, r4, r5, lr}
 80072b2:	4604      	mov	r4, r0
 80072b4:	460d      	mov	r5, r1
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 80072b6:	2200      	movs	r2, #0
 80072b8:	6800      	ldr	r0, [r0, #0]
 80072ba:	f7ff f8f9 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
 80072be:	6823      	ldr	r3, [r4, #0]
 80072c0:	6a19      	ldr	r1, [r3, #32]
 80072c2:	f241 1211 	movw	r2, #4369	; 0x1111
 80072c6:	4211      	tst	r1, r2
 80072c8:	d108      	bne.n	80072dc <HAL_TIM_IC_Stop+0x2c>
 80072ca:	6a19      	ldr	r1, [r3, #32]
 80072cc:	f240 4244 	movw	r2, #1092	; 0x444
 80072d0:	4211      	tst	r1, r2
 80072d2:	d103      	bne.n	80072dc <HAL_TIM_IC_Stop+0x2c>
 80072d4:	681a      	ldr	r2, [r3, #0]
 80072d6:	f022 0201 	bic.w	r2, r2, #1
 80072da:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80072dc:	b945      	cbnz	r5, 80072f0 <HAL_TIM_IC_Stop+0x40>
 80072de:	2301      	movs	r3, #1
 80072e0:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80072e4:	b9a5      	cbnz	r5, 8007310 <HAL_TIM_IC_Stop+0x60>
 80072e6:	2301      	movs	r3, #1
 80072e8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 80072ec:	2000      	movs	r0, #0
 80072ee:	bd38      	pop	{r3, r4, r5, pc}
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80072f0:	2d04      	cmp	r5, #4
 80072f2:	d005      	beq.n	8007300 <HAL_TIM_IC_Stop+0x50>
 80072f4:	2d08      	cmp	r5, #8
 80072f6:	d007      	beq.n	8007308 <HAL_TIM_IC_Stop+0x58>
 80072f8:	2301      	movs	r3, #1
 80072fa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80072fe:	e7f1      	b.n	80072e4 <HAL_TIM_IC_Stop+0x34>
 8007300:	2301      	movs	r3, #1
 8007302:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007306:	e7ed      	b.n	80072e4 <HAL_TIM_IC_Stop+0x34>
 8007308:	2301      	movs	r3, #1
 800730a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800730e:	e7e9      	b.n	80072e4 <HAL_TIM_IC_Stop+0x34>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007310:	2d04      	cmp	r5, #4
 8007312:	d005      	beq.n	8007320 <HAL_TIM_IC_Stop+0x70>
 8007314:	2d08      	cmp	r5, #8
 8007316:	d007      	beq.n	8007328 <HAL_TIM_IC_Stop+0x78>
 8007318:	2301      	movs	r3, #1
 800731a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800731e:	e7e5      	b.n	80072ec <HAL_TIM_IC_Stop+0x3c>
 8007320:	2301      	movs	r3, #1
 8007322:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007326:	e7e1      	b.n	80072ec <HAL_TIM_IC_Stop+0x3c>
 8007328:	2301      	movs	r3, #1
 800732a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800732e:	e7dd      	b.n	80072ec <HAL_TIM_IC_Stop+0x3c>

08007330 <HAL_TIM_IC_Start_IT>:
{
 8007330:	b510      	push	{r4, lr}
 8007332:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8007334:	460b      	mov	r3, r1
 8007336:	bb01      	cbnz	r1, 800737a <HAL_TIM_IC_Start_IT+0x4a>
 8007338:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 800733c:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 800733e:	bb63      	cbnz	r3, 800739a <HAL_TIM_IC_Start_IT+0x6a>
 8007340:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8007344:	b2d2      	uxtb	r2, r2
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
 8007346:	2801      	cmp	r0, #1
 8007348:	f040 8093 	bne.w	8007472 <HAL_TIM_IC_Start_IT+0x142>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
 800734c:	2a01      	cmp	r2, #1
 800734e:	f040 8091 	bne.w	8007474 <HAL_TIM_IC_Start_IT+0x144>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8007352:	bb93      	cbnz	r3, 80073ba <HAL_TIM_IC_Start_IT+0x8a>
 8007354:	2202      	movs	r2, #2
 8007356:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800735a:	2b00      	cmp	r3, #0
 800735c:	d13d      	bne.n	80073da <HAL_TIM_IC_Start_IT+0xaa>
 800735e:	2202      	movs	r2, #2
 8007360:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  switch (Channel)
 8007364:	2b0c      	cmp	r3, #12
 8007366:	d84d      	bhi.n	8007404 <HAL_TIM_IC_Start_IT+0xd4>
 8007368:	e8df f003 	tbb	[pc, r3]
 800736c:	4c4c4c47 	.word	0x4c4c4c47
 8007370:	4c4c4c66 	.word	0x4c4c4c66
 8007374:	4c4c4c6c 	.word	0x4c4c4c6c
 8007378:	72          	.byte	0x72
 8007379:	00          	.byte	0x00
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 800737a:	2904      	cmp	r1, #4
 800737c:	d005      	beq.n	800738a <HAL_TIM_IC_Start_IT+0x5a>
 800737e:	2908      	cmp	r1, #8
 8007380:	d007      	beq.n	8007392 <HAL_TIM_IC_Start_IT+0x62>
 8007382:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
 8007386:	b2c0      	uxtb	r0, r0
 8007388:	e7d9      	b.n	800733e <HAL_TIM_IC_Start_IT+0xe>
 800738a:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 800738e:	b2c0      	uxtb	r0, r0
 8007390:	e7d5      	b.n	800733e <HAL_TIM_IC_Start_IT+0xe>
 8007392:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
 8007396:	b2c0      	uxtb	r0, r0
 8007398:	e7d1      	b.n	800733e <HAL_TIM_IC_Start_IT+0xe>
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 800739a:	2b04      	cmp	r3, #4
 800739c:	d005      	beq.n	80073aa <HAL_TIM_IC_Start_IT+0x7a>
 800739e:	2b08      	cmp	r3, #8
 80073a0:	d007      	beq.n	80073b2 <HAL_TIM_IC_Start_IT+0x82>
 80073a2:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 80073a6:	b2d2      	uxtb	r2, r2
 80073a8:	e7cd      	b.n	8007346 <HAL_TIM_IC_Start_IT+0x16>
 80073aa:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 80073ae:	b2d2      	uxtb	r2, r2
 80073b0:	e7c9      	b.n	8007346 <HAL_TIM_IC_Start_IT+0x16>
 80073b2:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 80073b6:	b2d2      	uxtb	r2, r2
 80073b8:	e7c5      	b.n	8007346 <HAL_TIM_IC_Start_IT+0x16>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80073ba:	2b04      	cmp	r3, #4
 80073bc:	d005      	beq.n	80073ca <HAL_TIM_IC_Start_IT+0x9a>
 80073be:	2b08      	cmp	r3, #8
 80073c0:	d007      	beq.n	80073d2 <HAL_TIM_IC_Start_IT+0xa2>
 80073c2:	2202      	movs	r2, #2
 80073c4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
 80073c8:	e7c7      	b.n	800735a <HAL_TIM_IC_Start_IT+0x2a>
 80073ca:	2202      	movs	r2, #2
 80073cc:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
 80073d0:	e7c3      	b.n	800735a <HAL_TIM_IC_Start_IT+0x2a>
 80073d2:	2202      	movs	r2, #2
 80073d4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 80073d8:	e7bf      	b.n	800735a <HAL_TIM_IC_Start_IT+0x2a>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80073da:	2b04      	cmp	r3, #4
 80073dc:	d005      	beq.n	80073ea <HAL_TIM_IC_Start_IT+0xba>
 80073de:	2b08      	cmp	r3, #8
 80073e0:	d007      	beq.n	80073f2 <HAL_TIM_IC_Start_IT+0xc2>
 80073e2:	2202      	movs	r2, #2
 80073e4:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 80073e8:	e7bc      	b.n	8007364 <HAL_TIM_IC_Start_IT+0x34>
 80073ea:	2202      	movs	r2, #2
 80073ec:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 80073f0:	e7b8      	b.n	8007364 <HAL_TIM_IC_Start_IT+0x34>
 80073f2:	2202      	movs	r2, #2
 80073f4:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
 80073f8:	e7b4      	b.n	8007364 <HAL_TIM_IC_Start_IT+0x34>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 80073fa:	6821      	ldr	r1, [r4, #0]
 80073fc:	68ca      	ldr	r2, [r1, #12]
 80073fe:	f042 0202 	orr.w	r2, r2, #2
 8007402:	60ca      	str	r2, [r1, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8007404:	2201      	movs	r2, #1
 8007406:	4619      	mov	r1, r3
 8007408:	6820      	ldr	r0, [r4, #0]
 800740a:	f7ff f851 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800740e:	6823      	ldr	r3, [r4, #0]
 8007410:	4a1a      	ldr	r2, [pc, #104]	; (800747c <HAL_TIM_IC_Start_IT+0x14c>)
 8007412:	4293      	cmp	r3, r2
 8007414:	d022      	beq.n	800745c <HAL_TIM_IC_Start_IT+0x12c>
 8007416:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800741a:	d01f      	beq.n	800745c <HAL_TIM_IC_Start_IT+0x12c>
 800741c:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8007420:	4293      	cmp	r3, r2
 8007422:	d01b      	beq.n	800745c <HAL_TIM_IC_Start_IT+0x12c>
 8007424:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8007428:	4293      	cmp	r3, r2
 800742a:	d017      	beq.n	800745c <HAL_TIM_IC_Start_IT+0x12c>
    __HAL_TIM_ENABLE(htim);
 800742c:	681a      	ldr	r2, [r3, #0]
 800742e:	f042 0201 	orr.w	r2, r2, #1
 8007432:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8007434:	2000      	movs	r0, #0
 8007436:	e01d      	b.n	8007474 <HAL_TIM_IC_Start_IT+0x144>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8007438:	6821      	ldr	r1, [r4, #0]
 800743a:	68ca      	ldr	r2, [r1, #12]
 800743c:	f042 0204 	orr.w	r2, r2, #4
 8007440:	60ca      	str	r2, [r1, #12]
      break;
 8007442:	e7df      	b.n	8007404 <HAL_TIM_IC_Start_IT+0xd4>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8007444:	6821      	ldr	r1, [r4, #0]
 8007446:	68ca      	ldr	r2, [r1, #12]
 8007448:	f042 0208 	orr.w	r2, r2, #8
 800744c:	60ca      	str	r2, [r1, #12]
      break;
 800744e:	e7d9      	b.n	8007404 <HAL_TIM_IC_Start_IT+0xd4>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8007450:	6821      	ldr	r1, [r4, #0]
 8007452:	68ca      	ldr	r2, [r1, #12]
 8007454:	f042 0210 	orr.w	r2, r2, #16
 8007458:	60ca      	str	r2, [r1, #12]
      break;
 800745a:	e7d3      	b.n	8007404 <HAL_TIM_IC_Start_IT+0xd4>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800745c:	689a      	ldr	r2, [r3, #8]
 800745e:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007462:	2a06      	cmp	r2, #6
 8007464:	d007      	beq.n	8007476 <HAL_TIM_IC_Start_IT+0x146>
      __HAL_TIM_ENABLE(htim);
 8007466:	681a      	ldr	r2, [r3, #0]
 8007468:	f042 0201 	orr.w	r2, r2, #1
 800746c:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800746e:	2000      	movs	r0, #0
 8007470:	e000      	b.n	8007474 <HAL_TIM_IC_Start_IT+0x144>
    return HAL_ERROR;
 8007472:	2001      	movs	r0, #1
}
 8007474:	bd10      	pop	{r4, pc}
  return HAL_OK;
 8007476:	2000      	movs	r0, #0
 8007478:	e7fc      	b.n	8007474 <HAL_TIM_IC_Start_IT+0x144>
 800747a:	bf00      	nop
 800747c:	40012c00 	.word	0x40012c00

08007480 <HAL_TIM_IC_Stop_IT>:
{
 8007480:	b538      	push	{r3, r4, r5, lr}
 8007482:	4605      	mov	r5, r0
 8007484:	460c      	mov	r4, r1
  switch (Channel)
 8007486:	290c      	cmp	r1, #12
 8007488:	d80d      	bhi.n	80074a6 <HAL_TIM_IC_Stop_IT+0x26>
 800748a:	e8df f001 	tbb	[pc, r1]
 800748e:	0c07      	.short	0x0c07
 8007490:	0c2a0c0c 	.word	0x0c2a0c0c
 8007494:	0c300c0c 	.word	0x0c300c0c
 8007498:	0c0c      	.short	0x0c0c
 800749a:	36          	.byte	0x36
 800749b:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 800749c:	6802      	ldr	r2, [r0, #0]
 800749e:	68d3      	ldr	r3, [r2, #12]
 80074a0:	f023 0302 	bic.w	r3, r3, #2
 80074a4:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 80074a6:	2200      	movs	r2, #0
 80074a8:	4621      	mov	r1, r4
 80074aa:	6828      	ldr	r0, [r5, #0]
 80074ac:	f7ff f800 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
 80074b0:	682b      	ldr	r3, [r5, #0]
 80074b2:	6a19      	ldr	r1, [r3, #32]
 80074b4:	f241 1211 	movw	r2, #4369	; 0x1111
 80074b8:	4211      	tst	r1, r2
 80074ba:	d108      	bne.n	80074ce <HAL_TIM_IC_Stop_IT+0x4e>
 80074bc:	6a19      	ldr	r1, [r3, #32]
 80074be:	f240 4244 	movw	r2, #1092	; 0x444
 80074c2:	4211      	tst	r1, r2
 80074c4:	d103      	bne.n	80074ce <HAL_TIM_IC_Stop_IT+0x4e>
 80074c6:	681a      	ldr	r2, [r3, #0]
 80074c8:	f022 0201 	bic.w	r2, r2, #1
 80074cc:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80074ce:	b9d4      	cbnz	r4, 8007506 <HAL_TIM_IC_Stop_IT+0x86>
 80074d0:	2301      	movs	r3, #1
 80074d2:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80074d6:	bb34      	cbnz	r4, 8007526 <HAL_TIM_IC_Stop_IT+0xa6>
 80074d8:	2301      	movs	r3, #1
 80074da:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
 80074de:	2000      	movs	r0, #0
 80074e0:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 80074e2:	6802      	ldr	r2, [r0, #0]
 80074e4:	68d3      	ldr	r3, [r2, #12]
 80074e6:	f023 0304 	bic.w	r3, r3, #4
 80074ea:	60d3      	str	r3, [r2, #12]
      break;
 80074ec:	e7db      	b.n	80074a6 <HAL_TIM_IC_Stop_IT+0x26>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 80074ee:	6802      	ldr	r2, [r0, #0]
 80074f0:	68d3      	ldr	r3, [r2, #12]
 80074f2:	f023 0308 	bic.w	r3, r3, #8
 80074f6:	60d3      	str	r3, [r2, #12]
      break;
 80074f8:	e7d5      	b.n	80074a6 <HAL_TIM_IC_Stop_IT+0x26>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 80074fa:	6802      	ldr	r2, [r0, #0]
 80074fc:	68d3      	ldr	r3, [r2, #12]
 80074fe:	f023 0310 	bic.w	r3, r3, #16
 8007502:	60d3      	str	r3, [r2, #12]
      break;
 8007504:	e7cf      	b.n	80074a6 <HAL_TIM_IC_Stop_IT+0x26>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007506:	2c04      	cmp	r4, #4
 8007508:	d005      	beq.n	8007516 <HAL_TIM_IC_Stop_IT+0x96>
 800750a:	2c08      	cmp	r4, #8
 800750c:	d007      	beq.n	800751e <HAL_TIM_IC_Stop_IT+0x9e>
 800750e:	2301      	movs	r3, #1
 8007510:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 8007514:	e7df      	b.n	80074d6 <HAL_TIM_IC_Stop_IT+0x56>
 8007516:	2301      	movs	r3, #1
 8007518:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
 800751c:	e7db      	b.n	80074d6 <HAL_TIM_IC_Stop_IT+0x56>
 800751e:	2301      	movs	r3, #1
 8007520:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
 8007524:	e7d7      	b.n	80074d6 <HAL_TIM_IC_Stop_IT+0x56>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007526:	2c04      	cmp	r4, #4
 8007528:	d005      	beq.n	8007536 <HAL_TIM_IC_Stop_IT+0xb6>
 800752a:	2c08      	cmp	r4, #8
 800752c:	d007      	beq.n	800753e <HAL_TIM_IC_Stop_IT+0xbe>
 800752e:	2301      	movs	r3, #1
 8007530:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 8007534:	e7d3      	b.n	80074de <HAL_TIM_IC_Stop_IT+0x5e>
 8007536:	2301      	movs	r3, #1
 8007538:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
 800753c:	e7cf      	b.n	80074de <HAL_TIM_IC_Stop_IT+0x5e>
 800753e:	2301      	movs	r3, #1
 8007540:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8007544:	e7cb      	b.n	80074de <HAL_TIM_IC_Stop_IT+0x5e>

08007546 <HAL_TIM_IC_Start_DMA>:
{
 8007546:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800754a:	4604      	mov	r4, r0
 800754c:	4616      	mov	r6, r2
 800754e:	461f      	mov	r7, r3
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8007550:	460d      	mov	r5, r1
 8007552:	2900      	cmp	r1, #0
 8007554:	d13b      	bne.n	80075ce <HAL_TIM_IC_Start_DMA+0x88>
 8007556:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 800755a:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 800755c:	2d00      	cmp	r5, #0
 800755e:	d146      	bne.n	80075ee <HAL_TIM_IC_Start_DMA+0xa8>
 8007560:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8007564:	fa5f f883 	uxtb.w	r8, r3
  if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)
 8007568:	2802      	cmp	r0, #2
 800756a:	f000 80ec 	beq.w	8007746 <HAL_TIM_IC_Start_DMA+0x200>
      || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))
 800756e:	f1b8 0f02 	cmp.w	r8, #2
 8007572:	f000 80e5 	beq.w	8007740 <HAL_TIM_IC_Start_DMA+0x1fa>
  else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)
 8007576:	2801      	cmp	r0, #1
 8007578:	f040 80e4 	bne.w	8007744 <HAL_TIM_IC_Start_DMA+0x1fe>
           && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))
 800757c:	f1b8 0f01 	cmp.w	r8, #1
 8007580:	f040 80e1 	bne.w	8007746 <HAL_TIM_IC_Start_DMA+0x200>
    if ((pData == NULL) && (Length > 0U))
 8007584:	2e00      	cmp	r6, #0
 8007586:	d045      	beq.n	8007614 <HAL_TIM_IC_Start_DMA+0xce>
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8007588:	2d00      	cmp	r5, #0
 800758a:	d147      	bne.n	800761c <HAL_TIM_IC_Start_DMA+0xd6>
 800758c:	2302      	movs	r3, #2
 800758e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8007592:	2d00      	cmp	r5, #0
 8007594:	d152      	bne.n	800763c <HAL_TIM_IC_Start_DMA+0xf6>
 8007596:	2302      	movs	r3, #2
 8007598:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800759c:	2201      	movs	r2, #1
 800759e:	4629      	mov	r1, r5
 80075a0:	6820      	ldr	r0, [r4, #0]
 80075a2:	f7fe ff85 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80075a6:	6822      	ldr	r2, [r4, #0]
 80075a8:	4b6d      	ldr	r3, [pc, #436]	; (8007760 <HAL_TIM_IC_Start_DMA+0x21a>)
 80075aa:	429a      	cmp	r2, r3
 80075ac:	d056      	beq.n	800765c <HAL_TIM_IC_Start_DMA+0x116>
 80075ae:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 80075b2:	d053      	beq.n	800765c <HAL_TIM_IC_Start_DMA+0x116>
 80075b4:	f5a3 3394 	sub.w	r3, r3, #75776	; 0x12800
 80075b8:	429a      	cmp	r2, r3
 80075ba:	d04f      	beq.n	800765c <HAL_TIM_IC_Start_DMA+0x116>
 80075bc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80075c0:	429a      	cmp	r2, r3
 80075c2:	d04b      	beq.n	800765c <HAL_TIM_IC_Start_DMA+0x116>
    __HAL_TIM_ENABLE(htim);
 80075c4:	6813      	ldr	r3, [r2, #0]
 80075c6:	f043 0301 	orr.w	r3, r3, #1
 80075ca:	6013      	str	r3, [r2, #0]
 80075cc:	e04f      	b.n	800766e <HAL_TIM_IC_Start_DMA+0x128>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 80075ce:	2904      	cmp	r1, #4
 80075d0:	d005      	beq.n	80075de <HAL_TIM_IC_Start_DMA+0x98>
 80075d2:	2908      	cmp	r1, #8
 80075d4:	d007      	beq.n	80075e6 <HAL_TIM_IC_Start_DMA+0xa0>
 80075d6:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
 80075da:	b2c0      	uxtb	r0, r0
 80075dc:	e7be      	b.n	800755c <HAL_TIM_IC_Start_DMA+0x16>
 80075de:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 80075e2:	b2c0      	uxtb	r0, r0
 80075e4:	e7ba      	b.n	800755c <HAL_TIM_IC_Start_DMA+0x16>
 80075e6:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
 80075ea:	b2c0      	uxtb	r0, r0
 80075ec:	e7b6      	b.n	800755c <HAL_TIM_IC_Start_DMA+0x16>
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 80075ee:	2d04      	cmp	r5, #4
 80075f0:	d006      	beq.n	8007600 <HAL_TIM_IC_Start_DMA+0xba>
 80075f2:	2d08      	cmp	r5, #8
 80075f4:	d009      	beq.n	800760a <HAL_TIM_IC_Start_DMA+0xc4>
 80075f6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80075fa:	fa5f f883 	uxtb.w	r8, r3
 80075fe:	e7b3      	b.n	8007568 <HAL_TIM_IC_Start_DMA+0x22>
 8007600:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8007604:	fa5f f883 	uxtb.w	r8, r3
 8007608:	e7ae      	b.n	8007568 <HAL_TIM_IC_Start_DMA+0x22>
 800760a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800760e:	fa5f f883 	uxtb.w	r8, r3
 8007612:	e7a9      	b.n	8007568 <HAL_TIM_IC_Start_DMA+0x22>
    if ((pData == NULL) && (Length > 0U))
 8007614:	2f00      	cmp	r7, #0
 8007616:	d0b7      	beq.n	8007588 <HAL_TIM_IC_Start_DMA+0x42>
      return HAL_ERROR;
 8007618:	4640      	mov	r0, r8
 800761a:	e094      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800761c:	2d04      	cmp	r5, #4
 800761e:	d005      	beq.n	800762c <HAL_TIM_IC_Start_DMA+0xe6>
 8007620:	2d08      	cmp	r5, #8
 8007622:	d007      	beq.n	8007634 <HAL_TIM_IC_Start_DMA+0xee>
 8007624:	2302      	movs	r3, #2
 8007626:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 800762a:	e7b2      	b.n	8007592 <HAL_TIM_IC_Start_DMA+0x4c>
 800762c:	2302      	movs	r3, #2
 800762e:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007632:	e7ae      	b.n	8007592 <HAL_TIM_IC_Start_DMA+0x4c>
 8007634:	2302      	movs	r3, #2
 8007636:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800763a:	e7aa      	b.n	8007592 <HAL_TIM_IC_Start_DMA+0x4c>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800763c:	2d04      	cmp	r5, #4
 800763e:	d005      	beq.n	800764c <HAL_TIM_IC_Start_DMA+0x106>
 8007640:	2d08      	cmp	r5, #8
 8007642:	d007      	beq.n	8007654 <HAL_TIM_IC_Start_DMA+0x10e>
 8007644:	2302      	movs	r3, #2
 8007646:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800764a:	e7a7      	b.n	800759c <HAL_TIM_IC_Start_DMA+0x56>
 800764c:	2302      	movs	r3, #2
 800764e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007652:	e7a3      	b.n	800759c <HAL_TIM_IC_Start_DMA+0x56>
 8007654:	2302      	movs	r3, #2
 8007656:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800765a:	e79f      	b.n	800759c <HAL_TIM_IC_Start_DMA+0x56>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800765c:	6893      	ldr	r3, [r2, #8]
 800765e:	f003 0307 	and.w	r3, r3, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007662:	2b06      	cmp	r3, #6
 8007664:	d003      	beq.n	800766e <HAL_TIM_IC_Start_DMA+0x128>
      __HAL_TIM_ENABLE(htim);
 8007666:	6813      	ldr	r3, [r2, #0]
 8007668:	f043 0301 	orr.w	r3, r3, #1
 800766c:	6013      	str	r3, [r2, #0]
  switch (Channel)
 800766e:	2d0c      	cmp	r5, #12
 8007670:	d86b      	bhi.n	800774a <HAL_TIM_IC_Start_DMA+0x204>
 8007672:	e8df f005 	tbb	[pc, r5]
 8007676:	6a07      	.short	0x6a07
 8007678:	6a1f6a6a 	.word	0x6a1f6a6a
 800767c:	6a376a6a 	.word	0x6a376a6a
 8007680:	6a6a      	.short	0x6a6a
 8007682:	4e          	.byte	0x4e
 8007683:	00          	.byte	0x00
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
 8007684:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007686:	4a37      	ldr	r2, [pc, #220]	; (8007764 <HAL_TIM_IC_Start_DMA+0x21e>)
 8007688:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 800768a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800768c:	4a36      	ldr	r2, [pc, #216]	; (8007768 <HAL_TIM_IC_Start_DMA+0x222>)
 800768e:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 8007690:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007692:	4a36      	ldr	r2, [pc, #216]	; (800776c <HAL_TIM_IC_Start_DMA+0x226>)
 8007694:	631a      	str	r2, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData,
 8007696:	6821      	ldr	r1, [r4, #0]
 8007698:	463b      	mov	r3, r7
 800769a:	4632      	mov	r2, r6
 800769c:	3134      	adds	r1, #52	; 0x34
 800769e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80076a0:	f7fc f8de 	bl	8003860 <HAL_DMA_Start_IT>
 80076a4:	2800      	cmp	r0, #0
 80076a6:	d152      	bne.n	800774e <HAL_TIM_IC_Start_DMA+0x208>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 80076a8:	6822      	ldr	r2, [r4, #0]
 80076aa:	68d3      	ldr	r3, [r2, #12]
 80076ac:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80076b0:	60d3      	str	r3, [r2, #12]
      break;
 80076b2:	e048      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
 80076b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80076b6:	4a2b      	ldr	r2, [pc, #172]	; (8007764 <HAL_TIM_IC_Start_DMA+0x21e>)
 80076b8:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 80076ba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80076bc:	4a2a      	ldr	r2, [pc, #168]	; (8007768 <HAL_TIM_IC_Start_DMA+0x222>)
 80076be:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 80076c0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80076c2:	4a2a      	ldr	r2, [pc, #168]	; (800776c <HAL_TIM_IC_Start_DMA+0x226>)
 80076c4:	631a      	str	r2, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData,
 80076c6:	6821      	ldr	r1, [r4, #0]
 80076c8:	463b      	mov	r3, r7
 80076ca:	4632      	mov	r2, r6
 80076cc:	3138      	adds	r1, #56	; 0x38
 80076ce:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80076d0:	f7fc f8c6 	bl	8003860 <HAL_DMA_Start_IT>
 80076d4:	2800      	cmp	r0, #0
 80076d6:	d13c      	bne.n	8007752 <HAL_TIM_IC_Start_DMA+0x20c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 80076d8:	6822      	ldr	r2, [r4, #0]
 80076da:	68d3      	ldr	r3, [r2, #12]
 80076dc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80076e0:	60d3      	str	r3, [r2, #12]
      break;
 80076e2:	e030      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
 80076e4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80076e6:	4a1f      	ldr	r2, [pc, #124]	; (8007764 <HAL_TIM_IC_Start_DMA+0x21e>)
 80076e8:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 80076ea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80076ec:	4a1e      	ldr	r2, [pc, #120]	; (8007768 <HAL_TIM_IC_Start_DMA+0x222>)
 80076ee:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
 80076f0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80076f2:	4a1e      	ldr	r2, [pc, #120]	; (800776c <HAL_TIM_IC_Start_DMA+0x226>)
 80076f4:	631a      	str	r2, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData,
 80076f6:	6821      	ldr	r1, [r4, #0]
 80076f8:	463b      	mov	r3, r7
 80076fa:	4632      	mov	r2, r6
 80076fc:	313c      	adds	r1, #60	; 0x3c
 80076fe:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8007700:	f7fc f8ae 	bl	8003860 <HAL_DMA_Start_IT>
 8007704:	bb38      	cbnz	r0, 8007756 <HAL_TIM_IC_Start_DMA+0x210>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
 8007706:	6822      	ldr	r2, [r4, #0]
 8007708:	68d3      	ldr	r3, [r2, #12]
 800770a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800770e:	60d3      	str	r3, [r2, #12]
      break;
 8007710:	e019      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
 8007712:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007714:	4a13      	ldr	r2, [pc, #76]	; (8007764 <HAL_TIM_IC_Start_DMA+0x21e>)
 8007716:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 8007718:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800771a:	4a13      	ldr	r2, [pc, #76]	; (8007768 <HAL_TIM_IC_Start_DMA+0x222>)
 800771c:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
 800771e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007720:	4a12      	ldr	r2, [pc, #72]	; (800776c <HAL_TIM_IC_Start_DMA+0x226>)
 8007722:	631a      	str	r2, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData,
 8007724:	6821      	ldr	r1, [r4, #0]
 8007726:	463b      	mov	r3, r7
 8007728:	4632      	mov	r2, r6
 800772a:	3140      	adds	r1, #64	; 0x40
 800772c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800772e:	f7fc f897 	bl	8003860 <HAL_DMA_Start_IT>
 8007732:	b990      	cbnz	r0, 800775a <HAL_TIM_IC_Start_DMA+0x214>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
 8007734:	6822      	ldr	r2, [r4, #0]
 8007736:	68d3      	ldr	r3, [r2, #12]
 8007738:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800773c:	60d3      	str	r3, [r2, #12]
      break;
 800773e:	e002      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
    return HAL_BUSY;
 8007740:	4640      	mov	r0, r8
 8007742:	e000      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
    return HAL_ERROR;
 8007744:	2001      	movs	r0, #1
}
 8007746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 800774a:	2000      	movs	r0, #0
 800774c:	e7fb      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
        return HAL_ERROR;
 800774e:	4640      	mov	r0, r8
 8007750:	e7f9      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
        return HAL_ERROR;
 8007752:	4640      	mov	r0, r8
 8007754:	e7f7      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
        return HAL_ERROR;
 8007756:	4640      	mov	r0, r8
 8007758:	e7f5      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
        return HAL_ERROR;
 800775a:	4640      	mov	r0, r8
 800775c:	e7f3      	b.n	8007746 <HAL_TIM_IC_Start_DMA+0x200>
 800775e:	bf00      	nop
 8007760:	40012c00 	.word	0x40012c00
 8007764:	08005783 	.word	0x08005783
 8007768:	08005805 	.word	0x08005805
 800776c:	08005a95 	.word	0x08005a95

08007770 <HAL_TIM_IC_Stop_DMA>:
{
 8007770:	b538      	push	{r3, r4, r5, lr}
 8007772:	4605      	mov	r5, r0
 8007774:	460c      	mov	r4, r1
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8007776:	2200      	movs	r2, #0
 8007778:	6800      	ldr	r0, [r0, #0]
 800777a:	f7fe fe99 	bl	80064b0 <TIM_CCxChannelCmd>
  switch (Channel)
 800777e:	2c0c      	cmp	r4, #12
 8007780:	d810      	bhi.n	80077a4 <HAL_TIM_IC_Stop_DMA+0x34>
 8007782:	e8df f004 	tbb	[pc, r4]
 8007786:	0f07      	.short	0x0f07
 8007788:	0f280f0f 	.word	0x0f280f0f
 800778c:	0f310f0f 	.word	0x0f310f0f
 8007790:	0f0f      	.short	0x0f0f
 8007792:	3a          	.byte	0x3a
 8007793:	00          	.byte	0x00
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 8007794:	682a      	ldr	r2, [r5, #0]
 8007796:	68d3      	ldr	r3, [r2, #12]
 8007798:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800779c:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 800779e:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80077a0:	f7fc f8ba 	bl	8003918 <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
 80077a4:	682b      	ldr	r3, [r5, #0]
 80077a6:	6a19      	ldr	r1, [r3, #32]
 80077a8:	f241 1211 	movw	r2, #4369	; 0x1111
 80077ac:	4211      	tst	r1, r2
 80077ae:	d108      	bne.n	80077c2 <HAL_TIM_IC_Stop_DMA+0x52>
 80077b0:	6a19      	ldr	r1, [r3, #32]
 80077b2:	f240 4244 	movw	r2, #1092	; 0x444
 80077b6:	4211      	tst	r1, r2
 80077b8:	d103      	bne.n	80077c2 <HAL_TIM_IC_Stop_DMA+0x52>
 80077ba:	681a      	ldr	r2, [r3, #0]
 80077bc:	f022 0201 	bic.w	r2, r2, #1
 80077c0:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80077c2:	bb1c      	cbnz	r4, 800780c <HAL_TIM_IC_Stop_DMA+0x9c>
 80077c4:	2301      	movs	r3, #1
 80077c6:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80077ca:	bb7c      	cbnz	r4, 800782c <HAL_TIM_IC_Stop_DMA+0xbc>
 80077cc:	2301      	movs	r3, #1
 80077ce:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
 80077d2:	2000      	movs	r0, #0
 80077d4:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 80077d6:	682a      	ldr	r2, [r5, #0]
 80077d8:	68d3      	ldr	r3, [r2, #12]
 80077da:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80077de:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 80077e0:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 80077e2:	f7fc f899 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80077e6:	e7dd      	b.n	80077a4 <HAL_TIM_IC_Stop_DMA+0x34>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
 80077e8:	682a      	ldr	r2, [r5, #0]
 80077ea:	68d3      	ldr	r3, [r2, #12]
 80077ec:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80077f0:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 80077f2:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80077f4:	f7fc f890 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 80077f8:	e7d4      	b.n	80077a4 <HAL_TIM_IC_Stop_DMA+0x34>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
 80077fa:	682a      	ldr	r2, [r5, #0]
 80077fc:	68d3      	ldr	r3, [r2, #12]
 80077fe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8007802:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
 8007804:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8007806:	f7fc f887 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 800780a:	e7cb      	b.n	80077a4 <HAL_TIM_IC_Stop_DMA+0x34>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 800780c:	2c04      	cmp	r4, #4
 800780e:	d005      	beq.n	800781c <HAL_TIM_IC_Stop_DMA+0xac>
 8007810:	2c08      	cmp	r4, #8
 8007812:	d007      	beq.n	8007824 <HAL_TIM_IC_Stop_DMA+0xb4>
 8007814:	2301      	movs	r3, #1
 8007816:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 800781a:	e7d6      	b.n	80077ca <HAL_TIM_IC_Stop_DMA+0x5a>
 800781c:	2301      	movs	r3, #1
 800781e:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
 8007822:	e7d2      	b.n	80077ca <HAL_TIM_IC_Stop_DMA+0x5a>
 8007824:	2301      	movs	r3, #1
 8007826:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
 800782a:	e7ce      	b.n	80077ca <HAL_TIM_IC_Stop_DMA+0x5a>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 800782c:	2c04      	cmp	r4, #4
 800782e:	d005      	beq.n	800783c <HAL_TIM_IC_Stop_DMA+0xcc>
 8007830:	2c08      	cmp	r4, #8
 8007832:	d007      	beq.n	8007844 <HAL_TIM_IC_Stop_DMA+0xd4>
 8007834:	2301      	movs	r3, #1
 8007836:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 800783a:	e7ca      	b.n	80077d2 <HAL_TIM_IC_Stop_DMA+0x62>
 800783c:	2301      	movs	r3, #1
 800783e:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
 8007842:	e7c6      	b.n	80077d2 <HAL_TIM_IC_Stop_DMA+0x62>
 8007844:	2301      	movs	r3, #1
 8007846:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 800784a:	e7c2      	b.n	80077d2 <HAL_TIM_IC_Stop_DMA+0x62>

0800784c <HAL_TIM_OnePulse_Start>:
{
 800784c:	b510      	push	{r4, lr}
 800784e:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 8007850:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8007854:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8007856:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 800785a:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 800785e:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007862:	2801      	cmp	r0, #1
 8007864:	d128      	bne.n	80078b8 <HAL_TIM_OnePulse_Start+0x6c>
 8007866:	b2db      	uxtb	r3, r3
 8007868:	b2d2      	uxtb	r2, r2
 800786a:	b2c9      	uxtb	r1, r1
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 800786c:	2b01      	cmp	r3, #1
 800786e:	d124      	bne.n	80078ba <HAL_TIM_OnePulse_Start+0x6e>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007870:	2a01      	cmp	r2, #1
 8007872:	d123      	bne.n	80078bc <HAL_TIM_OnePulse_Start+0x70>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8007874:	2901      	cmp	r1, #1
 8007876:	d001      	beq.n	800787c <HAL_TIM_OnePulse_Start+0x30>
    return HAL_ERROR;
 8007878:	4610      	mov	r0, r2
 800787a:	e01e      	b.n	80078ba <HAL_TIM_OnePulse_Start+0x6e>
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 800787c:	2302      	movs	r3, #2
 800787e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007882:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007886:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 800788a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800788e:	2100      	movs	r1, #0
 8007890:	6820      	ldr	r0, [r4, #0]
 8007892:	f7fe fe0d 	bl	80064b0 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007896:	2201      	movs	r2, #1
 8007898:	2104      	movs	r1, #4
 800789a:	6820      	ldr	r0, [r4, #0]
 800789c:	f7fe fe08 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80078a0:	6823      	ldr	r3, [r4, #0]
 80078a2:	4a07      	ldr	r2, [pc, #28]	; (80078c0 <HAL_TIM_OnePulse_Start+0x74>)
 80078a4:	4293      	cmp	r3, r2
 80078a6:	d001      	beq.n	80078ac <HAL_TIM_OnePulse_Start+0x60>
  return HAL_OK;
 80078a8:	2000      	movs	r0, #0
 80078aa:	e006      	b.n	80078ba <HAL_TIM_OnePulse_Start+0x6e>
    __HAL_TIM_MOE_ENABLE(htim);
 80078ac:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80078ae:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80078b2:	645a      	str	r2, [r3, #68]	; 0x44
  return HAL_OK;
 80078b4:	2000      	movs	r0, #0
 80078b6:	e000      	b.n	80078ba <HAL_TIM_OnePulse_Start+0x6e>
    return HAL_ERROR;
 80078b8:	2001      	movs	r0, #1
}
 80078ba:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80078bc:	4618      	mov	r0, r3
 80078be:	e7fc      	b.n	80078ba <HAL_TIM_OnePulse_Start+0x6e>
 80078c0:	40012c00 	.word	0x40012c00

080078c4 <HAL_TIM_OnePulse_Stop>:
{
 80078c4:	b510      	push	{r4, lr}
 80078c6:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 80078c8:	2200      	movs	r2, #0
 80078ca:	4611      	mov	r1, r2
 80078cc:	6800      	ldr	r0, [r0, #0]
 80078ce:	f7fe fdef 	bl	80064b0 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 80078d2:	2200      	movs	r2, #0
 80078d4:	2104      	movs	r1, #4
 80078d6:	6820      	ldr	r0, [r4, #0]
 80078d8:	f7fe fdea 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80078dc:	6823      	ldr	r3, [r4, #0]
 80078de:	4a16      	ldr	r2, [pc, #88]	; (8007938 <HAL_TIM_OnePulse_Stop+0x74>)
 80078e0:	4293      	cmp	r3, r2
 80078e2:	d019      	beq.n	8007918 <HAL_TIM_OnePulse_Stop+0x54>
  __HAL_TIM_DISABLE(htim);
 80078e4:	6823      	ldr	r3, [r4, #0]
 80078e6:	6a19      	ldr	r1, [r3, #32]
 80078e8:	f241 1211 	movw	r2, #4369	; 0x1111
 80078ec:	4211      	tst	r1, r2
 80078ee:	d108      	bne.n	8007902 <HAL_TIM_OnePulse_Stop+0x3e>
 80078f0:	6a19      	ldr	r1, [r3, #32]
 80078f2:	f240 4244 	movw	r2, #1092	; 0x444
 80078f6:	4211      	tst	r1, r2
 80078f8:	d103      	bne.n	8007902 <HAL_TIM_OnePulse_Stop+0x3e>
 80078fa:	681a      	ldr	r2, [r3, #0]
 80078fc:	f022 0201 	bic.w	r2, r2, #1
 8007900:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007902:	2301      	movs	r3, #1
 8007904:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007908:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 800790c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007910:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
 8007914:	2000      	movs	r0, #0
 8007916:	bd10      	pop	{r4, pc}
    __HAL_TIM_MOE_DISABLE(htim);
 8007918:	6a19      	ldr	r1, [r3, #32]
 800791a:	f241 1211 	movw	r2, #4369	; 0x1111
 800791e:	4211      	tst	r1, r2
 8007920:	d1e0      	bne.n	80078e4 <HAL_TIM_OnePulse_Stop+0x20>
 8007922:	6a19      	ldr	r1, [r3, #32]
 8007924:	f240 4244 	movw	r2, #1092	; 0x444
 8007928:	4211      	tst	r1, r2
 800792a:	d1db      	bne.n	80078e4 <HAL_TIM_OnePulse_Stop+0x20>
 800792c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800792e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007932:	645a      	str	r2, [r3, #68]	; 0x44
 8007934:	e7d6      	b.n	80078e4 <HAL_TIM_OnePulse_Stop+0x20>
 8007936:	bf00      	nop
 8007938:	40012c00 	.word	0x40012c00

0800793c <HAL_TIM_OnePulse_Start_IT>:
{
 800793c:	b510      	push	{r4, lr}
 800793e:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 8007940:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8007944:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8007946:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 800794a:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 800794e:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007952:	2801      	cmp	r0, #1
 8007954:	d133      	bne.n	80079be <HAL_TIM_OnePulse_Start_IT+0x82>
 8007956:	b2db      	uxtb	r3, r3
 8007958:	b2d2      	uxtb	r2, r2
 800795a:	b2c9      	uxtb	r1, r1
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 800795c:	2b01      	cmp	r3, #1
 800795e:	d12f      	bne.n	80079c0 <HAL_TIM_OnePulse_Start_IT+0x84>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007960:	2a01      	cmp	r2, #1
 8007962:	d12e      	bne.n	80079c2 <HAL_TIM_OnePulse_Start_IT+0x86>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8007964:	2901      	cmp	r1, #1
 8007966:	d001      	beq.n	800796c <HAL_TIM_OnePulse_Start_IT+0x30>
    return HAL_ERROR;
 8007968:	4610      	mov	r0, r2
 800796a:	e029      	b.n	80079c0 <HAL_TIM_OnePulse_Start_IT+0x84>
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 800796c:	2302      	movs	r3, #2
 800796e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007972:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007976:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 800797a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 800797e:	6822      	ldr	r2, [r4, #0]
 8007980:	68d3      	ldr	r3, [r2, #12]
 8007982:	f043 0302 	orr.w	r3, r3, #2
 8007986:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8007988:	6822      	ldr	r2, [r4, #0]
 800798a:	68d3      	ldr	r3, [r2, #12]
 800798c:	f043 0304 	orr.w	r3, r3, #4
 8007990:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007992:	2201      	movs	r2, #1
 8007994:	2100      	movs	r1, #0
 8007996:	6820      	ldr	r0, [r4, #0]
 8007998:	f7fe fd8a 	bl	80064b0 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 800799c:	2201      	movs	r2, #1
 800799e:	2104      	movs	r1, #4
 80079a0:	6820      	ldr	r0, [r4, #0]
 80079a2:	f7fe fd85 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80079a6:	6823      	ldr	r3, [r4, #0]
 80079a8:	4a07      	ldr	r2, [pc, #28]	; (80079c8 <HAL_TIM_OnePulse_Start_IT+0x8c>)
 80079aa:	4293      	cmp	r3, r2
 80079ac:	d001      	beq.n	80079b2 <HAL_TIM_OnePulse_Start_IT+0x76>
  return HAL_OK;
 80079ae:	2000      	movs	r0, #0
 80079b0:	e006      	b.n	80079c0 <HAL_TIM_OnePulse_Start_IT+0x84>
    __HAL_TIM_MOE_ENABLE(htim);
 80079b2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80079b4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80079b8:	645a      	str	r2, [r3, #68]	; 0x44
  return HAL_OK;
 80079ba:	2000      	movs	r0, #0
 80079bc:	e000      	b.n	80079c0 <HAL_TIM_OnePulse_Start_IT+0x84>
    return HAL_ERROR;
 80079be:	2001      	movs	r0, #1
}
 80079c0:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80079c2:	4618      	mov	r0, r3
 80079c4:	e7fc      	b.n	80079c0 <HAL_TIM_OnePulse_Start_IT+0x84>
 80079c6:	bf00      	nop
 80079c8:	40012c00 	.word	0x40012c00

080079cc <HAL_TIM_OnePulse_Stop_IT>:
{
 80079cc:	b510      	push	{r4, lr}
 80079ce:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 80079d0:	6802      	ldr	r2, [r0, #0]
 80079d2:	68d3      	ldr	r3, [r2, #12]
 80079d4:	f023 0302 	bic.w	r3, r3, #2
 80079d8:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 80079da:	6802      	ldr	r2, [r0, #0]
 80079dc:	68d3      	ldr	r3, [r2, #12]
 80079de:	f023 0304 	bic.w	r3, r3, #4
 80079e2:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 80079e4:	2200      	movs	r2, #0
 80079e6:	4611      	mov	r1, r2
 80079e8:	6800      	ldr	r0, [r0, #0]
 80079ea:	f7fe fd61 	bl	80064b0 <TIM_CCxChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 80079ee:	2200      	movs	r2, #0
 80079f0:	2104      	movs	r1, #4
 80079f2:	6820      	ldr	r0, [r4, #0]
 80079f4:	f7fe fd5c 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80079f8:	6823      	ldr	r3, [r4, #0]
 80079fa:	4a16      	ldr	r2, [pc, #88]	; (8007a54 <HAL_TIM_OnePulse_Stop_IT+0x88>)
 80079fc:	4293      	cmp	r3, r2
 80079fe:	d019      	beq.n	8007a34 <HAL_TIM_OnePulse_Stop_IT+0x68>
  __HAL_TIM_DISABLE(htim);
 8007a00:	6823      	ldr	r3, [r4, #0]
 8007a02:	6a19      	ldr	r1, [r3, #32]
 8007a04:	f241 1211 	movw	r2, #4369	; 0x1111
 8007a08:	4211      	tst	r1, r2
 8007a0a:	d108      	bne.n	8007a1e <HAL_TIM_OnePulse_Stop_IT+0x52>
 8007a0c:	6a19      	ldr	r1, [r3, #32]
 8007a0e:	f240 4244 	movw	r2, #1092	; 0x444
 8007a12:	4211      	tst	r1, r2
 8007a14:	d103      	bne.n	8007a1e <HAL_TIM_OnePulse_Stop_IT+0x52>
 8007a16:	681a      	ldr	r2, [r3, #0]
 8007a18:	f022 0201 	bic.w	r2, r2, #1
 8007a1c:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007a1e:	2301      	movs	r3, #1
 8007a20:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007a24:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007a28:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007a2c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
 8007a30:	2000      	movs	r0, #0
 8007a32:	bd10      	pop	{r4, pc}
    __HAL_TIM_MOE_DISABLE(htim);
 8007a34:	6a19      	ldr	r1, [r3, #32]
 8007a36:	f241 1211 	movw	r2, #4369	; 0x1111
 8007a3a:	4211      	tst	r1, r2
 8007a3c:	d1e0      	bne.n	8007a00 <HAL_TIM_OnePulse_Stop_IT+0x34>
 8007a3e:	6a19      	ldr	r1, [r3, #32]
 8007a40:	f240 4244 	movw	r2, #1092	; 0x444
 8007a44:	4211      	tst	r1, r2
 8007a46:	d1db      	bne.n	8007a00 <HAL_TIM_OnePulse_Stop_IT+0x34>
 8007a48:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8007a4a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007a4e:	645a      	str	r2, [r3, #68]	; 0x44
 8007a50:	e7d6      	b.n	8007a00 <HAL_TIM_OnePulse_Stop_IT+0x34>
 8007a52:	bf00      	nop
 8007a54:	40012c00 	.word	0x40012c00

08007a58 <HAL_TIM_Encoder_Start>:
{
 8007a58:	b570      	push	{r4, r5, r6, lr}
 8007a5a:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 8007a5c:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8007a60:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8007a62:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 8007a66:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8007a6a:	b2d2      	uxtb	r2, r2
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 8007a6c:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
  if (Channel == TIM_CHANNEL_1)
 8007a70:	460e      	mov	r6, r1
 8007a72:	b9b1      	cbnz	r1, 8007aa2 <HAL_TIM_Encoder_Start+0x4a>
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007a74:	2801      	cmp	r0, #1
 8007a76:	d146      	bne.n	8007b06 <HAL_TIM_Encoder_Start+0xae>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
 8007a78:	2a01      	cmp	r2, #1
 8007a7a:	d145      	bne.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007a7c:	2302      	movs	r3, #2
 8007a7e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007a82:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  switch (Channel)
 8007a86:	b366      	cbz	r6, 8007ae2 <HAL_TIM_Encoder_Start+0x8a>
 8007a88:	2e04      	cmp	r6, #4
 8007a8a:	d036      	beq.n	8007afa <HAL_TIM_Encoder_Start+0xa2>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007a8c:	2201      	movs	r2, #1
 8007a8e:	2100      	movs	r1, #0
 8007a90:	6820      	ldr	r0, [r4, #0]
 8007a92:	f7fe fd0d 	bl	80064b0 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007a96:	2201      	movs	r2, #1
 8007a98:	2104      	movs	r1, #4
 8007a9a:	6820      	ldr	r0, [r4, #0]
 8007a9c:	f7fe fd08 	bl	80064b0 <TIM_CCxChannelCmd>
      break;
 8007aa0:	e024      	b.n	8007aec <HAL_TIM_Encoder_Start+0x94>
 8007aa2:	b2db      	uxtb	r3, r3
 8007aa4:	b2ed      	uxtb	r5, r5
  else if (Channel == TIM_CHANNEL_2)
 8007aa6:	2904      	cmp	r1, #4
 8007aa8:	d011      	beq.n	8007ace <HAL_TIM_Encoder_Start+0x76>
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007aaa:	2801      	cmp	r0, #1
 8007aac:	d131      	bne.n	8007b12 <HAL_TIM_Encoder_Start+0xba>
        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8007aae:	2b01      	cmp	r3, #1
 8007ab0:	d12a      	bne.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007ab2:	2a01      	cmp	r2, #1
 8007ab4:	d12f      	bne.n	8007b16 <HAL_TIM_Encoder_Start+0xbe>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8007ab6:	2d01      	cmp	r5, #1
 8007ab8:	d12f      	bne.n	8007b1a <HAL_TIM_Encoder_Start+0xc2>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007aba:	2302      	movs	r3, #2
 8007abc:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007ac0:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007ac4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007ac8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007acc:	e7db      	b.n	8007a86 <HAL_TIM_Encoder_Start+0x2e>
    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8007ace:	2b01      	cmp	r3, #1
 8007ad0:	d11b      	bne.n	8007b0a <HAL_TIM_Encoder_Start+0xb2>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8007ad2:	2d01      	cmp	r5, #1
 8007ad4:	d11b      	bne.n	8007b0e <HAL_TIM_Encoder_Start+0xb6>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007ad6:	2302      	movs	r3, #2
 8007ad8:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007adc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007ae0:	e7d1      	b.n	8007a86 <HAL_TIM_Encoder_Start+0x2e>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007ae2:	2201      	movs	r2, #1
 8007ae4:	2100      	movs	r1, #0
 8007ae6:	6820      	ldr	r0, [r4, #0]
 8007ae8:	f7fe fce2 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_ENABLE(htim);
 8007aec:	6822      	ldr	r2, [r4, #0]
 8007aee:	6813      	ldr	r3, [r2, #0]
 8007af0:	f043 0301 	orr.w	r3, r3, #1
 8007af4:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8007af6:	2000      	movs	r0, #0
 8007af8:	e006      	b.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007afa:	2201      	movs	r2, #1
 8007afc:	2104      	movs	r1, #4
 8007afe:	6820      	ldr	r0, [r4, #0]
 8007b00:	f7fe fcd6 	bl	80064b0 <TIM_CCxChannelCmd>
      break;
 8007b04:	e7f2      	b.n	8007aec <HAL_TIM_Encoder_Start+0x94>
      return HAL_ERROR;
 8007b06:	2001      	movs	r0, #1
}
 8007b08:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8007b0a:	2001      	movs	r0, #1
 8007b0c:	e7fc      	b.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
 8007b0e:	4618      	mov	r0, r3
 8007b10:	e7fa      	b.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
      return HAL_ERROR;
 8007b12:	2001      	movs	r0, #1
 8007b14:	e7f8      	b.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
 8007b16:	4618      	mov	r0, r3
 8007b18:	e7f6      	b.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>
 8007b1a:	4610      	mov	r0, r2
 8007b1c:	e7f4      	b.n	8007b08 <HAL_TIM_Encoder_Start+0xb0>

08007b1e <HAL_TIM_Encoder_Stop>:
{
 8007b1e:	b538      	push	{r3, r4, r5, lr}
 8007b20:	4604      	mov	r4, r0
  switch (Channel)
 8007b22:	460d      	mov	r5, r1
 8007b24:	b161      	cbz	r1, 8007b40 <HAL_TIM_Encoder_Stop+0x22>
 8007b26:	2904      	cmp	r1, #4
 8007b28:	d02b      	beq.n	8007b82 <HAL_TIM_Encoder_Stop+0x64>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 8007b2a:	2200      	movs	r2, #0
 8007b2c:	4611      	mov	r1, r2
 8007b2e:	6800      	ldr	r0, [r0, #0]
 8007b30:	f7fe fcbe 	bl	80064b0 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 8007b34:	2200      	movs	r2, #0
 8007b36:	2104      	movs	r1, #4
 8007b38:	6820      	ldr	r0, [r4, #0]
 8007b3a:	f7fe fcb9 	bl	80064b0 <TIM_CCxChannelCmd>
      break;
 8007b3e:	e004      	b.n	8007b4a <HAL_TIM_Encoder_Stop+0x2c>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 8007b40:	2200      	movs	r2, #0
 8007b42:	4611      	mov	r1, r2
 8007b44:	6800      	ldr	r0, [r0, #0]
 8007b46:	f7fe fcb3 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
 8007b4a:	6823      	ldr	r3, [r4, #0]
 8007b4c:	6a19      	ldr	r1, [r3, #32]
 8007b4e:	f241 1211 	movw	r2, #4369	; 0x1111
 8007b52:	4211      	tst	r1, r2
 8007b54:	d108      	bne.n	8007b68 <HAL_TIM_Encoder_Stop+0x4a>
 8007b56:	6a19      	ldr	r1, [r3, #32]
 8007b58:	f240 4244 	movw	r2, #1092	; 0x444
 8007b5c:	4211      	tst	r1, r2
 8007b5e:	d103      	bne.n	8007b68 <HAL_TIM_Encoder_Stop+0x4a>
 8007b60:	681a      	ldr	r2, [r3, #0]
 8007b62:	f022 0201 	bic.w	r2, r2, #1
 8007b66:	601a      	str	r2, [r3, #0]
  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
 8007b68:	b18d      	cbz	r5, 8007b8e <HAL_TIM_Encoder_Stop+0x70>
 8007b6a:	2d04      	cmp	r5, #4
 8007b6c:	d00f      	beq.n	8007b8e <HAL_TIM_Encoder_Stop+0x70>
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007b6e:	2301      	movs	r3, #1
 8007b70:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007b74:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007b78:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007b7c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007b80:	e00d      	b.n	8007b9e <HAL_TIM_Encoder_Stop+0x80>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 8007b82:	2200      	movs	r2, #0
 8007b84:	2104      	movs	r1, #4
 8007b86:	6800      	ldr	r0, [r0, #0]
 8007b88:	f7fe fc92 	bl	80064b0 <TIM_CCxChannelCmd>
      break;
 8007b8c:	e7dd      	b.n	8007b4a <HAL_TIM_Encoder_Stop+0x2c>
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007b8e:	b945      	cbnz	r5, 8007ba2 <HAL_TIM_Encoder_Stop+0x84>
 8007b90:	2301      	movs	r3, #1
 8007b92:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007b96:	b9a5      	cbnz	r5, 8007bc2 <HAL_TIM_Encoder_Stop+0xa4>
 8007b98:	2301      	movs	r3, #1
 8007b9a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 8007b9e:	2000      	movs	r0, #0
 8007ba0:	bd38      	pop	{r3, r4, r5, pc}
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007ba2:	2d04      	cmp	r5, #4
 8007ba4:	d005      	beq.n	8007bb2 <HAL_TIM_Encoder_Stop+0x94>
 8007ba6:	2d08      	cmp	r5, #8
 8007ba8:	d007      	beq.n	8007bba <HAL_TIM_Encoder_Stop+0x9c>
 8007baa:	2301      	movs	r3, #1
 8007bac:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8007bb0:	e7f1      	b.n	8007b96 <HAL_TIM_Encoder_Stop+0x78>
 8007bb2:	2301      	movs	r3, #1
 8007bb4:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007bb8:	e7ed      	b.n	8007b96 <HAL_TIM_Encoder_Stop+0x78>
 8007bba:	2301      	movs	r3, #1
 8007bbc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8007bc0:	e7e9      	b.n	8007b96 <HAL_TIM_Encoder_Stop+0x78>
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007bc2:	2d04      	cmp	r5, #4
 8007bc4:	d005      	beq.n	8007bd2 <HAL_TIM_Encoder_Stop+0xb4>
 8007bc6:	2d08      	cmp	r5, #8
 8007bc8:	d007      	beq.n	8007bda <HAL_TIM_Encoder_Stop+0xbc>
 8007bca:	2301      	movs	r3, #1
 8007bcc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8007bd0:	e7e5      	b.n	8007b9e <HAL_TIM_Encoder_Stop+0x80>
 8007bd2:	2301      	movs	r3, #1
 8007bd4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007bd8:	e7e1      	b.n	8007b9e <HAL_TIM_Encoder_Stop+0x80>
 8007bda:	2301      	movs	r3, #1
 8007bdc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8007be0:	e7dd      	b.n	8007b9e <HAL_TIM_Encoder_Stop+0x80>

08007be2 <HAL_TIM_Encoder_Start_IT>:
{
 8007be2:	b570      	push	{r4, r5, r6, lr}
 8007be4:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 8007be6:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8007bea:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8007bec:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 8007bf0:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8007bf4:	b2d2      	uxtb	r2, r2
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 8007bf6:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
  if (Channel == TIM_CHANNEL_1)
 8007bfa:	460e      	mov	r6, r1
 8007bfc:	bb09      	cbnz	r1, 8007c42 <HAL_TIM_Encoder_Start_IT+0x60>
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007bfe:	2801      	cmp	r0, #1
 8007c00:	d15b      	bne.n	8007cba <HAL_TIM_Encoder_Start_IT+0xd8>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))
 8007c02:	2a01      	cmp	r2, #1
 8007c04:	d15a      	bne.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c06:	2302      	movs	r3, #2
 8007c08:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c0c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  switch (Channel)
 8007c10:	2e00      	cmp	r6, #0
 8007c12:	d036      	beq.n	8007c82 <HAL_TIM_Encoder_Start_IT+0xa0>
 8007c14:	2e04      	cmp	r6, #4
 8007c16:	d045      	beq.n	8007ca4 <HAL_TIM_Encoder_Start_IT+0xc2>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007c18:	2201      	movs	r2, #1
 8007c1a:	2100      	movs	r1, #0
 8007c1c:	6820      	ldr	r0, [r4, #0]
 8007c1e:	f7fe fc47 	bl	80064b0 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007c22:	2201      	movs	r2, #1
 8007c24:	2104      	movs	r1, #4
 8007c26:	6820      	ldr	r0, [r4, #0]
 8007c28:	f7fe fc42 	bl	80064b0 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8007c2c:	6822      	ldr	r2, [r4, #0]
 8007c2e:	68d3      	ldr	r3, [r2, #12]
 8007c30:	f043 0302 	orr.w	r3, r3, #2
 8007c34:	60d3      	str	r3, [r2, #12]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8007c36:	6822      	ldr	r2, [r4, #0]
 8007c38:	68d3      	ldr	r3, [r2, #12]
 8007c3a:	f043 0304 	orr.w	r3, r3, #4
 8007c3e:	60d3      	str	r3, [r2, #12]
      break;
 8007c40:	e029      	b.n	8007c96 <HAL_TIM_Encoder_Start_IT+0xb4>
 8007c42:	b2db      	uxtb	r3, r3
 8007c44:	b2ed      	uxtb	r5, r5
  else if (Channel == TIM_CHANNEL_2)
 8007c46:	2904      	cmp	r1, #4
 8007c48:	d011      	beq.n	8007c6e <HAL_TIM_Encoder_Start_IT+0x8c>
    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007c4a:	2801      	cmp	r0, #1
 8007c4c:	d13b      	bne.n	8007cc6 <HAL_TIM_Encoder_Start_IT+0xe4>
        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8007c4e:	2b01      	cmp	r3, #1
 8007c50:	d134      	bne.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8007c52:	2a01      	cmp	r2, #1
 8007c54:	d139      	bne.n	8007cca <HAL_TIM_Encoder_Start_IT+0xe8>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8007c56:	2d01      	cmp	r5, #1
 8007c58:	d139      	bne.n	8007cce <HAL_TIM_Encoder_Start_IT+0xec>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c5a:	2302      	movs	r3, #2
 8007c5c:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c60:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c64:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c68:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007c6c:	e7d0      	b.n	8007c10 <HAL_TIM_Encoder_Start_IT+0x2e>
    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8007c6e:	2b01      	cmp	r3, #1
 8007c70:	d125      	bne.n	8007cbe <HAL_TIM_Encoder_Start_IT+0xdc>
        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8007c72:	2d01      	cmp	r5, #1
 8007c74:	d125      	bne.n	8007cc2 <HAL_TIM_Encoder_Start_IT+0xe0>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c76:	2302      	movs	r3, #2
 8007c78:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007c7c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007c80:	e7c6      	b.n	8007c10 <HAL_TIM_Encoder_Start_IT+0x2e>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007c82:	2201      	movs	r2, #1
 8007c84:	2100      	movs	r1, #0
 8007c86:	6820      	ldr	r0, [r4, #0]
 8007c88:	f7fe fc12 	bl	80064b0 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8007c8c:	6822      	ldr	r2, [r4, #0]
 8007c8e:	68d3      	ldr	r3, [r2, #12]
 8007c90:	f043 0302 	orr.w	r3, r3, #2
 8007c94:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_ENABLE(htim);
 8007c96:	6822      	ldr	r2, [r4, #0]
 8007c98:	6813      	ldr	r3, [r2, #0]
 8007c9a:	f043 0301 	orr.w	r3, r3, #1
 8007c9e:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8007ca0:	2000      	movs	r0, #0
 8007ca2:	e00b      	b.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007ca4:	2201      	movs	r2, #1
 8007ca6:	2104      	movs	r1, #4
 8007ca8:	6820      	ldr	r0, [r4, #0]
 8007caa:	f7fe fc01 	bl	80064b0 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8007cae:	6822      	ldr	r2, [r4, #0]
 8007cb0:	68d3      	ldr	r3, [r2, #12]
 8007cb2:	f043 0304 	orr.w	r3, r3, #4
 8007cb6:	60d3      	str	r3, [r2, #12]
      break;
 8007cb8:	e7ed      	b.n	8007c96 <HAL_TIM_Encoder_Start_IT+0xb4>
      return HAL_ERROR;
 8007cba:	2001      	movs	r0, #1
}
 8007cbc:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8007cbe:	2001      	movs	r0, #1
 8007cc0:	e7fc      	b.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
 8007cc2:	4618      	mov	r0, r3
 8007cc4:	e7fa      	b.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
      return HAL_ERROR;
 8007cc6:	2001      	movs	r0, #1
 8007cc8:	e7f8      	b.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
 8007cca:	4618      	mov	r0, r3
 8007ccc:	e7f6      	b.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>
 8007cce:	4610      	mov	r0, r2
 8007cd0:	e7f4      	b.n	8007cbc <HAL_TIM_Encoder_Start_IT+0xda>

08007cd2 <HAL_TIM_Encoder_Stop_IT>:
{
 8007cd2:	b538      	push	{r3, r4, r5, lr}
 8007cd4:	4604      	mov	r4, r0
  if (Channel == TIM_CHANNEL_1)
 8007cd6:	460d      	mov	r5, r1
 8007cd8:	2900      	cmp	r1, #0
 8007cda:	d031      	beq.n	8007d40 <HAL_TIM_Encoder_Stop_IT+0x6e>
  else if (Channel == TIM_CHANNEL_2)
 8007cdc:	2904      	cmp	r1, #4
 8007cde:	d03a      	beq.n	8007d56 <HAL_TIM_Encoder_Stop_IT+0x84>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 8007ce0:	2200      	movs	r2, #0
 8007ce2:	4611      	mov	r1, r2
 8007ce4:	6800      	ldr	r0, [r0, #0]
 8007ce6:	f7fe fbe3 	bl	80064b0 <TIM_CCxChannelCmd>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 8007cea:	2200      	movs	r2, #0
 8007cec:	2104      	movs	r1, #4
 8007cee:	6820      	ldr	r0, [r4, #0]
 8007cf0:	f7fe fbde 	bl	80064b0 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8007cf4:	6822      	ldr	r2, [r4, #0]
 8007cf6:	68d3      	ldr	r3, [r2, #12]
 8007cf8:	f023 0302 	bic.w	r3, r3, #2
 8007cfc:	60d3      	str	r3, [r2, #12]
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8007cfe:	6822      	ldr	r2, [r4, #0]
 8007d00:	68d3      	ldr	r3, [r2, #12]
 8007d02:	f023 0304 	bic.w	r3, r3, #4
 8007d06:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE(htim);
 8007d08:	6823      	ldr	r3, [r4, #0]
 8007d0a:	6a19      	ldr	r1, [r3, #32]
 8007d0c:	f241 1211 	movw	r2, #4369	; 0x1111
 8007d10:	4211      	tst	r1, r2
 8007d12:	d108      	bne.n	8007d26 <HAL_TIM_Encoder_Stop_IT+0x54>
 8007d14:	6a19      	ldr	r1, [r3, #32]
 8007d16:	f240 4244 	movw	r2, #1092	; 0x444
 8007d1a:	4211      	tst	r1, r2
 8007d1c:	d103      	bne.n	8007d26 <HAL_TIM_Encoder_Stop_IT+0x54>
 8007d1e:	681a      	ldr	r2, [r3, #0]
 8007d20:	f022 0201 	bic.w	r2, r2, #1
 8007d24:	601a      	str	r2, [r3, #0]
  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
 8007d26:	b30d      	cbz	r5, 8007d6c <HAL_TIM_Encoder_Stop_IT+0x9a>
 8007d28:	2d04      	cmp	r5, #4
 8007d2a:	d01f      	beq.n	8007d6c <HAL_TIM_Encoder_Stop_IT+0x9a>
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007d2c:	2301      	movs	r3, #1
 8007d2e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007d32:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007d36:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007d3a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007d3e:	e01d      	b.n	8007d7c <HAL_TIM_Encoder_Stop_IT+0xaa>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 8007d40:	2200      	movs	r2, #0
 8007d42:	4611      	mov	r1, r2
 8007d44:	6800      	ldr	r0, [r0, #0]
 8007d46:	f7fe fbb3 	bl	80064b0 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8007d4a:	6822      	ldr	r2, [r4, #0]
 8007d4c:	68d3      	ldr	r3, [r2, #12]
 8007d4e:	f023 0302 	bic.w	r3, r3, #2
 8007d52:	60d3      	str	r3, [r2, #12]
 8007d54:	e7d8      	b.n	8007d08 <HAL_TIM_Encoder_Stop_IT+0x36>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 8007d56:	2200      	movs	r2, #0
 8007d58:	2104      	movs	r1, #4
 8007d5a:	6800      	ldr	r0, [r0, #0]
 8007d5c:	f7fe fba8 	bl	80064b0 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8007d60:	6822      	ldr	r2, [r4, #0]
 8007d62:	68d3      	ldr	r3, [r2, #12]
 8007d64:	f023 0304 	bic.w	r3, r3, #4
 8007d68:	60d3      	str	r3, [r2, #12]
 8007d6a:	e7cd      	b.n	8007d08 <HAL_TIM_Encoder_Stop_IT+0x36>
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007d6c:	b945      	cbnz	r5, 8007d80 <HAL_TIM_Encoder_Stop_IT+0xae>
 8007d6e:	2301      	movs	r3, #1
 8007d70:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007d74:	b9a5      	cbnz	r5, 8007da0 <HAL_TIM_Encoder_Stop_IT+0xce>
 8007d76:	2301      	movs	r3, #1
 8007d78:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 8007d7c:	2000      	movs	r0, #0
 8007d7e:	bd38      	pop	{r3, r4, r5, pc}
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007d80:	2d04      	cmp	r5, #4
 8007d82:	d005      	beq.n	8007d90 <HAL_TIM_Encoder_Stop_IT+0xbe>
 8007d84:	2d08      	cmp	r5, #8
 8007d86:	d007      	beq.n	8007d98 <HAL_TIM_Encoder_Stop_IT+0xc6>
 8007d88:	2301      	movs	r3, #1
 8007d8a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8007d8e:	e7f1      	b.n	8007d74 <HAL_TIM_Encoder_Stop_IT+0xa2>
 8007d90:	2301      	movs	r3, #1
 8007d92:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007d96:	e7ed      	b.n	8007d74 <HAL_TIM_Encoder_Stop_IT+0xa2>
 8007d98:	2301      	movs	r3, #1
 8007d9a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8007d9e:	e7e9      	b.n	8007d74 <HAL_TIM_Encoder_Stop_IT+0xa2>
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8007da0:	2d04      	cmp	r5, #4
 8007da2:	d005      	beq.n	8007db0 <HAL_TIM_Encoder_Stop_IT+0xde>
 8007da4:	2d08      	cmp	r5, #8
 8007da6:	d007      	beq.n	8007db8 <HAL_TIM_Encoder_Stop_IT+0xe6>
 8007da8:	2301      	movs	r3, #1
 8007daa:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8007dae:	e7e5      	b.n	8007d7c <HAL_TIM_Encoder_Stop_IT+0xaa>
 8007db0:	2301      	movs	r3, #1
 8007db2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007db6:	e7e1      	b.n	8007d7c <HAL_TIM_Encoder_Stop_IT+0xaa>
 8007db8:	2301      	movs	r3, #1
 8007dba:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8007dbe:	e7dd      	b.n	8007d7c <HAL_TIM_Encoder_Stop_IT+0xaa>

08007dc0 <HAL_TIM_Encoder_Start_DMA>:
{
 8007dc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007dc4:	4604      	mov	r4, r0
 8007dc6:	461f      	mov	r7, r3
 8007dc8:	f8bd 8018 	ldrh.w	r8, [sp, #24]
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 8007dcc:	f890 503e 	ldrb.w	r5, [r0, #62]	; 0x3e
 8007dd0:	b2ed      	uxtb	r5, r5
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8007dd2:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
 8007dd6:	b2c6      	uxtb	r6, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 8007dd8:	f894 0042 	ldrb.w	r0, [r4, #66]	; 0x42
 8007ddc:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 8007dde:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
  if (Channel == TIM_CHANNEL_1)
 8007de2:	468c      	mov	ip, r1
 8007de4:	bb11      	cbnz	r1, 8007e2c <HAL_TIM_Encoder_Start_DMA+0x6c>
    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
 8007de6:	2d02      	cmp	r5, #2
 8007de8:	f000 80ee 	beq.w	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
 8007dec:	2802      	cmp	r0, #2
 8007dee:	f000 80e8 	beq.w	8007fc2 <HAL_TIM_Encoder_Start_DMA+0x202>
    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
 8007df2:	2d01      	cmp	r5, #1
 8007df4:	f040 80e7 	bne.w	8007fc6 <HAL_TIM_Encoder_Start_DMA+0x206>
             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
 8007df8:	2801      	cmp	r0, #1
 8007dfa:	f040 80e5 	bne.w	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      if ((pData1 == NULL) && (Length > 0U))
 8007dfe:	b182      	cbz	r2, 8007e22 <HAL_TIM_Encoder_Start_DMA+0x62>
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e00:	2302      	movs	r3, #2
 8007e02:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e06:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  switch (Channel)
 8007e0a:	f1bc 0f04 	cmp.w	ip, #4
 8007e0e:	d074      	beq.n	8007efa <HAL_TIM_Encoder_Start_DMA+0x13a>
 8007e10:	f1bc 0f3c 	cmp.w	ip, #60	; 0x3c
 8007e14:	f000 8095 	beq.w	8007f42 <HAL_TIM_Encoder_Start_DMA+0x182>
 8007e18:	f1bc 0f00 	cmp.w	ip, #0
 8007e1c:	d04a      	beq.n	8007eb4 <HAL_TIM_Encoder_Start_DMA+0xf4>
 8007e1e:	2500      	movs	r5, #0
 8007e20:	e0d2      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      if ((pData1 == NULL) && (Length > 0U))
 8007e22:	f1b8 0f00 	cmp.w	r8, #0
 8007e26:	d0eb      	beq.n	8007e00 <HAL_TIM_Encoder_Start_DMA+0x40>
        return HAL_ERROR;
 8007e28:	4605      	mov	r5, r0
 8007e2a:	e0cd      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007e2c:	b2db      	uxtb	r3, r3
  else if (Channel == TIM_CHANNEL_2)
 8007e2e:	2904      	cmp	r1, #4
 8007e30:	d023      	beq.n	8007e7a <HAL_TIM_Encoder_Start_DMA+0xba>
    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
 8007e32:	2d02      	cmp	r5, #2
 8007e34:	f000 80c8 	beq.w	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
        || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
 8007e38:	2e02      	cmp	r6, #2
 8007e3a:	f000 80d0 	beq.w	8007fde <HAL_TIM_Encoder_Start_DMA+0x21e>
        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
 8007e3e:	2802      	cmp	r0, #2
 8007e40:	f000 80cf 	beq.w	8007fe2 <HAL_TIM_Encoder_Start_DMA+0x222>
        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
 8007e44:	2b02      	cmp	r3, #2
 8007e46:	f000 80ce 	beq.w	8007fe6 <HAL_TIM_Encoder_Start_DMA+0x226>
    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
 8007e4a:	2d01      	cmp	r5, #1
 8007e4c:	f040 80cd 	bne.w	8007fea <HAL_TIM_Encoder_Start_DMA+0x22a>
             && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
 8007e50:	2e01      	cmp	r6, #1
 8007e52:	f040 80b9 	bne.w	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
 8007e56:	2801      	cmp	r0, #1
 8007e58:	f040 80c9 	bne.w	8007fee <HAL_TIM_Encoder_Start_DMA+0x22e>
             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
 8007e5c:	2b01      	cmp	r3, #1
 8007e5e:	f040 80c8 	bne.w	8007ff2 <HAL_TIM_Encoder_Start_DMA+0x232>
      if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
 8007e62:	b312      	cbz	r2, 8007eaa <HAL_TIM_Encoder_Start_DMA+0xea>
 8007e64:	b30f      	cbz	r7, 8007eaa <HAL_TIM_Encoder_Start_DMA+0xea>
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e66:	2302      	movs	r3, #2
 8007e68:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e6c:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e70:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e74:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
      if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
 8007e78:	e7c7      	b.n	8007e0a <HAL_TIM_Encoder_Start_DMA+0x4a>
    if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)
 8007e7a:	2e02      	cmp	r6, #2
 8007e7c:	f000 80a7 	beq.w	8007fce <HAL_TIM_Encoder_Start_DMA+0x20e>
        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))
 8007e80:	2b02      	cmp	r3, #2
 8007e82:	f000 80a6 	beq.w	8007fd2 <HAL_TIM_Encoder_Start_DMA+0x212>
    else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)
 8007e86:	2e01      	cmp	r6, #1
 8007e88:	f040 80a5 	bne.w	8007fd6 <HAL_TIM_Encoder_Start_DMA+0x216>
             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))
 8007e8c:	2b01      	cmp	r3, #1
 8007e8e:	f040 80a4 	bne.w	8007fda <HAL_TIM_Encoder_Start_DMA+0x21a>
      if ((pData2 == NULL) && (Length > 0U))
 8007e92:	b12f      	cbz	r7, 8007ea0 <HAL_TIM_Encoder_Start_DMA+0xe0>
        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e94:	2302      	movs	r3, #2
 8007e96:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8007e9a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007e9e:	e7b4      	b.n	8007e0a <HAL_TIM_Encoder_Start_DMA+0x4a>
      if ((pData2 == NULL) && (Length > 0U))
 8007ea0:	f1b8 0f00 	cmp.w	r8, #0
 8007ea4:	d0f6      	beq.n	8007e94 <HAL_TIM_Encoder_Start_DMA+0xd4>
        return HAL_ERROR;
 8007ea6:	461d      	mov	r5, r3
 8007ea8:	e08e      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
 8007eaa:	f1b8 0f00 	cmp.w	r8, #0
 8007eae:	d0da      	beq.n	8007e66 <HAL_TIM_Encoder_Start_DMA+0xa6>
        return HAL_ERROR;
 8007eb0:	461d      	mov	r5, r3
 8007eb2:	e089      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
 8007eb4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007eb6:	4950      	ldr	r1, [pc, #320]	; (8007ff8 <HAL_TIM_Encoder_Start_DMA+0x238>)
 8007eb8:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 8007eba:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007ebc:	494f      	ldr	r1, [pc, #316]	; (8007ffc <HAL_TIM_Encoder_Start_DMA+0x23c>)
 8007ebe:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 8007ec0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007ec2:	494f      	ldr	r1, [pc, #316]	; (8008000 <HAL_TIM_Encoder_Start_DMA+0x240>)
 8007ec4:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,
 8007ec6:	6821      	ldr	r1, [r4, #0]
 8007ec8:	4643      	mov	r3, r8
 8007eca:	3134      	adds	r1, #52	; 0x34
 8007ecc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8007ece:	f7fb fcc7 	bl	8003860 <HAL_DMA_Start_IT>
 8007ed2:	4605      	mov	r5, r0
 8007ed4:	b108      	cbz	r0, 8007eda <HAL_TIM_Encoder_Start_DMA+0x11a>
        return HAL_ERROR;
 8007ed6:	2501      	movs	r5, #1
 8007ed8:	e076      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 8007eda:	6822      	ldr	r2, [r4, #0]
 8007edc:	68d3      	ldr	r3, [r2, #12]
 8007ede:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007ee2:	60d3      	str	r3, [r2, #12]
      __HAL_TIM_ENABLE(htim);
 8007ee4:	6822      	ldr	r2, [r4, #0]
 8007ee6:	6813      	ldr	r3, [r2, #0]
 8007ee8:	f043 0301 	orr.w	r3, r3, #1
 8007eec:	6013      	str	r3, [r2, #0]
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007eee:	2201      	movs	r2, #1
 8007ef0:	2100      	movs	r1, #0
 8007ef2:	6820      	ldr	r0, [r4, #0]
 8007ef4:	f7fe fadc 	bl	80064b0 <TIM_CCxChannelCmd>
      break;
 8007ef8:	e066      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
 8007efa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007efc:	4a3e      	ldr	r2, [pc, #248]	; (8007ff8 <HAL_TIM_Encoder_Start_DMA+0x238>)
 8007efe:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 8007f00:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007f02:	4a3e      	ldr	r2, [pc, #248]	; (8007ffc <HAL_TIM_Encoder_Start_DMA+0x23c>)
 8007f04:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
 8007f06:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007f08:	4a3d      	ldr	r2, [pc, #244]	; (8008000 <HAL_TIM_Encoder_Start_DMA+0x240>)
 8007f0a:	631a      	str	r2, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,
 8007f0c:	6821      	ldr	r1, [r4, #0]
 8007f0e:	4643      	mov	r3, r8
 8007f10:	463a      	mov	r2, r7
 8007f12:	3138      	adds	r1, #56	; 0x38
 8007f14:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8007f16:	f7fb fca3 	bl	8003860 <HAL_DMA_Start_IT>
 8007f1a:	4605      	mov	r5, r0
 8007f1c:	b108      	cbz	r0, 8007f22 <HAL_TIM_Encoder_Start_DMA+0x162>
        return HAL_ERROR;
 8007f1e:	2501      	movs	r5, #1
 8007f20:	e052      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 8007f22:	6822      	ldr	r2, [r4, #0]
 8007f24:	68d3      	ldr	r3, [r2, #12]
 8007f26:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8007f2a:	60d3      	str	r3, [r2, #12]
      __HAL_TIM_ENABLE(htim);
 8007f2c:	6822      	ldr	r2, [r4, #0]
 8007f2e:	6813      	ldr	r3, [r2, #0]
 8007f30:	f043 0301 	orr.w	r3, r3, #1
 8007f34:	6013      	str	r3, [r2, #0]
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007f36:	2201      	movs	r2, #1
 8007f38:	2104      	movs	r1, #4
 8007f3a:	6820      	ldr	r0, [r4, #0]
 8007f3c:	f7fe fab8 	bl	80064b0 <TIM_CCxChannelCmd>
      break;
 8007f40:	e042      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
 8007f42:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f44:	492c      	ldr	r1, [pc, #176]	; (8007ff8 <HAL_TIM_Encoder_Start_DMA+0x238>)
 8007f46:	6299      	str	r1, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 8007f48:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f4a:	492c      	ldr	r1, [pc, #176]	; (8007ffc <HAL_TIM_Encoder_Start_DMA+0x23c>)
 8007f4c:	62d9      	str	r1, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 8007f4e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f50:	492b      	ldr	r1, [pc, #172]	; (8008000 <HAL_TIM_Encoder_Start_DMA+0x240>)
 8007f52:	6319      	str	r1, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,
 8007f54:	6821      	ldr	r1, [r4, #0]
 8007f56:	4643      	mov	r3, r8
 8007f58:	3134      	adds	r1, #52	; 0x34
 8007f5a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8007f5c:	f7fb fc80 	bl	8003860 <HAL_DMA_Start_IT>
 8007f60:	b108      	cbz	r0, 8007f66 <HAL_TIM_Encoder_Start_DMA+0x1a6>
        return HAL_ERROR;
 8007f62:	2501      	movs	r5, #1
 8007f64:	e030      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
 8007f66:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007f68:	4a23      	ldr	r2, [pc, #140]	; (8007ff8 <HAL_TIM_Encoder_Start_DMA+0x238>)
 8007f6a:	629a      	str	r2, [r3, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 8007f6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007f6e:	4a23      	ldr	r2, [pc, #140]	; (8007ffc <HAL_TIM_Encoder_Start_DMA+0x23c>)
 8007f70:	62da      	str	r2, [r3, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
 8007f72:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007f74:	4a22      	ldr	r2, [pc, #136]	; (8008000 <HAL_TIM_Encoder_Start_DMA+0x240>)
 8007f76:	631a      	str	r2, [r3, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,
 8007f78:	6821      	ldr	r1, [r4, #0]
 8007f7a:	4643      	mov	r3, r8
 8007f7c:	463a      	mov	r2, r7
 8007f7e:	3138      	adds	r1, #56	; 0x38
 8007f80:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8007f82:	f7fb fc6d 	bl	8003860 <HAL_DMA_Start_IT>
 8007f86:	4605      	mov	r5, r0
 8007f88:	b108      	cbz	r0, 8007f8e <HAL_TIM_Encoder_Start_DMA+0x1ce>
        return HAL_ERROR;
 8007f8a:	2501      	movs	r5, #1
 8007f8c:	e01c      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      __HAL_TIM_ENABLE(htim);
 8007f8e:	6822      	ldr	r2, [r4, #0]
 8007f90:	6813      	ldr	r3, [r2, #0]
 8007f92:	f043 0301 	orr.w	r3, r3, #1
 8007f96:	6013      	str	r3, [r2, #0]
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8007f98:	2201      	movs	r2, #1
 8007f9a:	2100      	movs	r1, #0
 8007f9c:	6820      	ldr	r0, [r4, #0]
 8007f9e:	f7fe fa87 	bl	80064b0 <TIM_CCxChannelCmd>
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
 8007fa2:	2201      	movs	r2, #1
 8007fa4:	2104      	movs	r1, #4
 8007fa6:	6820      	ldr	r0, [r4, #0]
 8007fa8:	f7fe fa82 	bl	80064b0 <TIM_CCxChannelCmd>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 8007fac:	6822      	ldr	r2, [r4, #0]
 8007fae:	68d3      	ldr	r3, [r2, #12]
 8007fb0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007fb4:	60d3      	str	r3, [r2, #12]
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 8007fb6:	6822      	ldr	r2, [r4, #0]
 8007fb8:	68d3      	ldr	r3, [r2, #12]
 8007fba:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8007fbe:	60d3      	str	r3, [r2, #12]
      break;
 8007fc0:	e002      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      return HAL_BUSY;
 8007fc2:	4605      	mov	r5, r0
 8007fc4:	e000      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      return HAL_ERROR;
 8007fc6:	2501      	movs	r5, #1
}
 8007fc8:	4628      	mov	r0, r5
 8007fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return HAL_BUSY;
 8007fce:	4635      	mov	r5, r6
 8007fd0:	e7fa      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007fd2:	461d      	mov	r5, r3
 8007fd4:	e7f8      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      return HAL_ERROR;
 8007fd6:	2501      	movs	r5, #1
 8007fd8:	e7f6      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007fda:	4635      	mov	r5, r6
 8007fdc:	e7f4      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      return HAL_BUSY;
 8007fde:	4635      	mov	r5, r6
 8007fe0:	e7f2      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007fe2:	4605      	mov	r5, r0
 8007fe4:	e7f0      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007fe6:	461d      	mov	r5, r3
 8007fe8:	e7ee      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
      return HAL_ERROR;
 8007fea:	2501      	movs	r5, #1
 8007fec:	e7ec      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007fee:	4635      	mov	r5, r6
 8007ff0:	e7ea      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007ff2:	4605      	mov	r5, r0
 8007ff4:	e7e8      	b.n	8007fc8 <HAL_TIM_Encoder_Start_DMA+0x208>
 8007ff6:	bf00      	nop
 8007ff8:	08005783 	.word	0x08005783
 8007ffc:	08005805 	.word	0x08005805
 8008000:	08005a95 	.word	0x08005a95

08008004 <HAL_TIM_Encoder_Stop_DMA>:
{
 8008004:	b538      	push	{r3, r4, r5, lr}
 8008006:	4604      	mov	r4, r0
  if (Channel == TIM_CHANNEL_1)
 8008008:	460d      	mov	r5, r1
 800800a:	2900      	cmp	r1, #0
 800800c:	d037      	beq.n	800807e <HAL_TIM_Encoder_Stop_DMA+0x7a>
  else if (Channel == TIM_CHANNEL_2)
 800800e:	2904      	cmp	r1, #4
 8008010:	d043      	beq.n	800809a <HAL_TIM_Encoder_Stop_DMA+0x96>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 8008012:	2200      	movs	r2, #0
 8008014:	4611      	mov	r1, r2
 8008016:	6800      	ldr	r0, [r0, #0]
 8008018:	f7fe fa4a 	bl	80064b0 <TIM_CCxChannelCmd>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 800801c:	2200      	movs	r2, #0
 800801e:	2104      	movs	r1, #4
 8008020:	6820      	ldr	r0, [r4, #0]
 8008022:	f7fe fa45 	bl	80064b0 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 8008026:	6822      	ldr	r2, [r4, #0]
 8008028:	68d3      	ldr	r3, [r2, #12]
 800802a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800802e:	60d3      	str	r3, [r2, #12]
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 8008030:	6822      	ldr	r2, [r4, #0]
 8008032:	68d3      	ldr	r3, [r2, #12]
 8008034:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008038:	60d3      	str	r3, [r2, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 800803a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800803c:	f7fb fc6c 	bl	8003918 <HAL_DMA_Abort_IT>
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 8008040:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008042:	f7fb fc69 	bl	8003918 <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
 8008046:	6823      	ldr	r3, [r4, #0]
 8008048:	6a19      	ldr	r1, [r3, #32]
 800804a:	f241 1211 	movw	r2, #4369	; 0x1111
 800804e:	4211      	tst	r1, r2
 8008050:	d108      	bne.n	8008064 <HAL_TIM_Encoder_Stop_DMA+0x60>
 8008052:	6a19      	ldr	r1, [r3, #32]
 8008054:	f240 4244 	movw	r2, #1092	; 0x444
 8008058:	4211      	tst	r1, r2
 800805a:	d103      	bne.n	8008064 <HAL_TIM_Encoder_Stop_DMA+0x60>
 800805c:	681a      	ldr	r2, [r3, #0]
 800805e:	f022 0201 	bic.w	r2, r2, #1
 8008062:	601a      	str	r2, [r3, #0]
  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))
 8008064:	b33d      	cbz	r5, 80080b6 <HAL_TIM_Encoder_Stop_DMA+0xb2>
 8008066:	2d04      	cmp	r5, #4
 8008068:	d025      	beq.n	80080b6 <HAL_TIM_Encoder_Stop_DMA+0xb2>
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 800806a:	2301      	movs	r3, #1
 800806c:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8008070:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8008074:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8008078:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800807c:	e023      	b.n	80080c6 <HAL_TIM_Encoder_Stop_DMA+0xc2>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 800807e:	2200      	movs	r2, #0
 8008080:	4611      	mov	r1, r2
 8008082:	6800      	ldr	r0, [r0, #0]
 8008084:	f7fe fa14 	bl	80064b0 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 8008088:	6822      	ldr	r2, [r4, #0]
 800808a:	68d3      	ldr	r3, [r2, #12]
 800808c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8008090:	60d3      	str	r3, [r2, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 8008092:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8008094:	f7fb fc40 	bl	8003918 <HAL_DMA_Abort_IT>
 8008098:	e7d5      	b.n	8008046 <HAL_TIM_Encoder_Stop_DMA+0x42>
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
 800809a:	2200      	movs	r2, #0
 800809c:	2104      	movs	r1, #4
 800809e:	6800      	ldr	r0, [r0, #0]
 80080a0:	f7fe fa06 	bl	80064b0 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 80080a4:	6822      	ldr	r2, [r4, #0]
 80080a6:	68d3      	ldr	r3, [r2, #12]
 80080a8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80080ac:	60d3      	str	r3, [r2, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 80080ae:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80080b0:	f7fb fc32 	bl	8003918 <HAL_DMA_Abort_IT>
 80080b4:	e7c7      	b.n	8008046 <HAL_TIM_Encoder_Stop_DMA+0x42>
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80080b6:	b945      	cbnz	r5, 80080ca <HAL_TIM_Encoder_Stop_DMA+0xc6>
 80080b8:	2301      	movs	r3, #1
 80080ba:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80080be:	b9a5      	cbnz	r5, 80080ea <HAL_TIM_Encoder_Stop_DMA+0xe6>
 80080c0:	2301      	movs	r3, #1
 80080c2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 80080c6:	2000      	movs	r0, #0
 80080c8:	bd38      	pop	{r3, r4, r5, pc}
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80080ca:	2d04      	cmp	r5, #4
 80080cc:	d005      	beq.n	80080da <HAL_TIM_Encoder_Stop_DMA+0xd6>
 80080ce:	2d08      	cmp	r5, #8
 80080d0:	d007      	beq.n	80080e2 <HAL_TIM_Encoder_Stop_DMA+0xde>
 80080d2:	2301      	movs	r3, #1
 80080d4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80080d8:	e7f1      	b.n	80080be <HAL_TIM_Encoder_Stop_DMA+0xba>
 80080da:	2301      	movs	r3, #1
 80080dc:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 80080e0:	e7ed      	b.n	80080be <HAL_TIM_Encoder_Stop_DMA+0xba>
 80080e2:	2301      	movs	r3, #1
 80080e4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80080e8:	e7e9      	b.n	80080be <HAL_TIM_Encoder_Stop_DMA+0xba>
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80080ea:	2d04      	cmp	r5, #4
 80080ec:	d005      	beq.n	80080fa <HAL_TIM_Encoder_Stop_DMA+0xf6>
 80080ee:	2d08      	cmp	r5, #8
 80080f0:	d007      	beq.n	8008102 <HAL_TIM_Encoder_Stop_DMA+0xfe>
 80080f2:	2301      	movs	r3, #1
 80080f4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80080f8:	e7e5      	b.n	80080c6 <HAL_TIM_Encoder_Stop_DMA+0xc2>
 80080fa:	2301      	movs	r3, #1
 80080fc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8008100:	e7e1      	b.n	80080c6 <HAL_TIM_Encoder_Stop_DMA+0xc2>
 8008102:	2301      	movs	r3, #1
 8008104:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8008108:	e7dd      	b.n	80080c6 <HAL_TIM_Encoder_Stop_DMA+0xc2>
 800810a:	bf00      	nop

0800810c <TIM_CCxNChannelCmd>:
  * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
  * @retval None
  */
static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
{
 800810c:	b410      	push	{r4}
  uint32_t tmp;

  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800810e:	f001 011f 	and.w	r1, r1, #31
 8008112:	2304      	movs	r3, #4
 8008114:	fa03 f401 	lsl.w	r4, r3, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &=  ~tmp;
 8008118:	6a03      	ldr	r3, [r0, #32]
 800811a:	ea23 0304 	bic.w	r3, r3, r4
 800811e:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */
  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8008120:	6a03      	ldr	r3, [r0, #32]
 8008122:	fa02 f101 	lsl.w	r1, r2, r1
 8008126:	430b      	orrs	r3, r1
 8008128:	6203      	str	r3, [r0, #32]
}
 800812a:	bc10      	pop	{r4}
 800812c:	4770      	bx	lr

0800812e <TIM_DMAErrorCCxN>:
{
 800812e:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008130:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8008132:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008134:	4283      	cmp	r3, r0
 8008136:	d00b      	beq.n	8008150 <TIM_DMAErrorCCxN+0x22>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 8008138:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800813a:	4283      	cmp	r3, r0
 800813c:	d00d      	beq.n	800815a <TIM_DMAErrorCCxN+0x2c>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 800813e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008140:	4283      	cmp	r3, r0
 8008142:	d010      	beq.n	8008166 <TIM_DMAErrorCCxN+0x38>
  HAL_TIM_ErrorCallback(htim);
 8008144:	4620      	mov	r0, r4
 8008146:	f7fd fca4 	bl	8005a92 <HAL_TIM_ErrorCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800814a:	2300      	movs	r3, #0
 800814c:	7723      	strb	r3, [r4, #28]
}
 800814e:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8008150:	2301      	movs	r3, #1
 8008152:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8008154:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8008158:	e7f4      	b.n	8008144 <TIM_DMAErrorCCxN+0x16>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800815a:	2302      	movs	r3, #2
 800815c:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 800815e:	2301      	movs	r3, #1
 8008160:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8008164:	e7ee      	b.n	8008144 <TIM_DMAErrorCCxN+0x16>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8008166:	2304      	movs	r3, #4
 8008168:	7723      	strb	r3, [r4, #28]
    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
 800816a:	2301      	movs	r3, #1
 800816c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8008170:	e7e8      	b.n	8008144 <TIM_DMAErrorCCxN+0x16>

08008172 <TIM_DMADelayPulseNCplt>:
{
 8008172:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008174:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
 8008176:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008178:	4283      	cmp	r3, r0
 800817a:	d00e      	beq.n	800819a <TIM_DMADelayPulseNCplt+0x28>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
 800817c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800817e:	4283      	cmp	r3, r0
 8008180:	d014      	beq.n	80081ac <TIM_DMADelayPulseNCplt+0x3a>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
 8008182:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008184:	4283      	cmp	r3, r0
 8008186:	d01a      	beq.n	80081be <TIM_DMADelayPulseNCplt+0x4c>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
 8008188:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800818a:	4283      	cmp	r3, r0
 800818c:	d020      	beq.n	80081d0 <TIM_DMADelayPulseNCplt+0x5e>
  HAL_TIM_PWM_PulseFinishedCallback(htim);
 800818e:	4620      	mov	r0, r4
 8008190:	f7fd fb57 	bl	8005842 <HAL_TIM_PWM_PulseFinishedCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8008194:	2300      	movs	r3, #0
 8008196:	7723      	strb	r3, [r4, #28]
}
 8008198:	bd10      	pop	{r4, pc}
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800819a:	2301      	movs	r3, #1
 800819c:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 800819e:	6983      	ldr	r3, [r0, #24]
 80081a0:	2b00      	cmp	r3, #0
 80081a2:	d1f4      	bne.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80081a4:	2301      	movs	r3, #1
 80081a6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80081aa:	e7f0      	b.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80081ac:	2302      	movs	r3, #2
 80081ae:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80081b0:	6983      	ldr	r3, [r0, #24]
 80081b2:	2b00      	cmp	r3, #0
 80081b4:	d1eb      	bne.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80081b6:	2301      	movs	r3, #1
 80081b8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80081bc:	e7e7      	b.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80081be:	2304      	movs	r3, #4
 80081c0:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80081c2:	6983      	ldr	r3, [r0, #24]
 80081c4:	2b00      	cmp	r3, #0
 80081c6:	d1e2      	bne.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
 80081c8:	2301      	movs	r3, #1
 80081ca:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80081ce:	e7de      	b.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80081d0:	2308      	movs	r3, #8
 80081d2:	7723      	strb	r3, [r4, #28]
    if (hdma->Init.Mode == DMA_NORMAL)
 80081d4:	6983      	ldr	r3, [r0, #24]
 80081d6:	2b00      	cmp	r3, #0
 80081d8:	d1d9      	bne.n	800818e <TIM_DMADelayPulseNCplt+0x1c>
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
 80081da:	2301      	movs	r3, #1
 80081dc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80081e0:	e7d5      	b.n	800818e <TIM_DMADelayPulseNCplt+0x1c>

080081e2 <HAL_TIMEx_HallSensor_MspInit>:
}
 80081e2:	4770      	bx	lr

080081e4 <HAL_TIMEx_HallSensor_Init>:
  if (htim == NULL)
 80081e4:	2800      	cmp	r0, #0
 80081e6:	d065      	beq.n	80082b4 <HAL_TIMEx_HallSensor_Init+0xd0>
{
 80081e8:	b570      	push	{r4, r5, r6, lr}
 80081ea:	b088      	sub	sp, #32
 80081ec:	460e      	mov	r6, r1
 80081ee:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 80081f0:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80081f4:	2b00      	cmp	r3, #0
 80081f6:	d058      	beq.n	80082aa <HAL_TIMEx_HallSensor_Init+0xc6>
  htim->State = HAL_TIM_STATE_BUSY;
 80081f8:	2302      	movs	r3, #2
 80081fa:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80081fe:	4621      	mov	r1, r4
 8008200:	f851 0b04 	ldr.w	r0, [r1], #4
 8008204:	f7fd fca0 	bl	8005b48 <TIM_Base_SetConfig>
  TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
 8008208:	68b3      	ldr	r3, [r6, #8]
 800820a:	2203      	movs	r2, #3
 800820c:	6831      	ldr	r1, [r6, #0]
 800820e:	6820      	ldr	r0, [r4, #0]
 8008210:	f7fd fecd 	bl	8005fae <TIM_TI1_SetConfig>
  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8008214:	6822      	ldr	r2, [r4, #0]
 8008216:	6993      	ldr	r3, [r2, #24]
 8008218:	f023 030c 	bic.w	r3, r3, #12
 800821c:	6193      	str	r3, [r2, #24]
  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
 800821e:	6822      	ldr	r2, [r4, #0]
 8008220:	6993      	ldr	r3, [r2, #24]
 8008222:	6871      	ldr	r1, [r6, #4]
 8008224:	430b      	orrs	r3, r1
 8008226:	6193      	str	r3, [r2, #24]
  htim->Instance->CR2 |= TIM_CR2_TI1S;
 8008228:	6822      	ldr	r2, [r4, #0]
 800822a:	6853      	ldr	r3, [r2, #4]
 800822c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008230:	6053      	str	r3, [r2, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_TS;
 8008232:	6822      	ldr	r2, [r4, #0]
 8008234:	6893      	ldr	r3, [r2, #8]
 8008236:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800823a:	6093      	str	r3, [r2, #8]
  htim->Instance->SMCR |= TIM_TS_TI1F_ED;
 800823c:	6822      	ldr	r2, [r4, #0]
 800823e:	6893      	ldr	r3, [r2, #8]
 8008240:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008244:	6093      	str	r3, [r2, #8]
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8008246:	6822      	ldr	r2, [r4, #0]
 8008248:	6893      	ldr	r3, [r2, #8]
 800824a:	f023 0307 	bic.w	r3, r3, #7
 800824e:	6093      	str	r3, [r2, #8]
  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
 8008250:	6822      	ldr	r2, [r4, #0]
 8008252:	6893      	ldr	r3, [r2, #8]
 8008254:	f043 0304 	orr.w	r3, r3, #4
 8008258:	6093      	str	r3, [r2, #8]
  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
 800825a:	2500      	movs	r5, #0
 800825c:	9505      	str	r5, [sp, #20]
  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
 800825e:	9506      	str	r5, [sp, #24]
  OC_Config.OCMode = TIM_OCMODE_PWM2;
 8008260:	2370      	movs	r3, #112	; 0x70
 8008262:	9301      	str	r3, [sp, #4]
  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8008264:	9507      	str	r5, [sp, #28]
  OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8008266:	9504      	str	r5, [sp, #16]
  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
 8008268:	9503      	str	r5, [sp, #12]
  OC_Config.Pulse = sConfig->Commutation_Delay;
 800826a:	68f3      	ldr	r3, [r6, #12]
 800826c:	9302      	str	r3, [sp, #8]
  TIM_OC2_SetConfig(htim->Instance, &OC_Config);
 800826e:	a901      	add	r1, sp, #4
 8008270:	6820      	ldr	r0, [r4, #0]
 8008272:	f7fd fdd9 	bl	8005e28 <TIM_OC2_SetConfig>
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8008276:	6822      	ldr	r2, [r4, #0]
 8008278:	6853      	ldr	r3, [r2, #4]
 800827a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800827e:	6053      	str	r3, [r2, #4]
  htim->Instance->CR2 |= TIM_TRGO_OC2REF;
 8008280:	6822      	ldr	r2, [r4, #0]
 8008282:	6853      	ldr	r3, [r2, #4]
 8008284:	f043 0350 	orr.w	r3, r3, #80	; 0x50
 8008288:	6053      	str	r3, [r2, #4]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800828a:	2301      	movs	r3, #1
 800828c:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8008290:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8008294:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8008298:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 800829c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  htim->State = HAL_TIM_STATE_READY;
 80082a0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80082a4:	4628      	mov	r0, r5
}
 80082a6:	b008      	add	sp, #32
 80082a8:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 80082aa:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIMEx_HallSensor_MspInit(htim);
 80082ae:	f7ff ff98 	bl	80081e2 <HAL_TIMEx_HallSensor_MspInit>
 80082b2:	e7a1      	b.n	80081f8 <HAL_TIMEx_HallSensor_Init+0x14>
    return HAL_ERROR;
 80082b4:	2001      	movs	r0, #1
}
 80082b6:	4770      	bx	lr

080082b8 <HAL_TIMEx_HallSensor_MspDeInit>:
}
 80082b8:	4770      	bx	lr

080082ba <HAL_TIMEx_HallSensor_DeInit>:
{
 80082ba:	b510      	push	{r4, lr}
 80082bc:	4604      	mov	r4, r0
  htim->State = HAL_TIM_STATE_BUSY;
 80082be:	2302      	movs	r3, #2
 80082c0:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 80082c4:	6803      	ldr	r3, [r0, #0]
 80082c6:	6a19      	ldr	r1, [r3, #32]
 80082c8:	f241 1211 	movw	r2, #4369	; 0x1111
 80082cc:	4211      	tst	r1, r2
 80082ce:	d108      	bne.n	80082e2 <HAL_TIMEx_HallSensor_DeInit+0x28>
 80082d0:	6a19      	ldr	r1, [r3, #32]
 80082d2:	f240 4244 	movw	r2, #1092	; 0x444
 80082d6:	4211      	tst	r1, r2
 80082d8:	d103      	bne.n	80082e2 <HAL_TIMEx_HallSensor_DeInit+0x28>
 80082da:	681a      	ldr	r2, [r3, #0]
 80082dc:	f022 0201 	bic.w	r2, r2, #1
 80082e0:	601a      	str	r2, [r3, #0]
  HAL_TIMEx_HallSensor_MspDeInit(htim);
 80082e2:	4620      	mov	r0, r4
 80082e4:	f7ff ffe8 	bl	80082b8 <HAL_TIMEx_HallSensor_MspDeInit>
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 80082e8:	2000      	movs	r0, #0
 80082ea:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
 80082ee:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
 80082f2:	f884 003f 	strb.w	r0, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
 80082f6:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
 80082fa:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  htim->State = HAL_TIM_STATE_RESET;
 80082fe:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8008302:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8008306:	bd10      	pop	{r4, pc}

08008308 <HAL_TIMEx_HallSensor_Start>:
{
 8008308:	b510      	push	{r4, lr}
 800830a:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 800830c:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 8008310:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8008312:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 8008316:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 800831a:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 800831e:	2801      	cmp	r0, #1
 8008320:	d137      	bne.n	8008392 <HAL_TIMEx_HallSensor_Start+0x8a>
 8008322:	b2db      	uxtb	r3, r3
 8008324:	b2d2      	uxtb	r2, r2
 8008326:	b2c9      	uxtb	r1, r1
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8008328:	2b01      	cmp	r3, #1
 800832a:	d133      	bne.n	8008394 <HAL_TIMEx_HallSensor_Start+0x8c>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 800832c:	2a01      	cmp	r2, #1
 800832e:	d132      	bne.n	8008396 <HAL_TIMEx_HallSensor_Start+0x8e>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 8008330:	2901      	cmp	r1, #1
 8008332:	d001      	beq.n	8008338 <HAL_TIMEx_HallSensor_Start+0x30>
    return HAL_ERROR;
 8008334:	4610      	mov	r0, r2
 8008336:	e02d      	b.n	8008394 <HAL_TIMEx_HallSensor_Start+0x8c>
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8008338:	2302      	movs	r3, #2
 800833a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 800833e:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8008342:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8008346:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800834a:	2100      	movs	r1, #0
 800834c:	6820      	ldr	r0, [r4, #0]
 800834e:	f7fe f8af 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008352:	6823      	ldr	r3, [r4, #0]
 8008354:	4a12      	ldr	r2, [pc, #72]	; (80083a0 <HAL_TIMEx_HallSensor_Start+0x98>)
 8008356:	4293      	cmp	r3, r2
 8008358:	d010      	beq.n	800837c <HAL_TIMEx_HallSensor_Start+0x74>
 800835a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800835e:	d00d      	beq.n	800837c <HAL_TIMEx_HallSensor_Start+0x74>
 8008360:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008364:	4293      	cmp	r3, r2
 8008366:	d009      	beq.n	800837c <HAL_TIMEx_HallSensor_Start+0x74>
 8008368:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800836c:	4293      	cmp	r3, r2
 800836e:	d005      	beq.n	800837c <HAL_TIMEx_HallSensor_Start+0x74>
    __HAL_TIM_ENABLE(htim);
 8008370:	681a      	ldr	r2, [r3, #0]
 8008372:	f042 0201 	orr.w	r2, r2, #1
 8008376:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008378:	2000      	movs	r0, #0
 800837a:	e00b      	b.n	8008394 <HAL_TIMEx_HallSensor_Start+0x8c>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800837c:	689a      	ldr	r2, [r3, #8]
 800837e:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8008382:	2a06      	cmp	r2, #6
 8008384:	d009      	beq.n	800839a <HAL_TIMEx_HallSensor_Start+0x92>
      __HAL_TIM_ENABLE(htim);
 8008386:	681a      	ldr	r2, [r3, #0]
 8008388:	f042 0201 	orr.w	r2, r2, #1
 800838c:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800838e:	2000      	movs	r0, #0
 8008390:	e000      	b.n	8008394 <HAL_TIMEx_HallSensor_Start+0x8c>
    return HAL_ERROR;
 8008392:	2001      	movs	r0, #1
}
 8008394:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8008396:	4618      	mov	r0, r3
 8008398:	e7fc      	b.n	8008394 <HAL_TIMEx_HallSensor_Start+0x8c>
  return HAL_OK;
 800839a:	2000      	movs	r0, #0
 800839c:	e7fa      	b.n	8008394 <HAL_TIMEx_HallSensor_Start+0x8c>
 800839e:	bf00      	nop
 80083a0:	40012c00 	.word	0x40012c00

080083a4 <HAL_TIMEx_HallSensor_Stop>:
{
 80083a4:	b510      	push	{r4, lr}
 80083a6:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 80083a8:	2200      	movs	r2, #0
 80083aa:	4611      	mov	r1, r2
 80083ac:	6800      	ldr	r0, [r0, #0]
 80083ae:	f7fe f87f 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
 80083b2:	6823      	ldr	r3, [r4, #0]
 80083b4:	6a19      	ldr	r1, [r3, #32]
 80083b6:	f241 1211 	movw	r2, #4369	; 0x1111
 80083ba:	4211      	tst	r1, r2
 80083bc:	d108      	bne.n	80083d0 <HAL_TIMEx_HallSensor_Stop+0x2c>
 80083be:	6a19      	ldr	r1, [r3, #32]
 80083c0:	f240 4244 	movw	r2, #1092	; 0x444
 80083c4:	4211      	tst	r1, r2
 80083c6:	d103      	bne.n	80083d0 <HAL_TIMEx_HallSensor_Stop+0x2c>
 80083c8:	681a      	ldr	r2, [r3, #0]
 80083ca:	f022 0201 	bic.w	r2, r2, #1
 80083ce:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80083d0:	2301      	movs	r3, #1
 80083d2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80083d6:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80083da:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80083de:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
 80083e2:	2000      	movs	r0, #0
 80083e4:	bd10      	pop	{r4, pc}

080083e6 <HAL_TIMEx_HallSensor_Start_IT>:
{
 80083e6:	b510      	push	{r4, lr}
 80083e8:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 80083ea:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
 80083ee:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 80083f0:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 80083f4:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 80083f8:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 80083fc:	2801      	cmp	r0, #1
 80083fe:	d13d      	bne.n	800847c <HAL_TIMEx_HallSensor_Start_IT+0x96>
 8008400:	b2db      	uxtb	r3, r3
 8008402:	b2d2      	uxtb	r2, r2
 8008404:	b2c9      	uxtb	r1, r1
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8008406:	2b01      	cmp	r3, #1
 8008408:	d139      	bne.n	800847e <HAL_TIMEx_HallSensor_Start_IT+0x98>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 800840a:	2a01      	cmp	r2, #1
 800840c:	d138      	bne.n	8008480 <HAL_TIMEx_HallSensor_Start_IT+0x9a>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 800840e:	2901      	cmp	r1, #1
 8008410:	d001      	beq.n	8008416 <HAL_TIMEx_HallSensor_Start_IT+0x30>
    return HAL_ERROR;
 8008412:	4610      	mov	r0, r2
 8008414:	e033      	b.n	800847e <HAL_TIMEx_HallSensor_Start_IT+0x98>
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8008416:	2302      	movs	r3, #2
 8008418:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 800841c:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8008420:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 8008424:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008428:	6822      	ldr	r2, [r4, #0]
 800842a:	68d3      	ldr	r3, [r2, #12]
 800842c:	f043 0302 	orr.w	r3, r3, #2
 8008430:	60d3      	str	r3, [r2, #12]
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 8008432:	2201      	movs	r2, #1
 8008434:	2100      	movs	r1, #0
 8008436:	6820      	ldr	r0, [r4, #0]
 8008438:	f7fe f83a 	bl	80064b0 <TIM_CCxChannelCmd>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800843c:	6823      	ldr	r3, [r4, #0]
 800843e:	4a12      	ldr	r2, [pc, #72]	; (8008488 <HAL_TIMEx_HallSensor_Start_IT+0xa2>)
 8008440:	4293      	cmp	r3, r2
 8008442:	d010      	beq.n	8008466 <HAL_TIMEx_HallSensor_Start_IT+0x80>
 8008444:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008448:	d00d      	beq.n	8008466 <HAL_TIMEx_HallSensor_Start_IT+0x80>
 800844a:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 800844e:	4293      	cmp	r3, r2
 8008450:	d009      	beq.n	8008466 <HAL_TIMEx_HallSensor_Start_IT+0x80>
 8008452:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008456:	4293      	cmp	r3, r2
 8008458:	d005      	beq.n	8008466 <HAL_TIMEx_HallSensor_Start_IT+0x80>
    __HAL_TIM_ENABLE(htim);
 800845a:	681a      	ldr	r2, [r3, #0]
 800845c:	f042 0201 	orr.w	r2, r2, #1
 8008460:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008462:	2000      	movs	r0, #0
 8008464:	e00b      	b.n	800847e <HAL_TIMEx_HallSensor_Start_IT+0x98>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8008466:	689a      	ldr	r2, [r3, #8]
 8008468:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800846c:	2a06      	cmp	r2, #6
 800846e:	d009      	beq.n	8008484 <HAL_TIMEx_HallSensor_Start_IT+0x9e>
      __HAL_TIM_ENABLE(htim);
 8008470:	681a      	ldr	r2, [r3, #0]
 8008472:	f042 0201 	orr.w	r2, r2, #1
 8008476:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008478:	2000      	movs	r0, #0
 800847a:	e000      	b.n	800847e <HAL_TIMEx_HallSensor_Start_IT+0x98>
    return HAL_ERROR;
 800847c:	2001      	movs	r0, #1
}
 800847e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8008480:	4618      	mov	r0, r3
 8008482:	e7fc      	b.n	800847e <HAL_TIMEx_HallSensor_Start_IT+0x98>
  return HAL_OK;
 8008484:	2000      	movs	r0, #0
 8008486:	e7fa      	b.n	800847e <HAL_TIMEx_HallSensor_Start_IT+0x98>
 8008488:	40012c00 	.word	0x40012c00

0800848c <HAL_TIMEx_HallSensor_Stop_IT>:
{
 800848c:	b510      	push	{r4, lr}
 800848e:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 8008490:	2200      	movs	r2, #0
 8008492:	4611      	mov	r1, r2
 8008494:	6800      	ldr	r0, [r0, #0]
 8008496:	f7fe f80b 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 800849a:	6822      	ldr	r2, [r4, #0]
 800849c:	68d3      	ldr	r3, [r2, #12]
 800849e:	f023 0302 	bic.w	r3, r3, #2
 80084a2:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE(htim);
 80084a4:	6823      	ldr	r3, [r4, #0]
 80084a6:	6a19      	ldr	r1, [r3, #32]
 80084a8:	f241 1211 	movw	r2, #4369	; 0x1111
 80084ac:	4211      	tst	r1, r2
 80084ae:	d108      	bne.n	80084c2 <HAL_TIMEx_HallSensor_Stop_IT+0x36>
 80084b0:	6a19      	ldr	r1, [r3, #32]
 80084b2:	f240 4244 	movw	r2, #1092	; 0x444
 80084b6:	4211      	tst	r1, r2
 80084b8:	d103      	bne.n	80084c2 <HAL_TIMEx_HallSensor_Stop_IT+0x36>
 80084ba:	681a      	ldr	r2, [r3, #0]
 80084bc:	f022 0201 	bic.w	r2, r2, #1
 80084c0:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80084c2:	2301      	movs	r3, #1
 80084c4:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80084c8:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80084cc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80084d0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
 80084d4:	2000      	movs	r0, #0
 80084d6:	bd10      	pop	{r4, pc}

080084d8 <HAL_TIMEx_HallSensor_Start_DMA>:
{
 80084d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80084da:	4604      	mov	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 80084dc:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 80084e0:	b2d8      	uxtb	r0, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 80084e2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
  if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
 80084e6:	2802      	cmp	r0, #2
 80084e8:	d04f      	beq.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
 80084ea:	460f      	mov	r7, r1
 80084ec:	4616      	mov	r6, r2
 80084ee:	b2dd      	uxtb	r5, r3
      || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
 80084f0:	2d02      	cmp	r5, #2
 80084f2:	d047      	beq.n	8008584 <HAL_TIMEx_HallSensor_Start_DMA+0xac>
  else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
 80084f4:	2801      	cmp	r0, #1
 80084f6:	d147      	bne.n	8008588 <HAL_TIMEx_HallSensor_Start_DMA+0xb0>
           && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
 80084f8:	2d01      	cmp	r5, #1
 80084fa:	d146      	bne.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
    if ((pData == NULL) && (Length > 0U))
 80084fc:	2900      	cmp	r1, #0
 80084fe:	d033      	beq.n	8008568 <HAL_TIMEx_HallSensor_Start_DMA+0x90>
      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8008500:	2302      	movs	r3, #2
 8008502:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 8008506:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
 800850a:	2201      	movs	r2, #1
 800850c:	2100      	movs	r1, #0
 800850e:	6820      	ldr	r0, [r4, #0]
 8008510:	f7fd ffce 	bl	80064b0 <TIM_CCxChannelCmd>
  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
 8008514:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008516:	4a1e      	ldr	r2, [pc, #120]	; (8008590 <HAL_TIMEx_HallSensor_Start_DMA+0xb8>)
 8008518:	629a      	str	r2, [r3, #40]	; 0x28
  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
 800851a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800851c:	4a1d      	ldr	r2, [pc, #116]	; (8008594 <HAL_TIMEx_HallSensor_Start_DMA+0xbc>)
 800851e:	62da      	str	r2, [r3, #44]	; 0x2c
  htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
 8008520:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008522:	4a1d      	ldr	r2, [pc, #116]	; (8008598 <HAL_TIMEx_HallSensor_Start_DMA+0xc0>)
 8008524:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
 8008526:	6821      	ldr	r1, [r4, #0]
 8008528:	4633      	mov	r3, r6
 800852a:	463a      	mov	r2, r7
 800852c:	3134      	adds	r1, #52	; 0x34
 800852e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8008530:	f7fb f996 	bl	8003860 <HAL_DMA_Start_IT>
 8008534:	bb50      	cbnz	r0, 800858c <HAL_TIMEx_HallSensor_Start_DMA+0xb4>
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 8008536:	6822      	ldr	r2, [r4, #0]
 8008538:	68d3      	ldr	r3, [r2, #12]
 800853a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800853e:	60d3      	str	r3, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008540:	6823      	ldr	r3, [r4, #0]
 8008542:	4a16      	ldr	r2, [pc, #88]	; (800859c <HAL_TIMEx_HallSensor_Start_DMA+0xc4>)
 8008544:	4293      	cmp	r3, r2
 8008546:	d013      	beq.n	8008570 <HAL_TIMEx_HallSensor_Start_DMA+0x98>
 8008548:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800854c:	d010      	beq.n	8008570 <HAL_TIMEx_HallSensor_Start_DMA+0x98>
 800854e:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008552:	4293      	cmp	r3, r2
 8008554:	d00c      	beq.n	8008570 <HAL_TIMEx_HallSensor_Start_DMA+0x98>
 8008556:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800855a:	4293      	cmp	r3, r2
 800855c:	d008      	beq.n	8008570 <HAL_TIMEx_HallSensor_Start_DMA+0x98>
    __HAL_TIM_ENABLE(htim);
 800855e:	681a      	ldr	r2, [r3, #0]
 8008560:	f042 0201 	orr.w	r2, r2, #1
 8008564:	601a      	str	r2, [r3, #0]
 8008566:	e010      	b.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
    if ((pData == NULL) && (Length > 0U))
 8008568:	2a00      	cmp	r2, #0
 800856a:	d0c9      	beq.n	8008500 <HAL_TIMEx_HallSensor_Start_DMA+0x28>
      return HAL_ERROR;
 800856c:	4628      	mov	r0, r5
 800856e:	e00c      	b.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8008570:	689a      	ldr	r2, [r3, #8]
 8008572:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8008576:	2a06      	cmp	r2, #6
 8008578:	d007      	beq.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
      __HAL_TIM_ENABLE(htim);
 800857a:	681a      	ldr	r2, [r3, #0]
 800857c:	f042 0201 	orr.w	r2, r2, #1
 8008580:	601a      	str	r2, [r3, #0]
 8008582:	e002      	b.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
    return HAL_BUSY;
 8008584:	4628      	mov	r0, r5
 8008586:	e000      	b.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
    return HAL_ERROR;
 8008588:	2001      	movs	r0, #1
}
 800858a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800858c:	4628      	mov	r0, r5
 800858e:	e7fc      	b.n	800858a <HAL_TIMEx_HallSensor_Start_DMA+0xb2>
 8008590:	08005783 	.word	0x08005783
 8008594:	08005805 	.word	0x08005805
 8008598:	08005a95 	.word	0x08005a95
 800859c:	40012c00 	.word	0x40012c00

080085a0 <HAL_TIMEx_HallSensor_Stop_DMA>:
{
 80085a0:	b510      	push	{r4, lr}
 80085a2:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
 80085a4:	2200      	movs	r2, #0
 80085a6:	4611      	mov	r1, r2
 80085a8:	6800      	ldr	r0, [r0, #0]
 80085aa:	f7fd ff81 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 80085ae:	6822      	ldr	r2, [r4, #0]
 80085b0:	68d3      	ldr	r3, [r2, #12]
 80085b2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80085b6:	60d3      	str	r3, [r2, #12]
  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 80085b8:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80085ba:	f7fb f9ad 	bl	8003918 <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
 80085be:	6823      	ldr	r3, [r4, #0]
 80085c0:	6a19      	ldr	r1, [r3, #32]
 80085c2:	f241 1211 	movw	r2, #4369	; 0x1111
 80085c6:	4211      	tst	r1, r2
 80085c8:	d108      	bne.n	80085dc <HAL_TIMEx_HallSensor_Stop_DMA+0x3c>
 80085ca:	6a19      	ldr	r1, [r3, #32]
 80085cc:	f240 4244 	movw	r2, #1092	; 0x444
 80085d0:	4211      	tst	r1, r2
 80085d2:	d103      	bne.n	80085dc <HAL_TIMEx_HallSensor_Stop_DMA+0x3c>
 80085d4:	681a      	ldr	r2, [r3, #0]
 80085d6:	f022 0201 	bic.w	r2, r2, #1
 80085da:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80085dc:	2301      	movs	r3, #1
 80085de:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80085e2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 80085e6:	2000      	movs	r0, #0
 80085e8:	bd10      	pop	{r4, pc}

080085ea <HAL_TIMEx_OCN_Start>:
{
 80085ea:	b510      	push	{r4, lr}
 80085ec:	4604      	mov	r4, r0
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80085ee:	4608      	mov	r0, r1
 80085f0:	bb59      	cbnz	r1, 800864a <HAL_TIMEx_OCN_Start+0x60>
 80085f2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80085f6:	b2db      	uxtb	r3, r3
 80085f8:	3b01      	subs	r3, #1
 80085fa:	bf18      	it	ne
 80085fc:	2301      	movne	r3, #1
 80085fe:	2b00      	cmp	r3, #0
 8008600:	d157      	bne.n	80086b2 <HAL_TIMEx_OCN_Start+0xc8>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008602:	2800      	cmp	r0, #0
 8008604:	d13a      	bne.n	800867c <HAL_TIMEx_OCN_Start+0x92>
 8008606:	2302      	movs	r3, #2
 8008608:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 800860c:	2204      	movs	r2, #4
 800860e:	4601      	mov	r1, r0
 8008610:	6820      	ldr	r0, [r4, #0]
 8008612:	f7ff fd7b 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 8008616:	6822      	ldr	r2, [r4, #0]
 8008618:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800861a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800861e:	6453      	str	r3, [r2, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008620:	6823      	ldr	r3, [r4, #0]
 8008622:	4a26      	ldr	r2, [pc, #152]	; (80086bc <HAL_TIMEx_OCN_Start+0xd2>)
 8008624:	4293      	cmp	r3, r2
 8008626:	d039      	beq.n	800869c <HAL_TIMEx_OCN_Start+0xb2>
 8008628:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800862c:	d036      	beq.n	800869c <HAL_TIMEx_OCN_Start+0xb2>
 800862e:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008632:	4293      	cmp	r3, r2
 8008634:	d032      	beq.n	800869c <HAL_TIMEx_OCN_Start+0xb2>
 8008636:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800863a:	4293      	cmp	r3, r2
 800863c:	d02e      	beq.n	800869c <HAL_TIMEx_OCN_Start+0xb2>
    __HAL_TIM_ENABLE(htim);
 800863e:	681a      	ldr	r2, [r3, #0]
 8008640:	f042 0201 	orr.w	r2, r2, #1
 8008644:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008646:	2000      	movs	r0, #0
 8008648:	e034      	b.n	80086b4 <HAL_TIMEx_OCN_Start+0xca>
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 800864a:	2904      	cmp	r1, #4
 800864c:	d008      	beq.n	8008660 <HAL_TIMEx_OCN_Start+0x76>
 800864e:	2908      	cmp	r1, #8
 8008650:	d00d      	beq.n	800866e <HAL_TIMEx_OCN_Start+0x84>
 8008652:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8008656:	b2db      	uxtb	r3, r3
 8008658:	3b01      	subs	r3, #1
 800865a:	bf18      	it	ne
 800865c:	2301      	movne	r3, #1
 800865e:	e7ce      	b.n	80085fe <HAL_TIMEx_OCN_Start+0x14>
 8008660:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8008664:	b2db      	uxtb	r3, r3
 8008666:	3b01      	subs	r3, #1
 8008668:	bf18      	it	ne
 800866a:	2301      	movne	r3, #1
 800866c:	e7c7      	b.n	80085fe <HAL_TIMEx_OCN_Start+0x14>
 800866e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8008672:	b2db      	uxtb	r3, r3
 8008674:	3b01      	subs	r3, #1
 8008676:	bf18      	it	ne
 8008678:	2301      	movne	r3, #1
 800867a:	e7c0      	b.n	80085fe <HAL_TIMEx_OCN_Start+0x14>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800867c:	2804      	cmp	r0, #4
 800867e:	d005      	beq.n	800868c <HAL_TIMEx_OCN_Start+0xa2>
 8008680:	2808      	cmp	r0, #8
 8008682:	d007      	beq.n	8008694 <HAL_TIMEx_OCN_Start+0xaa>
 8008684:	2302      	movs	r3, #2
 8008686:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800868a:	e7bf      	b.n	800860c <HAL_TIMEx_OCN_Start+0x22>
 800868c:	2302      	movs	r3, #2
 800868e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8008692:	e7bb      	b.n	800860c <HAL_TIMEx_OCN_Start+0x22>
 8008694:	2302      	movs	r3, #2
 8008696:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800869a:	e7b7      	b.n	800860c <HAL_TIMEx_OCN_Start+0x22>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800869c:	689a      	ldr	r2, [r3, #8]
 800869e:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80086a2:	2a06      	cmp	r2, #6
 80086a4:	d007      	beq.n	80086b6 <HAL_TIMEx_OCN_Start+0xcc>
      __HAL_TIM_ENABLE(htim);
 80086a6:	681a      	ldr	r2, [r3, #0]
 80086a8:	f042 0201 	orr.w	r2, r2, #1
 80086ac:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80086ae:	2000      	movs	r0, #0
 80086b0:	e000      	b.n	80086b4 <HAL_TIMEx_OCN_Start+0xca>
    return HAL_ERROR;
 80086b2:	2001      	movs	r0, #1
}
 80086b4:	bd10      	pop	{r4, pc}
  return HAL_OK;
 80086b6:	2000      	movs	r0, #0
 80086b8:	e7fc      	b.n	80086b4 <HAL_TIMEx_OCN_Start+0xca>
 80086ba:	bf00      	nop
 80086bc:	40012c00 	.word	0x40012c00

080086c0 <HAL_TIMEx_OCN_Stop>:
{
 80086c0:	b538      	push	{r3, r4, r5, lr}
 80086c2:	4604      	mov	r4, r0
 80086c4:	460d      	mov	r5, r1
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
 80086c6:	2200      	movs	r2, #0
 80086c8:	6800      	ldr	r0, [r0, #0]
 80086ca:	f7ff fd1f 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
 80086ce:	6823      	ldr	r3, [r4, #0]
 80086d0:	6a19      	ldr	r1, [r3, #32]
 80086d2:	f241 1211 	movw	r2, #4369	; 0x1111
 80086d6:	4211      	tst	r1, r2
 80086d8:	d108      	bne.n	80086ec <HAL_TIMEx_OCN_Stop+0x2c>
 80086da:	6a19      	ldr	r1, [r3, #32]
 80086dc:	f240 4244 	movw	r2, #1092	; 0x444
 80086e0:	4211      	tst	r1, r2
 80086e2:	d103      	bne.n	80086ec <HAL_TIMEx_OCN_Stop+0x2c>
 80086e4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80086e6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80086ea:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 80086ec:	6823      	ldr	r3, [r4, #0]
 80086ee:	6a19      	ldr	r1, [r3, #32]
 80086f0:	f241 1211 	movw	r2, #4369	; 0x1111
 80086f4:	4211      	tst	r1, r2
 80086f6:	d108      	bne.n	800870a <HAL_TIMEx_OCN_Stop+0x4a>
 80086f8:	6a19      	ldr	r1, [r3, #32]
 80086fa:	f240 4244 	movw	r2, #1092	; 0x444
 80086fe:	4211      	tst	r1, r2
 8008700:	d103      	bne.n	800870a <HAL_TIMEx_OCN_Stop+0x4a>
 8008702:	681a      	ldr	r2, [r3, #0]
 8008704:	f022 0201 	bic.w	r2, r2, #1
 8008708:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 800870a:	b925      	cbnz	r5, 8008716 <HAL_TIMEx_OCN_Stop+0x56>
 800870c:	2301      	movs	r3, #1
 800870e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 8008712:	2000      	movs	r0, #0
 8008714:	bd38      	pop	{r3, r4, r5, pc}
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008716:	2d04      	cmp	r5, #4
 8008718:	d005      	beq.n	8008726 <HAL_TIMEx_OCN_Stop+0x66>
 800871a:	2d08      	cmp	r5, #8
 800871c:	d007      	beq.n	800872e <HAL_TIMEx_OCN_Stop+0x6e>
 800871e:	2301      	movs	r3, #1
 8008720:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8008724:	e7f5      	b.n	8008712 <HAL_TIMEx_OCN_Stop+0x52>
 8008726:	2301      	movs	r3, #1
 8008728:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800872c:	e7f1      	b.n	8008712 <HAL_TIMEx_OCN_Stop+0x52>
 800872e:	2301      	movs	r3, #1
 8008730:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8008734:	e7ed      	b.n	8008712 <HAL_TIMEx_OCN_Stop+0x52>

08008736 <HAL_TIMEx_OCN_Start_IT>:
{
 8008736:	b510      	push	{r4, lr}
 8008738:	4604      	mov	r4, r0
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 800873a:	4608      	mov	r0, r1
 800873c:	2900      	cmp	r1, #0
 800873e:	d136      	bne.n	80087ae <HAL_TIMEx_OCN_Start_IT+0x78>
 8008740:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8008744:	b2db      	uxtb	r3, r3
 8008746:	3b01      	subs	r3, #1
 8008748:	bf18      	it	ne
 800874a:	2301      	movne	r3, #1
 800874c:	2b00      	cmp	r3, #0
 800874e:	d174      	bne.n	800883a <HAL_TIMEx_OCN_Start_IT+0x104>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008750:	2800      	cmp	r0, #0
 8008752:	d145      	bne.n	80087e0 <HAL_TIMEx_OCN_Start_IT+0xaa>
 8008754:	2302      	movs	r3, #2
 8008756:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  switch (Channel)
 800875a:	2804      	cmp	r0, #4
 800875c:	d056      	beq.n	800880c <HAL_TIMEx_OCN_Start_IT+0xd6>
 800875e:	2808      	cmp	r0, #8
 8008760:	d05a      	beq.n	8008818 <HAL_TIMEx_OCN_Start_IT+0xe2>
 8008762:	2800      	cmp	r0, #0
 8008764:	d04c      	beq.n	8008800 <HAL_TIMEx_OCN_Start_IT+0xca>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
 8008766:	6822      	ldr	r2, [r4, #0]
 8008768:	68d3      	ldr	r3, [r2, #12]
 800876a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800876e:	60d3      	str	r3, [r2, #12]
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 8008770:	2204      	movs	r2, #4
 8008772:	4601      	mov	r1, r0
 8008774:	6820      	ldr	r0, [r4, #0]
 8008776:	f7ff fcc9 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 800877a:	6822      	ldr	r2, [r4, #0]
 800877c:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800877e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008782:	6453      	str	r3, [r2, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008784:	6823      	ldr	r3, [r4, #0]
 8008786:	4a2f      	ldr	r2, [pc, #188]	; (8008844 <HAL_TIMEx_OCN_Start_IT+0x10e>)
 8008788:	4293      	cmp	r3, r2
 800878a:	d04b      	beq.n	8008824 <HAL_TIMEx_OCN_Start_IT+0xee>
 800878c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008790:	d048      	beq.n	8008824 <HAL_TIMEx_OCN_Start_IT+0xee>
 8008792:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008796:	4293      	cmp	r3, r2
 8008798:	d044      	beq.n	8008824 <HAL_TIMEx_OCN_Start_IT+0xee>
 800879a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800879e:	4293      	cmp	r3, r2
 80087a0:	d040      	beq.n	8008824 <HAL_TIMEx_OCN_Start_IT+0xee>
    __HAL_TIM_ENABLE(htim);
 80087a2:	681a      	ldr	r2, [r3, #0]
 80087a4:	f042 0201 	orr.w	r2, r2, #1
 80087a8:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80087aa:	2000      	movs	r0, #0
 80087ac:	e046      	b.n	800883c <HAL_TIMEx_OCN_Start_IT+0x106>
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80087ae:	2904      	cmp	r1, #4
 80087b0:	d008      	beq.n	80087c4 <HAL_TIMEx_OCN_Start_IT+0x8e>
 80087b2:	2908      	cmp	r1, #8
 80087b4:	d00d      	beq.n	80087d2 <HAL_TIMEx_OCN_Start_IT+0x9c>
 80087b6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80087ba:	b2db      	uxtb	r3, r3
 80087bc:	3b01      	subs	r3, #1
 80087be:	bf18      	it	ne
 80087c0:	2301      	movne	r3, #1
 80087c2:	e7c3      	b.n	800874c <HAL_TIMEx_OCN_Start_IT+0x16>
 80087c4:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 80087c8:	b2db      	uxtb	r3, r3
 80087ca:	3b01      	subs	r3, #1
 80087cc:	bf18      	it	ne
 80087ce:	2301      	movne	r3, #1
 80087d0:	e7bc      	b.n	800874c <HAL_TIMEx_OCN_Start_IT+0x16>
 80087d2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80087d6:	b2db      	uxtb	r3, r3
 80087d8:	3b01      	subs	r3, #1
 80087da:	bf18      	it	ne
 80087dc:	2301      	movne	r3, #1
 80087de:	e7b5      	b.n	800874c <HAL_TIMEx_OCN_Start_IT+0x16>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80087e0:	2804      	cmp	r0, #4
 80087e2:	d005      	beq.n	80087f0 <HAL_TIMEx_OCN_Start_IT+0xba>
 80087e4:	2808      	cmp	r0, #8
 80087e6:	d007      	beq.n	80087f8 <HAL_TIMEx_OCN_Start_IT+0xc2>
 80087e8:	2302      	movs	r3, #2
 80087ea:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80087ee:	e7b4      	b.n	800875a <HAL_TIMEx_OCN_Start_IT+0x24>
 80087f0:	2302      	movs	r3, #2
 80087f2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80087f6:	e7b0      	b.n	800875a <HAL_TIMEx_OCN_Start_IT+0x24>
 80087f8:	2302      	movs	r3, #2
 80087fa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80087fe:	e7ac      	b.n	800875a <HAL_TIMEx_OCN_Start_IT+0x24>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008800:	6822      	ldr	r2, [r4, #0]
 8008802:	68d3      	ldr	r3, [r2, #12]
 8008804:	f043 0302 	orr.w	r3, r3, #2
 8008808:	60d3      	str	r3, [r2, #12]
      break;
 800880a:	e7ac      	b.n	8008766 <HAL_TIMEx_OCN_Start_IT+0x30>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 800880c:	6822      	ldr	r2, [r4, #0]
 800880e:	68d3      	ldr	r3, [r2, #12]
 8008810:	f043 0304 	orr.w	r3, r3, #4
 8008814:	60d3      	str	r3, [r2, #12]
      break;
 8008816:	e7a6      	b.n	8008766 <HAL_TIMEx_OCN_Start_IT+0x30>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8008818:	6822      	ldr	r2, [r4, #0]
 800881a:	68d3      	ldr	r3, [r2, #12]
 800881c:	f043 0308 	orr.w	r3, r3, #8
 8008820:	60d3      	str	r3, [r2, #12]
      break;
 8008822:	e7a0      	b.n	8008766 <HAL_TIMEx_OCN_Start_IT+0x30>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8008824:	689a      	ldr	r2, [r3, #8]
 8008826:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800882a:	2a06      	cmp	r2, #6
 800882c:	d007      	beq.n	800883e <HAL_TIMEx_OCN_Start_IT+0x108>
      __HAL_TIM_ENABLE(htim);
 800882e:	681a      	ldr	r2, [r3, #0]
 8008830:	f042 0201 	orr.w	r2, r2, #1
 8008834:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008836:	2000      	movs	r0, #0
 8008838:	e000      	b.n	800883c <HAL_TIMEx_OCN_Start_IT+0x106>
    return HAL_ERROR;
 800883a:	2001      	movs	r0, #1
}
 800883c:	bd10      	pop	{r4, pc}
  return HAL_OK;
 800883e:	2000      	movs	r0, #0
 8008840:	e7fc      	b.n	800883c <HAL_TIMEx_OCN_Start_IT+0x106>
 8008842:	bf00      	nop
 8008844:	40012c00 	.word	0x40012c00

08008848 <HAL_TIMEx_OCN_Stop_IT>:
{
 8008848:	b538      	push	{r3, r4, r5, lr}
 800884a:	4605      	mov	r5, r0
 800884c:	460c      	mov	r4, r1
  switch (Channel)
 800884e:	2904      	cmp	r1, #4
 8008850:	d03c      	beq.n	80088cc <HAL_TIMEx_OCN_Stop_IT+0x84>
 8008852:	2908      	cmp	r1, #8
 8008854:	d040      	beq.n	80088d8 <HAL_TIMEx_OCN_Stop_IT+0x90>
 8008856:	2900      	cmp	r1, #0
 8008858:	d032      	beq.n	80088c0 <HAL_TIMEx_OCN_Stop_IT+0x78>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
 800885a:	2200      	movs	r2, #0
 800885c:	4621      	mov	r1, r4
 800885e:	6828      	ldr	r0, [r5, #0]
 8008860:	f7ff fc54 	bl	800810c <TIM_CCxNChannelCmd>
  tmpccer = htim->Instance->CCER;
 8008864:	682b      	ldr	r3, [r5, #0]
 8008866:	6a19      	ldr	r1, [r3, #32]
  if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
 8008868:	f240 4244 	movw	r2, #1092	; 0x444
 800886c:	4211      	tst	r1, r2
 800886e:	d103      	bne.n	8008878 <HAL_TIMEx_OCN_Stop_IT+0x30>
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
 8008870:	68da      	ldr	r2, [r3, #12]
 8008872:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8008876:	60da      	str	r2, [r3, #12]
  __HAL_TIM_MOE_DISABLE(htim);
 8008878:	682b      	ldr	r3, [r5, #0]
 800887a:	6a19      	ldr	r1, [r3, #32]
 800887c:	f241 1211 	movw	r2, #4369	; 0x1111
 8008880:	4211      	tst	r1, r2
 8008882:	d108      	bne.n	8008896 <HAL_TIMEx_OCN_Stop_IT+0x4e>
 8008884:	6a19      	ldr	r1, [r3, #32]
 8008886:	f240 4244 	movw	r2, #1092	; 0x444
 800888a:	4211      	tst	r1, r2
 800888c:	d103      	bne.n	8008896 <HAL_TIMEx_OCN_Stop_IT+0x4e>
 800888e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008890:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008894:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8008896:	682b      	ldr	r3, [r5, #0]
 8008898:	6a19      	ldr	r1, [r3, #32]
 800889a:	f241 1211 	movw	r2, #4369	; 0x1111
 800889e:	4211      	tst	r1, r2
 80088a0:	d108      	bne.n	80088b4 <HAL_TIMEx_OCN_Stop_IT+0x6c>
 80088a2:	6a19      	ldr	r1, [r3, #32]
 80088a4:	f240 4244 	movw	r2, #1092	; 0x444
 80088a8:	4211      	tst	r1, r2
 80088aa:	d103      	bne.n	80088b4 <HAL_TIMEx_OCN_Stop_IT+0x6c>
 80088ac:	681a      	ldr	r2, [r3, #0]
 80088ae:	f022 0201 	bic.w	r2, r2, #1
 80088b2:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80088b4:	b9b4      	cbnz	r4, 80088e4 <HAL_TIMEx_OCN_Stop_IT+0x9c>
 80088b6:	2301      	movs	r3, #1
 80088b8:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
 80088bc:	2000      	movs	r0, #0
 80088be:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 80088c0:	6802      	ldr	r2, [r0, #0]
 80088c2:	68d3      	ldr	r3, [r2, #12]
 80088c4:	f023 0302 	bic.w	r3, r3, #2
 80088c8:	60d3      	str	r3, [r2, #12]
      break;
 80088ca:	e7c6      	b.n	800885a <HAL_TIMEx_OCN_Stop_IT+0x12>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 80088cc:	6802      	ldr	r2, [r0, #0]
 80088ce:	68d3      	ldr	r3, [r2, #12]
 80088d0:	f023 0304 	bic.w	r3, r3, #4
 80088d4:	60d3      	str	r3, [r2, #12]
      break;
 80088d6:	e7c0      	b.n	800885a <HAL_TIMEx_OCN_Stop_IT+0x12>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 80088d8:	6802      	ldr	r2, [r0, #0]
 80088da:	68d3      	ldr	r3, [r2, #12]
 80088dc:	f023 0308 	bic.w	r3, r3, #8
 80088e0:	60d3      	str	r3, [r2, #12]
      break;
 80088e2:	e7ba      	b.n	800885a <HAL_TIMEx_OCN_Stop_IT+0x12>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 80088e4:	2c04      	cmp	r4, #4
 80088e6:	d005      	beq.n	80088f4 <HAL_TIMEx_OCN_Stop_IT+0xac>
 80088e8:	2c08      	cmp	r4, #8
 80088ea:	d007      	beq.n	80088fc <HAL_TIMEx_OCN_Stop_IT+0xb4>
 80088ec:	2301      	movs	r3, #1
 80088ee:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 80088f2:	e7e3      	b.n	80088bc <HAL_TIMEx_OCN_Stop_IT+0x74>
 80088f4:	2301      	movs	r3, #1
 80088f6:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
 80088fa:	e7df      	b.n	80088bc <HAL_TIMEx_OCN_Stop_IT+0x74>
 80088fc:	2301      	movs	r3, #1
 80088fe:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8008902:	e7db      	b.n	80088bc <HAL_TIMEx_OCN_Stop_IT+0x74>

08008904 <HAL_TIMEx_OCN_Start_DMA>:
{
 8008904:	b570      	push	{r4, r5, r6, lr}
 8008906:	4604      	mov	r4, r0
 8008908:	4616      	mov	r6, r2
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 800890a:	460d      	mov	r5, r1
 800890c:	2900      	cmp	r1, #0
 800890e:	d147      	bne.n	80089a0 <HAL_TIMEx_OCN_Start_DMA+0x9c>
 8008910:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
 8008914:	b2c0      	uxtb	r0, r0
 8008916:	2802      	cmp	r0, #2
 8008918:	bf14      	ite	ne
 800891a:	2000      	movne	r0, #0
 800891c:	2001      	moveq	r0, #1
 800891e:	2800      	cmp	r0, #0
 8008920:	f040 80d9 	bne.w	8008ad6 <HAL_TIMEx_OCN_Start_DMA+0x1d2>
  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 8008924:	2d00      	cmp	r5, #0
 8008926:	d157      	bne.n	80089d8 <HAL_TIMEx_OCN_Start_DMA+0xd4>
 8008928:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 800892c:	b2d2      	uxtb	r2, r2
 800892e:	2a01      	cmp	r2, #1
 8008930:	bf14      	ite	ne
 8008932:	2200      	movne	r2, #0
 8008934:	2201      	moveq	r2, #1
 8008936:	2a00      	cmp	r2, #0
 8008938:	f000 80cf 	beq.w	8008ada <HAL_TIMEx_OCN_Start_DMA+0x1d6>
    if ((pData == NULL) && (Length > 0U))
 800893c:	2e00      	cmp	r6, #0
 800893e:	d067      	beq.n	8008a10 <HAL_TIMEx_OCN_Start_DMA+0x10c>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008940:	2d00      	cmp	r5, #0
 8008942:	d169      	bne.n	8008a18 <HAL_TIMEx_OCN_Start_DMA+0x114>
 8008944:	2202      	movs	r2, #2
 8008946:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  switch (Channel)
 800894a:	2d04      	cmp	r5, #4
 800894c:	f000 808b 	beq.w	8008a66 <HAL_TIMEx_OCN_Start_DMA+0x162>
 8008950:	2d08      	cmp	r5, #8
 8008952:	f000 809f 	beq.w	8008a94 <HAL_TIMEx_OCN_Start_DMA+0x190>
 8008956:	2d00      	cmp	r5, #0
 8008958:	d06e      	beq.n	8008a38 <HAL_TIMEx_OCN_Start_DMA+0x134>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 800895a:	2204      	movs	r2, #4
 800895c:	4629      	mov	r1, r5
 800895e:	6820      	ldr	r0, [r4, #0]
 8008960:	f7ff fbd4 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 8008964:	6822      	ldr	r2, [r4, #0]
 8008966:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8008968:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800896c:	6453      	str	r3, [r2, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800896e:	6823      	ldr	r3, [r4, #0]
 8008970:	4a5f      	ldr	r2, [pc, #380]	; (8008af0 <HAL_TIMEx_OCN_Start_DMA+0x1ec>)
 8008972:	4293      	cmp	r3, r2
 8008974:	f000 80a4 	beq.w	8008ac0 <HAL_TIMEx_OCN_Start_DMA+0x1bc>
 8008978:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800897c:	f000 80a0 	beq.w	8008ac0 <HAL_TIMEx_OCN_Start_DMA+0x1bc>
 8008980:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008984:	4293      	cmp	r3, r2
 8008986:	f000 809b 	beq.w	8008ac0 <HAL_TIMEx_OCN_Start_DMA+0x1bc>
 800898a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800898e:	4293      	cmp	r3, r2
 8008990:	f000 8096 	beq.w	8008ac0 <HAL_TIMEx_OCN_Start_DMA+0x1bc>
    __HAL_TIM_ENABLE(htim);
 8008994:	681a      	ldr	r2, [r3, #0]
 8008996:	f042 0201 	orr.w	r2, r2, #1
 800899a:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800899c:	2000      	movs	r0, #0
 800899e:	e09d      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 80089a0:	2904      	cmp	r1, #4
 80089a2:	d009      	beq.n	80089b8 <HAL_TIMEx_OCN_Start_DMA+0xb4>
 80089a4:	2908      	cmp	r1, #8
 80089a6:	d00f      	beq.n	80089c8 <HAL_TIMEx_OCN_Start_DMA+0xc4>
 80089a8:	f890 0045 	ldrb.w	r0, [r0, #69]	; 0x45
 80089ac:	b2c0      	uxtb	r0, r0
 80089ae:	2802      	cmp	r0, #2
 80089b0:	bf14      	ite	ne
 80089b2:	2000      	movne	r0, #0
 80089b4:	2001      	moveq	r0, #1
 80089b6:	e7b2      	b.n	800891e <HAL_TIMEx_OCN_Start_DMA+0x1a>
 80089b8:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
 80089bc:	b2c0      	uxtb	r0, r0
 80089be:	2802      	cmp	r0, #2
 80089c0:	bf14      	ite	ne
 80089c2:	2000      	movne	r0, #0
 80089c4:	2001      	moveq	r0, #1
 80089c6:	e7aa      	b.n	800891e <HAL_TIMEx_OCN_Start_DMA+0x1a>
 80089c8:	f890 0044 	ldrb.w	r0, [r0, #68]	; 0x44
 80089cc:	b2c0      	uxtb	r0, r0
 80089ce:	2802      	cmp	r0, #2
 80089d0:	bf14      	ite	ne
 80089d2:	2000      	movne	r0, #0
 80089d4:	2001      	moveq	r0, #1
 80089d6:	e7a2      	b.n	800891e <HAL_TIMEx_OCN_Start_DMA+0x1a>
  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 80089d8:	2d04      	cmp	r5, #4
 80089da:	d009      	beq.n	80089f0 <HAL_TIMEx_OCN_Start_DMA+0xec>
 80089dc:	2d08      	cmp	r5, #8
 80089de:	d00f      	beq.n	8008a00 <HAL_TIMEx_OCN_Start_DMA+0xfc>
 80089e0:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 80089e4:	b2d2      	uxtb	r2, r2
 80089e6:	2a01      	cmp	r2, #1
 80089e8:	bf14      	ite	ne
 80089ea:	2200      	movne	r2, #0
 80089ec:	2201      	moveq	r2, #1
 80089ee:	e7a2      	b.n	8008936 <HAL_TIMEx_OCN_Start_DMA+0x32>
 80089f0:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 80089f4:	b2d2      	uxtb	r2, r2
 80089f6:	2a01      	cmp	r2, #1
 80089f8:	bf14      	ite	ne
 80089fa:	2200      	movne	r2, #0
 80089fc:	2201      	moveq	r2, #1
 80089fe:	e79a      	b.n	8008936 <HAL_TIMEx_OCN_Start_DMA+0x32>
 8008a00:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008a04:	b2d2      	uxtb	r2, r2
 8008a06:	2a01      	cmp	r2, #1
 8008a08:	bf14      	ite	ne
 8008a0a:	2200      	movne	r2, #0
 8008a0c:	2201      	moveq	r2, #1
 8008a0e:	e792      	b.n	8008936 <HAL_TIMEx_OCN_Start_DMA+0x32>
    if ((pData == NULL) && (Length > 0U))
 8008a10:	2b00      	cmp	r3, #0
 8008a12:	d095      	beq.n	8008940 <HAL_TIMEx_OCN_Start_DMA+0x3c>
      return HAL_ERROR;
 8008a14:	2001      	movs	r0, #1
 8008a16:	e061      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008a18:	2d04      	cmp	r5, #4
 8008a1a:	d005      	beq.n	8008a28 <HAL_TIMEx_OCN_Start_DMA+0x124>
 8008a1c:	2d08      	cmp	r5, #8
 8008a1e:	d007      	beq.n	8008a30 <HAL_TIMEx_OCN_Start_DMA+0x12c>
 8008a20:	2202      	movs	r2, #2
 8008a22:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 8008a26:	e790      	b.n	800894a <HAL_TIMEx_OCN_Start_DMA+0x46>
 8008a28:	2202      	movs	r2, #2
 8008a2a:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8008a2e:	e78c      	b.n	800894a <HAL_TIMEx_OCN_Start_DMA+0x46>
 8008a30:	2202      	movs	r2, #2
 8008a32:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
 8008a36:	e788      	b.n	800894a <HAL_TIMEx_OCN_Start_DMA+0x46>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
 8008a38:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008a3a:	492e      	ldr	r1, [pc, #184]	; (8008af4 <HAL_TIMEx_OCN_Start_DMA+0x1f0>)
 8008a3c:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8008a3e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008a40:	492d      	ldr	r1, [pc, #180]	; (8008af8 <HAL_TIMEx_OCN_Start_DMA+0x1f4>)
 8008a42:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
 8008a44:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008a46:	492d      	ldr	r1, [pc, #180]	; (8008afc <HAL_TIMEx_OCN_Start_DMA+0x1f8>)
 8008a48:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
 8008a4a:	6822      	ldr	r2, [r4, #0]
 8008a4c:	3234      	adds	r2, #52	; 0x34
 8008a4e:	4631      	mov	r1, r6
 8008a50:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8008a52:	f7fa ff05 	bl	8003860 <HAL_DMA_Start_IT>
 8008a56:	2800      	cmp	r0, #0
 8008a58:	d141      	bne.n	8008ade <HAL_TIMEx_OCN_Start_DMA+0x1da>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 8008a5a:	6822      	ldr	r2, [r4, #0]
 8008a5c:	68d3      	ldr	r3, [r2, #12]
 8008a5e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008a62:	60d3      	str	r3, [r2, #12]
      break;
 8008a64:	e779      	b.n	800895a <HAL_TIMEx_OCN_Start_DMA+0x56>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
 8008a66:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008a68:	4922      	ldr	r1, [pc, #136]	; (8008af4 <HAL_TIMEx_OCN_Start_DMA+0x1f0>)
 8008a6a:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8008a6c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008a6e:	4922      	ldr	r1, [pc, #136]	; (8008af8 <HAL_TIMEx_OCN_Start_DMA+0x1f4>)
 8008a70:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
 8008a72:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008a74:	4921      	ldr	r1, [pc, #132]	; (8008afc <HAL_TIMEx_OCN_Start_DMA+0x1f8>)
 8008a76:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
 8008a78:	6822      	ldr	r2, [r4, #0]
 8008a7a:	3238      	adds	r2, #56	; 0x38
 8008a7c:	4631      	mov	r1, r6
 8008a7e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008a80:	f7fa feee 	bl	8003860 <HAL_DMA_Start_IT>
 8008a84:	2800      	cmp	r0, #0
 8008a86:	d12c      	bne.n	8008ae2 <HAL_TIMEx_OCN_Start_DMA+0x1de>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 8008a88:	6822      	ldr	r2, [r4, #0]
 8008a8a:	68d3      	ldr	r3, [r2, #12]
 8008a8c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008a90:	60d3      	str	r3, [r2, #12]
      break;
 8008a92:	e762      	b.n	800895a <HAL_TIMEx_OCN_Start_DMA+0x56>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
 8008a94:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8008a96:	4917      	ldr	r1, [pc, #92]	; (8008af4 <HAL_TIMEx_OCN_Start_DMA+0x1f0>)
 8008a98:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8008a9a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8008a9c:	4916      	ldr	r1, [pc, #88]	; (8008af8 <HAL_TIMEx_OCN_Start_DMA+0x1f4>)
 8008a9e:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
 8008aa0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8008aa2:	4916      	ldr	r1, [pc, #88]	; (8008afc <HAL_TIMEx_OCN_Start_DMA+0x1f8>)
 8008aa4:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
 8008aa6:	6822      	ldr	r2, [r4, #0]
 8008aa8:	323c      	adds	r2, #60	; 0x3c
 8008aaa:	4631      	mov	r1, r6
 8008aac:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8008aae:	f7fa fed7 	bl	8003860 <HAL_DMA_Start_IT>
 8008ab2:	b9c0      	cbnz	r0, 8008ae6 <HAL_TIMEx_OCN_Start_DMA+0x1e2>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
 8008ab4:	6822      	ldr	r2, [r4, #0]
 8008ab6:	68d3      	ldr	r3, [r2, #12]
 8008ab8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8008abc:	60d3      	str	r3, [r2, #12]
      break;
 8008abe:	e74c      	b.n	800895a <HAL_TIMEx_OCN_Start_DMA+0x56>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8008ac0:	689a      	ldr	r2, [r3, #8]
 8008ac2:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8008ac6:	2a06      	cmp	r2, #6
 8008ac8:	d00f      	beq.n	8008aea <HAL_TIMEx_OCN_Start_DMA+0x1e6>
      __HAL_TIM_ENABLE(htim);
 8008aca:	681a      	ldr	r2, [r3, #0]
 8008acc:	f042 0201 	orr.w	r2, r2, #1
 8008ad0:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008ad2:	2000      	movs	r0, #0
 8008ad4:	e002      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
    return HAL_BUSY;
 8008ad6:	2002      	movs	r0, #2
 8008ad8:	e000      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
    return HAL_ERROR;
 8008ada:	2001      	movs	r0, #1
}
 8008adc:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8008ade:	2001      	movs	r0, #1
 8008ae0:	e7fc      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
        return HAL_ERROR;
 8008ae2:	2001      	movs	r0, #1
 8008ae4:	e7fa      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
        return HAL_ERROR;
 8008ae6:	2001      	movs	r0, #1
 8008ae8:	e7f8      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
  return HAL_OK;
 8008aea:	2000      	movs	r0, #0
 8008aec:	e7f6      	b.n	8008adc <HAL_TIMEx_OCN_Start_DMA+0x1d8>
 8008aee:	bf00      	nop
 8008af0:	40012c00 	.word	0x40012c00
 8008af4:	08008173 	.word	0x08008173
 8008af8:	080058b7 	.word	0x080058b7
 8008afc:	0800812f 	.word	0x0800812f

08008b00 <HAL_TIMEx_OCN_Stop_DMA>:
{
 8008b00:	b538      	push	{r3, r4, r5, lr}
 8008b02:	4605      	mov	r5, r0
 8008b04:	460c      	mov	r4, r1
  switch (Channel)
 8008b06:	2904      	cmp	r1, #4
 8008b08:	d034      	beq.n	8008b74 <HAL_TIMEx_OCN_Stop_DMA+0x74>
 8008b0a:	2908      	cmp	r1, #8
 8008b0c:	d03b      	beq.n	8008b86 <HAL_TIMEx_OCN_Stop_DMA+0x86>
 8008b0e:	b341      	cbz	r1, 8008b62 <HAL_TIMEx_OCN_Stop_DMA+0x62>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
 8008b10:	2200      	movs	r2, #0
 8008b12:	4621      	mov	r1, r4
 8008b14:	6828      	ldr	r0, [r5, #0]
 8008b16:	f7ff faf9 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
 8008b1a:	682b      	ldr	r3, [r5, #0]
 8008b1c:	6a19      	ldr	r1, [r3, #32]
 8008b1e:	f241 1211 	movw	r2, #4369	; 0x1111
 8008b22:	4211      	tst	r1, r2
 8008b24:	d108      	bne.n	8008b38 <HAL_TIMEx_OCN_Stop_DMA+0x38>
 8008b26:	6a19      	ldr	r1, [r3, #32]
 8008b28:	f240 4244 	movw	r2, #1092	; 0x444
 8008b2c:	4211      	tst	r1, r2
 8008b2e:	d103      	bne.n	8008b38 <HAL_TIMEx_OCN_Stop_DMA+0x38>
 8008b30:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008b32:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008b36:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8008b38:	682b      	ldr	r3, [r5, #0]
 8008b3a:	6a19      	ldr	r1, [r3, #32]
 8008b3c:	f241 1211 	movw	r2, #4369	; 0x1111
 8008b40:	4211      	tst	r1, r2
 8008b42:	d108      	bne.n	8008b56 <HAL_TIMEx_OCN_Stop_DMA+0x56>
 8008b44:	6a19      	ldr	r1, [r3, #32]
 8008b46:	f240 4244 	movw	r2, #1092	; 0x444
 8008b4a:	4211      	tst	r1, r2
 8008b4c:	d103      	bne.n	8008b56 <HAL_TIMEx_OCN_Stop_DMA+0x56>
 8008b4e:	681a      	ldr	r2, [r3, #0]
 8008b50:	f022 0201 	bic.w	r2, r2, #1
 8008b54:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008b56:	b9fc      	cbnz	r4, 8008b98 <HAL_TIMEx_OCN_Stop_DMA+0x98>
 8008b58:	2301      	movs	r3, #1
 8008b5a:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
 8008b5e:	2000      	movs	r0, #0
 8008b60:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 8008b62:	6802      	ldr	r2, [r0, #0]
 8008b64:	68d3      	ldr	r3, [r2, #12]
 8008b66:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8008b6a:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 8008b6c:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008b6e:	f7fa fed3 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8008b72:	e7cd      	b.n	8008b10 <HAL_TIMEx_OCN_Stop_DMA+0x10>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 8008b74:	6802      	ldr	r2, [r0, #0]
 8008b76:	68d3      	ldr	r3, [r2, #12]
 8008b78:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008b7c:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 8008b7e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8008b80:	f7fa feca 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8008b84:	e7c4      	b.n	8008b10 <HAL_TIMEx_OCN_Stop_DMA+0x10>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
 8008b86:	6802      	ldr	r2, [r0, #0]
 8008b88:	68d3      	ldr	r3, [r2, #12]
 8008b8a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8008b8e:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 8008b90:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8008b92:	f7fa fec1 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8008b96:	e7bb      	b.n	8008b10 <HAL_TIMEx_OCN_Stop_DMA+0x10>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008b98:	2c04      	cmp	r4, #4
 8008b9a:	d005      	beq.n	8008ba8 <HAL_TIMEx_OCN_Stop_DMA+0xa8>
 8008b9c:	2c08      	cmp	r4, #8
 8008b9e:	d007      	beq.n	8008bb0 <HAL_TIMEx_OCN_Stop_DMA+0xb0>
 8008ba0:	2301      	movs	r3, #1
 8008ba2:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 8008ba6:	e7da      	b.n	8008b5e <HAL_TIMEx_OCN_Stop_DMA+0x5e>
 8008ba8:	2301      	movs	r3, #1
 8008baa:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
 8008bae:	e7d6      	b.n	8008b5e <HAL_TIMEx_OCN_Stop_DMA+0x5e>
 8008bb0:	2301      	movs	r3, #1
 8008bb2:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8008bb6:	e7d2      	b.n	8008b5e <HAL_TIMEx_OCN_Stop_DMA+0x5e>

08008bb8 <HAL_TIMEx_PWMN_Start>:
{
 8008bb8:	b510      	push	{r4, lr}
 8008bba:	4604      	mov	r4, r0
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8008bbc:	4608      	mov	r0, r1
 8008bbe:	bb59      	cbnz	r1, 8008c18 <HAL_TIMEx_PWMN_Start+0x60>
 8008bc0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8008bc4:	b2db      	uxtb	r3, r3
 8008bc6:	3b01      	subs	r3, #1
 8008bc8:	bf18      	it	ne
 8008bca:	2301      	movne	r3, #1
 8008bcc:	2b00      	cmp	r3, #0
 8008bce:	d157      	bne.n	8008c80 <HAL_TIMEx_PWMN_Start+0xc8>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008bd0:	2800      	cmp	r0, #0
 8008bd2:	d13a      	bne.n	8008c4a <HAL_TIMEx_PWMN_Start+0x92>
 8008bd4:	2302      	movs	r3, #2
 8008bd6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 8008bda:	2204      	movs	r2, #4
 8008bdc:	4601      	mov	r1, r0
 8008bde:	6820      	ldr	r0, [r4, #0]
 8008be0:	f7ff fa94 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 8008be4:	6822      	ldr	r2, [r4, #0]
 8008be6:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8008be8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008bec:	6453      	str	r3, [r2, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008bee:	6823      	ldr	r3, [r4, #0]
 8008bf0:	4a25      	ldr	r2, [pc, #148]	; (8008c88 <HAL_TIMEx_PWMN_Start+0xd0>)
 8008bf2:	4293      	cmp	r3, r2
 8008bf4:	d039      	beq.n	8008c6a <HAL_TIMEx_PWMN_Start+0xb2>
 8008bf6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008bfa:	d036      	beq.n	8008c6a <HAL_TIMEx_PWMN_Start+0xb2>
 8008bfc:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008c00:	4293      	cmp	r3, r2
 8008c02:	d032      	beq.n	8008c6a <HAL_TIMEx_PWMN_Start+0xb2>
 8008c04:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008c08:	4293      	cmp	r3, r2
 8008c0a:	d02e      	beq.n	8008c6a <HAL_TIMEx_PWMN_Start+0xb2>
    __HAL_TIM_ENABLE(htim);
 8008c0c:	681a      	ldr	r2, [r3, #0]
 8008c0e:	f042 0201 	orr.w	r2, r2, #1
 8008c12:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008c14:	2000      	movs	r0, #0
 8008c16:	e034      	b.n	8008c82 <HAL_TIMEx_PWMN_Start+0xca>
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8008c18:	2904      	cmp	r1, #4
 8008c1a:	d008      	beq.n	8008c2e <HAL_TIMEx_PWMN_Start+0x76>
 8008c1c:	2908      	cmp	r1, #8
 8008c1e:	d00d      	beq.n	8008c3c <HAL_TIMEx_PWMN_Start+0x84>
 8008c20:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8008c24:	b2db      	uxtb	r3, r3
 8008c26:	3b01      	subs	r3, #1
 8008c28:	bf18      	it	ne
 8008c2a:	2301      	movne	r3, #1
 8008c2c:	e7ce      	b.n	8008bcc <HAL_TIMEx_PWMN_Start+0x14>
 8008c2e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8008c32:	b2db      	uxtb	r3, r3
 8008c34:	3b01      	subs	r3, #1
 8008c36:	bf18      	it	ne
 8008c38:	2301      	movne	r3, #1
 8008c3a:	e7c7      	b.n	8008bcc <HAL_TIMEx_PWMN_Start+0x14>
 8008c3c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8008c40:	b2db      	uxtb	r3, r3
 8008c42:	3b01      	subs	r3, #1
 8008c44:	bf18      	it	ne
 8008c46:	2301      	movne	r3, #1
 8008c48:	e7c0      	b.n	8008bcc <HAL_TIMEx_PWMN_Start+0x14>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008c4a:	2804      	cmp	r0, #4
 8008c4c:	d005      	beq.n	8008c5a <HAL_TIMEx_PWMN_Start+0xa2>
 8008c4e:	2808      	cmp	r0, #8
 8008c50:	d007      	beq.n	8008c62 <HAL_TIMEx_PWMN_Start+0xaa>
 8008c52:	2302      	movs	r3, #2
 8008c54:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8008c58:	e7bf      	b.n	8008bda <HAL_TIMEx_PWMN_Start+0x22>
 8008c5a:	2302      	movs	r3, #2
 8008c5c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8008c60:	e7bb      	b.n	8008bda <HAL_TIMEx_PWMN_Start+0x22>
 8008c62:	2302      	movs	r3, #2
 8008c64:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8008c68:	e7b7      	b.n	8008bda <HAL_TIMEx_PWMN_Start+0x22>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8008c6a:	689a      	ldr	r2, [r3, #8]
 8008c6c:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8008c70:	2a06      	cmp	r2, #6
 8008c72:	d007      	beq.n	8008c84 <HAL_TIMEx_PWMN_Start+0xcc>
      __HAL_TIM_ENABLE(htim);
 8008c74:	681a      	ldr	r2, [r3, #0]
 8008c76:	f042 0201 	orr.w	r2, r2, #1
 8008c7a:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008c7c:	2000      	movs	r0, #0
 8008c7e:	e000      	b.n	8008c82 <HAL_TIMEx_PWMN_Start+0xca>
    return HAL_ERROR;
 8008c80:	2001      	movs	r0, #1
}
 8008c82:	bd10      	pop	{r4, pc}
  return HAL_OK;
 8008c84:	2000      	movs	r0, #0
 8008c86:	e7fc      	b.n	8008c82 <HAL_TIMEx_PWMN_Start+0xca>
 8008c88:	40012c00 	.word	0x40012c00

08008c8c <HAL_TIMEx_PWMN_Stop>:
{
 8008c8c:	b538      	push	{r3, r4, r5, lr}
 8008c8e:	4604      	mov	r4, r0
 8008c90:	460d      	mov	r5, r1
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
 8008c92:	2200      	movs	r2, #0
 8008c94:	6800      	ldr	r0, [r0, #0]
 8008c96:	f7ff fa39 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
 8008c9a:	6823      	ldr	r3, [r4, #0]
 8008c9c:	6a19      	ldr	r1, [r3, #32]
 8008c9e:	f241 1211 	movw	r2, #4369	; 0x1111
 8008ca2:	4211      	tst	r1, r2
 8008ca4:	d108      	bne.n	8008cb8 <HAL_TIMEx_PWMN_Stop+0x2c>
 8008ca6:	6a19      	ldr	r1, [r3, #32]
 8008ca8:	f240 4244 	movw	r2, #1092	; 0x444
 8008cac:	4211      	tst	r1, r2
 8008cae:	d103      	bne.n	8008cb8 <HAL_TIMEx_PWMN_Stop+0x2c>
 8008cb0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008cb2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008cb6:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8008cb8:	6823      	ldr	r3, [r4, #0]
 8008cba:	6a19      	ldr	r1, [r3, #32]
 8008cbc:	f241 1211 	movw	r2, #4369	; 0x1111
 8008cc0:	4211      	tst	r1, r2
 8008cc2:	d108      	bne.n	8008cd6 <HAL_TIMEx_PWMN_Stop+0x4a>
 8008cc4:	6a19      	ldr	r1, [r3, #32]
 8008cc6:	f240 4244 	movw	r2, #1092	; 0x444
 8008cca:	4211      	tst	r1, r2
 8008ccc:	d103      	bne.n	8008cd6 <HAL_TIMEx_PWMN_Stop+0x4a>
 8008cce:	681a      	ldr	r2, [r3, #0]
 8008cd0:	f022 0201 	bic.w	r2, r2, #1
 8008cd4:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008cd6:	b925      	cbnz	r5, 8008ce2 <HAL_TIMEx_PWMN_Stop+0x56>
 8008cd8:	2301      	movs	r3, #1
 8008cda:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 8008cde:	2000      	movs	r0, #0
 8008ce0:	bd38      	pop	{r3, r4, r5, pc}
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008ce2:	2d04      	cmp	r5, #4
 8008ce4:	d005      	beq.n	8008cf2 <HAL_TIMEx_PWMN_Stop+0x66>
 8008ce6:	2d08      	cmp	r5, #8
 8008ce8:	d007      	beq.n	8008cfa <HAL_TIMEx_PWMN_Stop+0x6e>
 8008cea:	2301      	movs	r3, #1
 8008cec:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8008cf0:	e7f5      	b.n	8008cde <HAL_TIMEx_PWMN_Stop+0x52>
 8008cf2:	2301      	movs	r3, #1
 8008cf4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8008cf8:	e7f1      	b.n	8008cde <HAL_TIMEx_PWMN_Stop+0x52>
 8008cfa:	2301      	movs	r3, #1
 8008cfc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8008d00:	e7ed      	b.n	8008cde <HAL_TIMEx_PWMN_Stop+0x52>

08008d02 <HAL_TIMEx_PWMN_Start_IT>:
{
 8008d02:	b510      	push	{r4, lr}
 8008d04:	4604      	mov	r4, r0
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8008d06:	4608      	mov	r0, r1
 8008d08:	2900      	cmp	r1, #0
 8008d0a:	d136      	bne.n	8008d7a <HAL_TIMEx_PWMN_Start_IT+0x78>
 8008d0c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8008d10:	b2db      	uxtb	r3, r3
 8008d12:	3b01      	subs	r3, #1
 8008d14:	bf18      	it	ne
 8008d16:	2301      	movne	r3, #1
 8008d18:	2b00      	cmp	r3, #0
 8008d1a:	d174      	bne.n	8008e06 <HAL_TIMEx_PWMN_Start_IT+0x104>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008d1c:	2800      	cmp	r0, #0
 8008d1e:	d145      	bne.n	8008dac <HAL_TIMEx_PWMN_Start_IT+0xaa>
 8008d20:	2302      	movs	r3, #2
 8008d22:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  switch (Channel)
 8008d26:	2804      	cmp	r0, #4
 8008d28:	d056      	beq.n	8008dd8 <HAL_TIMEx_PWMN_Start_IT+0xd6>
 8008d2a:	2808      	cmp	r0, #8
 8008d2c:	d05a      	beq.n	8008de4 <HAL_TIMEx_PWMN_Start_IT+0xe2>
 8008d2e:	2800      	cmp	r0, #0
 8008d30:	d04c      	beq.n	8008dcc <HAL_TIMEx_PWMN_Start_IT+0xca>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
 8008d32:	6822      	ldr	r2, [r4, #0]
 8008d34:	68d3      	ldr	r3, [r2, #12]
 8008d36:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008d3a:	60d3      	str	r3, [r2, #12]
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 8008d3c:	2204      	movs	r2, #4
 8008d3e:	4601      	mov	r1, r0
 8008d40:	6820      	ldr	r0, [r4, #0]
 8008d42:	f7ff f9e3 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 8008d46:	6822      	ldr	r2, [r4, #0]
 8008d48:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8008d4a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008d4e:	6453      	str	r3, [r2, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008d50:	6823      	ldr	r3, [r4, #0]
 8008d52:	4a2f      	ldr	r2, [pc, #188]	; (8008e10 <HAL_TIMEx_PWMN_Start_IT+0x10e>)
 8008d54:	4293      	cmp	r3, r2
 8008d56:	d04b      	beq.n	8008df0 <HAL_TIMEx_PWMN_Start_IT+0xee>
 8008d58:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008d5c:	d048      	beq.n	8008df0 <HAL_TIMEx_PWMN_Start_IT+0xee>
 8008d5e:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008d62:	4293      	cmp	r3, r2
 8008d64:	d044      	beq.n	8008df0 <HAL_TIMEx_PWMN_Start_IT+0xee>
 8008d66:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008d6a:	4293      	cmp	r3, r2
 8008d6c:	d040      	beq.n	8008df0 <HAL_TIMEx_PWMN_Start_IT+0xee>
    __HAL_TIM_ENABLE(htim);
 8008d6e:	681a      	ldr	r2, [r3, #0]
 8008d70:	f042 0201 	orr.w	r2, r2, #1
 8008d74:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008d76:	2000      	movs	r0, #0
 8008d78:	e046      	b.n	8008e08 <HAL_TIMEx_PWMN_Start_IT+0x106>
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8008d7a:	2904      	cmp	r1, #4
 8008d7c:	d008      	beq.n	8008d90 <HAL_TIMEx_PWMN_Start_IT+0x8e>
 8008d7e:	2908      	cmp	r1, #8
 8008d80:	d00d      	beq.n	8008d9e <HAL_TIMEx_PWMN_Start_IT+0x9c>
 8008d82:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8008d86:	b2db      	uxtb	r3, r3
 8008d88:	3b01      	subs	r3, #1
 8008d8a:	bf18      	it	ne
 8008d8c:	2301      	movne	r3, #1
 8008d8e:	e7c3      	b.n	8008d18 <HAL_TIMEx_PWMN_Start_IT+0x16>
 8008d90:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8008d94:	b2db      	uxtb	r3, r3
 8008d96:	3b01      	subs	r3, #1
 8008d98:	bf18      	it	ne
 8008d9a:	2301      	movne	r3, #1
 8008d9c:	e7bc      	b.n	8008d18 <HAL_TIMEx_PWMN_Start_IT+0x16>
 8008d9e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8008da2:	b2db      	uxtb	r3, r3
 8008da4:	3b01      	subs	r3, #1
 8008da6:	bf18      	it	ne
 8008da8:	2301      	movne	r3, #1
 8008daa:	e7b5      	b.n	8008d18 <HAL_TIMEx_PWMN_Start_IT+0x16>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008dac:	2804      	cmp	r0, #4
 8008dae:	d005      	beq.n	8008dbc <HAL_TIMEx_PWMN_Start_IT+0xba>
 8008db0:	2808      	cmp	r0, #8
 8008db2:	d007      	beq.n	8008dc4 <HAL_TIMEx_PWMN_Start_IT+0xc2>
 8008db4:	2302      	movs	r3, #2
 8008db6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8008dba:	e7b4      	b.n	8008d26 <HAL_TIMEx_PWMN_Start_IT+0x24>
 8008dbc:	2302      	movs	r3, #2
 8008dbe:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8008dc2:	e7b0      	b.n	8008d26 <HAL_TIMEx_PWMN_Start_IT+0x24>
 8008dc4:	2302      	movs	r3, #2
 8008dc6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8008dca:	e7ac      	b.n	8008d26 <HAL_TIMEx_PWMN_Start_IT+0x24>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008dcc:	6822      	ldr	r2, [r4, #0]
 8008dce:	68d3      	ldr	r3, [r2, #12]
 8008dd0:	f043 0302 	orr.w	r3, r3, #2
 8008dd4:	60d3      	str	r3, [r2, #12]
      break;
 8008dd6:	e7ac      	b.n	8008d32 <HAL_TIMEx_PWMN_Start_IT+0x30>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8008dd8:	6822      	ldr	r2, [r4, #0]
 8008dda:	68d3      	ldr	r3, [r2, #12]
 8008ddc:	f043 0304 	orr.w	r3, r3, #4
 8008de0:	60d3      	str	r3, [r2, #12]
      break;
 8008de2:	e7a6      	b.n	8008d32 <HAL_TIMEx_PWMN_Start_IT+0x30>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8008de4:	6822      	ldr	r2, [r4, #0]
 8008de6:	68d3      	ldr	r3, [r2, #12]
 8008de8:	f043 0308 	orr.w	r3, r3, #8
 8008dec:	60d3      	str	r3, [r2, #12]
      break;
 8008dee:	e7a0      	b.n	8008d32 <HAL_TIMEx_PWMN_Start_IT+0x30>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8008df0:	689a      	ldr	r2, [r3, #8]
 8008df2:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8008df6:	2a06      	cmp	r2, #6
 8008df8:	d007      	beq.n	8008e0a <HAL_TIMEx_PWMN_Start_IT+0x108>
      __HAL_TIM_ENABLE(htim);
 8008dfa:	681a      	ldr	r2, [r3, #0]
 8008dfc:	f042 0201 	orr.w	r2, r2, #1
 8008e00:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008e02:	2000      	movs	r0, #0
 8008e04:	e000      	b.n	8008e08 <HAL_TIMEx_PWMN_Start_IT+0x106>
    return HAL_ERROR;
 8008e06:	2001      	movs	r0, #1
}
 8008e08:	bd10      	pop	{r4, pc}
  return HAL_OK;
 8008e0a:	2000      	movs	r0, #0
 8008e0c:	e7fc      	b.n	8008e08 <HAL_TIMEx_PWMN_Start_IT+0x106>
 8008e0e:	bf00      	nop
 8008e10:	40012c00 	.word	0x40012c00

08008e14 <HAL_TIMEx_PWMN_Stop_IT>:
{
 8008e14:	b538      	push	{r3, r4, r5, lr}
 8008e16:	4605      	mov	r5, r0
 8008e18:	460c      	mov	r4, r1
  switch (Channel)
 8008e1a:	2904      	cmp	r1, #4
 8008e1c:	d03c      	beq.n	8008e98 <HAL_TIMEx_PWMN_Stop_IT+0x84>
 8008e1e:	2908      	cmp	r1, #8
 8008e20:	d040      	beq.n	8008ea4 <HAL_TIMEx_PWMN_Stop_IT+0x90>
 8008e22:	2900      	cmp	r1, #0
 8008e24:	d032      	beq.n	8008e8c <HAL_TIMEx_PWMN_Stop_IT+0x78>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
 8008e26:	2200      	movs	r2, #0
 8008e28:	4621      	mov	r1, r4
 8008e2a:	6828      	ldr	r0, [r5, #0]
 8008e2c:	f7ff f96e 	bl	800810c <TIM_CCxNChannelCmd>
  tmpccer = htim->Instance->CCER;
 8008e30:	682b      	ldr	r3, [r5, #0]
 8008e32:	6a19      	ldr	r1, [r3, #32]
  if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
 8008e34:	f240 4244 	movw	r2, #1092	; 0x444
 8008e38:	4211      	tst	r1, r2
 8008e3a:	d103      	bne.n	8008e44 <HAL_TIMEx_PWMN_Stop_IT+0x30>
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
 8008e3c:	68da      	ldr	r2, [r3, #12]
 8008e3e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8008e42:	60da      	str	r2, [r3, #12]
  __HAL_TIM_MOE_DISABLE(htim);
 8008e44:	682b      	ldr	r3, [r5, #0]
 8008e46:	6a19      	ldr	r1, [r3, #32]
 8008e48:	f241 1211 	movw	r2, #4369	; 0x1111
 8008e4c:	4211      	tst	r1, r2
 8008e4e:	d108      	bne.n	8008e62 <HAL_TIMEx_PWMN_Stop_IT+0x4e>
 8008e50:	6a19      	ldr	r1, [r3, #32]
 8008e52:	f240 4244 	movw	r2, #1092	; 0x444
 8008e56:	4211      	tst	r1, r2
 8008e58:	d103      	bne.n	8008e62 <HAL_TIMEx_PWMN_Stop_IT+0x4e>
 8008e5a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008e5c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008e60:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8008e62:	682b      	ldr	r3, [r5, #0]
 8008e64:	6a19      	ldr	r1, [r3, #32]
 8008e66:	f241 1211 	movw	r2, #4369	; 0x1111
 8008e6a:	4211      	tst	r1, r2
 8008e6c:	d108      	bne.n	8008e80 <HAL_TIMEx_PWMN_Stop_IT+0x6c>
 8008e6e:	6a19      	ldr	r1, [r3, #32]
 8008e70:	f240 4244 	movw	r2, #1092	; 0x444
 8008e74:	4211      	tst	r1, r2
 8008e76:	d103      	bne.n	8008e80 <HAL_TIMEx_PWMN_Stop_IT+0x6c>
 8008e78:	681a      	ldr	r2, [r3, #0]
 8008e7a:	f022 0201 	bic.w	r2, r2, #1
 8008e7e:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008e80:	b9b4      	cbnz	r4, 8008eb0 <HAL_TIMEx_PWMN_Stop_IT+0x9c>
 8008e82:	2301      	movs	r3, #1
 8008e84:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
 8008e88:	2000      	movs	r0, #0
 8008e8a:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8008e8c:	6802      	ldr	r2, [r0, #0]
 8008e8e:	68d3      	ldr	r3, [r2, #12]
 8008e90:	f023 0302 	bic.w	r3, r3, #2
 8008e94:	60d3      	str	r3, [r2, #12]
      break;
 8008e96:	e7c6      	b.n	8008e26 <HAL_TIMEx_PWMN_Stop_IT+0x12>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8008e98:	6802      	ldr	r2, [r0, #0]
 8008e9a:	68d3      	ldr	r3, [r2, #12]
 8008e9c:	f023 0304 	bic.w	r3, r3, #4
 8008ea0:	60d3      	str	r3, [r2, #12]
      break;
 8008ea2:	e7c0      	b.n	8008e26 <HAL_TIMEx_PWMN_Stop_IT+0x12>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8008ea4:	6802      	ldr	r2, [r0, #0]
 8008ea6:	68d3      	ldr	r3, [r2, #12]
 8008ea8:	f023 0308 	bic.w	r3, r3, #8
 8008eac:	60d3      	str	r3, [r2, #12]
      break;
 8008eae:	e7ba      	b.n	8008e26 <HAL_TIMEx_PWMN_Stop_IT+0x12>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8008eb0:	2c04      	cmp	r4, #4
 8008eb2:	d005      	beq.n	8008ec0 <HAL_TIMEx_PWMN_Stop_IT+0xac>
 8008eb4:	2c08      	cmp	r4, #8
 8008eb6:	d007      	beq.n	8008ec8 <HAL_TIMEx_PWMN_Stop_IT+0xb4>
 8008eb8:	2301      	movs	r3, #1
 8008eba:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 8008ebe:	e7e3      	b.n	8008e88 <HAL_TIMEx_PWMN_Stop_IT+0x74>
 8008ec0:	2301      	movs	r3, #1
 8008ec2:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
 8008ec6:	e7df      	b.n	8008e88 <HAL_TIMEx_PWMN_Stop_IT+0x74>
 8008ec8:	2301      	movs	r3, #1
 8008eca:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8008ece:	e7db      	b.n	8008e88 <HAL_TIMEx_PWMN_Stop_IT+0x74>

08008ed0 <HAL_TIMEx_PWMN_Start_DMA>:
{
 8008ed0:	b570      	push	{r4, r5, r6, lr}
 8008ed2:	4604      	mov	r4, r0
 8008ed4:	4616      	mov	r6, r2
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 8008ed6:	460d      	mov	r5, r1
 8008ed8:	2900      	cmp	r1, #0
 8008eda:	d147      	bne.n	8008f6c <HAL_TIMEx_PWMN_Start_DMA+0x9c>
 8008edc:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
 8008ee0:	b2c0      	uxtb	r0, r0
 8008ee2:	2802      	cmp	r0, #2
 8008ee4:	bf14      	ite	ne
 8008ee6:	2000      	movne	r0, #0
 8008ee8:	2001      	moveq	r0, #1
 8008eea:	2800      	cmp	r0, #0
 8008eec:	f040 80d9 	bne.w	80090a2 <HAL_TIMEx_PWMN_Start_DMA+0x1d2>
  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 8008ef0:	2d00      	cmp	r5, #0
 8008ef2:	d157      	bne.n	8008fa4 <HAL_TIMEx_PWMN_Start_DMA+0xd4>
 8008ef4:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8008ef8:	b2d2      	uxtb	r2, r2
 8008efa:	2a01      	cmp	r2, #1
 8008efc:	bf14      	ite	ne
 8008efe:	2200      	movne	r2, #0
 8008f00:	2201      	moveq	r2, #1
 8008f02:	2a00      	cmp	r2, #0
 8008f04:	f000 80cf 	beq.w	80090a6 <HAL_TIMEx_PWMN_Start_DMA+0x1d6>
    if ((pData == NULL) && (Length > 0U))
 8008f08:	2e00      	cmp	r6, #0
 8008f0a:	d067      	beq.n	8008fdc <HAL_TIMEx_PWMN_Start_DMA+0x10c>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008f0c:	2d00      	cmp	r5, #0
 8008f0e:	d169      	bne.n	8008fe4 <HAL_TIMEx_PWMN_Start_DMA+0x114>
 8008f10:	2202      	movs	r2, #2
 8008f12:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  switch (Channel)
 8008f16:	2d04      	cmp	r5, #4
 8008f18:	f000 808b 	beq.w	8009032 <HAL_TIMEx_PWMN_Start_DMA+0x162>
 8008f1c:	2d08      	cmp	r5, #8
 8008f1e:	f000 809f 	beq.w	8009060 <HAL_TIMEx_PWMN_Start_DMA+0x190>
 8008f22:	2d00      	cmp	r5, #0
 8008f24:	d06e      	beq.n	8009004 <HAL_TIMEx_PWMN_Start_DMA+0x134>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 8008f26:	2204      	movs	r2, #4
 8008f28:	4629      	mov	r1, r5
 8008f2a:	6820      	ldr	r0, [r4, #0]
 8008f2c:	f7ff f8ee 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 8008f30:	6822      	ldr	r2, [r4, #0]
 8008f32:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8008f34:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008f38:	6453      	str	r3, [r2, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008f3a:	6823      	ldr	r3, [r4, #0]
 8008f3c:	4a5f      	ldr	r2, [pc, #380]	; (80090bc <HAL_TIMEx_PWMN_Start_DMA+0x1ec>)
 8008f3e:	4293      	cmp	r3, r2
 8008f40:	f000 80a4 	beq.w	800908c <HAL_TIMEx_PWMN_Start_DMA+0x1bc>
 8008f44:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008f48:	f000 80a0 	beq.w	800908c <HAL_TIMEx_PWMN_Start_DMA+0x1bc>
 8008f4c:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8008f50:	4293      	cmp	r3, r2
 8008f52:	f000 809b 	beq.w	800908c <HAL_TIMEx_PWMN_Start_DMA+0x1bc>
 8008f56:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008f5a:	4293      	cmp	r3, r2
 8008f5c:	f000 8096 	beq.w	800908c <HAL_TIMEx_PWMN_Start_DMA+0x1bc>
    __HAL_TIM_ENABLE(htim);
 8008f60:	681a      	ldr	r2, [r3, #0]
 8008f62:	f042 0201 	orr.w	r2, r2, #1
 8008f66:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8008f68:	2000      	movs	r0, #0
 8008f6a:	e09d      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
 8008f6c:	2904      	cmp	r1, #4
 8008f6e:	d009      	beq.n	8008f84 <HAL_TIMEx_PWMN_Start_DMA+0xb4>
 8008f70:	2908      	cmp	r1, #8
 8008f72:	d00f      	beq.n	8008f94 <HAL_TIMEx_PWMN_Start_DMA+0xc4>
 8008f74:	f890 0045 	ldrb.w	r0, [r0, #69]	; 0x45
 8008f78:	b2c0      	uxtb	r0, r0
 8008f7a:	2802      	cmp	r0, #2
 8008f7c:	bf14      	ite	ne
 8008f7e:	2000      	movne	r0, #0
 8008f80:	2001      	moveq	r0, #1
 8008f82:	e7b2      	b.n	8008eea <HAL_TIMEx_PWMN_Start_DMA+0x1a>
 8008f84:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
 8008f88:	b2c0      	uxtb	r0, r0
 8008f8a:	2802      	cmp	r0, #2
 8008f8c:	bf14      	ite	ne
 8008f8e:	2000      	movne	r0, #0
 8008f90:	2001      	moveq	r0, #1
 8008f92:	e7aa      	b.n	8008eea <HAL_TIMEx_PWMN_Start_DMA+0x1a>
 8008f94:	f890 0044 	ldrb.w	r0, [r0, #68]	; 0x44
 8008f98:	b2c0      	uxtb	r0, r0
 8008f9a:	2802      	cmp	r0, #2
 8008f9c:	bf14      	ite	ne
 8008f9e:	2000      	movne	r0, #0
 8008fa0:	2001      	moveq	r0, #1
 8008fa2:	e7a2      	b.n	8008eea <HAL_TIMEx_PWMN_Start_DMA+0x1a>
  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
 8008fa4:	2d04      	cmp	r5, #4
 8008fa6:	d009      	beq.n	8008fbc <HAL_TIMEx_PWMN_Start_DMA+0xec>
 8008fa8:	2d08      	cmp	r5, #8
 8008faa:	d00f      	beq.n	8008fcc <HAL_TIMEx_PWMN_Start_DMA+0xfc>
 8008fac:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 8008fb0:	b2d2      	uxtb	r2, r2
 8008fb2:	2a01      	cmp	r2, #1
 8008fb4:	bf14      	ite	ne
 8008fb6:	2200      	movne	r2, #0
 8008fb8:	2201      	moveq	r2, #1
 8008fba:	e7a2      	b.n	8008f02 <HAL_TIMEx_PWMN_Start_DMA+0x32>
 8008fbc:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8008fc0:	b2d2      	uxtb	r2, r2
 8008fc2:	2a01      	cmp	r2, #1
 8008fc4:	bf14      	ite	ne
 8008fc6:	2200      	movne	r2, #0
 8008fc8:	2201      	moveq	r2, #1
 8008fca:	e79a      	b.n	8008f02 <HAL_TIMEx_PWMN_Start_DMA+0x32>
 8008fcc:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008fd0:	b2d2      	uxtb	r2, r2
 8008fd2:	2a01      	cmp	r2, #1
 8008fd4:	bf14      	ite	ne
 8008fd6:	2200      	movne	r2, #0
 8008fd8:	2201      	moveq	r2, #1
 8008fda:	e792      	b.n	8008f02 <HAL_TIMEx_PWMN_Start_DMA+0x32>
    if ((pData == NULL) && (Length > 0U))
 8008fdc:	2b00      	cmp	r3, #0
 8008fde:	d095      	beq.n	8008f0c <HAL_TIMEx_PWMN_Start_DMA+0x3c>
      return HAL_ERROR;
 8008fe0:	2001      	movs	r0, #1
 8008fe2:	e061      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8008fe4:	2d04      	cmp	r5, #4
 8008fe6:	d005      	beq.n	8008ff4 <HAL_TIMEx_PWMN_Start_DMA+0x124>
 8008fe8:	2d08      	cmp	r5, #8
 8008fea:	d007      	beq.n	8008ffc <HAL_TIMEx_PWMN_Start_DMA+0x12c>
 8008fec:	2202      	movs	r2, #2
 8008fee:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 8008ff2:	e790      	b.n	8008f16 <HAL_TIMEx_PWMN_Start_DMA+0x46>
 8008ff4:	2202      	movs	r2, #2
 8008ff6:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8008ffa:	e78c      	b.n	8008f16 <HAL_TIMEx_PWMN_Start_DMA+0x46>
 8008ffc:	2202      	movs	r2, #2
 8008ffe:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
 8009002:	e788      	b.n	8008f16 <HAL_TIMEx_PWMN_Start_DMA+0x46>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
 8009004:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8009006:	492e      	ldr	r1, [pc, #184]	; (80090c0 <HAL_TIMEx_PWMN_Start_DMA+0x1f0>)
 8009008:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 800900a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800900c:	492d      	ldr	r1, [pc, #180]	; (80090c4 <HAL_TIMEx_PWMN_Start_DMA+0x1f4>)
 800900e:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
 8009010:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8009012:	492d      	ldr	r1, [pc, #180]	; (80090c8 <HAL_TIMEx_PWMN_Start_DMA+0x1f8>)
 8009014:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
 8009016:	6822      	ldr	r2, [r4, #0]
 8009018:	3234      	adds	r2, #52	; 0x34
 800901a:	4631      	mov	r1, r6
 800901c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800901e:	f7fa fc1f 	bl	8003860 <HAL_DMA_Start_IT>
 8009022:	2800      	cmp	r0, #0
 8009024:	d141      	bne.n	80090aa <HAL_TIMEx_PWMN_Start_DMA+0x1da>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
 8009026:	6822      	ldr	r2, [r4, #0]
 8009028:	68d3      	ldr	r3, [r2, #12]
 800902a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800902e:	60d3      	str	r3, [r2, #12]
      break;
 8009030:	e779      	b.n	8008f26 <HAL_TIMEx_PWMN_Start_DMA+0x56>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
 8009032:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009034:	4922      	ldr	r1, [pc, #136]	; (80090c0 <HAL_TIMEx_PWMN_Start_DMA+0x1f0>)
 8009036:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8009038:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800903a:	4922      	ldr	r1, [pc, #136]	; (80090c4 <HAL_TIMEx_PWMN_Start_DMA+0x1f4>)
 800903c:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
 800903e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009040:	4921      	ldr	r1, [pc, #132]	; (80090c8 <HAL_TIMEx_PWMN_Start_DMA+0x1f8>)
 8009042:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
 8009044:	6822      	ldr	r2, [r4, #0]
 8009046:	3238      	adds	r2, #56	; 0x38
 8009048:	4631      	mov	r1, r6
 800904a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800904c:	f7fa fc08 	bl	8003860 <HAL_DMA_Start_IT>
 8009050:	2800      	cmp	r0, #0
 8009052:	d12c      	bne.n	80090ae <HAL_TIMEx_PWMN_Start_DMA+0x1de>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
 8009054:	6822      	ldr	r2, [r4, #0]
 8009056:	68d3      	ldr	r3, [r2, #12]
 8009058:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800905c:	60d3      	str	r3, [r2, #12]
      break;
 800905e:	e762      	b.n	8008f26 <HAL_TIMEx_PWMN_Start_DMA+0x56>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
 8009060:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009062:	4917      	ldr	r1, [pc, #92]	; (80090c0 <HAL_TIMEx_PWMN_Start_DMA+0x1f0>)
 8009064:	6291      	str	r1, [r2, #40]	; 0x28
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
 8009066:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009068:	4916      	ldr	r1, [pc, #88]	; (80090c4 <HAL_TIMEx_PWMN_Start_DMA+0x1f4>)
 800906a:	62d1      	str	r1, [r2, #44]	; 0x2c
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
 800906c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800906e:	4916      	ldr	r1, [pc, #88]	; (80090c8 <HAL_TIMEx_PWMN_Start_DMA+0x1f8>)
 8009070:	6311      	str	r1, [r2, #48]	; 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
 8009072:	6822      	ldr	r2, [r4, #0]
 8009074:	323c      	adds	r2, #60	; 0x3c
 8009076:	4631      	mov	r1, r6
 8009078:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800907a:	f7fa fbf1 	bl	8003860 <HAL_DMA_Start_IT>
 800907e:	b9c0      	cbnz	r0, 80090b2 <HAL_TIMEx_PWMN_Start_DMA+0x1e2>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
 8009080:	6822      	ldr	r2, [r4, #0]
 8009082:	68d3      	ldr	r3, [r2, #12]
 8009084:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009088:	60d3      	str	r3, [r2, #12]
      break;
 800908a:	e74c      	b.n	8008f26 <HAL_TIMEx_PWMN_Start_DMA+0x56>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800908c:	689a      	ldr	r2, [r3, #8]
 800908e:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8009092:	2a06      	cmp	r2, #6
 8009094:	d00f      	beq.n	80090b6 <HAL_TIMEx_PWMN_Start_DMA+0x1e6>
      __HAL_TIM_ENABLE(htim);
 8009096:	681a      	ldr	r2, [r3, #0]
 8009098:	f042 0201 	orr.w	r2, r2, #1
 800909c:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800909e:	2000      	movs	r0, #0
 80090a0:	e002      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
    return HAL_BUSY;
 80090a2:	2002      	movs	r0, #2
 80090a4:	e000      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
    return HAL_ERROR;
 80090a6:	2001      	movs	r0, #1
}
 80090a8:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 80090aa:	2001      	movs	r0, #1
 80090ac:	e7fc      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
        return HAL_ERROR;
 80090ae:	2001      	movs	r0, #1
 80090b0:	e7fa      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
        return HAL_ERROR;
 80090b2:	2001      	movs	r0, #1
 80090b4:	e7f8      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
  return HAL_OK;
 80090b6:	2000      	movs	r0, #0
 80090b8:	e7f6      	b.n	80090a8 <HAL_TIMEx_PWMN_Start_DMA+0x1d8>
 80090ba:	bf00      	nop
 80090bc:	40012c00 	.word	0x40012c00
 80090c0:	08008173 	.word	0x08008173
 80090c4:	080058b7 	.word	0x080058b7
 80090c8:	0800812f 	.word	0x0800812f

080090cc <HAL_TIMEx_PWMN_Stop_DMA>:
{
 80090cc:	b538      	push	{r3, r4, r5, lr}
 80090ce:	4605      	mov	r5, r0
 80090d0:	460c      	mov	r4, r1
  switch (Channel)
 80090d2:	2904      	cmp	r1, #4
 80090d4:	d034      	beq.n	8009140 <HAL_TIMEx_PWMN_Stop_DMA+0x74>
 80090d6:	2908      	cmp	r1, #8
 80090d8:	d03b      	beq.n	8009152 <HAL_TIMEx_PWMN_Stop_DMA+0x86>
 80090da:	b341      	cbz	r1, 800912e <HAL_TIMEx_PWMN_Stop_DMA+0x62>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
 80090dc:	2200      	movs	r2, #0
 80090de:	4621      	mov	r1, r4
 80090e0:	6828      	ldr	r0, [r5, #0]
 80090e2:	f7ff f813 	bl	800810c <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
 80090e6:	682b      	ldr	r3, [r5, #0]
 80090e8:	6a19      	ldr	r1, [r3, #32]
 80090ea:	f241 1211 	movw	r2, #4369	; 0x1111
 80090ee:	4211      	tst	r1, r2
 80090f0:	d108      	bne.n	8009104 <HAL_TIMEx_PWMN_Stop_DMA+0x38>
 80090f2:	6a19      	ldr	r1, [r3, #32]
 80090f4:	f240 4244 	movw	r2, #1092	; 0x444
 80090f8:	4211      	tst	r1, r2
 80090fa:	d103      	bne.n	8009104 <HAL_TIMEx_PWMN_Stop_DMA+0x38>
 80090fc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80090fe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8009102:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8009104:	682b      	ldr	r3, [r5, #0]
 8009106:	6a19      	ldr	r1, [r3, #32]
 8009108:	f241 1211 	movw	r2, #4369	; 0x1111
 800910c:	4211      	tst	r1, r2
 800910e:	d108      	bne.n	8009122 <HAL_TIMEx_PWMN_Stop_DMA+0x56>
 8009110:	6a19      	ldr	r1, [r3, #32]
 8009112:	f240 4244 	movw	r2, #1092	; 0x444
 8009116:	4211      	tst	r1, r2
 8009118:	d103      	bne.n	8009122 <HAL_TIMEx_PWMN_Stop_DMA+0x56>
 800911a:	681a      	ldr	r2, [r3, #0]
 800911c:	f022 0201 	bic.w	r2, r2, #1
 8009120:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8009122:	b9fc      	cbnz	r4, 8009164 <HAL_TIMEx_PWMN_Stop_DMA+0x98>
 8009124:	2301      	movs	r3, #1
 8009126:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
 800912a:	2000      	movs	r0, #0
 800912c:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
 800912e:	6802      	ldr	r2, [r0, #0]
 8009130:	68d3      	ldr	r3, [r2, #12]
 8009132:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8009136:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
 8009138:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800913a:	f7fa fbed 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 800913e:	e7cd      	b.n	80090dc <HAL_TIMEx_PWMN_Stop_DMA+0x10>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
 8009140:	6802      	ldr	r2, [r0, #0]
 8009142:	68d3      	ldr	r3, [r2, #12]
 8009144:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009148:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
 800914a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800914c:	f7fa fbe4 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8009150:	e7c4      	b.n	80090dc <HAL_TIMEx_PWMN_Stop_DMA+0x10>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
 8009152:	6802      	ldr	r2, [r0, #0]
 8009154:	68d3      	ldr	r3, [r2, #12]
 8009156:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800915a:	60d3      	str	r3, [r2, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
 800915c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800915e:	f7fa fbdb 	bl	8003918 <HAL_DMA_Abort_IT>
      break;
 8009162:	e7bb      	b.n	80090dc <HAL_TIMEx_PWMN_Stop_DMA+0x10>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8009164:	2c04      	cmp	r4, #4
 8009166:	d005      	beq.n	8009174 <HAL_TIMEx_PWMN_Stop_DMA+0xa8>
 8009168:	2c08      	cmp	r4, #8
 800916a:	d007      	beq.n	800917c <HAL_TIMEx_PWMN_Stop_DMA+0xb0>
 800916c:	2301      	movs	r3, #1
 800916e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 8009172:	e7da      	b.n	800912a <HAL_TIMEx_PWMN_Stop_DMA+0x5e>
 8009174:	2301      	movs	r3, #1
 8009176:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
 800917a:	e7d6      	b.n	800912a <HAL_TIMEx_PWMN_Stop_DMA+0x5e>
 800917c:	2301      	movs	r3, #1
 800917e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8009182:	e7d2      	b.n	800912a <HAL_TIMEx_PWMN_Stop_DMA+0x5e>

08009184 <HAL_TIMEx_OnePulseN_Start>:
{
 8009184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009186:	4604      	mov	r4, r0
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 8009188:	460f      	mov	r7, r1
 800918a:	b9b1      	cbnz	r1, 80091ba <HAL_TIMEx_OnePulseN_Start+0x36>
 800918c:	2504      	movs	r5, #4
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 800918e:	f894 003e 	ldrb.w	r0, [r4, #62]	; 0x3e
 8009192:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 8009194:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8009198:	b2db      	uxtb	r3, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 800919a:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 800919e:	b2d2      	uxtb	r2, r2
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 80091a0:	f894 6043 	ldrb.w	r6, [r4, #67]	; 0x43
 80091a4:	b2f6      	uxtb	r6, r6
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 80091a6:	2801      	cmp	r0, #1
 80091a8:	d123      	bne.n	80091f2 <HAL_TIMEx_OnePulseN_Start+0x6e>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 80091aa:	2b01      	cmp	r3, #1
 80091ac:	d122      	bne.n	80091f4 <HAL_TIMEx_OnePulseN_Start+0x70>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 80091ae:	2a01      	cmp	r2, #1
 80091b0:	d121      	bne.n	80091f6 <HAL_TIMEx_OnePulseN_Start+0x72>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 80091b2:	2e01      	cmp	r6, #1
 80091b4:	d003      	beq.n	80091be <HAL_TIMEx_OnePulseN_Start+0x3a>
    return HAL_ERROR;
 80091b6:	4610      	mov	r0, r2
 80091b8:	e01c      	b.n	80091f4 <HAL_TIMEx_OnePulseN_Start+0x70>
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 80091ba:	2500      	movs	r5, #0
 80091bc:	e7e7      	b.n	800918e <HAL_TIMEx_OnePulseN_Start+0xa>
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 80091be:	2302      	movs	r3, #2
 80091c0:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 80091c4:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 80091c8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 80091cc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
 80091d0:	2204      	movs	r2, #4
 80091d2:	4639      	mov	r1, r7
 80091d4:	6820      	ldr	r0, [r4, #0]
 80091d6:	f7fe ff99 	bl	800810c <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
 80091da:	2201      	movs	r2, #1
 80091dc:	4629      	mov	r1, r5
 80091de:	6820      	ldr	r0, [r4, #0]
 80091e0:	f7fd f966 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 80091e4:	6822      	ldr	r2, [r4, #0]
 80091e6:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80091e8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80091ec:	6453      	str	r3, [r2, #68]	; 0x44
  return HAL_OK;
 80091ee:	2000      	movs	r0, #0
 80091f0:	e000      	b.n	80091f4 <HAL_TIMEx_OnePulseN_Start+0x70>
    return HAL_ERROR;
 80091f2:	2001      	movs	r0, #1
}
 80091f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80091f6:	4618      	mov	r0, r3
 80091f8:	e7fc      	b.n	80091f4 <HAL_TIMEx_OnePulseN_Start+0x70>

080091fa <HAL_TIMEx_OnePulseN_Stop>:
{
 80091fa:	b538      	push	{r3, r4, r5, lr}
 80091fc:	4604      	mov	r4, r0
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 80091fe:	2900      	cmp	r1, #0
 8009200:	d132      	bne.n	8009268 <HAL_TIMEx_OnePulseN_Stop+0x6e>
 8009202:	2504      	movs	r5, #4
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
 8009204:	2200      	movs	r2, #0
 8009206:	6820      	ldr	r0, [r4, #0]
 8009208:	f7fe ff80 	bl	800810c <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
 800920c:	2200      	movs	r2, #0
 800920e:	4629      	mov	r1, r5
 8009210:	6820      	ldr	r0, [r4, #0]
 8009212:	f7fd f94d 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
 8009216:	6823      	ldr	r3, [r4, #0]
 8009218:	6a19      	ldr	r1, [r3, #32]
 800921a:	f241 1211 	movw	r2, #4369	; 0x1111
 800921e:	4211      	tst	r1, r2
 8009220:	d108      	bne.n	8009234 <HAL_TIMEx_OnePulseN_Stop+0x3a>
 8009222:	6a19      	ldr	r1, [r3, #32]
 8009224:	f240 4244 	movw	r2, #1092	; 0x444
 8009228:	4211      	tst	r1, r2
 800922a:	d103      	bne.n	8009234 <HAL_TIMEx_OnePulseN_Stop+0x3a>
 800922c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800922e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8009232:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8009234:	6823      	ldr	r3, [r4, #0]
 8009236:	6a19      	ldr	r1, [r3, #32]
 8009238:	f241 1211 	movw	r2, #4369	; 0x1111
 800923c:	4211      	tst	r1, r2
 800923e:	d108      	bne.n	8009252 <HAL_TIMEx_OnePulseN_Stop+0x58>
 8009240:	6a19      	ldr	r1, [r3, #32]
 8009242:	f240 4244 	movw	r2, #1092	; 0x444
 8009246:	4211      	tst	r1, r2
 8009248:	d103      	bne.n	8009252 <HAL_TIMEx_OnePulseN_Stop+0x58>
 800924a:	681a      	ldr	r2, [r3, #0]
 800924c:	f022 0201 	bic.w	r2, r2, #1
 8009250:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8009252:	2301      	movs	r3, #1
 8009254:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8009258:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 800925c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8009260:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
 8009264:	2000      	movs	r0, #0
 8009266:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 8009268:	2500      	movs	r5, #0
 800926a:	e7cb      	b.n	8009204 <HAL_TIMEx_OnePulseN_Stop+0xa>

0800926c <HAL_TIMEx_OnePulseN_Start_IT>:
{
 800926c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800926e:	4604      	mov	r4, r0
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 8009270:	460f      	mov	r7, r1
 8009272:	b9b1      	cbnz	r1, 80092a2 <HAL_TIMEx_OnePulseN_Start_IT+0x36>
 8009274:	2504      	movs	r5, #4
  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
 8009276:	f894 003e 	ldrb.w	r0, [r4, #62]	; 0x3e
 800927a:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
 800927c:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8009280:	b2db      	uxtb	r3, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
 8009282:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8009286:	b2d2      	uxtb	r2, r2
  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
 8009288:	f894 6043 	ldrb.w	r6, [r4, #67]	; 0x43
 800928c:	b2f6      	uxtb	r6, r6
  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 800928e:	2801      	cmp	r0, #1
 8009290:	d12d      	bne.n	80092ee <HAL_TIMEx_OnePulseN_Start_IT+0x82>
      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
 8009292:	2b01      	cmp	r3, #1
 8009294:	d12c      	bne.n	80092f0 <HAL_TIMEx_OnePulseN_Start_IT+0x84>
      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
 8009296:	2a01      	cmp	r2, #1
 8009298:	d12b      	bne.n	80092f2 <HAL_TIMEx_OnePulseN_Start_IT+0x86>
      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
 800929a:	2e01      	cmp	r6, #1
 800929c:	d003      	beq.n	80092a6 <HAL_TIMEx_OnePulseN_Start_IT+0x3a>
    return HAL_ERROR;
 800929e:	4610      	mov	r0, r2
 80092a0:	e026      	b.n	80092f0 <HAL_TIMEx_OnePulseN_Start_IT+0x84>
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 80092a2:	2500      	movs	r5, #0
 80092a4:	e7e7      	b.n	8009276 <HAL_TIMEx_OnePulseN_Start_IT+0xa>
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 80092a6:	2302      	movs	r3, #2
 80092a8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 80092ac:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
 80092b0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
 80092b4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 80092b8:	6822      	ldr	r2, [r4, #0]
 80092ba:	68d3      	ldr	r3, [r2, #12]
 80092bc:	f043 0302 	orr.w	r3, r3, #2
 80092c0:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 80092c2:	6822      	ldr	r2, [r4, #0]
 80092c4:	68d3      	ldr	r3, [r2, #12]
 80092c6:	f043 0304 	orr.w	r3, r3, #4
 80092ca:	60d3      	str	r3, [r2, #12]
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
 80092cc:	2204      	movs	r2, #4
 80092ce:	4639      	mov	r1, r7
 80092d0:	6820      	ldr	r0, [r4, #0]
 80092d2:	f7fe ff1b 	bl	800810c <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
 80092d6:	2201      	movs	r2, #1
 80092d8:	4629      	mov	r1, r5
 80092da:	6820      	ldr	r0, [r4, #0]
 80092dc:	f7fd f8e8 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
 80092e0:	6822      	ldr	r2, [r4, #0]
 80092e2:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80092e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80092e8:	6453      	str	r3, [r2, #68]	; 0x44
  return HAL_OK;
 80092ea:	2000      	movs	r0, #0
 80092ec:	e000      	b.n	80092f0 <HAL_TIMEx_OnePulseN_Start_IT+0x84>
    return HAL_ERROR;
 80092ee:	2001      	movs	r0, #1
}
 80092f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80092f2:	4618      	mov	r0, r3
 80092f4:	e7fc      	b.n	80092f0 <HAL_TIMEx_OnePulseN_Start_IT+0x84>

080092f6 <HAL_TIMEx_OnePulseN_Stop_IT>:
{
 80092f6:	b538      	push	{r3, r4, r5, lr}
 80092f8:	4604      	mov	r4, r0
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 80092fa:	2900      	cmp	r1, #0
 80092fc:	d13c      	bne.n	8009378 <HAL_TIMEx_OnePulseN_Stop_IT+0x82>
 80092fe:	2504      	movs	r5, #4
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8009300:	6822      	ldr	r2, [r4, #0]
 8009302:	68d3      	ldr	r3, [r2, #12]
 8009304:	f023 0302 	bic.w	r3, r3, #2
 8009308:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 800930a:	6822      	ldr	r2, [r4, #0]
 800930c:	68d3      	ldr	r3, [r2, #12]
 800930e:	f023 0304 	bic.w	r3, r3, #4
 8009312:	60d3      	str	r3, [r2, #12]
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
 8009314:	2200      	movs	r2, #0
 8009316:	6820      	ldr	r0, [r4, #0]
 8009318:	f7fe fef8 	bl	800810c <TIM_CCxNChannelCmd>
  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
 800931c:	2200      	movs	r2, #0
 800931e:	4629      	mov	r1, r5
 8009320:	6820      	ldr	r0, [r4, #0]
 8009322:	f7fd f8c5 	bl	80064b0 <TIM_CCxChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
 8009326:	6823      	ldr	r3, [r4, #0]
 8009328:	6a19      	ldr	r1, [r3, #32]
 800932a:	f241 1211 	movw	r2, #4369	; 0x1111
 800932e:	4211      	tst	r1, r2
 8009330:	d108      	bne.n	8009344 <HAL_TIMEx_OnePulseN_Stop_IT+0x4e>
 8009332:	6a19      	ldr	r1, [r3, #32]
 8009334:	f240 4244 	movw	r2, #1092	; 0x444
 8009338:	4211      	tst	r1, r2
 800933a:	d103      	bne.n	8009344 <HAL_TIMEx_OnePulseN_Stop_IT+0x4e>
 800933c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800933e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8009342:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8009344:	6823      	ldr	r3, [r4, #0]
 8009346:	6a19      	ldr	r1, [r3, #32]
 8009348:	f241 1211 	movw	r2, #4369	; 0x1111
 800934c:	4211      	tst	r1, r2
 800934e:	d108      	bne.n	8009362 <HAL_TIMEx_OnePulseN_Stop_IT+0x6c>
 8009350:	6a19      	ldr	r1, [r3, #32]
 8009352:	f240 4244 	movw	r2, #1092	; 0x444
 8009356:	4211      	tst	r1, r2
 8009358:	d103      	bne.n	8009362 <HAL_TIMEx_OnePulseN_Stop_IT+0x6c>
 800935a:	681a      	ldr	r2, [r3, #0]
 800935c:	f022 0201 	bic.w	r2, r2, #1
 8009360:	601a      	str	r2, [r3, #0]
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8009362:	2301      	movs	r3, #1
 8009364:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8009368:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 800936c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8009370:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
 8009374:	2000      	movs	r0, #0
 8009376:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
 8009378:	2500      	movs	r5, #0
 800937a:	e7c1      	b.n	8009300 <HAL_TIMEx_OnePulseN_Stop_IT+0xa>

0800937c <HAL_TIMEx_ConfigCommutEvent>:
  __HAL_LOCK(htim);
 800937c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009380:	2b01      	cmp	r3, #1
 8009382:	d031      	beq.n	80093e8 <HAL_TIMEx_ConfigCommutEvent+0x6c>
{
 8009384:	b410      	push	{r4}
  __HAL_LOCK(htim);
 8009386:	2301      	movs	r3, #1
 8009388:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
 800938c:	b129      	cbz	r1, 800939a <HAL_TIMEx_ConfigCommutEvent+0x1e>
 800938e:	2910      	cmp	r1, #16
 8009390:	d003      	beq.n	800939a <HAL_TIMEx_ConfigCommutEvent+0x1e>
 8009392:	2920      	cmp	r1, #32
 8009394:	d001      	beq.n	800939a <HAL_TIMEx_ConfigCommutEvent+0x1e>
      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
 8009396:	2930      	cmp	r1, #48	; 0x30
 8009398:	d108      	bne.n	80093ac <HAL_TIMEx_ConfigCommutEvent+0x30>
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
 800939a:	6804      	ldr	r4, [r0, #0]
 800939c:	68a3      	ldr	r3, [r4, #8]
 800939e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80093a2:	60a3      	str	r3, [r4, #8]
    htim->Instance->SMCR |= InputTrigger;
 80093a4:	6804      	ldr	r4, [r0, #0]
 80093a6:	68a3      	ldr	r3, [r4, #8]
 80093a8:	4319      	orrs	r1, r3
 80093aa:	60a1      	str	r1, [r4, #8]
  htim->Instance->CR2 |= TIM_CR2_CCPC;
 80093ac:	6801      	ldr	r1, [r0, #0]
 80093ae:	684b      	ldr	r3, [r1, #4]
 80093b0:	f043 0301 	orr.w	r3, r3, #1
 80093b4:	604b      	str	r3, [r1, #4]
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
 80093b6:	6801      	ldr	r1, [r0, #0]
 80093b8:	684b      	ldr	r3, [r1, #4]
 80093ba:	f023 0304 	bic.w	r3, r3, #4
 80093be:	604b      	str	r3, [r1, #4]
  htim->Instance->CR2 |= CommutationSource;
 80093c0:	6801      	ldr	r1, [r0, #0]
 80093c2:	684b      	ldr	r3, [r1, #4]
 80093c4:	431a      	orrs	r2, r3
 80093c6:	604a      	str	r2, [r1, #4]
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
 80093c8:	6802      	ldr	r2, [r0, #0]
 80093ca:	68d3      	ldr	r3, [r2, #12]
 80093cc:	f023 0320 	bic.w	r3, r3, #32
 80093d0:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
 80093d2:	6802      	ldr	r2, [r0, #0]
 80093d4:	68d3      	ldr	r3, [r2, #12]
 80093d6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80093da:	60d3      	str	r3, [r2, #12]
  __HAL_UNLOCK(htim);
 80093dc:	2300      	movs	r3, #0
 80093de:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 80093e2:	4618      	mov	r0, r3
}
 80093e4:	bc10      	pop	{r4}
 80093e6:	4770      	bx	lr
  __HAL_LOCK(htim);
 80093e8:	2002      	movs	r0, #2
}
 80093ea:	4770      	bx	lr

080093ec <HAL_TIMEx_ConfigCommutEvent_IT>:
  __HAL_LOCK(htim);
 80093ec:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80093f0:	2b01      	cmp	r3, #1
 80093f2:	d031      	beq.n	8009458 <HAL_TIMEx_ConfigCommutEvent_IT+0x6c>
{
 80093f4:	b410      	push	{r4}
  __HAL_LOCK(htim);
 80093f6:	2301      	movs	r3, #1
 80093f8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
 80093fc:	b129      	cbz	r1, 800940a <HAL_TIMEx_ConfigCommutEvent_IT+0x1e>
 80093fe:	2910      	cmp	r1, #16
 8009400:	d003      	beq.n	800940a <HAL_TIMEx_ConfigCommutEvent_IT+0x1e>
 8009402:	2920      	cmp	r1, #32
 8009404:	d001      	beq.n	800940a <HAL_TIMEx_ConfigCommutEvent_IT+0x1e>
      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
 8009406:	2930      	cmp	r1, #48	; 0x30
 8009408:	d108      	bne.n	800941c <HAL_TIMEx_ConfigCommutEvent_IT+0x30>
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
 800940a:	6804      	ldr	r4, [r0, #0]
 800940c:	68a3      	ldr	r3, [r4, #8]
 800940e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009412:	60a3      	str	r3, [r4, #8]
    htim->Instance->SMCR |= InputTrigger;
 8009414:	6804      	ldr	r4, [r0, #0]
 8009416:	68a3      	ldr	r3, [r4, #8]
 8009418:	4319      	orrs	r1, r3
 800941a:	60a1      	str	r1, [r4, #8]
  htim->Instance->CR2 |= TIM_CR2_CCPC;
 800941c:	6801      	ldr	r1, [r0, #0]
 800941e:	684b      	ldr	r3, [r1, #4]
 8009420:	f043 0301 	orr.w	r3, r3, #1
 8009424:	604b      	str	r3, [r1, #4]
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
 8009426:	6801      	ldr	r1, [r0, #0]
 8009428:	684b      	ldr	r3, [r1, #4]
 800942a:	f023 0304 	bic.w	r3, r3, #4
 800942e:	604b      	str	r3, [r1, #4]
  htim->Instance->CR2 |= CommutationSource;
 8009430:	6801      	ldr	r1, [r0, #0]
 8009432:	684b      	ldr	r3, [r1, #4]
 8009434:	431a      	orrs	r2, r3
 8009436:	604a      	str	r2, [r1, #4]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
 8009438:	6802      	ldr	r2, [r0, #0]
 800943a:	68d3      	ldr	r3, [r2, #12]
 800943c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009440:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
 8009442:	6802      	ldr	r2, [r0, #0]
 8009444:	68d3      	ldr	r3, [r2, #12]
 8009446:	f043 0320 	orr.w	r3, r3, #32
 800944a:	60d3      	str	r3, [r2, #12]
  __HAL_UNLOCK(htim);
 800944c:	2300      	movs	r3, #0
 800944e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8009452:	4618      	mov	r0, r3
}
 8009454:	bc10      	pop	{r4}
 8009456:	4770      	bx	lr
  __HAL_LOCK(htim);
 8009458:	2002      	movs	r0, #2
}
 800945a:	4770      	bx	lr

0800945c <HAL_TIMEx_ConfigCommutEvent_DMA>:
  __HAL_LOCK(htim);
 800945c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009460:	2b01      	cmp	r3, #1
 8009462:	d03a      	beq.n	80094da <HAL_TIMEx_ConfigCommutEvent_DMA+0x7e>
{
 8009464:	b410      	push	{r4}
  __HAL_LOCK(htim);
 8009466:	2301      	movs	r3, #1
 8009468:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
 800946c:	b129      	cbz	r1, 800947a <HAL_TIMEx_ConfigCommutEvent_DMA+0x1e>
 800946e:	2910      	cmp	r1, #16
 8009470:	d003      	beq.n	800947a <HAL_TIMEx_ConfigCommutEvent_DMA+0x1e>
 8009472:	2920      	cmp	r1, #32
 8009474:	d001      	beq.n	800947a <HAL_TIMEx_ConfigCommutEvent_DMA+0x1e>
      (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
 8009476:	2930      	cmp	r1, #48	; 0x30
 8009478:	d108      	bne.n	800948c <HAL_TIMEx_ConfigCommutEvent_DMA+0x30>
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
 800947a:	6804      	ldr	r4, [r0, #0]
 800947c:	68a3      	ldr	r3, [r4, #8]
 800947e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009482:	60a3      	str	r3, [r4, #8]
    htim->Instance->SMCR |= InputTrigger;
 8009484:	6804      	ldr	r4, [r0, #0]
 8009486:	68a3      	ldr	r3, [r4, #8]
 8009488:	4319      	orrs	r1, r3
 800948a:	60a1      	str	r1, [r4, #8]
  htim->Instance->CR2 |= TIM_CR2_CCPC;
 800948c:	6801      	ldr	r1, [r0, #0]
 800948e:	684b      	ldr	r3, [r1, #4]
 8009490:	f043 0301 	orr.w	r3, r3, #1
 8009494:	604b      	str	r3, [r1, #4]
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
 8009496:	6801      	ldr	r1, [r0, #0]
 8009498:	684b      	ldr	r3, [r1, #4]
 800949a:	f023 0304 	bic.w	r3, r3, #4
 800949e:	604b      	str	r3, [r1, #4]
  htim->Instance->CR2 |= CommutationSource;
 80094a0:	6801      	ldr	r1, [r0, #0]
 80094a2:	684b      	ldr	r3, [r1, #4]
 80094a4:	431a      	orrs	r2, r3
 80094a6:	604a      	str	r2, [r1, #4]
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
 80094a8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80094aa:	4a0d      	ldr	r2, [pc, #52]	; (80094e0 <HAL_TIMEx_ConfigCommutEvent_DMA+0x84>)
 80094ac:	629a      	str	r2, [r3, #40]	; 0x28
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
 80094ae:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80094b0:	4a0c      	ldr	r2, [pc, #48]	; (80094e4 <HAL_TIMEx_ConfigCommutEvent_DMA+0x88>)
 80094b2:	62da      	str	r2, [r3, #44]	; 0x2c
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
 80094b4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80094b6:	4a0c      	ldr	r2, [pc, #48]	; (80094e8 <HAL_TIMEx_ConfigCommutEvent_DMA+0x8c>)
 80094b8:	631a      	str	r2, [r3, #48]	; 0x30
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
 80094ba:	6802      	ldr	r2, [r0, #0]
 80094bc:	68d3      	ldr	r3, [r2, #12]
 80094be:	f023 0320 	bic.w	r3, r3, #32
 80094c2:	60d3      	str	r3, [r2, #12]
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
 80094c4:	6802      	ldr	r2, [r0, #0]
 80094c6:	68d3      	ldr	r3, [r2, #12]
 80094c8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80094cc:	60d3      	str	r3, [r2, #12]
  __HAL_UNLOCK(htim);
 80094ce:	2300      	movs	r3, #0
 80094d0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 80094d4:	4618      	mov	r0, r3
}
 80094d6:	bc10      	pop	{r4}
 80094d8:	4770      	bx	lr
  __HAL_LOCK(htim);
 80094da:	2002      	movs	r0, #2
}
 80094dc:	4770      	bx	lr
 80094de:	bf00      	nop
 80094e0:	080095ad 	.word	0x080095ad
 80094e4:	080095bf 	.word	0x080095bf
 80094e8:	08005a95 	.word	0x08005a95

080094ec <HAL_TIMEx_MasterConfigSynchronization>:
  __HAL_LOCK(htim);
 80094ec:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80094f0:	2b01      	cmp	r3, #1
 80094f2:	d02b      	beq.n	800954c <HAL_TIMEx_MasterConfigSynchronization+0x60>
{
 80094f4:	b430      	push	{r4, r5}
  __HAL_LOCK(htim);
 80094f6:	2301      	movs	r3, #1
 80094f8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 80094fc:	2302      	movs	r3, #2
 80094fe:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
 8009502:	6803      	ldr	r3, [r0, #0]
 8009504:	685c      	ldr	r4, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 8009506:	689d      	ldr	r5, [r3, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 8009508:	f024 0470 	bic.w	r4, r4, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800950c:	680a      	ldr	r2, [r1, #0]
 800950e:	4322      	orrs	r2, r4
  htim->Instance->CR2 = tmpcr2;
 8009510:	605a      	str	r2, [r3, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8009512:	6803      	ldr	r3, [r0, #0]
 8009514:	4a0e      	ldr	r2, [pc, #56]	; (8009550 <HAL_TIMEx_MasterConfigSynchronization+0x64>)
 8009516:	4293      	cmp	r3, r2
 8009518:	d00a      	beq.n	8009530 <HAL_TIMEx_MasterConfigSynchronization+0x44>
 800951a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800951e:	d007      	beq.n	8009530 <HAL_TIMEx_MasterConfigSynchronization+0x44>
 8009520:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8009524:	4293      	cmp	r3, r2
 8009526:	d003      	beq.n	8009530 <HAL_TIMEx_MasterConfigSynchronization+0x44>
 8009528:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800952c:	4293      	cmp	r3, r2
 800952e:	d104      	bne.n	800953a <HAL_TIMEx_MasterConfigSynchronization+0x4e>
    tmpsmcr &= ~TIM_SMCR_MSM;
 8009530:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8009534:	684a      	ldr	r2, [r1, #4]
 8009536:	4315      	orrs	r5, r2
    htim->Instance->SMCR = tmpsmcr;
 8009538:	609d      	str	r5, [r3, #8]
  htim->State = HAL_TIM_STATE_READY;
 800953a:	2301      	movs	r3, #1
 800953c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8009540:	2300      	movs	r3, #0
 8009542:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8009546:	4618      	mov	r0, r3
}
 8009548:	bc30      	pop	{r4, r5}
 800954a:	4770      	bx	lr
  __HAL_LOCK(htim);
 800954c:	2002      	movs	r0, #2
}
 800954e:	4770      	bx	lr
 8009550:	40012c00 	.word	0x40012c00

08009554 <HAL_TIMEx_ConfigBreakDeadTime>:
  __HAL_LOCK(htim);
 8009554:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009558:	2b01      	cmp	r3, #1
 800955a:	d022      	beq.n	80095a2 <HAL_TIMEx_ConfigBreakDeadTime+0x4e>
 800955c:	2301      	movs	r3, #1
 800955e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
 8009562:	68cb      	ldr	r3, [r1, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8009564:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8009568:	688a      	ldr	r2, [r1, #8]
 800956a:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 800956c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009570:	684a      	ldr	r2, [r1, #4]
 8009572:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8009574:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8009578:	680a      	ldr	r2, [r1, #0]
 800957a:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 800957c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009580:	690a      	ldr	r2, [r1, #16]
 8009582:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8009584:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009588:	694a      	ldr	r2, [r1, #20]
 800958a:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800958c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8009590:	69ca      	ldr	r2, [r1, #28]
 8009592:	4313      	orrs	r3, r2
  htim->Instance->BDTR = tmpbdtr;
 8009594:	6802      	ldr	r2, [r0, #0]
 8009596:	6453      	str	r3, [r2, #68]	; 0x44
  __HAL_UNLOCK(htim);
 8009598:	2300      	movs	r3, #0
 800959a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800959e:	4618      	mov	r0, r3
 80095a0:	4770      	bx	lr
  __HAL_LOCK(htim);
 80095a2:	2002      	movs	r0, #2
}
 80095a4:	4770      	bx	lr

080095a6 <HAL_TIMEx_RemapConfig>:
}
 80095a6:	2000      	movs	r0, #0
 80095a8:	4770      	bx	lr

080095aa <HAL_TIMEx_CommutCallback>:
}
 80095aa:	4770      	bx	lr

080095ac <TIMEx_DMACommutationCplt>:
{
 80095ac:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80095ae:	6a40      	ldr	r0, [r0, #36]	; 0x24
  htim->State = HAL_TIM_STATE_READY;
 80095b0:	2301      	movs	r3, #1
 80095b2:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  HAL_TIMEx_CommutCallback(htim);
 80095b6:	f7ff fff8 	bl	80095aa <HAL_TIMEx_CommutCallback>
}
 80095ba:	bd08      	pop	{r3, pc}

080095bc <HAL_TIMEx_CommutHalfCpltCallback>:
}
 80095bc:	4770      	bx	lr

080095be <TIMEx_DMACommutationHalfCplt>:
{
 80095be:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80095c0:	6a40      	ldr	r0, [r0, #36]	; 0x24
  htim->State = HAL_TIM_STATE_READY;
 80095c2:	2301      	movs	r3, #1
 80095c4:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  HAL_TIMEx_CommutHalfCpltCallback(htim);
 80095c8:	f7ff fff8 	bl	80095bc <HAL_TIMEx_CommutHalfCpltCallback>
}
 80095cc:	bd08      	pop	{r3, pc}

080095ce <HAL_TIMEx_BreakCallback>:
}
 80095ce:	4770      	bx	lr

080095d0 <HAL_TIMEx_HallSensor_GetState>:
  return htim->State;
 80095d0:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 80095d4:	4770      	bx	lr

080095d6 <HAL_TIMEx_GetChannelNState>:
  channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);
 80095d6:	b919      	cbnz	r1, 80095e0 <HAL_TIMEx_GetChannelNState+0xa>
 80095d8:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
 80095dc:	b2c0      	uxtb	r0, r0
 80095de:	4770      	bx	lr
 80095e0:	2904      	cmp	r1, #4
 80095e2:	d005      	beq.n	80095f0 <HAL_TIMEx_GetChannelNState+0x1a>
 80095e4:	2908      	cmp	r1, #8
 80095e6:	d007      	beq.n	80095f8 <HAL_TIMEx_GetChannelNState+0x22>
 80095e8:	f890 0045 	ldrb.w	r0, [r0, #69]	; 0x45
 80095ec:	b2c0      	uxtb	r0, r0
}
 80095ee:	4770      	bx	lr
  channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);
 80095f0:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
 80095f4:	b2c0      	uxtb	r0, r0
 80095f6:	4770      	bx	lr
 80095f8:	f890 0044 	ldrb.w	r0, [r0, #68]	; 0x44
 80095fc:	b2c0      	uxtb	r0, r0
 80095fe:	4770      	bx	lr

08009600 <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8009600:	6802      	ldr	r2, [r0, #0]
 8009602:	68d3      	ldr	r3, [r2, #12]
 8009604:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009608:	60d3      	str	r3, [r2, #12]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800960a:	2320      	movs	r3, #32
 800960c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8009610:	4770      	bx	lr

08009612 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8009612:	6802      	ldr	r2, [r0, #0]
 8009614:	68d3      	ldr	r3, [r2, #12]
 8009616:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800961a:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800961c:	6802      	ldr	r2, [r0, #0]
 800961e:	6953      	ldr	r3, [r2, #20]
 8009620:	f023 0301 	bic.w	r3, r3, #1
 8009624:	6153      	str	r3, [r2, #20]

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8009626:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8009628:	2b01      	cmp	r3, #1
 800962a:	d005      	beq.n	8009638 <UART_EndRxTransfer+0x26>
  {
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800962c:	2320      	movs	r3, #32
 800962e:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009632:	2300      	movs	r3, #0
 8009634:	6303      	str	r3, [r0, #48]	; 0x30
}
 8009636:	4770      	bx	lr
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8009638:	6802      	ldr	r2, [r0, #0]
 800963a:	68d3      	ldr	r3, [r2, #12]
 800963c:	f023 0310 	bic.w	r3, r3, #16
 8009640:	60d3      	str	r3, [r2, #12]
 8009642:	e7f3      	b.n	800962c <UART_EndRxTransfer+0x1a>

08009644 <UART_Transmit_IT>:
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8009644:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009648:	b2db      	uxtb	r3, r3
 800964a:	2b21      	cmp	r3, #33	; 0x21
 800964c:	d001      	beq.n	8009652 <UART_Transmit_IT+0xe>
    }
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800964e:	2002      	movs	r0, #2
  }
}
 8009650:	4770      	bx	lr
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8009652:	6883      	ldr	r3, [r0, #8]
 8009654:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009658:	d017      	beq.n	800968a <UART_Transmit_IT+0x46>
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 800965a:	6a03      	ldr	r3, [r0, #32]
 800965c:	1c5a      	adds	r2, r3, #1
 800965e:	6202      	str	r2, [r0, #32]
 8009660:	781a      	ldrb	r2, [r3, #0]
 8009662:	6803      	ldr	r3, [r0, #0]
 8009664:	605a      	str	r2, [r3, #4]
    if (--huart->TxXferCount == 0U)
 8009666:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 8009668:	b29b      	uxth	r3, r3
 800966a:	3b01      	subs	r3, #1
 800966c:	b29b      	uxth	r3, r3
 800966e:	84c3      	strh	r3, [r0, #38]	; 0x26
 8009670:	b94b      	cbnz	r3, 8009686 <UART_Transmit_IT+0x42>
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8009672:	6802      	ldr	r2, [r0, #0]
 8009674:	68d3      	ldr	r3, [r2, #12]
 8009676:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800967a:	60d3      	str	r3, [r2, #12]
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 800967c:	6802      	ldr	r2, [r0, #0]
 800967e:	68d3      	ldr	r3, [r2, #12]
 8009680:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009684:	60d3      	str	r3, [r2, #12]
    return HAL_OK;
 8009686:	2000      	movs	r0, #0
 8009688:	4770      	bx	lr
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800968a:	6903      	ldr	r3, [r0, #16]
 800968c:	2b00      	cmp	r3, #0
 800968e:	d1e4      	bne.n	800965a <UART_Transmit_IT+0x16>
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8009690:	6a03      	ldr	r3, [r0, #32]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8009692:	881b      	ldrh	r3, [r3, #0]
 8009694:	6802      	ldr	r2, [r0, #0]
 8009696:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800969a:	6053      	str	r3, [r2, #4]
      huart->pTxBuffPtr += 2U;
 800969c:	6a03      	ldr	r3, [r0, #32]
 800969e:	3302      	adds	r3, #2
 80096a0:	6203      	str	r3, [r0, #32]
 80096a2:	e7e0      	b.n	8009666 <UART_Transmit_IT+0x22>

080096a4 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80096a4:	b510      	push	{r4, lr}
 80096a6:	4604      	mov	r4, r0
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80096a8:	6802      	ldr	r2, [r0, #0]
 80096aa:	6913      	ldr	r3, [r2, #16]
 80096ac:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80096b0:	68c1      	ldr	r1, [r0, #12]
 80096b2:	430b      	orrs	r3, r1
 80096b4:	6113      	str	r3, [r2, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 80096b6:	6883      	ldr	r3, [r0, #8]
 80096b8:	6902      	ldr	r2, [r0, #16]
 80096ba:	4313      	orrs	r3, r2
 80096bc:	6942      	ldr	r2, [r0, #20]
 80096be:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1,
 80096c0:	6801      	ldr	r1, [r0, #0]
 80096c2:	68cb      	ldr	r3, [r1, #12]
 80096c4:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 80096c8:	f023 030c 	bic.w	r3, r3, #12
 80096cc:	4313      	orrs	r3, r2
 80096ce:	60cb      	str	r3, [r1, #12]
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80096d0:	6802      	ldr	r2, [r0, #0]
 80096d2:	6953      	ldr	r3, [r2, #20]
 80096d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80096d8:	6981      	ldr	r1, [r0, #24]
 80096da:	430b      	orrs	r3, r1
 80096dc:	6153      	str	r3, [r2, #20]


  if(huart->Instance == USART1)
 80096de:	6802      	ldr	r2, [r0, #0]
 80096e0:	4b12      	ldr	r3, [pc, #72]	; (800972c <UART_SetConfig+0x88>)
 80096e2:	429a      	cmp	r2, r3
 80096e4:	d01f      	beq.n	8009726 <UART_SetConfig+0x82>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 80096e6:	f7fb f8f5 	bl	80048d4 <HAL_RCC_GetPCLK1Freq>
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 80096ea:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 80096ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80096f2:	6862      	ldr	r2, [r4, #4]
 80096f4:	0092      	lsls	r2, r2, #2
 80096f6:	fbb3 f2f2 	udiv	r2, r3, r2
 80096fa:	480d      	ldr	r0, [pc, #52]	; (8009730 <UART_SetConfig+0x8c>)
 80096fc:	fba0 3102 	umull	r3, r1, r0, r2
 8009700:	0949      	lsrs	r1, r1, #5
 8009702:	2364      	movs	r3, #100	; 0x64
 8009704:	fb03 2311 	mls	r3, r3, r1, r2
 8009708:	011b      	lsls	r3, r3, #4
 800970a:	3332      	adds	r3, #50	; 0x32
 800970c:	fba0 2303 	umull	r2, r3, r0, r3
 8009710:	095b      	lsrs	r3, r3, #5
 8009712:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8009716:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800971a:	f003 030f 	and.w	r3, r3, #15
 800971e:	6821      	ldr	r1, [r4, #0]
 8009720:	4413      	add	r3, r2
 8009722:	608b      	str	r3, [r1, #8]
#endif /* USART_CR1_OVER8 */
}
 8009724:	bd10      	pop	{r4, pc}
    pclk = HAL_RCC_GetPCLK2Freq();
 8009726:	f7fb f8e5 	bl	80048f4 <HAL_RCC_GetPCLK2Freq>
 800972a:	e7de      	b.n	80096ea <UART_SetConfig+0x46>
 800972c:	40013800 	.word	0x40013800
 8009730:	51eb851f 	.word	0x51eb851f

08009734 <UART_WaitOnFlagUntilTimeout>:
{
 8009734:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009738:	4605      	mov	r5, r0
 800973a:	460f      	mov	r7, r1
 800973c:	4616      	mov	r6, r2
 800973e:	4699      	mov	r9, r3
 8009740:	f8dd 8020 	ldr.w	r8, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8009744:	682c      	ldr	r4, [r5, #0]
 8009746:	6824      	ldr	r4, [r4, #0]
 8009748:	ea37 0304 	bics.w	r3, r7, r4
 800974c:	bf0c      	ite	eq
 800974e:	2401      	moveq	r4, #1
 8009750:	2400      	movne	r4, #0
 8009752:	42b4      	cmp	r4, r6
 8009754:	d11f      	bne.n	8009796 <UART_WaitOnFlagUntilTimeout+0x62>
    if (Timeout != HAL_MAX_DELAY)
 8009756:	f1b8 3fff 	cmp.w	r8, #4294967295
 800975a:	d0f3      	beq.n	8009744 <UART_WaitOnFlagUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800975c:	f1b8 0f00 	cmp.w	r8, #0
 8009760:	d005      	beq.n	800976e <UART_WaitOnFlagUntilTimeout+0x3a>
 8009762:	f7f8 fbbb 	bl	8001edc <HAL_GetTick>
 8009766:	eba0 0009 	sub.w	r0, r0, r9
 800976a:	4540      	cmp	r0, r8
 800976c:	d9ea      	bls.n	8009744 <UART_WaitOnFlagUntilTimeout+0x10>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800976e:	682a      	ldr	r2, [r5, #0]
 8009770:	68d3      	ldr	r3, [r2, #12]
 8009772:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 8009776:	60d3      	str	r3, [r2, #12]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009778:	682a      	ldr	r2, [r5, #0]
 800977a:	6953      	ldr	r3, [r2, #20]
 800977c:	f023 0301 	bic.w	r3, r3, #1
 8009780:	6153      	str	r3, [r2, #20]
        huart->gState  = HAL_UART_STATE_READY;
 8009782:	2320      	movs	r3, #32
 8009784:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
        huart->RxState = HAL_UART_STATE_READY;
 8009788:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
        __HAL_UNLOCK(huart);
 800978c:	2300      	movs	r3, #0
 800978e:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
        return HAL_TIMEOUT;
 8009792:	2003      	movs	r0, #3
 8009794:	e000      	b.n	8009798 <UART_WaitOnFlagUntilTimeout+0x64>
  return HAL_OK;
 8009796:	2000      	movs	r0, #0
}
 8009798:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}
 800979c:	4770      	bx	lr

0800979e <HAL_UART_Init>:
  if (huart == NULL)
 800979e:	b358      	cbz	r0, 80097f8 <HAL_UART_Init+0x5a>
{
 80097a0:	b510      	push	{r4, lr}
 80097a2:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 80097a4:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80097a8:	b30b      	cbz	r3, 80097ee <HAL_UART_Init+0x50>
  huart->gState = HAL_UART_STATE_BUSY;
 80097aa:	2324      	movs	r3, #36	; 0x24
 80097ac:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 80097b0:	6822      	ldr	r2, [r4, #0]
 80097b2:	68d3      	ldr	r3, [r2, #12]
 80097b4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80097b8:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 80097ba:	4620      	mov	r0, r4
 80097bc:	f7ff ff72 	bl	80096a4 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80097c0:	6822      	ldr	r2, [r4, #0]
 80097c2:	6913      	ldr	r3, [r2, #16]
 80097c4:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80097c8:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80097ca:	6822      	ldr	r2, [r4, #0]
 80097cc:	6953      	ldr	r3, [r2, #20]
 80097ce:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 80097d2:	6153      	str	r3, [r2, #20]
  __HAL_UART_ENABLE(huart);
 80097d4:	6822      	ldr	r2, [r4, #0]
 80097d6:	68d3      	ldr	r3, [r2, #12]
 80097d8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80097dc:	60d3      	str	r3, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80097de:	2000      	movs	r0, #0
 80097e0:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 80097e2:	2320      	movs	r3, #32
 80097e4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 80097e8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 80097ec:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 80097ee:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 80097f2:	f7f8 f99d 	bl	8001b30 <HAL_UART_MspInit>
 80097f6:	e7d8      	b.n	80097aa <HAL_UART_Init+0xc>
    return HAL_ERROR;
 80097f8:	2001      	movs	r0, #1
}
 80097fa:	4770      	bx	lr

080097fc <HAL_HalfDuplex_Init>:
  if (huart == NULL)
 80097fc:	2800      	cmp	r0, #0
 80097fe:	d030      	beq.n	8009862 <HAL_HalfDuplex_Init+0x66>
{
 8009800:	b510      	push	{r4, lr}
 8009802:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 8009804:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009808:	b333      	cbz	r3, 8009858 <HAL_HalfDuplex_Init+0x5c>
  huart->gState = HAL_UART_STATE_BUSY;
 800980a:	2324      	movs	r3, #36	; 0x24
 800980c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 8009810:	6822      	ldr	r2, [r4, #0]
 8009812:	68d3      	ldr	r3, [r2, #12]
 8009814:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009818:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 800981a:	4620      	mov	r0, r4
 800981c:	f7ff ff42 	bl	80096a4 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8009820:	6822      	ldr	r2, [r4, #0]
 8009822:	6913      	ldr	r3, [r2, #16]
 8009824:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8009828:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
 800982a:	6822      	ldr	r2, [r4, #0]
 800982c:	6953      	ldr	r3, [r2, #20]
 800982e:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 8009832:	6153      	str	r3, [r2, #20]
  SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 8009834:	6822      	ldr	r2, [r4, #0]
 8009836:	6953      	ldr	r3, [r2, #20]
 8009838:	f043 0308 	orr.w	r3, r3, #8
 800983c:	6153      	str	r3, [r2, #20]
  __HAL_UART_ENABLE(huart);
 800983e:	6822      	ldr	r2, [r4, #0]
 8009840:	68d3      	ldr	r3, [r2, #12]
 8009842:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009846:	60d3      	str	r3, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009848:	2000      	movs	r0, #0
 800984a:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 800984c:	2320      	movs	r3, #32
 800984e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 8009852:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 8009856:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 8009858:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 800985c:	f7f8 f968 	bl	8001b30 <HAL_UART_MspInit>
 8009860:	e7d3      	b.n	800980a <HAL_HalfDuplex_Init+0xe>
    return HAL_ERROR;
 8009862:	2001      	movs	r0, #1
}
 8009864:	4770      	bx	lr

08009866 <HAL_LIN_Init>:
  if (huart == NULL)
 8009866:	2800      	cmp	r0, #0
 8009868:	d03b      	beq.n	80098e2 <HAL_LIN_Init+0x7c>
{
 800986a:	b538      	push	{r3, r4, r5, lr}
 800986c:	460d      	mov	r5, r1
 800986e:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 8009870:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009874:	2b00      	cmp	r3, #0
 8009876:	d02f      	beq.n	80098d8 <HAL_LIN_Init+0x72>
  huart->gState = HAL_UART_STATE_BUSY;
 8009878:	2324      	movs	r3, #36	; 0x24
 800987a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 800987e:	6822      	ldr	r2, [r4, #0]
 8009880:	68d3      	ldr	r3, [r2, #12]
 8009882:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009886:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8009888:	4620      	mov	r0, r4
 800988a:	f7ff ff0b 	bl	80096a4 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
 800988e:	6822      	ldr	r2, [r4, #0]
 8009890:	6913      	ldr	r3, [r2, #16]
 8009892:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8009896:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
 8009898:	6822      	ldr	r2, [r4, #0]
 800989a:	6953      	ldr	r3, [r2, #20]
 800989c:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 80098a0:	6153      	str	r3, [r2, #20]
  SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
 80098a2:	6822      	ldr	r2, [r4, #0]
 80098a4:	6913      	ldr	r3, [r2, #16]
 80098a6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80098aa:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
 80098ac:	6822      	ldr	r2, [r4, #0]
 80098ae:	6913      	ldr	r3, [r2, #16]
 80098b0:	f023 0320 	bic.w	r3, r3, #32
 80098b4:	6113      	str	r3, [r2, #16]
  SET_BIT(huart->Instance->CR2, BreakDetectLength);
 80098b6:	6823      	ldr	r3, [r4, #0]
 80098b8:	6919      	ldr	r1, [r3, #16]
 80098ba:	430d      	orrs	r5, r1
 80098bc:	611d      	str	r5, [r3, #16]
  __HAL_UART_ENABLE(huart);
 80098be:	6822      	ldr	r2, [r4, #0]
 80098c0:	68d3      	ldr	r3, [r2, #12]
 80098c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80098c6:	60d3      	str	r3, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80098c8:	2000      	movs	r0, #0
 80098ca:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 80098cc:	2320      	movs	r3, #32
 80098ce:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 80098d2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 80098d6:	bd38      	pop	{r3, r4, r5, pc}
    huart->Lock = HAL_UNLOCKED;
 80098d8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 80098dc:	f7f8 f928 	bl	8001b30 <HAL_UART_MspInit>
 80098e0:	e7ca      	b.n	8009878 <HAL_LIN_Init+0x12>
    return HAL_ERROR;
 80098e2:	2001      	movs	r0, #1
}
 80098e4:	4770      	bx	lr

080098e6 <HAL_MultiProcessor_Init>:
  if (huart == NULL)
 80098e6:	2800      	cmp	r0, #0
 80098e8:	d040      	beq.n	800996c <HAL_MultiProcessor_Init+0x86>
{
 80098ea:	b570      	push	{r4, r5, r6, lr}
 80098ec:	460d      	mov	r5, r1
 80098ee:	4616      	mov	r6, r2
 80098f0:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 80098f2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80098f6:	2b00      	cmp	r3, #0
 80098f8:	d033      	beq.n	8009962 <HAL_MultiProcessor_Init+0x7c>
  huart->gState = HAL_UART_STATE_BUSY;
 80098fa:	2324      	movs	r3, #36	; 0x24
 80098fc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 8009900:	6822      	ldr	r2, [r4, #0]
 8009902:	68d3      	ldr	r3, [r2, #12]
 8009904:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009908:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 800990a:	4620      	mov	r0, r4
 800990c:	f7ff feca 	bl	80096a4 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8009910:	6822      	ldr	r2, [r4, #0]
 8009912:	6913      	ldr	r3, [r2, #16]
 8009914:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8009918:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800991a:	6822      	ldr	r2, [r4, #0]
 800991c:	6953      	ldr	r3, [r2, #20]
 800991e:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8009922:	6153      	str	r3, [r2, #20]
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
 8009924:	6822      	ldr	r2, [r4, #0]
 8009926:	6913      	ldr	r3, [r2, #16]
 8009928:	f023 030f 	bic.w	r3, r3, #15
 800992c:	6113      	str	r3, [r2, #16]
  SET_BIT(huart->Instance->CR2, Address);
 800992e:	6823      	ldr	r3, [r4, #0]
 8009930:	6919      	ldr	r1, [r3, #16]
 8009932:	430d      	orrs	r5, r1
 8009934:	611d      	str	r5, [r3, #16]
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
 8009936:	6822      	ldr	r2, [r4, #0]
 8009938:	68d3      	ldr	r3, [r2, #12]
 800993a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800993e:	60d3      	str	r3, [r2, #12]
  SET_BIT(huart->Instance->CR1, WakeUpMethod);
 8009940:	6823      	ldr	r3, [r4, #0]
 8009942:	68da      	ldr	r2, [r3, #12]
 8009944:	4316      	orrs	r6, r2
 8009946:	60de      	str	r6, [r3, #12]
  __HAL_UART_ENABLE(huart);
 8009948:	6822      	ldr	r2, [r4, #0]
 800994a:	68d3      	ldr	r3, [r2, #12]
 800994c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009950:	60d3      	str	r3, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009952:	2000      	movs	r0, #0
 8009954:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 8009956:	2320      	movs	r3, #32
 8009958:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 800995c:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 8009960:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 8009962:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 8009966:	f7f8 f8e3 	bl	8001b30 <HAL_UART_MspInit>
 800996a:	e7c6      	b.n	80098fa <HAL_MultiProcessor_Init+0x14>
    return HAL_ERROR;
 800996c:	2001      	movs	r0, #1
}
 800996e:	4770      	bx	lr
}
 8009970:	4770      	bx	lr

08009972 <HAL_UART_DeInit>:
  if (huart == NULL)
 8009972:	b1a8      	cbz	r0, 80099a0 <HAL_UART_DeInit+0x2e>
{
 8009974:	b510      	push	{r4, lr}
 8009976:	4604      	mov	r4, r0
  huart->gState = HAL_UART_STATE_BUSY;
 8009978:	2324      	movs	r3, #36	; 0x24
 800997a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 800997e:	6802      	ldr	r2, [r0, #0]
 8009980:	68d3      	ldr	r3, [r2, #12]
 8009982:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009986:	60d3      	str	r3, [r2, #12]
  HAL_UART_MspDeInit(huart);
 8009988:	f7f8 f94e 	bl	8001c28 <HAL_UART_MspDeInit>
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800998c:	2000      	movs	r0, #0
 800998e:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_RESET;
 8009990:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_RESET;
 8009994:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009998:	6320      	str	r0, [r4, #48]	; 0x30
  __HAL_UNLOCK(huart);
 800999a:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 800999e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80099a0:	2001      	movs	r0, #1
}
 80099a2:	4770      	bx	lr

080099a4 <HAL_UART_Transmit>:
{
 80099a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80099a8:	b082      	sub	sp, #8
 80099aa:	461e      	mov	r6, r3
  if (huart->gState == HAL_UART_STATE_READY)
 80099ac:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80099b0:	b2db      	uxtb	r3, r3
 80099b2:	2b20      	cmp	r3, #32
 80099b4:	d154      	bne.n	8009a60 <HAL_UART_Transmit+0xbc>
 80099b6:	4604      	mov	r4, r0
 80099b8:	460d      	mov	r5, r1
 80099ba:	4690      	mov	r8, r2
    if ((pData == NULL) || (Size == 0U))
 80099bc:	2900      	cmp	r1, #0
 80099be:	d053      	beq.n	8009a68 <HAL_UART_Transmit+0xc4>
 80099c0:	2a00      	cmp	r2, #0
 80099c2:	d053      	beq.n	8009a6c <HAL_UART_Transmit+0xc8>
    __HAL_LOCK(huart);
 80099c4:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80099c8:	2b01      	cmp	r3, #1
 80099ca:	d051      	beq.n	8009a70 <HAL_UART_Transmit+0xcc>
 80099cc:	2301      	movs	r3, #1
 80099ce:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80099d2:	2300      	movs	r3, #0
 80099d4:	6403      	str	r3, [r0, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80099d6:	2321      	movs	r3, #33	; 0x21
 80099d8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    tickstart = HAL_GetTick();
 80099dc:	f7f8 fa7e 	bl	8001edc <HAL_GetTick>
 80099e0:	4607      	mov	r7, r0
    huart->TxXferSize = Size;
 80099e2:	f8a4 8024 	strh.w	r8, [r4, #36]	; 0x24
    huart->TxXferCount = Size;
 80099e6:	f8a4 8026 	strh.w	r8, [r4, #38]	; 0x26
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80099ea:	68a3      	ldr	r3, [r4, #8]
 80099ec:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80099f0:	d005      	beq.n	80099fe <HAL_UART_Transmit+0x5a>
      pdata16bits = NULL;
 80099f2:	f04f 0800 	mov.w	r8, #0
    __HAL_UNLOCK(huart);
 80099f6:	2300      	movs	r3, #0
 80099f8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    while (huart->TxXferCount > 0U)
 80099fc:	e012      	b.n	8009a24 <HAL_UART_Transmit+0x80>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80099fe:	6923      	ldr	r3, [r4, #16]
 8009a00:	b113      	cbz	r3, 8009a08 <HAL_UART_Transmit+0x64>
      pdata16bits = NULL;
 8009a02:	f04f 0800 	mov.w	r8, #0
 8009a06:	e7f6      	b.n	80099f6 <HAL_UART_Transmit+0x52>
      pdata16bits = (uint16_t *) pData;
 8009a08:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 8009a0a:	2500      	movs	r5, #0
 8009a0c:	e7f3      	b.n	80099f6 <HAL_UART_Transmit+0x52>
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 8009a0e:	f838 3b02 	ldrh.w	r3, [r8], #2
 8009a12:	6822      	ldr	r2, [r4, #0]
 8009a14:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009a18:	6053      	str	r3, [r2, #4]
      huart->TxXferCount--;
 8009a1a:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8009a1c:	b292      	uxth	r2, r2
 8009a1e:	3a01      	subs	r2, #1
 8009a20:	b292      	uxth	r2, r2
 8009a22:	84e2      	strh	r2, [r4, #38]	; 0x26
    while (huart->TxXferCount > 0U)
 8009a24:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 8009a26:	b29b      	uxth	r3, r3
 8009a28:	b173      	cbz	r3, 8009a48 <HAL_UART_Transmit+0xa4>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8009a2a:	9600      	str	r6, [sp, #0]
 8009a2c:	463b      	mov	r3, r7
 8009a2e:	2200      	movs	r2, #0
 8009a30:	2180      	movs	r1, #128	; 0x80
 8009a32:	4620      	mov	r0, r4
 8009a34:	f7ff fe7e 	bl	8009734 <UART_WaitOnFlagUntilTimeout>
 8009a38:	b9e0      	cbnz	r0, 8009a74 <HAL_UART_Transmit+0xd0>
      if (pdata8bits == NULL)
 8009a3a:	2d00      	cmp	r5, #0
 8009a3c:	d0e7      	beq.n	8009a0e <HAL_UART_Transmit+0x6a>
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 8009a3e:	f815 2b01 	ldrb.w	r2, [r5], #1
 8009a42:	6823      	ldr	r3, [r4, #0]
 8009a44:	605a      	str	r2, [r3, #4]
        pdata8bits++;
 8009a46:	e7e8      	b.n	8009a1a <HAL_UART_Transmit+0x76>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8009a48:	9600      	str	r6, [sp, #0]
 8009a4a:	463b      	mov	r3, r7
 8009a4c:	2200      	movs	r2, #0
 8009a4e:	2140      	movs	r1, #64	; 0x40
 8009a50:	4620      	mov	r0, r4
 8009a52:	f7ff fe6f 	bl	8009734 <UART_WaitOnFlagUntilTimeout>
 8009a56:	b978      	cbnz	r0, 8009a78 <HAL_UART_Transmit+0xd4>
    huart->gState = HAL_UART_STATE_READY;
 8009a58:	2320      	movs	r3, #32
 8009a5a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    return HAL_OK;
 8009a5e:	e000      	b.n	8009a62 <HAL_UART_Transmit+0xbe>
    return HAL_BUSY;
 8009a60:	2002      	movs	r0, #2
}
 8009a62:	b002      	add	sp, #8
 8009a64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 8009a68:	2001      	movs	r0, #1
 8009a6a:	e7fa      	b.n	8009a62 <HAL_UART_Transmit+0xbe>
 8009a6c:	2001      	movs	r0, #1
 8009a6e:	e7f8      	b.n	8009a62 <HAL_UART_Transmit+0xbe>
    __HAL_LOCK(huart);
 8009a70:	2002      	movs	r0, #2
 8009a72:	e7f6      	b.n	8009a62 <HAL_UART_Transmit+0xbe>
        return HAL_TIMEOUT;
 8009a74:	2003      	movs	r0, #3
 8009a76:	e7f4      	b.n	8009a62 <HAL_UART_Transmit+0xbe>
      return HAL_TIMEOUT;
 8009a78:	2003      	movs	r0, #3
 8009a7a:	e7f2      	b.n	8009a62 <HAL_UART_Transmit+0xbe>

08009a7c <HAL_UART_Receive>:
{
 8009a7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009a80:	b082      	sub	sp, #8
 8009a82:	461e      	mov	r6, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 8009a84:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8009a88:	b2db      	uxtb	r3, r3
 8009a8a:	2b20      	cmp	r3, #32
 8009a8c:	d15c      	bne.n	8009b48 <HAL_UART_Receive+0xcc>
 8009a8e:	4604      	mov	r4, r0
 8009a90:	460d      	mov	r5, r1
 8009a92:	4690      	mov	r8, r2
    if ((pData == NULL) || (Size == 0U))
 8009a94:	2900      	cmp	r1, #0
 8009a96:	d05b      	beq.n	8009b50 <HAL_UART_Receive+0xd4>
 8009a98:	2a00      	cmp	r2, #0
 8009a9a:	d05b      	beq.n	8009b54 <HAL_UART_Receive+0xd8>
    __HAL_LOCK(huart);
 8009a9c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009aa0:	2b01      	cmp	r3, #1
 8009aa2:	d059      	beq.n	8009b58 <HAL_UART_Receive+0xdc>
 8009aa4:	2301      	movs	r3, #1
 8009aa6:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009aaa:	2300      	movs	r3, #0
 8009aac:	6403      	str	r3, [r0, #64]	; 0x40
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8009aae:	2222      	movs	r2, #34	; 0x22
 8009ab0:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009ab4:	6303      	str	r3, [r0, #48]	; 0x30
    tickstart = HAL_GetTick();
 8009ab6:	f7f8 fa11 	bl	8001edc <HAL_GetTick>
 8009aba:	4607      	mov	r7, r0
    huart->RxXferSize = Size;
 8009abc:	f8a4 802c 	strh.w	r8, [r4, #44]	; 0x2c
    huart->RxXferCount = Size;
 8009ac0:	f8a4 802e 	strh.w	r8, [r4, #46]	; 0x2e
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8009ac4:	68a3      	ldr	r3, [r4, #8]
 8009ac6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009aca:	d005      	beq.n	8009ad8 <HAL_UART_Receive+0x5c>
      pdata16bits = NULL;
 8009acc:	f04f 0800 	mov.w	r8, #0
    __HAL_UNLOCK(huart);
 8009ad0:	2300      	movs	r3, #0
 8009ad2:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    while (huart->RxXferCount > 0U)
 8009ad6:	e017      	b.n	8009b08 <HAL_UART_Receive+0x8c>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8009ad8:	6923      	ldr	r3, [r4, #16]
 8009ada:	b113      	cbz	r3, 8009ae2 <HAL_UART_Receive+0x66>
      pdata16bits = NULL;
 8009adc:	f04f 0800 	mov.w	r8, #0
 8009ae0:	e7f6      	b.n	8009ad0 <HAL_UART_Receive+0x54>
      pdata16bits = (uint16_t *) pData;
 8009ae2:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 8009ae4:	2500      	movs	r5, #0
 8009ae6:	e7f3      	b.n	8009ad0 <HAL_UART_Receive+0x54>
        *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
 8009ae8:	6823      	ldr	r3, [r4, #0]
 8009aea:	685b      	ldr	r3, [r3, #4]
 8009aec:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009af0:	f828 3b02 	strh.w	r3, [r8], #2
        pdata16bits++;
 8009af4:	e003      	b.n	8009afe <HAL_UART_Receive+0x82>
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8009af6:	6823      	ldr	r3, [r4, #0]
 8009af8:	685b      	ldr	r3, [r3, #4]
 8009afa:	702b      	strb	r3, [r5, #0]
        pdata8bits++;
 8009afc:	3501      	adds	r5, #1
      huart->RxXferCount--;
 8009afe:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 8009b00:	b292      	uxth	r2, r2
 8009b02:	3a01      	subs	r2, #1
 8009b04:	b292      	uxth	r2, r2
 8009b06:	85e2      	strh	r2, [r4, #46]	; 0x2e
    while (huart->RxXferCount > 0U)
 8009b08:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8009b0a:	b29b      	uxth	r3, r3
 8009b0c:	b1bb      	cbz	r3, 8009b3e <HAL_UART_Receive+0xc2>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8009b0e:	9600      	str	r6, [sp, #0]
 8009b10:	463b      	mov	r3, r7
 8009b12:	2200      	movs	r2, #0
 8009b14:	2120      	movs	r1, #32
 8009b16:	4620      	mov	r0, r4
 8009b18:	f7ff fe0c 	bl	8009734 <UART_WaitOnFlagUntilTimeout>
 8009b1c:	b9f0      	cbnz	r0, 8009b5c <HAL_UART_Receive+0xe0>
      if (pdata8bits == NULL)
 8009b1e:	2d00      	cmp	r5, #0
 8009b20:	d0e2      	beq.n	8009ae8 <HAL_UART_Receive+0x6c>
        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8009b22:	68a3      	ldr	r3, [r4, #8]
 8009b24:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009b28:	d0e5      	beq.n	8009af6 <HAL_UART_Receive+0x7a>
 8009b2a:	b913      	cbnz	r3, 8009b32 <HAL_UART_Receive+0xb6>
 8009b2c:	6923      	ldr	r3, [r4, #16]
 8009b2e:	2b00      	cmp	r3, #0
 8009b30:	d0e1      	beq.n	8009af6 <HAL_UART_Receive+0x7a>
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8009b32:	6823      	ldr	r3, [r4, #0]
 8009b34:	685b      	ldr	r3, [r3, #4]
 8009b36:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009b3a:	702b      	strb	r3, [r5, #0]
 8009b3c:	e7de      	b.n	8009afc <HAL_UART_Receive+0x80>
    huart->RxState = HAL_UART_STATE_READY;
 8009b3e:	2320      	movs	r3, #32
 8009b40:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    return HAL_OK;
 8009b44:	2000      	movs	r0, #0
 8009b46:	e000      	b.n	8009b4a <HAL_UART_Receive+0xce>
    return HAL_BUSY;
 8009b48:	2002      	movs	r0, #2
}
 8009b4a:	b002      	add	sp, #8
 8009b4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 8009b50:	2001      	movs	r0, #1
 8009b52:	e7fa      	b.n	8009b4a <HAL_UART_Receive+0xce>
 8009b54:	2001      	movs	r0, #1
 8009b56:	e7f8      	b.n	8009b4a <HAL_UART_Receive+0xce>
    __HAL_LOCK(huart);
 8009b58:	2002      	movs	r0, #2
 8009b5a:	e7f6      	b.n	8009b4a <HAL_UART_Receive+0xce>
        return HAL_TIMEOUT;
 8009b5c:	2003      	movs	r0, #3
 8009b5e:	e7f4      	b.n	8009b4a <HAL_UART_Receive+0xce>

08009b60 <HAL_UART_Transmit_IT>:
  if (huart->gState == HAL_UART_STATE_READY)
 8009b60:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009b64:	b2db      	uxtb	r3, r3
 8009b66:	2b20      	cmp	r3, #32
 8009b68:	d116      	bne.n	8009b98 <HAL_UART_Transmit_IT+0x38>
    if ((pData == NULL) || (Size == 0U))
 8009b6a:	b1b9      	cbz	r1, 8009b9c <HAL_UART_Transmit_IT+0x3c>
 8009b6c:	b1c2      	cbz	r2, 8009ba0 <HAL_UART_Transmit_IT+0x40>
    __HAL_LOCK(huart);
 8009b6e:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009b72:	2b01      	cmp	r3, #1
 8009b74:	d016      	beq.n	8009ba4 <HAL_UART_Transmit_IT+0x44>
    huart->pTxBuffPtr = pData;
 8009b76:	6201      	str	r1, [r0, #32]
    huart->TxXferSize = Size;
 8009b78:	8482      	strh	r2, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 8009b7a:	84c2      	strh	r2, [r0, #38]	; 0x26
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009b7c:	2300      	movs	r3, #0
 8009b7e:	6403      	str	r3, [r0, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8009b80:	2221      	movs	r2, #33	; 0x21
 8009b82:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    __HAL_UNLOCK(huart);
 8009b86:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
 8009b8a:	6801      	ldr	r1, [r0, #0]
 8009b8c:	68ca      	ldr	r2, [r1, #12]
 8009b8e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009b92:	60ca      	str	r2, [r1, #12]
    return HAL_OK;
 8009b94:	4618      	mov	r0, r3
 8009b96:	4770      	bx	lr
    return HAL_BUSY;
 8009b98:	2002      	movs	r0, #2
 8009b9a:	4770      	bx	lr
      return HAL_ERROR;
 8009b9c:	2001      	movs	r0, #1
 8009b9e:	4770      	bx	lr
 8009ba0:	2001      	movs	r0, #1
 8009ba2:	4770      	bx	lr
    __HAL_LOCK(huart);
 8009ba4:	2002      	movs	r0, #2
}
 8009ba6:	4770      	bx	lr

08009ba8 <HAL_UART_Transmit_DMA>:
{
 8009ba8:	b538      	push	{r3, r4, r5, lr}
  if (huart->gState == HAL_UART_STATE_READY)
 8009baa:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009bae:	b2db      	uxtb	r3, r3
 8009bb0:	2b20      	cmp	r3, #32
 8009bb2:	d131      	bne.n	8009c18 <HAL_UART_Transmit_DMA+0x70>
 8009bb4:	4604      	mov	r4, r0
    if ((pData == NULL) || (Size == 0U))
 8009bb6:	2900      	cmp	r1, #0
 8009bb8:	d030      	beq.n	8009c1c <HAL_UART_Transmit_DMA+0x74>
 8009bba:	2a00      	cmp	r2, #0
 8009bbc:	d030      	beq.n	8009c20 <HAL_UART_Transmit_DMA+0x78>
    __HAL_LOCK(huart);
 8009bbe:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009bc2:	2b01      	cmp	r3, #1
 8009bc4:	d02e      	beq.n	8009c24 <HAL_UART_Transmit_DMA+0x7c>
 8009bc6:	2301      	movs	r3, #1
 8009bc8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->pTxBuffPtr = pData;
 8009bcc:	6201      	str	r1, [r0, #32]
    huart->TxXferSize = Size;
 8009bce:	8482      	strh	r2, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 8009bd0:	84c2      	strh	r2, [r0, #38]	; 0x26
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009bd2:	2500      	movs	r5, #0
 8009bd4:	6405      	str	r5, [r0, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8009bd6:	2321      	movs	r3, #33	; 0x21
 8009bd8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8009bdc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8009bde:	4812      	ldr	r0, [pc, #72]	; (8009c28 <HAL_UART_Transmit_DMA+0x80>)
 8009be0:	6298      	str	r0, [r3, #40]	; 0x28
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8009be2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009be4:	4811      	ldr	r0, [pc, #68]	; (8009c2c <HAL_UART_Transmit_DMA+0x84>)
 8009be6:	62d8      	str	r0, [r3, #44]	; 0x2c
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 8009be8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009bea:	4811      	ldr	r0, [pc, #68]	; (8009c30 <HAL_UART_Transmit_DMA+0x88>)
 8009bec:	6318      	str	r0, [r3, #48]	; 0x30
    huart->hdmatx->XferAbortCallback = NULL;
 8009bee:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009bf0:	635d      	str	r5, [r3, #52]	; 0x34
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 8009bf2:	6820      	ldr	r0, [r4, #0]
 8009bf4:	4613      	mov	r3, r2
 8009bf6:	1d02      	adds	r2, r0, #4
 8009bf8:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8009bfa:	f7f9 fe31 	bl	8003860 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8009bfe:	6823      	ldr	r3, [r4, #0]
 8009c00:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009c04:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(huart);
 8009c06:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8009c0a:	6822      	ldr	r2, [r4, #0]
 8009c0c:	6953      	ldr	r3, [r2, #20]
 8009c0e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009c12:	6153      	str	r3, [r2, #20]
    return HAL_OK;
 8009c14:	4628      	mov	r0, r5
 8009c16:	e000      	b.n	8009c1a <HAL_UART_Transmit_DMA+0x72>
    return HAL_BUSY;
 8009c18:	2002      	movs	r0, #2
}
 8009c1a:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 8009c1c:	2001      	movs	r0, #1
 8009c1e:	e7fc      	b.n	8009c1a <HAL_UART_Transmit_DMA+0x72>
 8009c20:	2001      	movs	r0, #1
 8009c22:	e7fa      	b.n	8009c1a <HAL_UART_Transmit_DMA+0x72>
    __HAL_LOCK(huart);
 8009c24:	2002      	movs	r0, #2
 8009c26:	e7f8      	b.n	8009c1a <HAL_UART_Transmit_DMA+0x72>
 8009c28:	0800a01b 	.word	0x0800a01b
 8009c2c:	0800a067 	.word	0x0800a067
 8009c30:	0800a077 	.word	0x0800a077

08009c34 <HAL_UART_DMAPause>:
  __HAL_LOCK(huart);
 8009c34:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009c38:	2b01      	cmp	r3, #1
 8009c3a:	d031      	beq.n	8009ca0 <HAL_UART_DMAPause+0x6c>
 8009c3c:	2301      	movs	r3, #1
 8009c3e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8009c42:	6801      	ldr	r1, [r0, #0]
 8009c44:	694a      	ldr	r2, [r1, #20]
 8009c46:	f002 0280 	and.w	r2, r2, #128	; 0x80
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8009c4a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009c4e:	b2db      	uxtb	r3, r3
 8009c50:	2b21      	cmp	r3, #33	; 0x21
 8009c52:	d00d      	beq.n	8009c70 <HAL_UART_DMAPause+0x3c>
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8009c54:	6801      	ldr	r1, [r0, #0]
 8009c56:	694a      	ldr	r2, [r1, #20]
 8009c58:	f002 0240 	and.w	r2, r2, #64	; 0x40
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8009c5c:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8009c60:	b2db      	uxtb	r3, r3
 8009c62:	2b22      	cmp	r3, #34	; 0x22
 8009c64:	d00b      	beq.n	8009c7e <HAL_UART_DMAPause+0x4a>
  __HAL_UNLOCK(huart);
 8009c66:	2300      	movs	r3, #0
 8009c68:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8009c6c:	4618      	mov	r0, r3
 8009c6e:	4770      	bx	lr
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8009c70:	2a00      	cmp	r2, #0
 8009c72:	d0ef      	beq.n	8009c54 <HAL_UART_DMAPause+0x20>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8009c74:	694b      	ldr	r3, [r1, #20]
 8009c76:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009c7a:	614b      	str	r3, [r1, #20]
 8009c7c:	e7ea      	b.n	8009c54 <HAL_UART_DMAPause+0x20>
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8009c7e:	2a00      	cmp	r2, #0
 8009c80:	d0f1      	beq.n	8009c66 <HAL_UART_DMAPause+0x32>
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8009c82:	68cb      	ldr	r3, [r1, #12]
 8009c84:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8009c88:	60cb      	str	r3, [r1, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009c8a:	6802      	ldr	r2, [r0, #0]
 8009c8c:	6953      	ldr	r3, [r2, #20]
 8009c8e:	f023 0301 	bic.w	r3, r3, #1
 8009c92:	6153      	str	r3, [r2, #20]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8009c94:	6802      	ldr	r2, [r0, #0]
 8009c96:	6953      	ldr	r3, [r2, #20]
 8009c98:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009c9c:	6153      	str	r3, [r2, #20]
 8009c9e:	e7e2      	b.n	8009c66 <HAL_UART_DMAPause+0x32>
  __HAL_LOCK(huart);
 8009ca0:	2002      	movs	r0, #2
}
 8009ca2:	4770      	bx	lr

08009ca4 <HAL_UART_DMAResume>:
  __HAL_LOCK(huart);
 8009ca4:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009ca8:	2b01      	cmp	r3, #1
 8009caa:	d034      	beq.n	8009d16 <HAL_UART_DMAResume+0x72>
 8009cac:	2301      	movs	r3, #1
 8009cae:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8009cb2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009cb6:	b2db      	uxtb	r3, r3
 8009cb8:	2b21      	cmp	r3, #33	; 0x21
 8009cba:	d009      	beq.n	8009cd0 <HAL_UART_DMAResume+0x2c>
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8009cbc:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8009cc0:	b2db      	uxtb	r3, r3
 8009cc2:	2b22      	cmp	r3, #34	; 0x22
 8009cc4:	d00a      	beq.n	8009cdc <HAL_UART_DMAResume+0x38>
  __HAL_UNLOCK(huart);
 8009cc6:	2300      	movs	r3, #0
 8009cc8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8009ccc:	4618      	mov	r0, r3
}
 8009cce:	4770      	bx	lr
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8009cd0:	6802      	ldr	r2, [r0, #0]
 8009cd2:	6953      	ldr	r3, [r2, #20]
 8009cd4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009cd8:	6153      	str	r3, [r2, #20]
 8009cda:	e7ef      	b.n	8009cbc <HAL_UART_DMAResume+0x18>
{
 8009cdc:	b082      	sub	sp, #8
    __HAL_UART_CLEAR_OREFLAG(huart);
 8009cde:	2300      	movs	r3, #0
 8009ce0:	9301      	str	r3, [sp, #4]
 8009ce2:	6803      	ldr	r3, [r0, #0]
 8009ce4:	681a      	ldr	r2, [r3, #0]
 8009ce6:	9201      	str	r2, [sp, #4]
 8009ce8:	685a      	ldr	r2, [r3, #4]
 8009cea:	9201      	str	r2, [sp, #4]
 8009cec:	9a01      	ldr	r2, [sp, #4]
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8009cee:	68da      	ldr	r2, [r3, #12]
 8009cf0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009cf4:	60da      	str	r2, [r3, #12]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009cf6:	6802      	ldr	r2, [r0, #0]
 8009cf8:	6953      	ldr	r3, [r2, #20]
 8009cfa:	f043 0301 	orr.w	r3, r3, #1
 8009cfe:	6153      	str	r3, [r2, #20]
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8009d00:	6802      	ldr	r2, [r0, #0]
 8009d02:	6953      	ldr	r3, [r2, #20]
 8009d04:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009d08:	6153      	str	r3, [r2, #20]
  __HAL_UNLOCK(huart);
 8009d0a:	2300      	movs	r3, #0
 8009d0c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8009d10:	4618      	mov	r0, r3
}
 8009d12:	b002      	add	sp, #8
 8009d14:	4770      	bx	lr
  __HAL_LOCK(huart);
 8009d16:	2002      	movs	r0, #2
 8009d18:	4770      	bx	lr

08009d1a <HAL_UART_DMAStop>:
{
 8009d1a:	b510      	push	{r4, lr}
 8009d1c:	4604      	mov	r4, r0
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8009d1e:	6801      	ldr	r1, [r0, #0]
 8009d20:	694a      	ldr	r2, [r1, #20]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8009d22:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009d26:	b2db      	uxtb	r3, r3
 8009d28:	2b21      	cmp	r3, #33	; 0x21
 8009d2a:	d00a      	beq.n	8009d42 <HAL_UART_DMAStop+0x28>
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8009d2c:	6821      	ldr	r1, [r4, #0]
 8009d2e:	694a      	ldr	r2, [r1, #20]
 8009d30:	f002 0240 	and.w	r2, r2, #64	; 0x40
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8009d34:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8009d38:	b2db      	uxtb	r3, r3
 8009d3a:	2b22      	cmp	r3, #34	; 0x22
 8009d3c:	d011      	beq.n	8009d62 <HAL_UART_DMAStop+0x48>
}
 8009d3e:	2000      	movs	r0, #0
 8009d40:	bd10      	pop	{r4, pc}
 8009d42:	f002 0280 	and.w	r2, r2, #128	; 0x80
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8009d46:	2a00      	cmp	r2, #0
 8009d48:	d0f0      	beq.n	8009d2c <HAL_UART_DMAStop+0x12>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8009d4a:	694b      	ldr	r3, [r1, #20]
 8009d4c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009d50:	614b      	str	r3, [r1, #20]
    if (huart->hdmatx != NULL)
 8009d52:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8009d54:	b108      	cbz	r0, 8009d5a <HAL_UART_DMAStop+0x40>
      HAL_DMA_Abort(huart->hdmatx);
 8009d56:	f7f9 fdbd 	bl	80038d4 <HAL_DMA_Abort>
    UART_EndTxTransfer(huart);
 8009d5a:	4620      	mov	r0, r4
 8009d5c:	f7ff fc50 	bl	8009600 <UART_EndTxTransfer>
 8009d60:	e7e4      	b.n	8009d2c <HAL_UART_DMAStop+0x12>
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8009d62:	2a00      	cmp	r2, #0
 8009d64:	d0eb      	beq.n	8009d3e <HAL_UART_DMAStop+0x24>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8009d66:	694b      	ldr	r3, [r1, #20]
 8009d68:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009d6c:	614b      	str	r3, [r1, #20]
    if (huart->hdmarx != NULL)
 8009d6e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8009d70:	b108      	cbz	r0, 8009d76 <HAL_UART_DMAStop+0x5c>
      HAL_DMA_Abort(huart->hdmarx);
 8009d72:	f7f9 fdaf 	bl	80038d4 <HAL_DMA_Abort>
    UART_EndRxTransfer(huart);
 8009d76:	4620      	mov	r0, r4
 8009d78:	f7ff fc4b 	bl	8009612 <UART_EndRxTransfer>
 8009d7c:	e7df      	b.n	8009d3e <HAL_UART_DMAStop+0x24>

08009d7e <HAL_UARTEx_ReceiveToIdle>:
{
 8009d7e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009d82:	b083      	sub	sp, #12
 8009d84:	461e      	mov	r6, r3
 8009d86:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  if (huart->RxState == HAL_UART_STATE_READY)
 8009d88:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8009d8c:	b2db      	uxtb	r3, r3
 8009d8e:	2b20      	cmp	r3, #32
 8009d90:	f040 8087 	bne.w	8009ea2 <HAL_UARTEx_ReceiveToIdle+0x124>
 8009d94:	4604      	mov	r4, r0
 8009d96:	460d      	mov	r5, r1
 8009d98:	4691      	mov	r9, r2
    if ((pData == NULL) || (Size == 0U))
 8009d9a:	2900      	cmp	r1, #0
 8009d9c:	f000 8085 	beq.w	8009eaa <HAL_UARTEx_ReceiveToIdle+0x12c>
 8009da0:	2a00      	cmp	r2, #0
 8009da2:	f000 8084 	beq.w	8009eae <HAL_UARTEx_ReceiveToIdle+0x130>
    __HAL_LOCK(huart);
 8009da6:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009daa:	2b01      	cmp	r3, #1
 8009dac:	f000 8081 	beq.w	8009eb2 <HAL_UARTEx_ReceiveToIdle+0x134>
 8009db0:	2301      	movs	r3, #1
 8009db2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009db6:	2200      	movs	r2, #0
 8009db8:	6402      	str	r2, [r0, #64]	; 0x40
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8009dba:	2222      	movs	r2, #34	; 0x22
 8009dbc:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
 8009dc0:	6303      	str	r3, [r0, #48]	; 0x30
    tickstart = HAL_GetTick();
 8009dc2:	f7f8 f88b 	bl	8001edc <HAL_GetTick>
 8009dc6:	4680      	mov	r8, r0
    huart->RxXferSize  = Size;
 8009dc8:	f8a4 902c 	strh.w	r9, [r4, #44]	; 0x2c
    huart->RxXferCount = Size;
 8009dcc:	f8a4 902e 	strh.w	r9, [r4, #46]	; 0x2e
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8009dd0:	68a3      	ldr	r3, [r4, #8]
 8009dd2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009dd6:	d006      	beq.n	8009de6 <HAL_UARTEx_ReceiveToIdle+0x68>
      pdata16bits = NULL;
 8009dd8:	f04f 0900 	mov.w	r9, #0
    __HAL_UNLOCK(huart);
 8009ddc:	2300      	movs	r3, #0
 8009dde:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    *RxLen = 0U;
 8009de2:	8033      	strh	r3, [r6, #0]
    while (huart->RxXferCount > 0U)
 8009de4:	e020      	b.n	8009e28 <HAL_UARTEx_ReceiveToIdle+0xaa>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8009de6:	6923      	ldr	r3, [r4, #16]
 8009de8:	b113      	cbz	r3, 8009df0 <HAL_UARTEx_ReceiveToIdle+0x72>
      pdata16bits = NULL;
 8009dea:	f04f 0900 	mov.w	r9, #0
 8009dee:	e7f5      	b.n	8009ddc <HAL_UARTEx_ReceiveToIdle+0x5e>
      pdata16bits = (uint16_t *) pData;
 8009df0:	46a9      	mov	r9, r5
      pdata8bits  = NULL;
 8009df2:	2500      	movs	r5, #0
 8009df4:	e7f2      	b.n	8009ddc <HAL_UARTEx_ReceiveToIdle+0x5e>
          huart->RxState = HAL_UART_STATE_READY;
 8009df6:	2320      	movs	r3, #32
 8009df8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
          return HAL_OK;
 8009dfc:	2000      	movs	r0, #0
 8009dfe:	e051      	b.n	8009ea4 <HAL_UARTEx_ReceiveToIdle+0x126>
          *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8009e00:	6853      	ldr	r3, [r2, #4]
 8009e02:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009e06:	f829 3b02 	strh.w	r3, [r9], #2
          pdata16bits++;
 8009e0a:	e002      	b.n	8009e12 <HAL_UARTEx_ReceiveToIdle+0x94>
             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8009e0c:	6853      	ldr	r3, [r2, #4]
 8009e0e:	702b      	strb	r3, [r5, #0]
          pdata8bits++;
 8009e10:	3501      	adds	r5, #1
        *RxLen += 1U;
 8009e12:	8833      	ldrh	r3, [r6, #0]
 8009e14:	3301      	adds	r3, #1
 8009e16:	8033      	strh	r3, [r6, #0]
        huart->RxXferCount--;
 8009e18:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8009e1a:	b29b      	uxth	r3, r3
 8009e1c:	3b01      	subs	r3, #1
 8009e1e:	b29b      	uxth	r3, r3
 8009e20:	85e3      	strh	r3, [r4, #46]	; 0x2e
      if (Timeout != HAL_MAX_DELAY)
 8009e22:	f1b7 3fff 	cmp.w	r7, #4294967295
 8009e26:	d125      	bne.n	8009e74 <HAL_UARTEx_ReceiveToIdle+0xf6>
    while (huart->RxXferCount > 0U)
 8009e28:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 8009e2a:	b292      	uxth	r2, r2
 8009e2c:	2a00      	cmp	r2, #0
 8009e2e:	d02e      	beq.n	8009e8e <HAL_UARTEx_ReceiveToIdle+0x110>
      if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
 8009e30:	6822      	ldr	r2, [r4, #0]
 8009e32:	6813      	ldr	r3, [r2, #0]
 8009e34:	f013 0f10 	tst.w	r3, #16
 8009e38:	d009      	beq.n	8009e4e <HAL_UARTEx_ReceiveToIdle+0xd0>
        __HAL_UART_CLEAR_IDLEFLAG(huart);
 8009e3a:	2300      	movs	r3, #0
 8009e3c:	9301      	str	r3, [sp, #4]
 8009e3e:	6813      	ldr	r3, [r2, #0]
 8009e40:	9301      	str	r3, [sp, #4]
 8009e42:	6853      	ldr	r3, [r2, #4]
 8009e44:	9301      	str	r3, [sp, #4]
 8009e46:	9b01      	ldr	r3, [sp, #4]
        if (*RxLen > 0U)
 8009e48:	8833      	ldrh	r3, [r6, #0]
 8009e4a:	2b00      	cmp	r3, #0
 8009e4c:	d1d3      	bne.n	8009df6 <HAL_UARTEx_ReceiveToIdle+0x78>
      if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
 8009e4e:	6813      	ldr	r3, [r2, #0]
 8009e50:	f013 0f20 	tst.w	r3, #32
 8009e54:	d0e5      	beq.n	8009e22 <HAL_UARTEx_ReceiveToIdle+0xa4>
        if (pdata8bits == NULL)
 8009e56:	2d00      	cmp	r5, #0
 8009e58:	d0d2      	beq.n	8009e00 <HAL_UARTEx_ReceiveToIdle+0x82>
           if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8009e5a:	68a3      	ldr	r3, [r4, #8]
 8009e5c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009e60:	d0d4      	beq.n	8009e0c <HAL_UARTEx_ReceiveToIdle+0x8e>
 8009e62:	b913      	cbnz	r3, 8009e6a <HAL_UARTEx_ReceiveToIdle+0xec>
 8009e64:	6923      	ldr	r3, [r4, #16]
 8009e66:	2b00      	cmp	r3, #0
 8009e68:	d0d0      	beq.n	8009e0c <HAL_UARTEx_ReceiveToIdle+0x8e>
             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8009e6a:	6853      	ldr	r3, [r2, #4]
 8009e6c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009e70:	702b      	strb	r3, [r5, #0]
 8009e72:	e7cd      	b.n	8009e10 <HAL_UARTEx_ReceiveToIdle+0x92>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8009e74:	f7f8 f832 	bl	8001edc <HAL_GetTick>
 8009e78:	eba0 0008 	sub.w	r0, r0, r8
 8009e7c:	42b8      	cmp	r0, r7
 8009e7e:	d801      	bhi.n	8009e84 <HAL_UARTEx_ReceiveToIdle+0x106>
 8009e80:	2f00      	cmp	r7, #0
 8009e82:	d1d1      	bne.n	8009e28 <HAL_UARTEx_ReceiveToIdle+0xaa>
          huart->RxState = HAL_UART_STATE_READY;
 8009e84:	2320      	movs	r3, #32
 8009e86:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
          return HAL_TIMEOUT;
 8009e8a:	2003      	movs	r0, #3
 8009e8c:	e00a      	b.n	8009ea4 <HAL_UARTEx_ReceiveToIdle+0x126>
    *RxLen = huart->RxXferSize - huart->RxXferCount;
 8009e8e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8009e90:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
 8009e92:	b292      	uxth	r2, r2
 8009e94:	1a9b      	subs	r3, r3, r2
 8009e96:	8033      	strh	r3, [r6, #0]
    huart->RxState = HAL_UART_STATE_READY;
 8009e98:	2320      	movs	r3, #32
 8009e9a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    return HAL_OK;
 8009e9e:	2000      	movs	r0, #0
 8009ea0:	e000      	b.n	8009ea4 <HAL_UARTEx_ReceiveToIdle+0x126>
    return HAL_BUSY;
 8009ea2:	2002      	movs	r0, #2
}
 8009ea4:	b003      	add	sp, #12
 8009ea6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      return  HAL_ERROR;
 8009eaa:	2001      	movs	r0, #1
 8009eac:	e7fa      	b.n	8009ea4 <HAL_UARTEx_ReceiveToIdle+0x126>
 8009eae:	2001      	movs	r0, #1
 8009eb0:	e7f8      	b.n	8009ea4 <HAL_UARTEx_ReceiveToIdle+0x126>
    __HAL_LOCK(huart);
 8009eb2:	2002      	movs	r0, #2
 8009eb4:	e7f6      	b.n	8009ea4 <HAL_UARTEx_ReceiveToIdle+0x126>

08009eb6 <HAL_UART_Abort>:
{
 8009eb6:	b510      	push	{r4, lr}
 8009eb8:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
 8009eba:	6802      	ldr	r2, [r0, #0]
 8009ebc:	68d3      	ldr	r3, [r2, #12]
 8009ebe:	f423 73f0 	bic.w	r3, r3, #480	; 0x1e0
 8009ec2:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009ec4:	6802      	ldr	r2, [r0, #0]
 8009ec6:	6953      	ldr	r3, [r2, #20]
 8009ec8:	f023 0301 	bic.w	r3, r3, #1
 8009ecc:	6153      	str	r3, [r2, #20]
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8009ece:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8009ed0:	2b01      	cmp	r3, #1
 8009ed2:	d02c      	beq.n	8009f2e <HAL_UART_Abort+0x78>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 8009ed4:	6823      	ldr	r3, [r4, #0]
 8009ed6:	695a      	ldr	r2, [r3, #20]
 8009ed8:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009edc:	d00b      	beq.n	8009ef6 <HAL_UART_Abort+0x40>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8009ede:	695a      	ldr	r2, [r3, #20]
 8009ee0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009ee4:	615a      	str	r2, [r3, #20]
    if (huart->hdmatx != NULL)
 8009ee6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009ee8:	b12b      	cbz	r3, 8009ef6 <HAL_UART_Abort+0x40>
      huart->hdmatx->XferAbortCallback = NULL;
 8009eea:	2200      	movs	r2, #0
 8009eec:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
 8009eee:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8009ef0:	f7f9 fcf0 	bl	80038d4 <HAL_DMA_Abort>
 8009ef4:	bb08      	cbnz	r0, 8009f3a <HAL_UART_Abort+0x84>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8009ef6:	6823      	ldr	r3, [r4, #0]
 8009ef8:	695a      	ldr	r2, [r3, #20]
 8009efa:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009efe:	d00b      	beq.n	8009f18 <HAL_UART_Abort+0x62>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8009f00:	695a      	ldr	r2, [r3, #20]
 8009f02:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009f06:	615a      	str	r2, [r3, #20]
    if (huart->hdmarx != NULL)
 8009f08:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009f0a:	b12b      	cbz	r3, 8009f18 <HAL_UART_Abort+0x62>
      huart->hdmarx->XferAbortCallback = NULL;
 8009f0c:	2200      	movs	r2, #0
 8009f0e:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
 8009f10:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8009f12:	f7f9 fcdf 	bl	80038d4 <HAL_DMA_Abort>
 8009f16:	b9c8      	cbnz	r0, 8009f4c <HAL_UART_Abort+0x96>
  huart->TxXferCount = 0x00U;
 8009f18:	2000      	movs	r0, #0
 8009f1a:	84e0      	strh	r0, [r4, #38]	; 0x26
  huart->RxXferCount = 0x00U;
 8009f1c:	85e0      	strh	r0, [r4, #46]	; 0x2e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009f1e:	6420      	str	r0, [r4, #64]	; 0x40
  huart->RxState = HAL_UART_STATE_READY;
 8009f20:	2320      	movs	r3, #32
 8009f22:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  huart->gState = HAL_UART_STATE_READY;
 8009f26:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009f2a:	6320      	str	r0, [r4, #48]	; 0x30
}
 8009f2c:	bd10      	pop	{r4, pc}
    CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
 8009f2e:	6802      	ldr	r2, [r0, #0]
 8009f30:	68d3      	ldr	r3, [r2, #12]
 8009f32:	f023 0310 	bic.w	r3, r3, #16
 8009f36:	60d3      	str	r3, [r2, #12]
 8009f38:	e7cc      	b.n	8009ed4 <HAL_UART_Abort+0x1e>
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
 8009f3a:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8009f3c:	f7f9 ff42 	bl	8003dc4 <HAL_DMA_GetError>
 8009f40:	2820      	cmp	r0, #32
 8009f42:	d1d8      	bne.n	8009ef6 <HAL_UART_Abort+0x40>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 8009f44:	2310      	movs	r3, #16
 8009f46:	6423      	str	r3, [r4, #64]	; 0x40
          return HAL_TIMEOUT;
 8009f48:	2003      	movs	r0, #3
 8009f4a:	e7ef      	b.n	8009f2c <HAL_UART_Abort+0x76>
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
 8009f4c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8009f4e:	f7f9 ff39 	bl	8003dc4 <HAL_DMA_GetError>
 8009f52:	2820      	cmp	r0, #32
 8009f54:	d1e0      	bne.n	8009f18 <HAL_UART_Abort+0x62>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 8009f56:	2310      	movs	r3, #16
 8009f58:	6423      	str	r3, [r4, #64]	; 0x40
          return HAL_TIMEOUT;
 8009f5a:	2003      	movs	r0, #3
 8009f5c:	e7e6      	b.n	8009f2c <HAL_UART_Abort+0x76>

08009f5e <HAL_UART_AbortTransmit>:
{
 8009f5e:	b510      	push	{r4, lr}
 8009f60:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8009f62:	6802      	ldr	r2, [r0, #0]
 8009f64:	68d3      	ldr	r3, [r2, #12]
 8009f66:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009f6a:	60d3      	str	r3, [r2, #12]
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 8009f6c:	6803      	ldr	r3, [r0, #0]
 8009f6e:	695a      	ldr	r2, [r3, #20]
 8009f70:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009f74:	d00b      	beq.n	8009f8e <HAL_UART_AbortTransmit+0x30>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8009f76:	695a      	ldr	r2, [r3, #20]
 8009f78:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009f7c:	615a      	str	r2, [r3, #20]
    if (huart->hdmatx != NULL)
 8009f7e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8009f80:	b12b      	cbz	r3, 8009f8e <HAL_UART_AbortTransmit+0x30>
      huart->hdmatx->XferAbortCallback = NULL;
 8009f82:	2200      	movs	r2, #0
 8009f84:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
 8009f86:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8009f88:	f7f9 fca4 	bl	80038d4 <HAL_DMA_Abort>
 8009f8c:	b928      	cbnz	r0, 8009f9a <HAL_UART_AbortTransmit+0x3c>
  huart->TxXferCount = 0x00U;
 8009f8e:	2000      	movs	r0, #0
 8009f90:	84e0      	strh	r0, [r4, #38]	; 0x26
  huart->gState = HAL_UART_STATE_READY;
 8009f92:	2320      	movs	r3, #32
 8009f94:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8009f98:	bd10      	pop	{r4, pc}
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
 8009f9a:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8009f9c:	f7f9 ff12 	bl	8003dc4 <HAL_DMA_GetError>
 8009fa0:	2820      	cmp	r0, #32
 8009fa2:	d1f4      	bne.n	8009f8e <HAL_UART_AbortTransmit+0x30>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 8009fa4:	2310      	movs	r3, #16
 8009fa6:	6423      	str	r3, [r4, #64]	; 0x40
          return HAL_TIMEOUT;
 8009fa8:	2003      	movs	r0, #3
 8009faa:	e7f5      	b.n	8009f98 <HAL_UART_AbortTransmit+0x3a>

08009fac <HAL_UART_AbortReceive>:
{
 8009fac:	b510      	push	{r4, lr}
 8009fae:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8009fb0:	6802      	ldr	r2, [r0, #0]
 8009fb2:	68d3      	ldr	r3, [r2, #12]
 8009fb4:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8009fb8:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009fba:	6802      	ldr	r2, [r0, #0]
 8009fbc:	6953      	ldr	r3, [r2, #20]
 8009fbe:	f023 0301 	bic.w	r3, r3, #1
 8009fc2:	6153      	str	r3, [r2, #20]
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8009fc4:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8009fc6:	2b01      	cmp	r3, #1
 8009fc8:	d017      	beq.n	8009ffa <HAL_UART_AbortReceive+0x4e>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8009fca:	6823      	ldr	r3, [r4, #0]
 8009fcc:	695a      	ldr	r2, [r3, #20]
 8009fce:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009fd2:	d00b      	beq.n	8009fec <HAL_UART_AbortReceive+0x40>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8009fd4:	695a      	ldr	r2, [r3, #20]
 8009fd6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009fda:	615a      	str	r2, [r3, #20]
    if (huart->hdmarx != NULL)
 8009fdc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009fde:	b12b      	cbz	r3, 8009fec <HAL_UART_AbortReceive+0x40>
      huart->hdmarx->XferAbortCallback = NULL;
 8009fe0:	2200      	movs	r2, #0
 8009fe2:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
 8009fe4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8009fe6:	f7f9 fc75 	bl	80038d4 <HAL_DMA_Abort>
 8009fea:	b960      	cbnz	r0, 800a006 <HAL_UART_AbortReceive+0x5a>
  huart->RxXferCount = 0x00U;
 8009fec:	2000      	movs	r0, #0
 8009fee:	85e0      	strh	r0, [r4, #46]	; 0x2e
  huart->RxState = HAL_UART_STATE_READY;
 8009ff0:	2320      	movs	r3, #32
 8009ff2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009ff6:	6320      	str	r0, [r4, #48]	; 0x30
}
 8009ff8:	bd10      	pop	{r4, pc}
    CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
 8009ffa:	6802      	ldr	r2, [r0, #0]
 8009ffc:	68d3      	ldr	r3, [r2, #12]
 8009ffe:	f023 0310 	bic.w	r3, r3, #16
 800a002:	60d3      	str	r3, [r2, #12]
 800a004:	e7e1      	b.n	8009fca <HAL_UART_AbortReceive+0x1e>
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
 800a006:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a008:	f7f9 fedc 	bl	8003dc4 <HAL_DMA_GetError>
 800a00c:	2820      	cmp	r0, #32
 800a00e:	d1ed      	bne.n	8009fec <HAL_UART_AbortReceive+0x40>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 800a010:	2310      	movs	r3, #16
 800a012:	6423      	str	r3, [r4, #64]	; 0x40
          return HAL_TIMEOUT;
 800a014:	2003      	movs	r0, #3
 800a016:	e7ef      	b.n	8009ff8 <HAL_UART_AbortReceive+0x4c>
}
 800a018:	4770      	bx	lr

0800a01a <UART_DMATransmitCplt>:
{
 800a01a:	b508      	push	{r3, lr}
 800a01c:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a01e:	6a40      	ldr	r0, [r0, #36]	; 0x24
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800a020:	681b      	ldr	r3, [r3, #0]
 800a022:	681b      	ldr	r3, [r3, #0]
 800a024:	f013 0f20 	tst.w	r3, #32
 800a028:	d10c      	bne.n	800a044 <UART_DMATransmitCplt+0x2a>
    huart->TxXferCount = 0x00U;
 800a02a:	2300      	movs	r3, #0
 800a02c:	84c3      	strh	r3, [r0, #38]	; 0x26
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800a02e:	6802      	ldr	r2, [r0, #0]
 800a030:	6953      	ldr	r3, [r2, #20]
 800a032:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a036:	6153      	str	r3, [r2, #20]
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800a038:	6802      	ldr	r2, [r0, #0]
 800a03a:	68d3      	ldr	r3, [r2, #12]
 800a03c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a040:	60d3      	str	r3, [r2, #12]
}
 800a042:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 800a044:	f7f6 fa94 	bl	8000570 <HAL_UART_TxCpltCallback>
}
 800a048:	e7fb      	b.n	800a042 <UART_DMATransmitCplt+0x28>

0800a04a <UART_EndTransmit_IT>:
{
 800a04a:	b508      	push	{r3, lr}
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 800a04c:	6801      	ldr	r1, [r0, #0]
 800a04e:	68ca      	ldr	r2, [r1, #12]
 800a050:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a054:	60ca      	str	r2, [r1, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a056:	2220      	movs	r2, #32
 800a058:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  HAL_UART_TxCpltCallback(huart);
 800a05c:	f7f6 fa88 	bl	8000570 <HAL_UART_TxCpltCallback>
}
 800a060:	2000      	movs	r0, #0
 800a062:	bd08      	pop	{r3, pc}

0800a064 <HAL_UART_TxHalfCpltCallback>:
}
 800a064:	4770      	bx	lr

0800a066 <UART_DMATxHalfCplt>:
{
 800a066:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 800a068:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800a06a:	f7ff fffb 	bl	800a064 <HAL_UART_TxHalfCpltCallback>
}
 800a06e:	bd08      	pop	{r3, pc}
}
 800a070:	4770      	bx	lr

0800a072 <HAL_UART_RxHalfCpltCallback>:
}
 800a072:	4770      	bx	lr

0800a074 <HAL_UART_ErrorCallback>:
}
 800a074:	4770      	bx	lr

0800a076 <UART_DMAError>:
{
 800a076:	b510      	push	{r4, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a078:	6a44      	ldr	r4, [r0, #36]	; 0x24
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 800a07a:	6823      	ldr	r3, [r4, #0]
 800a07c:	695a      	ldr	r2, [r3, #20]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 800a07e:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800a082:	b2db      	uxtb	r3, r3
 800a084:	2b21      	cmp	r3, #33	; 0x21
 800a086:	d010      	beq.n	800a0aa <UART_DMAError+0x34>
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 800a088:	6823      	ldr	r3, [r4, #0]
 800a08a:	695a      	ldr	r2, [r3, #20]
 800a08c:	f002 0240 	and.w	r2, r2, #64	; 0x40
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 800a090:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 800a094:	b2db      	uxtb	r3, r3
 800a096:	2b22      	cmp	r3, #34	; 0x22
 800a098:	d011      	beq.n	800a0be <UART_DMAError+0x48>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800a09a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800a09c:	f043 0310 	orr.w	r3, r3, #16
 800a0a0:	6423      	str	r3, [r4, #64]	; 0x40
  HAL_UART_ErrorCallback(huart);
 800a0a2:	4620      	mov	r0, r4
 800a0a4:	f7ff ffe6 	bl	800a074 <HAL_UART_ErrorCallback>
}
 800a0a8:	bd10      	pop	{r4, pc}
 800a0aa:	f002 0280 	and.w	r2, r2, #128	; 0x80
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 800a0ae:	2a00      	cmp	r2, #0
 800a0b0:	d0ea      	beq.n	800a088 <UART_DMAError+0x12>
    huart->TxXferCount = 0x00U;
 800a0b2:	2300      	movs	r3, #0
 800a0b4:	84e3      	strh	r3, [r4, #38]	; 0x26
    UART_EndTxTransfer(huart);
 800a0b6:	4620      	mov	r0, r4
 800a0b8:	f7ff faa2 	bl	8009600 <UART_EndTxTransfer>
 800a0bc:	e7e4      	b.n	800a088 <UART_DMAError+0x12>
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 800a0be:	2a00      	cmp	r2, #0
 800a0c0:	d0eb      	beq.n	800a09a <UART_DMAError+0x24>
    huart->RxXferCount = 0x00U;
 800a0c2:	2300      	movs	r3, #0
 800a0c4:	85e3      	strh	r3, [r4, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 800a0c6:	4620      	mov	r0, r4
 800a0c8:	f7ff faa3 	bl	8009612 <UART_EndRxTransfer>
 800a0cc:	e7e5      	b.n	800a09a <UART_DMAError+0x24>

0800a0ce <UART_DMAAbortOnError>:
{
 800a0ce:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a0d0:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->RxXferCount = 0x00U;
 800a0d2:	2300      	movs	r3, #0
 800a0d4:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 800a0d6:	84c3      	strh	r3, [r0, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 800a0d8:	f7ff ffcc 	bl	800a074 <HAL_UART_ErrorCallback>
}
 800a0dc:	bd08      	pop	{r3, pc}

0800a0de <HAL_UART_AbortCpltCallback>:
}
 800a0de:	4770      	bx	lr

0800a0e0 <HAL_UART_Abort_IT>:
{
 800a0e0:	b510      	push	{r4, lr}
 800a0e2:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
 800a0e4:	6802      	ldr	r2, [r0, #0]
 800a0e6:	68d3      	ldr	r3, [r2, #12]
 800a0e8:	f423 73f0 	bic.w	r3, r3, #480	; 0x1e0
 800a0ec:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a0ee:	6802      	ldr	r2, [r0, #0]
 800a0f0:	6953      	ldr	r3, [r2, #20]
 800a0f2:	f023 0301 	bic.w	r3, r3, #1
 800a0f6:	6153      	str	r3, [r2, #20]
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a0f8:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a0fa:	2b01      	cmp	r3, #1
 800a0fc:	d026      	beq.n	800a14c <HAL_UART_Abort_IT+0x6c>
  if (huart->hdmatx != NULL)
 800a0fe:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a100:	b133      	cbz	r3, 800a110 <HAL_UART_Abort_IT+0x30>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800a102:	6822      	ldr	r2, [r4, #0]
 800a104:	6952      	ldr	r2, [r2, #20]
 800a106:	f012 0f80 	tst.w	r2, #128	; 0x80
 800a10a:	d025      	beq.n	800a158 <HAL_UART_Abort_IT+0x78>
      huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
 800a10c:	4a29      	ldr	r2, [pc, #164]	; (800a1b4 <HAL_UART_Abort_IT+0xd4>)
 800a10e:	635a      	str	r2, [r3, #52]	; 0x34
  if (huart->hdmarx != NULL)
 800a110:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a112:	b133      	cbz	r3, 800a122 <HAL_UART_Abort_IT+0x42>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a114:	6822      	ldr	r2, [r4, #0]
 800a116:	6952      	ldr	r2, [r2, #20]
 800a118:	f012 0f40 	tst.w	r2, #64	; 0x40
 800a11c:	d01f      	beq.n	800a15e <HAL_UART_Abort_IT+0x7e>
      huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
 800a11e:	4a26      	ldr	r2, [pc, #152]	; (800a1b8 <HAL_UART_Abort_IT+0xd8>)
 800a120:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800a122:	6823      	ldr	r3, [r4, #0]
 800a124:	695a      	ldr	r2, [r3, #20]
 800a126:	f012 0f80 	tst.w	r2, #128	; 0x80
 800a12a:	d01b      	beq.n	800a164 <HAL_UART_Abort_IT+0x84>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800a12c:	695a      	ldr	r2, [r3, #20]
 800a12e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a132:	615a      	str	r2, [r3, #20]
    if (huart->hdmatx != NULL)
 800a134:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800a136:	2800      	cmp	r0, #0
 800a138:	d034      	beq.n	800a1a4 <HAL_UART_Abort_IT+0xc4>
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
 800a13a:	f7f9 fbed 	bl	8003918 <HAL_DMA_Abort_IT>
 800a13e:	2800      	cmp	r0, #0
 800a140:	d032      	beq.n	800a1a8 <HAL_UART_Abort_IT+0xc8>
        huart->hdmatx->XferAbortCallback = NULL;
 800a142:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a144:	2200      	movs	r2, #0
 800a146:	635a      	str	r2, [r3, #52]	; 0x34
  uint32_t AbortCplt = 0x01U;
 800a148:	2101      	movs	r1, #1
 800a14a:	e00c      	b.n	800a166 <HAL_UART_Abort_IT+0x86>
    CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
 800a14c:	6802      	ldr	r2, [r0, #0]
 800a14e:	68d3      	ldr	r3, [r2, #12]
 800a150:	f023 0310 	bic.w	r3, r3, #16
 800a154:	60d3      	str	r3, [r2, #12]
 800a156:	e7d2      	b.n	800a0fe <HAL_UART_Abort_IT+0x1e>
      huart->hdmatx->XferAbortCallback = NULL;
 800a158:	2200      	movs	r2, #0
 800a15a:	635a      	str	r2, [r3, #52]	; 0x34
 800a15c:	e7d8      	b.n	800a110 <HAL_UART_Abort_IT+0x30>
      huart->hdmarx->XferAbortCallback = NULL;
 800a15e:	2200      	movs	r2, #0
 800a160:	635a      	str	r2, [r3, #52]	; 0x34
 800a162:	e7de      	b.n	800a122 <HAL_UART_Abort_IT+0x42>
  uint32_t AbortCplt = 0x01U;
 800a164:	2101      	movs	r1, #1
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a166:	6823      	ldr	r3, [r4, #0]
 800a168:	695a      	ldr	r2, [r3, #20]
 800a16a:	f012 0f40 	tst.w	r2, #64	; 0x40
 800a16e:	d01d      	beq.n	800a1ac <HAL_UART_Abort_IT+0xcc>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a170:	695a      	ldr	r2, [r3, #20]
 800a172:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a176:	615a      	str	r2, [r3, #20]
    if (huart->hdmarx != NULL)
 800a178:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a17a:	b1b8      	cbz	r0, 800a1ac <HAL_UART_Abort_IT+0xcc>
      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800a17c:	f7f9 fbcc 	bl	8003918 <HAL_DMA_Abort_IT>
 800a180:	b1b0      	cbz	r0, 800a1b0 <HAL_UART_Abort_IT+0xd0>
        huart->hdmarx->XferAbortCallback = NULL;
 800a182:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a184:	2200      	movs	r2, #0
 800a186:	635a      	str	r2, [r3, #52]	; 0x34
    huart->TxXferCount = 0x00U;
 800a188:	2300      	movs	r3, #0
 800a18a:	84e3      	strh	r3, [r4, #38]	; 0x26
    huart->RxXferCount = 0x00U;
 800a18c:	85e3      	strh	r3, [r4, #46]	; 0x2e
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a18e:	6423      	str	r3, [r4, #64]	; 0x40
    huart->gState  = HAL_UART_STATE_READY;
 800a190:	2220      	movs	r2, #32
 800a192:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    huart->RxState = HAL_UART_STATE_READY;
 800a196:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a19a:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_UART_AbortCpltCallback(huart);
 800a19c:	4620      	mov	r0, r4
 800a19e:	f7ff ff9e 	bl	800a0de <HAL_UART_AbortCpltCallback>
 800a1a2:	e005      	b.n	800a1b0 <HAL_UART_Abort_IT+0xd0>
  uint32_t AbortCplt = 0x01U;
 800a1a4:	2101      	movs	r1, #1
 800a1a6:	e7de      	b.n	800a166 <HAL_UART_Abort_IT+0x86>
        AbortCplt = 0x00U;
 800a1a8:	2100      	movs	r1, #0
 800a1aa:	e7dc      	b.n	800a166 <HAL_UART_Abort_IT+0x86>
  if (AbortCplt == 0x01U)
 800a1ac:	2900      	cmp	r1, #0
 800a1ae:	d1eb      	bne.n	800a188 <HAL_UART_Abort_IT+0xa8>
}
 800a1b0:	2000      	movs	r0, #0
 800a1b2:	bd10      	pop	{r4, pc}
 800a1b4:	0800a1e9 	.word	0x0800a1e9
 800a1b8:	0800a1bd 	.word	0x0800a1bd

0800a1bc <UART_DMARxAbortCallback>:
{
 800a1bc:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a1be:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->hdmarx->XferAbortCallback = NULL;
 800a1c0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a1c2:	2200      	movs	r2, #0
 800a1c4:	635a      	str	r2, [r3, #52]	; 0x34
  if (huart->hdmatx != NULL)
 800a1c6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a1c8:	b10b      	cbz	r3, 800a1ce <UART_DMARxAbortCallback+0x12>
    if (huart->hdmatx->XferAbortCallback != NULL)
 800a1ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a1cc:	b95b      	cbnz	r3, 800a1e6 <UART_DMARxAbortCallback+0x2a>
  huart->TxXferCount = 0x00U;
 800a1ce:	2300      	movs	r3, #0
 800a1d0:	84c3      	strh	r3, [r0, #38]	; 0x26
  huart->RxXferCount = 0x00U;
 800a1d2:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a1d4:	6403      	str	r3, [r0, #64]	; 0x40
  huart->gState  = HAL_UART_STATE_READY;
 800a1d6:	2220      	movs	r2, #32
 800a1d8:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 800a1dc:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a1e0:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_UART_AbortCpltCallback(huart);
 800a1e2:	f7ff ff7c 	bl	800a0de <HAL_UART_AbortCpltCallback>
}
 800a1e6:	bd08      	pop	{r3, pc}

0800a1e8 <UART_DMATxAbortCallback>:
{
 800a1e8:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a1ea:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->hdmatx->XferAbortCallback = NULL;
 800a1ec:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a1ee:	2200      	movs	r2, #0
 800a1f0:	635a      	str	r2, [r3, #52]	; 0x34
  if (huart->hdmarx != NULL)
 800a1f2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a1f4:	b10b      	cbz	r3, 800a1fa <UART_DMATxAbortCallback+0x12>
    if (huart->hdmarx->XferAbortCallback != NULL)
 800a1f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a1f8:	b95b      	cbnz	r3, 800a212 <UART_DMATxAbortCallback+0x2a>
  huart->TxXferCount = 0x00U;
 800a1fa:	2300      	movs	r3, #0
 800a1fc:	84c3      	strh	r3, [r0, #38]	; 0x26
  huart->RxXferCount = 0x00U;
 800a1fe:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a200:	6403      	str	r3, [r0, #64]	; 0x40
  huart->gState  = HAL_UART_STATE_READY;
 800a202:	2220      	movs	r2, #32
 800a204:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 800a208:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a20c:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_UART_AbortCpltCallback(huart);
 800a20e:	f7ff ff66 	bl	800a0de <HAL_UART_AbortCpltCallback>
}
 800a212:	bd08      	pop	{r3, pc}

0800a214 <HAL_UART_AbortTransmitCpltCallback>:
}
 800a214:	4770      	bx	lr

0800a216 <HAL_UART_AbortTransmit_IT>:
{
 800a216:	b510      	push	{r4, lr}
 800a218:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800a21a:	6802      	ldr	r2, [r0, #0]
 800a21c:	68d3      	ldr	r3, [r2, #12]
 800a21e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800a222:	60d3      	str	r3, [r2, #12]
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800a224:	6803      	ldr	r3, [r0, #0]
 800a226:	695a      	ldr	r2, [r3, #20]
 800a228:	f012 0f80 	tst.w	r2, #128	; 0x80
 800a22c:	d017      	beq.n	800a25e <HAL_UART_AbortTransmit_IT+0x48>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800a22e:	695a      	ldr	r2, [r3, #20]
 800a230:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a234:	615a      	str	r2, [r3, #20]
    if (huart->hdmatx != NULL)
 800a236:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a238:	b14b      	cbz	r3, 800a24e <HAL_UART_AbortTransmit_IT+0x38>
      huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
 800a23a:	4a0d      	ldr	r2, [pc, #52]	; (800a270 <HAL_UART_AbortTransmit_IT+0x5a>)
 800a23c:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
 800a23e:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800a240:	f7f9 fb6a 	bl	8003918 <HAL_DMA_Abort_IT>
 800a244:	b190      	cbz	r0, 800a26c <HAL_UART_AbortTransmit_IT+0x56>
        huart->hdmatx->XferAbortCallback(huart->hdmatx);
 800a246:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800a248:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a24a:	4798      	blx	r3
 800a24c:	e00e      	b.n	800a26c <HAL_UART_AbortTransmit_IT+0x56>
      huart->TxXferCount = 0x00U;
 800a24e:	2300      	movs	r3, #0
 800a250:	84c3      	strh	r3, [r0, #38]	; 0x26
      huart->gState = HAL_UART_STATE_READY;
 800a252:	2320      	movs	r3, #32
 800a254:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_UART_AbortTransmitCpltCallback(huart);
 800a258:	f7ff ffdc 	bl	800a214 <HAL_UART_AbortTransmitCpltCallback>
 800a25c:	e006      	b.n	800a26c <HAL_UART_AbortTransmit_IT+0x56>
    huart->TxXferCount = 0x00U;
 800a25e:	2300      	movs	r3, #0
 800a260:	84c3      	strh	r3, [r0, #38]	; 0x26
    huart->gState = HAL_UART_STATE_READY;
 800a262:	2320      	movs	r3, #32
 800a264:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    HAL_UART_AbortTransmitCpltCallback(huart);
 800a268:	f7ff ffd4 	bl	800a214 <HAL_UART_AbortTransmitCpltCallback>
}
 800a26c:	2000      	movs	r0, #0
 800a26e:	bd10      	pop	{r4, pc}
 800a270:	0800a275 	.word	0x0800a275

0800a274 <UART_DMATxOnlyAbortCallback>:
{
 800a274:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a276:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->TxXferCount = 0x00U;
 800a278:	2300      	movs	r3, #0
 800a27a:	84c3      	strh	r3, [r0, #38]	; 0x26
  huart->gState = HAL_UART_STATE_READY;
 800a27c:	2320      	movs	r3, #32
 800a27e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  HAL_UART_AbortTransmitCpltCallback(huart);
 800a282:	f7ff ffc7 	bl	800a214 <HAL_UART_AbortTransmitCpltCallback>
}
 800a286:	bd08      	pop	{r3, pc}

0800a288 <HAL_UART_AbortReceiveCpltCallback>:
}
 800a288:	4770      	bx	lr

0800a28a <HAL_UART_AbortReceive_IT>:
{
 800a28a:	b510      	push	{r4, lr}
 800a28c:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a28e:	6802      	ldr	r2, [r0, #0]
 800a290:	68d3      	ldr	r3, [r2, #12]
 800a292:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800a296:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a298:	6802      	ldr	r2, [r0, #0]
 800a29a:	6953      	ldr	r3, [r2, #20]
 800a29c:	f023 0301 	bic.w	r3, r3, #1
 800a2a0:	6153      	str	r3, [r2, #20]
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a2a2:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a2a4:	2b01      	cmp	r3, #1
 800a2a6:	d014      	beq.n	800a2d2 <HAL_UART_AbortReceive_IT+0x48>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a2a8:	6823      	ldr	r3, [r4, #0]
 800a2aa:	695a      	ldr	r2, [r3, #20]
 800a2ac:	f012 0f40 	tst.w	r2, #64	; 0x40
 800a2b0:	d01f      	beq.n	800a2f2 <HAL_UART_AbortReceive_IT+0x68>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a2b2:	695a      	ldr	r2, [r3, #20]
 800a2b4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a2b8:	615a      	str	r2, [r3, #20]
    if (huart->hdmarx != NULL)
 800a2ba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a2bc:	b17b      	cbz	r3, 800a2de <HAL_UART_AbortReceive_IT+0x54>
      huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
 800a2be:	4a12      	ldr	r2, [pc, #72]	; (800a308 <HAL_UART_AbortReceive_IT+0x7e>)
 800a2c0:	635a      	str	r2, [r3, #52]	; 0x34
      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800a2c2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a2c4:	f7f9 fb28 	bl	8003918 <HAL_DMA_Abort_IT>
 800a2c8:	b1e0      	cbz	r0, 800a304 <HAL_UART_AbortReceive_IT+0x7a>
        huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800a2ca:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a2cc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a2ce:	4798      	blx	r3
 800a2d0:	e018      	b.n	800a304 <HAL_UART_AbortReceive_IT+0x7a>
    CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
 800a2d2:	6802      	ldr	r2, [r0, #0]
 800a2d4:	68d3      	ldr	r3, [r2, #12]
 800a2d6:	f023 0310 	bic.w	r3, r3, #16
 800a2da:	60d3      	str	r3, [r2, #12]
 800a2dc:	e7e4      	b.n	800a2a8 <HAL_UART_AbortReceive_IT+0x1e>
      huart->RxXferCount = 0x00U;
 800a2de:	2300      	movs	r3, #0
 800a2e0:	85e3      	strh	r3, [r4, #46]	; 0x2e
      huart->RxState = HAL_UART_STATE_READY;
 800a2e2:	2220      	movs	r2, #32
 800a2e4:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a2e8:	6323      	str	r3, [r4, #48]	; 0x30
      HAL_UART_AbortReceiveCpltCallback(huart);
 800a2ea:	4620      	mov	r0, r4
 800a2ec:	f7ff ffcc 	bl	800a288 <HAL_UART_AbortReceiveCpltCallback>
 800a2f0:	e008      	b.n	800a304 <HAL_UART_AbortReceive_IT+0x7a>
    huart->RxXferCount = 0x00U;
 800a2f2:	2300      	movs	r3, #0
 800a2f4:	85e3      	strh	r3, [r4, #46]	; 0x2e
    huart->RxState = HAL_UART_STATE_READY;
 800a2f6:	2220      	movs	r2, #32
 800a2f8:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a2fc:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_UART_AbortReceiveCpltCallback(huart);
 800a2fe:	4620      	mov	r0, r4
 800a300:	f7ff ffc2 	bl	800a288 <HAL_UART_AbortReceiveCpltCallback>
}
 800a304:	2000      	movs	r0, #0
 800a306:	bd10      	pop	{r4, pc}
 800a308:	0800a30d 	.word	0x0800a30d

0800a30c <UART_DMARxOnlyAbortCallback>:
{
 800a30c:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a30e:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->RxXferCount = 0x00U;
 800a310:	2300      	movs	r3, #0
 800a312:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->RxState = HAL_UART_STATE_READY;
 800a314:	2220      	movs	r2, #32
 800a316:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a31a:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_UART_AbortReceiveCpltCallback(huart);
 800a31c:	f7ff ffb4 	bl	800a288 <HAL_UART_AbortReceiveCpltCallback>
}
 800a320:	bd08      	pop	{r3, pc}

0800a322 <HAL_UARTEx_RxEventCallback>:
}
 800a322:	4770      	bx	lr

0800a324 <UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800a324:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 800a328:	b2db      	uxtb	r3, r3
 800a32a:	2b22      	cmp	r3, #34	; 0x22
 800a32c:	d160      	bne.n	800a3f0 <UART_Receive_IT+0xcc>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a32e:	6883      	ldr	r3, [r0, #8]
 800a330:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a334:	d046      	beq.n	800a3c4 <UART_Receive_IT+0xa0>
      pdata8bits = (uint8_t *) huart->pRxBuffPtr;
 800a336:	6a82      	ldr	r2, [r0, #40]	; 0x28
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 800a338:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a33c:	d004      	beq.n	800a348 <UART_Receive_IT+0x24>
 800a33e:	2b00      	cmp	r3, #0
 800a340:	d14d      	bne.n	800a3de <UART_Receive_IT+0xba>
 800a342:	6903      	ldr	r3, [r0, #16]
 800a344:	2b00      	cmp	r3, #0
 800a346:	d14a      	bne.n	800a3de <UART_Receive_IT+0xba>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 800a348:	6803      	ldr	r3, [r0, #0]
 800a34a:	685b      	ldr	r3, [r3, #4]
 800a34c:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr += 1U;
 800a34e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a350:	3301      	adds	r3, #1
 800a352:	6283      	str	r3, [r0, #40]	; 0x28
    if (--huart->RxXferCount == 0U)
 800a354:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 800a356:	b29b      	uxth	r3, r3
 800a358:	3b01      	subs	r3, #1
 800a35a:	b29b      	uxth	r3, r3
 800a35c:	85c3      	strh	r3, [r0, #46]	; 0x2e
 800a35e:	2b00      	cmp	r3, #0
 800a360:	d148      	bne.n	800a3f4 <UART_Receive_IT+0xd0>
{
 800a362:	b500      	push	{lr}
 800a364:	b083      	sub	sp, #12
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 800a366:	6802      	ldr	r2, [r0, #0]
 800a368:	68d3      	ldr	r3, [r2, #12]
 800a36a:	f023 0320 	bic.w	r3, r3, #32
 800a36e:	60d3      	str	r3, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 800a370:	6802      	ldr	r2, [r0, #0]
 800a372:	68d3      	ldr	r3, [r2, #12]
 800a374:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a378:	60d3      	str	r3, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 800a37a:	6802      	ldr	r2, [r0, #0]
 800a37c:	6953      	ldr	r3, [r2, #20]
 800a37e:	f023 0301 	bic.w	r3, r3, #1
 800a382:	6153      	str	r3, [r2, #20]
      huart->RxState = HAL_UART_STATE_READY;
 800a384:	2320      	movs	r3, #32
 800a386:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a38a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a38c:	2b01      	cmp	r3, #1
 800a38e:	d12c      	bne.n	800a3ea <UART_Receive_IT+0xc6>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a390:	2300      	movs	r3, #0
 800a392:	6303      	str	r3, [r0, #48]	; 0x30
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a394:	6802      	ldr	r2, [r0, #0]
 800a396:	68d3      	ldr	r3, [r2, #12]
 800a398:	f023 0310 	bic.w	r3, r3, #16
 800a39c:	60d3      	str	r3, [r2, #12]
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
 800a39e:	6803      	ldr	r3, [r0, #0]
 800a3a0:	681a      	ldr	r2, [r3, #0]
 800a3a2:	f012 0f10 	tst.w	r2, #16
 800a3a6:	d006      	beq.n	800a3b6 <UART_Receive_IT+0x92>
          __HAL_UART_CLEAR_IDLEFLAG(huart);
 800a3a8:	2200      	movs	r2, #0
 800a3aa:	9201      	str	r2, [sp, #4]
 800a3ac:	681a      	ldr	r2, [r3, #0]
 800a3ae:	9201      	str	r2, [sp, #4]
 800a3b0:	685b      	ldr	r3, [r3, #4]
 800a3b2:	9301      	str	r3, [sp, #4]
 800a3b4:	9b01      	ldr	r3, [sp, #4]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800a3b6:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 800a3b8:	f7ff ffb3 	bl	800a322 <HAL_UARTEx_RxEventCallback>
      return HAL_OK;
 800a3bc:	2000      	movs	r0, #0
}
 800a3be:	b003      	add	sp, #12
 800a3c0:	f85d fb04 	ldr.w	pc, [sp], #4
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a3c4:	6902      	ldr	r2, [r0, #16]
 800a3c6:	2a00      	cmp	r2, #0
 800a3c8:	d1b5      	bne.n	800a336 <UART_Receive_IT+0x12>
      pdata16bits = (uint16_t *) huart->pRxBuffPtr;
 800a3ca:	6a82      	ldr	r2, [r0, #40]	; 0x28
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 800a3cc:	6803      	ldr	r3, [r0, #0]
 800a3ce:	685b      	ldr	r3, [r3, #4]
 800a3d0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a3d4:	8013      	strh	r3, [r2, #0]
      huart->pRxBuffPtr += 2U;
 800a3d6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a3d8:	3302      	adds	r3, #2
 800a3da:	6283      	str	r3, [r0, #40]	; 0x28
 800a3dc:	e7ba      	b.n	800a354 <UART_Receive_IT+0x30>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 800a3de:	6803      	ldr	r3, [r0, #0]
 800a3e0:	685b      	ldr	r3, [r3, #4]
 800a3e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800a3e6:	7013      	strb	r3, [r2, #0]
 800a3e8:	e7b1      	b.n	800a34e <UART_Receive_IT+0x2a>
       HAL_UART_RxCpltCallback(huart);
 800a3ea:	f7f6 f8d5 	bl	8000598 <HAL_UART_RxCpltCallback>
 800a3ee:	e7e5      	b.n	800a3bc <UART_Receive_IT+0x98>
    return HAL_BUSY;
 800a3f0:	2002      	movs	r0, #2
 800a3f2:	4770      	bx	lr
    return HAL_OK;
 800a3f4:	2000      	movs	r0, #0
}
 800a3f6:	4770      	bx	lr

0800a3f8 <HAL_UART_IRQHandler>:
{
 800a3f8:	b530      	push	{r4, r5, lr}
 800a3fa:	b083      	sub	sp, #12
 800a3fc:	4604      	mov	r4, r0
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 800a3fe:	6802      	ldr	r2, [r0, #0]
 800a400:	6813      	ldr	r3, [r2, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800a402:	68d0      	ldr	r0, [r2, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800a404:	6951      	ldr	r1, [r2, #20]
  if (errorflags == RESET)
 800a406:	f013 050f 	ands.w	r5, r3, #15
 800a40a:	d105      	bne.n	800a418 <HAL_UART_IRQHandler+0x20>
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 800a40c:	f013 0f20 	tst.w	r3, #32
 800a410:	d002      	beq.n	800a418 <HAL_UART_IRQHandler+0x20>
 800a412:	f010 0f20 	tst.w	r0, #32
 800a416:	d119      	bne.n	800a44c <HAL_UART_IRQHandler+0x54>
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 800a418:	b12d      	cbz	r5, 800a426 <HAL_UART_IRQHandler+0x2e>
 800a41a:	f011 0101 	ands.w	r1, r1, #1
 800a41e:	d119      	bne.n	800a454 <HAL_UART_IRQHandler+0x5c>
 800a420:	f410 7f90 	tst.w	r0, #288	; 0x120
 800a424:	d116      	bne.n	800a454 <HAL_UART_IRQHandler+0x5c>
  if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a426:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800a428:	2901      	cmp	r1, #1
 800a42a:	d075      	beq.n	800a518 <HAL_UART_IRQHandler+0x120>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 800a42c:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a430:	d003      	beq.n	800a43a <HAL_UART_IRQHandler+0x42>
 800a432:	f010 0f80 	tst.w	r0, #128	; 0x80
 800a436:	f040 80d7 	bne.w	800a5e8 <HAL_UART_IRQHandler+0x1f0>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 800a43a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a43e:	d003      	beq.n	800a448 <HAL_UART_IRQHandler+0x50>
 800a440:	f010 0f40 	tst.w	r0, #64	; 0x40
 800a444:	f040 80d4 	bne.w	800a5f0 <HAL_UART_IRQHandler+0x1f8>
}
 800a448:	b003      	add	sp, #12
 800a44a:	bd30      	pop	{r4, r5, pc}
      UART_Receive_IT(huart);
 800a44c:	4620      	mov	r0, r4
 800a44e:	f7ff ff69 	bl	800a324 <UART_Receive_IT>
      return;
 800a452:	e7f9      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 800a454:	f013 0f01 	tst.w	r3, #1
 800a458:	d006      	beq.n	800a468 <HAL_UART_IRQHandler+0x70>
 800a45a:	f410 7f80 	tst.w	r0, #256	; 0x100
 800a45e:	d003      	beq.n	800a468 <HAL_UART_IRQHandler+0x70>
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800a460:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a462:	f042 0201 	orr.w	r2, r2, #1
 800a466:	6422      	str	r2, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 800a468:	f013 0f04 	tst.w	r3, #4
 800a46c:	d004      	beq.n	800a478 <HAL_UART_IRQHandler+0x80>
 800a46e:	b119      	cbz	r1, 800a478 <HAL_UART_IRQHandler+0x80>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 800a470:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a472:	f042 0202 	orr.w	r2, r2, #2
 800a476:	6422      	str	r2, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 800a478:	f013 0f02 	tst.w	r3, #2
 800a47c:	d004      	beq.n	800a488 <HAL_UART_IRQHandler+0x90>
 800a47e:	b119      	cbz	r1, 800a488 <HAL_UART_IRQHandler+0x90>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800a480:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a482:	f042 0204 	orr.w	r2, r2, #4
 800a486:	6422      	str	r2, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 800a488:	f013 0f08 	tst.w	r3, #8
 800a48c:	d007      	beq.n	800a49e <HAL_UART_IRQHandler+0xa6>
 800a48e:	f010 0f20 	tst.w	r0, #32
 800a492:	d100      	bne.n	800a496 <HAL_UART_IRQHandler+0x9e>
 800a494:	b119      	cbz	r1, 800a49e <HAL_UART_IRQHandler+0xa6>
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800a496:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a498:	f042 0208 	orr.w	r2, r2, #8
 800a49c:	6422      	str	r2, [r4, #64]	; 0x40
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800a49e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a4a0:	2a00      	cmp	r2, #0
 800a4a2:	d0d1      	beq.n	800a448 <HAL_UART_IRQHandler+0x50>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 800a4a4:	f013 0f20 	tst.w	r3, #32
 800a4a8:	d002      	beq.n	800a4b0 <HAL_UART_IRQHandler+0xb8>
 800a4aa:	f010 0f20 	tst.w	r0, #32
 800a4ae:	d121      	bne.n	800a4f4 <HAL_UART_IRQHandler+0xfc>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 800a4b0:	6823      	ldr	r3, [r4, #0]
 800a4b2:	695b      	ldr	r3, [r3, #20]
 800a4b4:	f003 0340 	and.w	r3, r3, #64	; 0x40
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 800a4b8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a4ba:	f012 0f08 	tst.w	r2, #8
 800a4be:	d100      	bne.n	800a4c2 <HAL_UART_IRQHandler+0xca>
 800a4c0:	b323      	cbz	r3, 800a50c <HAL_UART_IRQHandler+0x114>
        UART_EndRxTransfer(huart);
 800a4c2:	4620      	mov	r0, r4
 800a4c4:	f7ff f8a5 	bl	8009612 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a4c8:	6823      	ldr	r3, [r4, #0]
 800a4ca:	695a      	ldr	r2, [r3, #20]
 800a4cc:	f012 0f40 	tst.w	r2, #64	; 0x40
 800a4d0:	d018      	beq.n	800a504 <HAL_UART_IRQHandler+0x10c>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a4d2:	695a      	ldr	r2, [r3, #20]
 800a4d4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a4d8:	615a      	str	r2, [r3, #20]
          if (huart->hdmarx != NULL)
 800a4da:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a4dc:	b173      	cbz	r3, 800a4fc <HAL_UART_IRQHandler+0x104>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800a4de:	4a46      	ldr	r2, [pc, #280]	; (800a5f8 <HAL_UART_IRQHandler+0x200>)
 800a4e0:	635a      	str	r2, [r3, #52]	; 0x34
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800a4e2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a4e4:	f7f9 fa18 	bl	8003918 <HAL_DMA_Abort_IT>
 800a4e8:	2800      	cmp	r0, #0
 800a4ea:	d0ad      	beq.n	800a448 <HAL_UART_IRQHandler+0x50>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800a4ec:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a4ee:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a4f0:	4798      	blx	r3
 800a4f2:	e7a9      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
        UART_Receive_IT(huart);
 800a4f4:	4620      	mov	r0, r4
 800a4f6:	f7ff ff15 	bl	800a324 <UART_Receive_IT>
 800a4fa:	e7d9      	b.n	800a4b0 <HAL_UART_IRQHandler+0xb8>
            HAL_UART_ErrorCallback(huart);
 800a4fc:	4620      	mov	r0, r4
 800a4fe:	f7ff fdb9 	bl	800a074 <HAL_UART_ErrorCallback>
 800a502:	e7a1      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
          HAL_UART_ErrorCallback(huart);
 800a504:	4620      	mov	r0, r4
 800a506:	f7ff fdb5 	bl	800a074 <HAL_UART_ErrorCallback>
 800a50a:	e79d      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
        HAL_UART_ErrorCallback(huart);
 800a50c:	4620      	mov	r0, r4
 800a50e:	f7ff fdb1 	bl	800a074 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a512:	2300      	movs	r3, #0
 800a514:	6423      	str	r3, [r4, #64]	; 0x40
    return;
 800a516:	e797      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
      &&((isrflags & USART_SR_IDLE) != 0U)
 800a518:	f013 0f10 	tst.w	r3, #16
 800a51c:	d086      	beq.n	800a42c <HAL_UART_IRQHandler+0x34>
      &&((cr1its & USART_SR_IDLE) != 0U))
 800a51e:	f010 0f10 	tst.w	r0, #16
 800a522:	d083      	beq.n	800a42c <HAL_UART_IRQHandler+0x34>
    __HAL_UART_CLEAR_IDLEFLAG(huart);
 800a524:	2300      	movs	r3, #0
 800a526:	9301      	str	r3, [sp, #4]
 800a528:	6813      	ldr	r3, [r2, #0]
 800a52a:	9301      	str	r3, [sp, #4]
 800a52c:	6853      	ldr	r3, [r2, #4]
 800a52e:	9301      	str	r3, [sp, #4]
 800a530:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a532:	6953      	ldr	r3, [r2, #20]
 800a534:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a538:	d032      	beq.n	800a5a0 <HAL_UART_IRQHandler+0x1a8>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 800a53a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800a53c:	680b      	ldr	r3, [r1, #0]
 800a53e:	685b      	ldr	r3, [r3, #4]
 800a540:	b29b      	uxth	r3, r3
      if (  (nb_remaining_rx_data > 0U)
 800a542:	2b00      	cmp	r3, #0
 800a544:	d080      	beq.n	800a448 <HAL_UART_IRQHandler+0x50>
          &&(nb_remaining_rx_data < huart->RxXferSize))
 800a546:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 800a548:	4298      	cmp	r0, r3
 800a54a:	f67f af7d 	bls.w	800a448 <HAL_UART_IRQHandler+0x50>
        huart->RxXferCount = nb_remaining_rx_data;
 800a54e:	85e3      	strh	r3, [r4, #46]	; 0x2e
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 800a550:	698b      	ldr	r3, [r1, #24]
 800a552:	2b20      	cmp	r3, #32
 800a554:	d108      	bne.n	800a568 <HAL_UART_IRQHandler+0x170>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 800a556:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 800a558:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800a55a:	b29b      	uxth	r3, r3
 800a55c:	1ac9      	subs	r1, r1, r3
 800a55e:	b289      	uxth	r1, r1
 800a560:	4620      	mov	r0, r4
 800a562:	f7ff fede 	bl	800a322 <HAL_UARTEx_RxEventCallback>
      return;
 800a566:	e76f      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a568:	68d3      	ldr	r3, [r2, #12]
 800a56a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a56e:	60d3      	str	r3, [r2, #12]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a570:	6822      	ldr	r2, [r4, #0]
 800a572:	6953      	ldr	r3, [r2, #20]
 800a574:	f023 0301 	bic.w	r3, r3, #1
 800a578:	6153      	str	r3, [r2, #20]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a57a:	6822      	ldr	r2, [r4, #0]
 800a57c:	6953      	ldr	r3, [r2, #20]
 800a57e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a582:	6153      	str	r3, [r2, #20]
          huart->RxState = HAL_UART_STATE_READY;
 800a584:	2320      	movs	r3, #32
 800a586:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a58a:	2300      	movs	r3, #0
 800a58c:	6323      	str	r3, [r4, #48]	; 0x30
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a58e:	6822      	ldr	r2, [r4, #0]
 800a590:	68d3      	ldr	r3, [r2, #12]
 800a592:	f023 0310 	bic.w	r3, r3, #16
 800a596:	60d3      	str	r3, [r2, #12]
          (void)HAL_DMA_Abort(huart->hdmarx);
 800a598:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a59a:	f7f9 f99b 	bl	80038d4 <HAL_DMA_Abort>
 800a59e:	e7da      	b.n	800a556 <HAL_UART_IRQHandler+0x15e>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 800a5a0:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 800a5a2:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800a5a4:	b29b      	uxth	r3, r3
 800a5a6:	1ac9      	subs	r1, r1, r3
 800a5a8:	b289      	uxth	r1, r1
      if (  (huart->RxXferCount > 0U)
 800a5aa:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800a5ac:	b29b      	uxth	r3, r3
 800a5ae:	2b00      	cmp	r3, #0
 800a5b0:	f43f af4a 	beq.w	800a448 <HAL_UART_IRQHandler+0x50>
          &&(nb_rx_data > 0U) )
 800a5b4:	2900      	cmp	r1, #0
 800a5b6:	f43f af47 	beq.w	800a448 <HAL_UART_IRQHandler+0x50>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a5ba:	68d3      	ldr	r3, [r2, #12]
 800a5bc:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800a5c0:	60d3      	str	r3, [r2, #12]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a5c2:	6822      	ldr	r2, [r4, #0]
 800a5c4:	6953      	ldr	r3, [r2, #20]
 800a5c6:	f023 0301 	bic.w	r3, r3, #1
 800a5ca:	6153      	str	r3, [r2, #20]
        huart->RxState = HAL_UART_STATE_READY;
 800a5cc:	2320      	movs	r3, #32
 800a5ce:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a5d2:	2300      	movs	r3, #0
 800a5d4:	6323      	str	r3, [r4, #48]	; 0x30
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a5d6:	6822      	ldr	r2, [r4, #0]
 800a5d8:	68d3      	ldr	r3, [r2, #12]
 800a5da:	f023 0310 	bic.w	r3, r3, #16
 800a5de:	60d3      	str	r3, [r2, #12]
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 800a5e0:	4620      	mov	r0, r4
 800a5e2:	f7ff fe9e 	bl	800a322 <HAL_UARTEx_RxEventCallback>
      return;
 800a5e6:	e72f      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
    UART_Transmit_IT(huart);
 800a5e8:	4620      	mov	r0, r4
 800a5ea:	f7ff f82b 	bl	8009644 <UART_Transmit_IT>
    return;
 800a5ee:	e72b      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
    UART_EndTransmit_IT(huart);
 800a5f0:	4620      	mov	r0, r4
 800a5f2:	f7ff fd2a 	bl	800a04a <UART_EndTransmit_IT>
    return;
 800a5f6:	e727      	b.n	800a448 <HAL_UART_IRQHandler+0x50>
 800a5f8:	0800a0cf 	.word	0x0800a0cf

0800a5fc <UART_DMARxHalfCplt>:
{
 800a5fc:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a5fe:	6a40      	ldr	r0, [r0, #36]	; 0x24
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a600:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a602:	2b01      	cmp	r3, #1
 800a604:	d002      	beq.n	800a60c <UART_DMARxHalfCplt+0x10>
    HAL_UART_RxHalfCpltCallback(huart);
 800a606:	f7ff fd34 	bl	800a072 <HAL_UART_RxHalfCpltCallback>
}
 800a60a:	bd08      	pop	{r3, pc}
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize/2U);
 800a60c:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 800a60e:	0849      	lsrs	r1, r1, #1
 800a610:	f7ff fe87 	bl	800a322 <HAL_UARTEx_RxEventCallback>
 800a614:	e7f9      	b.n	800a60a <UART_DMARxHalfCplt+0xe>

0800a616 <UART_DMAReceiveCplt>:
{
 800a616:	b508      	push	{r3, lr}
 800a618:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800a61a:	6a40      	ldr	r0, [r0, #36]	; 0x24
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800a61c:	681b      	ldr	r3, [r3, #0]
 800a61e:	681b      	ldr	r3, [r3, #0]
 800a620:	f013 0f20 	tst.w	r3, #32
 800a624:	d116      	bne.n	800a654 <UART_DMAReceiveCplt+0x3e>
    huart->RxXferCount = 0U;
 800a626:	2300      	movs	r3, #0
 800a628:	85c3      	strh	r3, [r0, #46]	; 0x2e
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a62a:	6802      	ldr	r2, [r0, #0]
 800a62c:	68d3      	ldr	r3, [r2, #12]
 800a62e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a632:	60d3      	str	r3, [r2, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a634:	6802      	ldr	r2, [r0, #0]
 800a636:	6953      	ldr	r3, [r2, #20]
 800a638:	f023 0301 	bic.w	r3, r3, #1
 800a63c:	6153      	str	r3, [r2, #20]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a63e:	6802      	ldr	r2, [r0, #0]
 800a640:	6953      	ldr	r3, [r2, #20]
 800a642:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a646:	6153      	str	r3, [r2, #20]
    huart->RxState = HAL_UART_STATE_READY;
 800a648:	2320      	movs	r3, #32
 800a64a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a64e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a650:	2b01      	cmp	r3, #1
 800a652:	d005      	beq.n	800a660 <UART_DMAReceiveCplt+0x4a>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a654:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a656:	2b01      	cmp	r3, #1
 800a658:	d008      	beq.n	800a66c <UART_DMAReceiveCplt+0x56>
    HAL_UART_RxCpltCallback(huart);
 800a65a:	f7f5 ff9d 	bl	8000598 <HAL_UART_RxCpltCallback>
}
 800a65e:	bd08      	pop	{r3, pc}
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a660:	6802      	ldr	r2, [r0, #0]
 800a662:	68d3      	ldr	r3, [r2, #12]
 800a664:	f023 0310 	bic.w	r3, r3, #16
 800a668:	60d3      	str	r3, [r2, #12]
 800a66a:	e7f3      	b.n	800a654 <UART_DMAReceiveCplt+0x3e>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800a66c:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 800a66e:	f7ff fe58 	bl	800a322 <HAL_UARTEx_RxEventCallback>
 800a672:	e7f4      	b.n	800a65e <UART_DMAReceiveCplt+0x48>

0800a674 <HAL_LIN_SendBreak>:
  __HAL_LOCK(huart);
 800a674:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a678:	2b01      	cmp	r3, #1
 800a67a:	d012      	beq.n	800a6a2 <HAL_LIN_SendBreak+0x2e>
 800a67c:	2301      	movs	r3, #1
 800a67e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_BUSY;
 800a682:	2324      	movs	r3, #36	; 0x24
 800a684:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
 800a688:	6802      	ldr	r2, [r0, #0]
 800a68a:	68d3      	ldr	r3, [r2, #12]
 800a68c:	f043 0301 	orr.w	r3, r3, #1
 800a690:	60d3      	str	r3, [r2, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a692:	2320      	movs	r3, #32
 800a694:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(huart);
 800a698:	2300      	movs	r3, #0
 800a69a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800a69e:	4618      	mov	r0, r3
 800a6a0:	4770      	bx	lr
  __HAL_LOCK(huart);
 800a6a2:	2002      	movs	r0, #2
}
 800a6a4:	4770      	bx	lr

0800a6a6 <HAL_MultiProcessor_EnterMuteMode>:
  __HAL_LOCK(huart);
 800a6a6:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a6aa:	2b01      	cmp	r3, #1
 800a6ac:	d012      	beq.n	800a6d4 <HAL_MultiProcessor_EnterMuteMode+0x2e>
 800a6ae:	2301      	movs	r3, #1
 800a6b0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_BUSY;
 800a6b4:	2324      	movs	r3, #36	; 0x24
 800a6b6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
 800a6ba:	6802      	ldr	r2, [r0, #0]
 800a6bc:	68d3      	ldr	r3, [r2, #12]
 800a6be:	f043 0302 	orr.w	r3, r3, #2
 800a6c2:	60d3      	str	r3, [r2, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a6c4:	2320      	movs	r3, #32
 800a6c6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(huart);
 800a6ca:	2300      	movs	r3, #0
 800a6cc:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800a6d0:	4618      	mov	r0, r3
 800a6d2:	4770      	bx	lr
  __HAL_LOCK(huart);
 800a6d4:	2002      	movs	r0, #2
}
 800a6d6:	4770      	bx	lr

0800a6d8 <HAL_MultiProcessor_ExitMuteMode>:
  __HAL_LOCK(huart);
 800a6d8:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a6dc:	2b01      	cmp	r3, #1
 800a6de:	d012      	beq.n	800a706 <HAL_MultiProcessor_ExitMuteMode+0x2e>
 800a6e0:	2301      	movs	r3, #1
 800a6e2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_BUSY;
 800a6e6:	2324      	movs	r3, #36	; 0x24
 800a6e8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
 800a6ec:	6802      	ldr	r2, [r0, #0]
 800a6ee:	68d3      	ldr	r3, [r2, #12]
 800a6f0:	f023 0302 	bic.w	r3, r3, #2
 800a6f4:	60d3      	str	r3, [r2, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a6f6:	2320      	movs	r3, #32
 800a6f8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(huart);
 800a6fc:	2300      	movs	r3, #0
 800a6fe:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800a702:	4618      	mov	r0, r3
 800a704:	4770      	bx	lr
  __HAL_LOCK(huart);
 800a706:	2002      	movs	r0, #2
}
 800a708:	4770      	bx	lr

0800a70a <HAL_HalfDuplex_EnableTransmitter>:
  __HAL_LOCK(huart);
 800a70a:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a70e:	2b01      	cmp	r3, #1
 800a710:	d014      	beq.n	800a73c <HAL_HalfDuplex_EnableTransmitter+0x32>
 800a712:	2301      	movs	r3, #1
 800a714:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_BUSY;
 800a718:	2324      	movs	r3, #36	; 0x24
 800a71a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  tmpreg = huart->Instance->CR1;
 800a71e:	6802      	ldr	r2, [r0, #0]
 800a720:	68d3      	ldr	r3, [r2, #12]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
 800a722:	f023 030c 	bic.w	r3, r3, #12
  tmpreg |= (uint32_t)USART_CR1_TE;
 800a726:	f043 0308 	orr.w	r3, r3, #8
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 800a72a:	60d3      	str	r3, [r2, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a72c:	2320      	movs	r3, #32
 800a72e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(huart);
 800a732:	2300      	movs	r3, #0
 800a734:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800a738:	4618      	mov	r0, r3
 800a73a:	4770      	bx	lr
  __HAL_LOCK(huart);
 800a73c:	2002      	movs	r0, #2
}
 800a73e:	4770      	bx	lr

0800a740 <HAL_HalfDuplex_EnableReceiver>:
  __HAL_LOCK(huart);
 800a740:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a744:	2b01      	cmp	r3, #1
 800a746:	d014      	beq.n	800a772 <HAL_HalfDuplex_EnableReceiver+0x32>
 800a748:	2301      	movs	r3, #1
 800a74a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_BUSY;
 800a74e:	2324      	movs	r3, #36	; 0x24
 800a750:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  tmpreg = huart->Instance->CR1;
 800a754:	6802      	ldr	r2, [r0, #0]
 800a756:	68d3      	ldr	r3, [r2, #12]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
 800a758:	f023 030c 	bic.w	r3, r3, #12
  tmpreg |= (uint32_t)USART_CR1_RE;
 800a75c:	f043 0304 	orr.w	r3, r3, #4
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 800a760:	60d3      	str	r3, [r2, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a762:	2320      	movs	r3, #32
 800a764:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UNLOCK(huart);
 800a768:	2300      	movs	r3, #0
 800a76a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800a76e:	4618      	mov	r0, r3
 800a770:	4770      	bx	lr
  __HAL_LOCK(huart);
 800a772:	2002      	movs	r0, #2
}
 800a774:	4770      	bx	lr

0800a776 <HAL_UART_GetState>:
  temp1 = huart->gState;
 800a776:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  temp2 = huart->RxState;
 800a77a:	f890 003e 	ldrb.w	r0, [r0, #62]	; 0x3e
}
 800a77e:	4318      	orrs	r0, r3
 800a780:	4770      	bx	lr

0800a782 <HAL_UART_GetError>:
  return huart->ErrorCode;
 800a782:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 800a784:	4770      	bx	lr

0800a786 <UART_Start_Receive_IT>:
{
 800a786:	4603      	mov	r3, r0
  huart->pRxBuffPtr = pData;
 800a788:	6281      	str	r1, [r0, #40]	; 0x28
  huart->RxXferSize = Size;
 800a78a:	8582      	strh	r2, [r0, #44]	; 0x2c
  huart->RxXferCount = Size;
 800a78c:	85c2      	strh	r2, [r0, #46]	; 0x2e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a78e:	2000      	movs	r0, #0
 800a790:	6418      	str	r0, [r3, #64]	; 0x40
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800a792:	2222      	movs	r2, #34	; 0x22
 800a794:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  __HAL_UNLOCK(huart);
 800a798:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
 800a79c:	6819      	ldr	r1, [r3, #0]
 800a79e:	68ca      	ldr	r2, [r1, #12]
 800a7a0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a7a4:	60ca      	str	r2, [r1, #12]
  __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
 800a7a6:	6819      	ldr	r1, [r3, #0]
 800a7a8:	694a      	ldr	r2, [r1, #20]
 800a7aa:	f042 0201 	orr.w	r2, r2, #1
 800a7ae:	614a      	str	r2, [r1, #20]
  __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
 800a7b0:	681a      	ldr	r2, [r3, #0]
 800a7b2:	68d3      	ldr	r3, [r2, #12]
 800a7b4:	f043 0320 	orr.w	r3, r3, #32
 800a7b8:	60d3      	str	r3, [r2, #12]
}
 800a7ba:	4770      	bx	lr

0800a7bc <HAL_UART_Receive_IT>:
{
 800a7bc:	b508      	push	{r3, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 800a7be:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 800a7c2:	b2db      	uxtb	r3, r3
 800a7c4:	2b20      	cmp	r3, #32
 800a7c6:	d10d      	bne.n	800a7e4 <HAL_UART_Receive_IT+0x28>
    if ((pData == NULL) || (Size == 0U))
 800a7c8:	b171      	cbz	r1, 800a7e8 <HAL_UART_Receive_IT+0x2c>
 800a7ca:	b17a      	cbz	r2, 800a7ec <HAL_UART_Receive_IT+0x30>
    __HAL_LOCK(huart);
 800a7cc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a7d0:	2b01      	cmp	r3, #1
 800a7d2:	d00d      	beq.n	800a7f0 <HAL_UART_Receive_IT+0x34>
 800a7d4:	2301      	movs	r3, #1
 800a7d6:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a7da:	2300      	movs	r3, #0
 800a7dc:	6303      	str	r3, [r0, #48]	; 0x30
    return(UART_Start_Receive_IT(huart, pData, Size));
 800a7de:	f7ff ffd2 	bl	800a786 <UART_Start_Receive_IT>
 800a7e2:	e000      	b.n	800a7e6 <HAL_UART_Receive_IT+0x2a>
    return HAL_BUSY;
 800a7e4:	2002      	movs	r0, #2
}
 800a7e6:	bd08      	pop	{r3, pc}
      return HAL_ERROR;
 800a7e8:	2001      	movs	r0, #1
 800a7ea:	e7fc      	b.n	800a7e6 <HAL_UART_Receive_IT+0x2a>
 800a7ec:	2001      	movs	r0, #1
 800a7ee:	e7fa      	b.n	800a7e6 <HAL_UART_Receive_IT+0x2a>
    __HAL_LOCK(huart);
 800a7f0:	2002      	movs	r0, #2
 800a7f2:	e7f8      	b.n	800a7e6 <HAL_UART_Receive_IT+0x2a>

0800a7f4 <HAL_UARTEx_ReceiveToIdle_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 800a7f4:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 800a7f8:	b2db      	uxtb	r3, r3
 800a7fa:	2b20      	cmp	r3, #32
 800a7fc:	d121      	bne.n	800a842 <HAL_UARTEx_ReceiveToIdle_IT+0x4e>
{
 800a7fe:	b510      	push	{r4, lr}
 800a800:	b082      	sub	sp, #8
 800a802:	4604      	mov	r4, r0
    if ((pData == NULL) || (Size == 0U))
 800a804:	b1f9      	cbz	r1, 800a846 <HAL_UARTEx_ReceiveToIdle_IT+0x52>
 800a806:	b302      	cbz	r2, 800a84a <HAL_UARTEx_ReceiveToIdle_IT+0x56>
    __HAL_LOCK(huart);
 800a808:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a80c:	2b01      	cmp	r3, #1
 800a80e:	d01f      	beq.n	800a850 <HAL_UARTEx_ReceiveToIdle_IT+0x5c>
 800a810:	2301      	movs	r3, #1
 800a812:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
 800a816:	6303      	str	r3, [r0, #48]	; 0x30
    status =  UART_Start_Receive_IT(huart, pData, Size);
 800a818:	f7ff ffb5 	bl	800a786 <UART_Start_Receive_IT>
    if (status == HAL_OK)
 800a81c:	b9b0      	cbnz	r0, 800a84c <HAL_UARTEx_ReceiveToIdle_IT+0x58>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a81e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a820:	2b01      	cmp	r3, #1
 800a822:	d001      	beq.n	800a828 <HAL_UARTEx_ReceiveToIdle_IT+0x34>
        status = HAL_ERROR;
 800a824:	2001      	movs	r0, #1
    return status;
 800a826:	e011      	b.n	800a84c <HAL_UARTEx_ReceiveToIdle_IT+0x58>
        __HAL_UART_CLEAR_IDLEFLAG(huart);
 800a828:	2300      	movs	r3, #0
 800a82a:	9301      	str	r3, [sp, #4]
 800a82c:	6823      	ldr	r3, [r4, #0]
 800a82e:	681a      	ldr	r2, [r3, #0]
 800a830:	9201      	str	r2, [sp, #4]
 800a832:	685a      	ldr	r2, [r3, #4]
 800a834:	9201      	str	r2, [sp, #4]
 800a836:	9a01      	ldr	r2, [sp, #4]
        SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a838:	68da      	ldr	r2, [r3, #12]
 800a83a:	f042 0210 	orr.w	r2, r2, #16
 800a83e:	60da      	str	r2, [r3, #12]
 800a840:	e004      	b.n	800a84c <HAL_UARTEx_ReceiveToIdle_IT+0x58>
    return HAL_BUSY;
 800a842:	2002      	movs	r0, #2
}
 800a844:	4770      	bx	lr
      return HAL_ERROR;
 800a846:	2001      	movs	r0, #1
 800a848:	e000      	b.n	800a84c <HAL_UARTEx_ReceiveToIdle_IT+0x58>
 800a84a:	2001      	movs	r0, #1
}
 800a84c:	b002      	add	sp, #8
 800a84e:	bd10      	pop	{r4, pc}
    __HAL_LOCK(huart);
 800a850:	2002      	movs	r0, #2
 800a852:	e7fb      	b.n	800a84c <HAL_UARTEx_ReceiveToIdle_IT+0x58>

0800a854 <UART_Start_Receive_DMA>:
{
 800a854:	b530      	push	{r4, r5, lr}
 800a856:	b083      	sub	sp, #12
 800a858:	4604      	mov	r4, r0
 800a85a:	4613      	mov	r3, r2
  huart->pRxBuffPtr = pData;
 800a85c:	6281      	str	r1, [r0, #40]	; 0x28
  huart->RxXferSize = Size;
 800a85e:	8582      	strh	r2, [r0, #44]	; 0x2c
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a860:	2500      	movs	r5, #0
 800a862:	6405      	str	r5, [r0, #64]	; 0x40
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800a864:	2222      	movs	r2, #34	; 0x22
 800a866:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
  huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800a86a:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800a86c:	4814      	ldr	r0, [pc, #80]	; (800a8c0 <UART_Start_Receive_DMA+0x6c>)
 800a86e:	6290      	str	r0, [r2, #40]	; 0x28
  huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800a870:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a872:	4814      	ldr	r0, [pc, #80]	; (800a8c4 <UART_Start_Receive_DMA+0x70>)
 800a874:	62d0      	str	r0, [r2, #44]	; 0x2c
  huart->hdmarx->XferErrorCallback = UART_DMAError;
 800a876:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a878:	4813      	ldr	r0, [pc, #76]	; (800a8c8 <UART_Start_Receive_DMA+0x74>)
 800a87a:	6310      	str	r0, [r2, #48]	; 0x30
  huart->hdmarx->XferAbortCallback = NULL;
 800a87c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a87e:	6355      	str	r5, [r2, #52]	; 0x34
  HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 800a880:	6820      	ldr	r0, [r4, #0]
 800a882:	460a      	mov	r2, r1
 800a884:	1d01      	adds	r1, r0, #4
 800a886:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a888:	f7f8 ffea 	bl	8003860 <HAL_DMA_Start_IT>
  __HAL_UART_CLEAR_OREFLAG(huart);
 800a88c:	9501      	str	r5, [sp, #4]
 800a88e:	6823      	ldr	r3, [r4, #0]
 800a890:	681a      	ldr	r2, [r3, #0]
 800a892:	9201      	str	r2, [sp, #4]
 800a894:	685a      	ldr	r2, [r3, #4]
 800a896:	9201      	str	r2, [sp, #4]
 800a898:	9a01      	ldr	r2, [sp, #4]
  __HAL_UNLOCK(huart);
 800a89a:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
  SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a89e:	68da      	ldr	r2, [r3, #12]
 800a8a0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a8a4:	60da      	str	r2, [r3, #12]
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a8a6:	6822      	ldr	r2, [r4, #0]
 800a8a8:	6953      	ldr	r3, [r2, #20]
 800a8aa:	f043 0301 	orr.w	r3, r3, #1
 800a8ae:	6153      	str	r3, [r2, #20]
  SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a8b0:	6822      	ldr	r2, [r4, #0]
 800a8b2:	6953      	ldr	r3, [r2, #20]
 800a8b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a8b8:	6153      	str	r3, [r2, #20]
}
 800a8ba:	4628      	mov	r0, r5
 800a8bc:	b003      	add	sp, #12
 800a8be:	bd30      	pop	{r4, r5, pc}
 800a8c0:	0800a617 	.word	0x0800a617
 800a8c4:	0800a5fd 	.word	0x0800a5fd
 800a8c8:	0800a077 	.word	0x0800a077

0800a8cc <HAL_UART_Receive_DMA>:
{
 800a8cc:	b508      	push	{r3, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 800a8ce:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 800a8d2:	b2db      	uxtb	r3, r3
 800a8d4:	2b20      	cmp	r3, #32
 800a8d6:	d10d      	bne.n	800a8f4 <HAL_UART_Receive_DMA+0x28>
    if ((pData == NULL) || (Size == 0U))
 800a8d8:	b171      	cbz	r1, 800a8f8 <HAL_UART_Receive_DMA+0x2c>
 800a8da:	b17a      	cbz	r2, 800a8fc <HAL_UART_Receive_DMA+0x30>
    __HAL_LOCK(huart);
 800a8dc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a8e0:	2b01      	cmp	r3, #1
 800a8e2:	d00d      	beq.n	800a900 <HAL_UART_Receive_DMA+0x34>
 800a8e4:	2301      	movs	r3, #1
 800a8e6:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a8ea:	2300      	movs	r3, #0
 800a8ec:	6303      	str	r3, [r0, #48]	; 0x30
    return(UART_Start_Receive_DMA(huart, pData, Size));
 800a8ee:	f7ff ffb1 	bl	800a854 <UART_Start_Receive_DMA>
 800a8f2:	e000      	b.n	800a8f6 <HAL_UART_Receive_DMA+0x2a>
    return HAL_BUSY;
 800a8f4:	2002      	movs	r0, #2
}
 800a8f6:	bd08      	pop	{r3, pc}
      return HAL_ERROR;
 800a8f8:	2001      	movs	r0, #1
 800a8fa:	e7fc      	b.n	800a8f6 <HAL_UART_Receive_DMA+0x2a>
 800a8fc:	2001      	movs	r0, #1
 800a8fe:	e7fa      	b.n	800a8f6 <HAL_UART_Receive_DMA+0x2a>
    __HAL_LOCK(huart);
 800a900:	2002      	movs	r0, #2
 800a902:	e7f8      	b.n	800a8f6 <HAL_UART_Receive_DMA+0x2a>

0800a904 <HAL_UARTEx_ReceiveToIdle_DMA>:
  if (huart->RxState == HAL_UART_STATE_READY)
 800a904:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 800a908:	b2db      	uxtb	r3, r3
 800a90a:	2b20      	cmp	r3, #32
 800a90c:	d121      	bne.n	800a952 <HAL_UARTEx_ReceiveToIdle_DMA+0x4e>
{
 800a90e:	b510      	push	{r4, lr}
 800a910:	b082      	sub	sp, #8
 800a912:	4604      	mov	r4, r0
    if ((pData == NULL) || (Size == 0U))
 800a914:	b1f9      	cbz	r1, 800a956 <HAL_UARTEx_ReceiveToIdle_DMA+0x52>
 800a916:	b302      	cbz	r2, 800a95a <HAL_UARTEx_ReceiveToIdle_DMA+0x56>
    __HAL_LOCK(huart);
 800a918:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800a91c:	2b01      	cmp	r3, #1
 800a91e:	d01f      	beq.n	800a960 <HAL_UARTEx_ReceiveToIdle_DMA+0x5c>
 800a920:	2301      	movs	r3, #1
 800a922:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
 800a926:	6303      	str	r3, [r0, #48]	; 0x30
    status =  UART_Start_Receive_DMA(huart, pData, Size);
 800a928:	f7ff ff94 	bl	800a854 <UART_Start_Receive_DMA>
    if (status == HAL_OK)
 800a92c:	b9b0      	cbnz	r0, 800a95c <HAL_UARTEx_ReceiveToIdle_DMA+0x58>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a92e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a930:	2b01      	cmp	r3, #1
 800a932:	d001      	beq.n	800a938 <HAL_UARTEx_ReceiveToIdle_DMA+0x34>
        status = HAL_ERROR;
 800a934:	2001      	movs	r0, #1
    return status;
 800a936:	e011      	b.n	800a95c <HAL_UARTEx_ReceiveToIdle_DMA+0x58>
        __HAL_UART_CLEAR_IDLEFLAG(huart);
 800a938:	2300      	movs	r3, #0
 800a93a:	9301      	str	r3, [sp, #4]
 800a93c:	6823      	ldr	r3, [r4, #0]
 800a93e:	681a      	ldr	r2, [r3, #0]
 800a940:	9201      	str	r2, [sp, #4]
 800a942:	685a      	ldr	r2, [r3, #4]
 800a944:	9201      	str	r2, [sp, #4]
 800a946:	9a01      	ldr	r2, [sp, #4]
        SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a948:	68da      	ldr	r2, [r3, #12]
 800a94a:	f042 0210 	orr.w	r2, r2, #16
 800a94e:	60da      	str	r2, [r3, #12]
 800a950:	e004      	b.n	800a95c <HAL_UARTEx_ReceiveToIdle_DMA+0x58>
    return HAL_BUSY;
 800a952:	2002      	movs	r0, #2
}
 800a954:	4770      	bx	lr
      return HAL_ERROR;
 800a956:	2001      	movs	r0, #1
 800a958:	e000      	b.n	800a95c <HAL_UARTEx_ReceiveToIdle_DMA+0x58>
 800a95a:	2001      	movs	r0, #1
}
 800a95c:	b002      	add	sp, #8
 800a95e:	bd10      	pop	{r4, pc}
    __HAL_LOCK(huart);
 800a960:	2002      	movs	r0, #2
 800a962:	e7fb      	b.n	800a95c <HAL_UARTEx_ReceiveToIdle_DMA+0x58>

0800a964 <TimerCallback>:
  return (stat);
}

/*---------------------------------------------------------------------------*/

static void TimerCallback (TimerHandle_t hTimer) {
 800a964:	b508      	push	{r3, lr}
  TimerCallback_t *callb;

  callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
 800a966:	f004 fb75 	bl	800f054 <pvTimerGetTimerID>

  if (callb != NULL) {
 800a96a:	b110      	cbz	r0, 800a972 <TimerCallback+0xe>
    callb->func (callb->arg);
 800a96c:	6802      	ldr	r2, [r0, #0]
 800a96e:	6840      	ldr	r0, [r0, #4]
 800a970:	4790      	blx	r2
  }
}
 800a972:	bd08      	pop	{r3, pc}

0800a974 <osKernelInitialize>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800a974:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800a978:	b993      	cbnz	r3, 800a9a0 <osKernelInitialize+0x2c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800a97a:	f3ef 8310 	mrs	r3, PRIMASK
 800a97e:	b993      	cbnz	r3, 800a9a6 <osKernelInitialize+0x32>
 800a980:	4b0c      	ldr	r3, [pc, #48]	; (800a9b4 <osKernelInitialize+0x40>)
 800a982:	6818      	ldr	r0, [r3, #0]
 800a984:	2802      	cmp	r0, #2
 800a986:	d004      	beq.n	800a992 <osKernelInitialize+0x1e>
    if (KernelState == osKernelInactive) {
 800a988:	b980      	cbnz	r0, 800a9ac <osKernelInitialize+0x38>
      KernelState = osKernelReady;
 800a98a:	4b0a      	ldr	r3, [pc, #40]	; (800a9b4 <osKernelInitialize+0x40>)
 800a98c:	2201      	movs	r2, #1
 800a98e:	601a      	str	r2, [r3, #0]
      stat = osOK;
 800a990:	4770      	bx	lr
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a992:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800a996:	2b00      	cmp	r3, #0
 800a998:	d0f6      	beq.n	800a988 <osKernelInitialize+0x14>
    stat = osErrorISR;
 800a99a:	f06f 0005 	mvn.w	r0, #5
 800a99e:	4770      	bx	lr
 800a9a0:	f06f 0005 	mvn.w	r0, #5
 800a9a4:	4770      	bx	lr
 800a9a6:	f06f 0005 	mvn.w	r0, #5
 800a9aa:	4770      	bx	lr
      stat = osError;
 800a9ac:	f04f 30ff 	mov.w	r0, #4294967295
}
 800a9b0:	4770      	bx	lr
 800a9b2:	bf00      	nop
 800a9b4:	200001c8 	.word	0x200001c8

0800a9b8 <osKernelGetInfo>:
osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
 800a9b8:	b508      	push	{r3, lr}
 800a9ba:	460b      	mov	r3, r1
  if (version != NULL) {
 800a9bc:	b118      	cbz	r0, 800a9c6 <osKernelGetInfo+0xe>
 800a9be:	4601      	mov	r1, r0
    version->api    = KERNEL_VERSION;
 800a9c0:	4806      	ldr	r0, [pc, #24]	; (800a9dc <osKernelGetInfo+0x24>)
 800a9c2:	6008      	str	r0, [r1, #0]
    version->kernel = KERNEL_VERSION;
 800a9c4:	6048      	str	r0, [r1, #4]
  if ((id_buf != NULL) && (id_size != 0U)) {
 800a9c6:	b13b      	cbz	r3, 800a9d8 <osKernelGetInfo+0x20>
 800a9c8:	b132      	cbz	r2, 800a9d8 <osKernelGetInfo+0x20>
    if (id_size > sizeof(KERNEL_ID)) {
 800a9ca:	2a11      	cmp	r2, #17
 800a9cc:	d900      	bls.n	800a9d0 <osKernelGetInfo+0x18>
      id_size = sizeof(KERNEL_ID);
 800a9ce:	2211      	movs	r2, #17
    memcpy(id_buf, KERNEL_ID, id_size);
 800a9d0:	4903      	ldr	r1, [pc, #12]	; (800a9e0 <osKernelGetInfo+0x28>)
 800a9d2:	4618      	mov	r0, r3
 800a9d4:	f005 f85c 	bl	800fa90 <memcpy>
}
 800a9d8:	2000      	movs	r0, #0
 800a9da:	bd08      	pop	{r3, pc}
 800a9dc:	05f5e101 	.word	0x05f5e101
 800a9e0:	0800fe94 	.word	0x0800fe94

0800a9e4 <osKernelGetState>:
osKernelState_t osKernelGetState (void) {
 800a9e4:	b508      	push	{r3, lr}
  switch (xTaskGetSchedulerState()) {
 800a9e6:	f003 fd55 	bl	800e494 <xTaskGetSchedulerState>
 800a9ea:	b140      	cbz	r0, 800a9fe <osKernelGetState+0x1a>
 800a9ec:	4603      	mov	r3, r0
 800a9ee:	2802      	cmp	r0, #2
 800a9f0:	d006      	beq.n	800aa00 <osKernelGetState+0x1c>
      if (KernelState == osKernelReady) {
 800a9f2:	4b04      	ldr	r3, [pc, #16]	; (800aa04 <osKernelGetState+0x20>)
 800a9f4:	681b      	ldr	r3, [r3, #0]
 800a9f6:	2b01      	cmp	r3, #1
 800a9f8:	d002      	beq.n	800aa00 <osKernelGetState+0x1c>
        state = osKernelInactive;
 800a9fa:	2300      	movs	r3, #0
  return (state);
 800a9fc:	e000      	b.n	800aa00 <osKernelGetState+0x1c>
      state = osKernelLocked;
 800a9fe:	2303      	movs	r3, #3
}
 800aa00:	4618      	mov	r0, r3
 800aa02:	bd08      	pop	{r3, pc}
 800aa04:	200001c8 	.word	0x200001c8

0800aa08 <osKernelStart>:
osStatus_t osKernelStart (void) {
 800aa08:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800aa0a:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800aa0e:	b9b3      	cbnz	r3, 800aa3e <osKernelStart+0x36>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800aa10:	f3ef 8310 	mrs	r3, PRIMASK
 800aa14:	b9b3      	cbnz	r3, 800aa44 <osKernelStart+0x3c>
 800aa16:	4b0e      	ldr	r3, [pc, #56]	; (800aa50 <osKernelStart+0x48>)
 800aa18:	681b      	ldr	r3, [r3, #0]
 800aa1a:	2b02      	cmp	r3, #2
 800aa1c:	d008      	beq.n	800aa30 <osKernelStart+0x28>
    if (KernelState == osKernelReady) {
 800aa1e:	2b01      	cmp	r3, #1
 800aa20:	d113      	bne.n	800aa4a <osKernelStart+0x42>
      KernelState = osKernelRunning;
 800aa22:	4b0b      	ldr	r3, [pc, #44]	; (800aa50 <osKernelStart+0x48>)
 800aa24:	2202      	movs	r2, #2
 800aa26:	601a      	str	r2, [r3, #0]
      vTaskStartScheduler();
 800aa28:	f003 f846 	bl	800dab8 <vTaskStartScheduler>
      stat = osOK;
 800aa2c:	2000      	movs	r0, #0
}
 800aa2e:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa30:	f3ef 8211 	mrs	r2, BASEPRI
  if (IS_IRQ()) {
 800aa34:	2a00      	cmp	r2, #0
 800aa36:	d0f2      	beq.n	800aa1e <osKernelStart+0x16>
    stat = osErrorISR;
 800aa38:	f06f 0005 	mvn.w	r0, #5
 800aa3c:	e7f7      	b.n	800aa2e <osKernelStart+0x26>
 800aa3e:	f06f 0005 	mvn.w	r0, #5
 800aa42:	e7f4      	b.n	800aa2e <osKernelStart+0x26>
 800aa44:	f06f 0005 	mvn.w	r0, #5
 800aa48:	e7f1      	b.n	800aa2e <osKernelStart+0x26>
      stat = osError;
 800aa4a:	f04f 30ff 	mov.w	r0, #4294967295
  return (stat);
 800aa4e:	e7ee      	b.n	800aa2e <osKernelStart+0x26>
 800aa50:	200001c8 	.word	0x200001c8

0800aa54 <osKernelLock>:
int32_t osKernelLock (void) {
 800aa54:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800aa56:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800aa5a:	b993      	cbnz	r3, 800aa82 <osKernelLock+0x2e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800aa5c:	f3ef 8310 	mrs	r3, PRIMASK
 800aa60:	b993      	cbnz	r3, 800aa88 <osKernelLock+0x34>
 800aa62:	4b0f      	ldr	r3, [pc, #60]	; (800aaa0 <osKernelLock+0x4c>)
 800aa64:	681b      	ldr	r3, [r3, #0]
 800aa66:	2b02      	cmp	r3, #2
 800aa68:	d102      	bne.n	800aa70 <osKernelLock+0x1c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa6a:	f3ef 8311 	mrs	r3, BASEPRI
 800aa6e:	b973      	cbnz	r3, 800aa8e <osKernelLock+0x3a>
    switch (xTaskGetSchedulerState()) {
 800aa70:	f003 fd10 	bl	800e494 <xTaskGetSchedulerState>
 800aa74:	b170      	cbz	r0, 800aa94 <osKernelLock+0x40>
 800aa76:	2802      	cmp	r0, #2
 800aa78:	d10e      	bne.n	800aa98 <osKernelLock+0x44>
        vTaskSuspendAll();
 800aa7a:	f003 f879 	bl	800db70 <vTaskSuspendAll>
        lock = 0;
 800aa7e:	2000      	movs	r0, #0
        break;
 800aa80:	e00c      	b.n	800aa9c <osKernelLock+0x48>
    lock = (int32_t)osErrorISR;
 800aa82:	f06f 0005 	mvn.w	r0, #5
 800aa86:	e009      	b.n	800aa9c <osKernelLock+0x48>
 800aa88:	f06f 0005 	mvn.w	r0, #5
 800aa8c:	e006      	b.n	800aa9c <osKernelLock+0x48>
 800aa8e:	f06f 0005 	mvn.w	r0, #5
 800aa92:	e003      	b.n	800aa9c <osKernelLock+0x48>
    switch (xTaskGetSchedulerState()) {
 800aa94:	2001      	movs	r0, #1
 800aa96:	e001      	b.n	800aa9c <osKernelLock+0x48>
        lock = (int32_t)osError;
 800aa98:	f04f 30ff 	mov.w	r0, #4294967295
}
 800aa9c:	bd08      	pop	{r3, pc}
 800aa9e:	bf00      	nop
 800aaa0:	200001c8 	.word	0x200001c8

0800aaa4 <osKernelUnlock>:
int32_t osKernelUnlock (void) {
 800aaa4:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800aaa6:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800aaaa:	b9cb      	cbnz	r3, 800aae0 <osKernelUnlock+0x3c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800aaac:	f3ef 8310 	mrs	r3, PRIMASK
 800aab0:	b9cb      	cbnz	r3, 800aae6 <osKernelUnlock+0x42>
 800aab2:	4b13      	ldr	r3, [pc, #76]	; (800ab00 <osKernelUnlock+0x5c>)
 800aab4:	681b      	ldr	r3, [r3, #0]
 800aab6:	2b02      	cmp	r3, #2
 800aab8:	d102      	bne.n	800aac0 <osKernelUnlock+0x1c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aaba:	f3ef 8311 	mrs	r3, BASEPRI
 800aabe:	b9ab      	cbnz	r3, 800aaec <osKernelUnlock+0x48>
    switch (xTaskGetSchedulerState()) {
 800aac0:	f003 fce8 	bl	800e494 <xTaskGetSchedulerState>
 800aac4:	b118      	cbz	r0, 800aace <osKernelUnlock+0x2a>
 800aac6:	2802      	cmp	r0, #2
 800aac8:	d113      	bne.n	800aaf2 <osKernelUnlock+0x4e>
 800aaca:	2000      	movs	r0, #0
}
 800aacc:	bd08      	pop	{r3, pc}
        if (xTaskResumeAll() != pdTRUE) {
 800aace:	f003 f90b 	bl	800dce8 <xTaskResumeAll>
 800aad2:	2801      	cmp	r0, #1
 800aad4:	d0fa      	beq.n	800aacc <osKernelUnlock+0x28>
          if (xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) {
 800aad6:	f003 fcdd 	bl	800e494 <xTaskGetSchedulerState>
 800aada:	b168      	cbz	r0, 800aaf8 <osKernelUnlock+0x54>
        lock = 1;
 800aadc:	2001      	movs	r0, #1
 800aade:	e7f5      	b.n	800aacc <osKernelUnlock+0x28>
    lock = (int32_t)osErrorISR;
 800aae0:	f06f 0005 	mvn.w	r0, #5
 800aae4:	e7f2      	b.n	800aacc <osKernelUnlock+0x28>
 800aae6:	f06f 0005 	mvn.w	r0, #5
 800aaea:	e7ef      	b.n	800aacc <osKernelUnlock+0x28>
 800aaec:	f06f 0005 	mvn.w	r0, #5
 800aaf0:	e7ec      	b.n	800aacc <osKernelUnlock+0x28>
        lock = (int32_t)osError;
 800aaf2:	f04f 30ff 	mov.w	r0, #4294967295
 800aaf6:	e7e9      	b.n	800aacc <osKernelUnlock+0x28>
            lock = (int32_t)osError;
 800aaf8:	f04f 30ff 	mov.w	r0, #4294967295
  return (lock);
 800aafc:	e7e6      	b.n	800aacc <osKernelUnlock+0x28>
 800aafe:	bf00      	nop
 800ab00:	200001c8 	.word	0x200001c8

0800ab04 <osKernelRestoreLock>:
int32_t osKernelRestoreLock (int32_t lock) {
 800ab04:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ab06:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800ab0a:	bb13      	cbnz	r3, 800ab52 <osKernelRestoreLock+0x4e>
 800ab0c:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ab0e:	f3ef 8310 	mrs	r3, PRIMASK
 800ab12:	bb0b      	cbnz	r3, 800ab58 <osKernelRestoreLock+0x54>
 800ab14:	4b16      	ldr	r3, [pc, #88]	; (800ab70 <osKernelRestoreLock+0x6c>)
 800ab16:	681b      	ldr	r3, [r3, #0]
 800ab18:	2b02      	cmp	r3, #2
 800ab1a:	d102      	bne.n	800ab22 <osKernelRestoreLock+0x1e>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ab1c:	f3ef 8311 	mrs	r3, BASEPRI
 800ab20:	b9eb      	cbnz	r3, 800ab5e <osKernelRestoreLock+0x5a>
    switch (xTaskGetSchedulerState()) {
 800ab22:	f003 fcb7 	bl	800e494 <xTaskGetSchedulerState>
 800ab26:	b108      	cbz	r0, 800ab2c <osKernelRestoreLock+0x28>
 800ab28:	2802      	cmp	r0, #2
 800ab2a:	d11b      	bne.n	800ab64 <osKernelRestoreLock+0x60>
        if (lock == 1) {
 800ab2c:	2c01      	cmp	r4, #1
 800ab2e:	d006      	beq.n	800ab3e <osKernelRestoreLock+0x3a>
          if (lock != 0) {
 800ab30:	b9dc      	cbnz	r4, 800ab6a <osKernelRestoreLock+0x66>
            if (xTaskResumeAll() != pdTRUE) {
 800ab32:	f003 f8d9 	bl	800dce8 <xTaskResumeAll>
 800ab36:	2801      	cmp	r0, #1
 800ab38:	d104      	bne.n	800ab44 <osKernelRestoreLock+0x40>
}
 800ab3a:	4620      	mov	r0, r4
 800ab3c:	bd10      	pop	{r4, pc}
          vTaskSuspendAll();
 800ab3e:	f003 f817 	bl	800db70 <vTaskSuspendAll>
 800ab42:	e7fa      	b.n	800ab3a <osKernelRestoreLock+0x36>
              if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
 800ab44:	f003 fca6 	bl	800e494 <xTaskGetSchedulerState>
 800ab48:	2802      	cmp	r0, #2
 800ab4a:	d0f6      	beq.n	800ab3a <osKernelRestoreLock+0x36>
                lock = (int32_t)osError;
 800ab4c:	f04f 34ff 	mov.w	r4, #4294967295
 800ab50:	e7f3      	b.n	800ab3a <osKernelRestoreLock+0x36>
    lock = (int32_t)osErrorISR;
 800ab52:	f06f 0405 	mvn.w	r4, #5
 800ab56:	e7f0      	b.n	800ab3a <osKernelRestoreLock+0x36>
 800ab58:	f06f 0405 	mvn.w	r4, #5
 800ab5c:	e7ed      	b.n	800ab3a <osKernelRestoreLock+0x36>
 800ab5e:	f06f 0405 	mvn.w	r4, #5
 800ab62:	e7ea      	b.n	800ab3a <osKernelRestoreLock+0x36>
    switch (xTaskGetSchedulerState()) {
 800ab64:	f04f 34ff 	mov.w	r4, #4294967295
 800ab68:	e7e7      	b.n	800ab3a <osKernelRestoreLock+0x36>
            lock = (int32_t)osError;
 800ab6a:	f04f 34ff 	mov.w	r4, #4294967295
 800ab6e:	e7e4      	b.n	800ab3a <osKernelRestoreLock+0x36>
 800ab70:	200001c8 	.word	0x200001c8

0800ab74 <osKernelGetTickCount>:
uint32_t osKernelGetTickCount (void) {
 800ab74:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ab76:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800ab7a:	b94b      	cbnz	r3, 800ab90 <osKernelGetTickCount+0x1c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ab7c:	f3ef 8310 	mrs	r3, PRIMASK
 800ab80:	b933      	cbnz	r3, 800ab90 <osKernelGetTickCount+0x1c>
 800ab82:	4b06      	ldr	r3, [pc, #24]	; (800ab9c <osKernelGetTickCount+0x28>)
 800ab84:	681b      	ldr	r3, [r3, #0]
 800ab86:	2b02      	cmp	r3, #2
 800ab88:	d105      	bne.n	800ab96 <osKernelGetTickCount+0x22>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ab8a:	f3ef 8311 	mrs	r3, BASEPRI
 800ab8e:	b113      	cbz	r3, 800ab96 <osKernelGetTickCount+0x22>
    ticks = xTaskGetTickCountFromISR();
 800ab90:	f002 fffc 	bl	800db8c <xTaskGetTickCountFromISR>
}
 800ab94:	bd08      	pop	{r3, pc}
    ticks = xTaskGetTickCount();
 800ab96:	f002 fff3 	bl	800db80 <xTaskGetTickCount>
  return (ticks);
 800ab9a:	e7fb      	b.n	800ab94 <osKernelGetTickCount+0x20>
 800ab9c:	200001c8 	.word	0x200001c8

0800aba0 <osKernelGetTickFreq>:
}
 800aba0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800aba4:	4770      	bx	lr

0800aba6 <osKernelGetSysTimerCount>:
uint32_t osKernelGetSysTimerCount (void) {
 800aba6:	b508      	push	{r3, lr}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800aba8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800abac:	f383 8811 	msr	BASEPRI, r3
 800abb0:	f3bf 8f6f 	isb	sy
 800abb4:	f3bf 8f4f 	dsb	sy
  ticks = xTaskGetTickCount();
 800abb8:	f002 ffe2 	bl	800db80 <xTaskGetTickCount>
  val = ticks * ( configCPU_CLOCK_HZ / configTICK_RATE_HZ );
 800abbc:	4b05      	ldr	r3, [pc, #20]	; (800abd4 <osKernelGetSysTimerCount+0x2e>)
 800abbe:	681b      	ldr	r3, [r3, #0]
 800abc0:	4a05      	ldr	r2, [pc, #20]	; (800abd8 <osKernelGetSysTimerCount+0x32>)
 800abc2:	fba2 2303 	umull	r2, r3, r2, r3
 800abc6:	099b      	lsrs	r3, r3, #6
 800abc8:	fb00 f003 	mul.w	r0, r0, r3
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800abcc:	2300      	movs	r3, #0
 800abce:	f383 8811 	msr	BASEPRI, r3
}
 800abd2:	bd08      	pop	{r3, pc}
 800abd4:	20000028 	.word	0x20000028
 800abd8:	10624dd3 	.word	0x10624dd3

0800abdc <osKernelGetSysTimerFreq>:
}
 800abdc:	4b01      	ldr	r3, [pc, #4]	; (800abe4 <osKernelGetSysTimerFreq+0x8>)
 800abde:	6818      	ldr	r0, [r3, #0]
 800abe0:	4770      	bx	lr
 800abe2:	bf00      	nop
 800abe4:	20000028 	.word	0x20000028

0800abe8 <osThreadNew>:
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 800abe8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800abea:	b087      	sub	sp, #28
  hTask = NULL;
 800abec:	2400      	movs	r4, #0
 800abee:	9404      	str	r4, [sp, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800abf0:	f3ef 8405 	mrs	r4, IPSR
  if (!IS_IRQ() && (func != NULL)) {
 800abf4:	2c00      	cmp	r4, #0
 800abf6:	d143      	bne.n	800ac80 <osThreadNew+0x98>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800abf8:	f3ef 8310 	mrs	r3, PRIMASK
 800abfc:	2b00      	cmp	r3, #0
 800abfe:	d13f      	bne.n	800ac80 <osThreadNew+0x98>
 800ac00:	4b33      	ldr	r3, [pc, #204]	; (800acd0 <osThreadNew+0xe8>)
 800ac02:	681b      	ldr	r3, [r3, #0]
 800ac04:	2b02      	cmp	r3, #2
 800ac06:	d021      	beq.n	800ac4c <osThreadNew+0x64>
 800ac08:	2800      	cmp	r0, #0
 800ac0a:	d039      	beq.n	800ac80 <osThreadNew+0x98>
    empty = '\0';
 800ac0c:	2300      	movs	r3, #0
 800ac0e:	f88d 3017 	strb.w	r3, [sp, #23]
    if (attr != NULL) {
 800ac12:	b362      	cbz	r2, 800ac6e <osThreadNew+0x86>
      if (attr->name != NULL) {
 800ac14:	6815      	ldr	r5, [r2, #0]
 800ac16:	b1ed      	cbz	r5, 800ac54 <osThreadNew+0x6c>
      if (attr->priority != osPriorityNone) {
 800ac18:	6993      	ldr	r3, [r2, #24]
 800ac1a:	b903      	cbnz	r3, 800ac1e <osThreadNew+0x36>
    prio  = (UBaseType_t)osPriorityNormal;
 800ac1c:	2318      	movs	r3, #24
      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 800ac1e:	1e5c      	subs	r4, r3, #1
 800ac20:	2c37      	cmp	r4, #55	; 0x37
 800ac22:	d851      	bhi.n	800acc8 <osThreadNew+0xe0>
 800ac24:	6854      	ldr	r4, [r2, #4]
 800ac26:	f014 0f01 	tst.w	r4, #1
 800ac2a:	d14f      	bne.n	800accc <osThreadNew+0xe4>
      if (attr->stack_size > 0U) {
 800ac2c:	6956      	ldr	r6, [r2, #20]
 800ac2e:	b1a6      	cbz	r6, 800ac5a <osThreadNew+0x72>
        stack = attr->stack_size / sizeof(StackType_t);
 800ac30:	ea4f 0c96 	mov.w	ip, r6, lsr #2
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 800ac34:	6894      	ldr	r4, [r2, #8]
 800ac36:	b12c      	cbz	r4, 800ac44 <osThreadNew+0x5c>
 800ac38:	68d7      	ldr	r7, [r2, #12]
 800ac3a:	2f6b      	cmp	r7, #107	; 0x6b
 800ac3c:	d902      	bls.n	800ac44 <osThreadNew+0x5c>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 800ac3e:	6917      	ldr	r7, [r2, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 800ac40:	b107      	cbz	r7, 800ac44 <osThreadNew+0x5c>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 800ac42:	bb06      	cbnz	r6, 800ac86 <osThreadNew+0x9e>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 800ac44:	b164      	cbz	r4, 800ac60 <osThreadNew+0x78>
    mem   = -1;
 800ac46:	f04f 34ff 	mov.w	r4, #4294967295
 800ac4a:	e016      	b.n	800ac7a <osThreadNew+0x92>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ac4c:	f3ef 8311 	mrs	r3, BASEPRI
  if (!IS_IRQ() && (func != NULL)) {
 800ac50:	b9b3      	cbnz	r3, 800ac80 <osThreadNew+0x98>
 800ac52:	e7d9      	b.n	800ac08 <osThreadNew+0x20>
    name  = &empty;
 800ac54:	f10d 0517 	add.w	r5, sp, #23
 800ac58:	e7de      	b.n	800ac18 <osThreadNew+0x30>
    stack = configMINIMAL_STACK_SIZE;
 800ac5a:	f04f 0c40 	mov.w	ip, #64	; 0x40
 800ac5e:	e7e9      	b.n	800ac34 <osThreadNew+0x4c>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 800ac60:	68d4      	ldr	r4, [r2, #12]
 800ac62:	b994      	cbnz	r4, 800ac8a <osThreadNew+0xa2>
 800ac64:	6914      	ldr	r4, [r2, #16]
 800ac66:	b19c      	cbz	r4, 800ac90 <osThreadNew+0xa8>
    mem   = -1;
 800ac68:	f04f 34ff 	mov.w	r4, #4294967295
 800ac6c:	e005      	b.n	800ac7a <osThreadNew+0x92>
      mem = 0;
 800ac6e:	2400      	movs	r4, #0
    prio  = (UBaseType_t)osPriorityNormal;
 800ac70:	2318      	movs	r3, #24
    stack = configMINIMAL_STACK_SIZE;
 800ac72:	f04f 0c40 	mov.w	ip, #64	; 0x40
    name  = &empty;
 800ac76:	f10d 0517 	add.w	r5, sp, #23
    if (mem == 1) {
 800ac7a:	2c01      	cmp	r4, #1
 800ac7c:	d00a      	beq.n	800ac94 <osThreadNew+0xac>
      if (mem == 0) {
 800ac7e:	b1ac      	cbz	r4, 800acac <osThreadNew+0xc4>
  return ((osThreadId_t)hTask);
 800ac80:	9804      	ldr	r0, [sp, #16]
}
 800ac82:	b007      	add	sp, #28
 800ac84:	bdf0      	pop	{r4, r5, r6, r7, pc}
        mem = 1;
 800ac86:	2401      	movs	r4, #1
 800ac88:	e7f7      	b.n	800ac7a <osThreadNew+0x92>
    mem   = -1;
 800ac8a:	f04f 34ff 	mov.w	r4, #4294967295
 800ac8e:	e7f4      	b.n	800ac7a <osThreadNew+0x92>
          mem = 0;
 800ac90:	2400      	movs	r4, #0
 800ac92:	e7f2      	b.n	800ac7a <osThreadNew+0x92>
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 800ac94:	6914      	ldr	r4, [r2, #16]
                                                                                    (StaticTask_t *)attr->cb_mem);
 800ac96:	6892      	ldr	r2, [r2, #8]
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 800ac98:	9202      	str	r2, [sp, #8]
 800ac9a:	9401      	str	r4, [sp, #4]
 800ac9c:	9300      	str	r3, [sp, #0]
 800ac9e:	460b      	mov	r3, r1
 800aca0:	4662      	mov	r2, ip
 800aca2:	4629      	mov	r1, r5
 800aca4:	f002 fcd8 	bl	800d658 <xTaskCreateStatic>
 800aca8:	9004      	str	r0, [sp, #16]
 800acaa:	e7e9      	b.n	800ac80 <osThreadNew+0x98>
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 800acac:	aa04      	add	r2, sp, #16
 800acae:	9201      	str	r2, [sp, #4]
 800acb0:	9300      	str	r3, [sp, #0]
 800acb2:	460b      	mov	r3, r1
 800acb4:	fa1f f28c 	uxth.w	r2, ip
 800acb8:	4629      	mov	r1, r5
 800acba:	f002 fd06 	bl	800d6ca <xTaskCreate>
 800acbe:	2801      	cmp	r0, #1
 800acc0:	d0de      	beq.n	800ac80 <osThreadNew+0x98>
          hTask = NULL;
 800acc2:	2300      	movs	r3, #0
 800acc4:	9304      	str	r3, [sp, #16]
 800acc6:	e7db      	b.n	800ac80 <osThreadNew+0x98>
        return (NULL);
 800acc8:	2000      	movs	r0, #0
 800acca:	e7da      	b.n	800ac82 <osThreadNew+0x9a>
 800accc:	2000      	movs	r0, #0
 800acce:	e7d8      	b.n	800ac82 <osThreadNew+0x9a>
 800acd0:	200001c8 	.word	0x200001c8

0800acd4 <osThreadGetName>:
const char *osThreadGetName (osThreadId_t thread_id) {
 800acd4:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800acd6:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ() || (hTask == NULL)) {
 800acda:	b983      	cbnz	r3, 800acfe <osThreadGetName+0x2a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800acdc:	f3ef 8310 	mrs	r3, PRIMASK
 800ace0:	b97b      	cbnz	r3, 800ad02 <osThreadGetName+0x2e>
 800ace2:	4b09      	ldr	r3, [pc, #36]	; (800ad08 <osThreadGetName+0x34>)
 800ace4:	681b      	ldr	r3, [r3, #0]
 800ace6:	2b02      	cmp	r3, #2
 800ace8:	d003      	beq.n	800acf2 <osThreadGetName+0x1e>
 800acea:	b108      	cbz	r0, 800acf0 <osThreadGetName+0x1c>
    name = pcTaskGetName (hTask);
 800acec:	f002 ff5c 	bl	800dba8 <pcTaskGetName>
}
 800acf0:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800acf2:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ() || (hTask == NULL)) {
 800acf6:	2b00      	cmp	r3, #0
 800acf8:	d0f7      	beq.n	800acea <osThreadGetName+0x16>
    name = NULL;
 800acfa:	2000      	movs	r0, #0
 800acfc:	e7f8      	b.n	800acf0 <osThreadGetName+0x1c>
 800acfe:	2000      	movs	r0, #0
 800ad00:	e7f6      	b.n	800acf0 <osThreadGetName+0x1c>
 800ad02:	2000      	movs	r0, #0
 800ad04:	e7f4      	b.n	800acf0 <osThreadGetName+0x1c>
 800ad06:	bf00      	nop
 800ad08:	200001c8 	.word	0x200001c8

0800ad0c <osThreadGetId>:
osThreadId_t osThreadGetId (void) {
 800ad0c:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ad0e:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800ad12:	b963      	cbnz	r3, 800ad2e <osThreadGetId+0x22>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ad14:	f3ef 8310 	mrs	r3, PRIMASK
 800ad18:	b95b      	cbnz	r3, 800ad32 <osThreadGetId+0x26>
 800ad1a:	4b08      	ldr	r3, [pc, #32]	; (800ad3c <osThreadGetId+0x30>)
 800ad1c:	681b      	ldr	r3, [r3, #0]
 800ad1e:	2b02      	cmp	r3, #2
 800ad20:	d102      	bne.n	800ad28 <osThreadGetId+0x1c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ad22:	f3ef 8311 	mrs	r3, BASEPRI
 800ad26:	b933      	cbnz	r3, 800ad36 <osThreadGetId+0x2a>
    id = (osThreadId_t)xTaskGetCurrentTaskHandle();
 800ad28:	f003 fbae 	bl	800e488 <xTaskGetCurrentTaskHandle>
}
 800ad2c:	bd08      	pop	{r3, pc}
    id = NULL;
 800ad2e:	2000      	movs	r0, #0
 800ad30:	e7fc      	b.n	800ad2c <osThreadGetId+0x20>
 800ad32:	2000      	movs	r0, #0
 800ad34:	e7fa      	b.n	800ad2c <osThreadGetId+0x20>
 800ad36:	2000      	movs	r0, #0
  return (id);
 800ad38:	e7f8      	b.n	800ad2c <osThreadGetId+0x20>
 800ad3a:	bf00      	nop
 800ad3c:	200001c8 	.word	0x200001c8

0800ad40 <osThreadGetState>:
osThreadState_t osThreadGetState (osThreadId_t thread_id) {
 800ad40:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ad42:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ() || (hTask == NULL)) {
 800ad46:	bb03      	cbnz	r3, 800ad8a <osThreadGetState+0x4a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ad48:	f3ef 8310 	mrs	r3, PRIMASK
 800ad4c:	bb03      	cbnz	r3, 800ad90 <osThreadGetState+0x50>
 800ad4e:	4b14      	ldr	r3, [pc, #80]	; (800ada0 <osThreadGetState+0x60>)
 800ad50:	681b      	ldr	r3, [r3, #0]
 800ad52:	2b02      	cmp	r3, #2
 800ad54:	d009      	beq.n	800ad6a <osThreadGetState+0x2a>
 800ad56:	b1f0      	cbz	r0, 800ad96 <osThreadGetState+0x56>
    switch (eTaskGetState (hTask)) {
 800ad58:	f002 fd46 	bl	800d7e8 <eTaskGetState>
 800ad5c:	2804      	cmp	r0, #4
 800ad5e:	d811      	bhi.n	800ad84 <osThreadGetState+0x44>
 800ad60:	e8df f000 	tbb	[pc, r0]
 800ad64:	0c0c1c0a 	.word	0x0c0c1c0a
 800ad68:	0e          	.byte	0x0e
 800ad69:	00          	.byte	0x00
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ad6a:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ() || (hTask == NULL)) {
 800ad6e:	2b00      	cmp	r3, #0
 800ad70:	d0f1      	beq.n	800ad56 <osThreadGetState+0x16>
    state = osThreadError;
 800ad72:	f04f 30ff 	mov.w	r0, #4294967295
 800ad76:	e000      	b.n	800ad7a <osThreadGetState+0x3a>
    switch (eTaskGetState (hTask)) {
 800ad78:	2002      	movs	r0, #2
}
 800ad7a:	bd08      	pop	{r3, pc}
      case eSuspended: state = osThreadBlocked;    break;
 800ad7c:	2003      	movs	r0, #3
 800ad7e:	e7fc      	b.n	800ad7a <osThreadGetState+0x3a>
      case eDeleted:   state = osThreadTerminated; break;
 800ad80:	2004      	movs	r0, #4
 800ad82:	e7fa      	b.n	800ad7a <osThreadGetState+0x3a>
      default:         state = osThreadError;      break;
 800ad84:	f04f 30ff 	mov.w	r0, #4294967295
 800ad88:	e7f7      	b.n	800ad7a <osThreadGetState+0x3a>
    state = osThreadError;
 800ad8a:	f04f 30ff 	mov.w	r0, #4294967295
 800ad8e:	e7f4      	b.n	800ad7a <osThreadGetState+0x3a>
 800ad90:	f04f 30ff 	mov.w	r0, #4294967295
 800ad94:	e7f1      	b.n	800ad7a <osThreadGetState+0x3a>
 800ad96:	f04f 30ff 	mov.w	r0, #4294967295
 800ad9a:	e7ee      	b.n	800ad7a <osThreadGetState+0x3a>
      case eReady:     state = osThreadReady;      break;
 800ad9c:	2001      	movs	r0, #1
  return (state);
 800ad9e:	e7ec      	b.n	800ad7a <osThreadGetState+0x3a>
 800ada0:	200001c8 	.word	0x200001c8

0800ada4 <osThreadGetStackSpace>:
uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
 800ada4:	b508      	push	{r3, lr}
 800ada6:	4603      	mov	r3, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ada8:	f3ef 8005 	mrs	r0, IPSR
  if (IS_IRQ() || (hTask == NULL)) {
 800adac:	b988      	cbnz	r0, 800add2 <osThreadGetStackSpace+0x2e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800adae:	f3ef 8210 	mrs	r2, PRIMASK
 800adb2:	b97a      	cbnz	r2, 800add4 <osThreadGetStackSpace+0x30>
 800adb4:	4909      	ldr	r1, [pc, #36]	; (800addc <osThreadGetStackSpace+0x38>)
 800adb6:	6809      	ldr	r1, [r1, #0]
 800adb8:	2902      	cmp	r1, #2
 800adba:	d004      	beq.n	800adc6 <osThreadGetStackSpace+0x22>
 800adbc:	b15b      	cbz	r3, 800add6 <osThreadGetStackSpace+0x32>
    sz = (uint32_t)uxTaskGetStackHighWaterMark (hTask);
 800adbe:	4618      	mov	r0, r3
 800adc0:	f003 fb56 	bl	800e470 <uxTaskGetStackHighWaterMark>
 800adc4:	e006      	b.n	800add4 <osThreadGetStackSpace+0x30>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800adc6:	f3ef 8111 	mrs	r1, BASEPRI
  if (IS_IRQ() || (hTask == NULL)) {
 800adca:	2900      	cmp	r1, #0
 800adcc:	d0f6      	beq.n	800adbc <osThreadGetStackSpace+0x18>
    sz = 0U;
 800adce:	4610      	mov	r0, r2
 800add0:	e000      	b.n	800add4 <osThreadGetStackSpace+0x30>
 800add2:	2000      	movs	r0, #0
}
 800add4:	bd08      	pop	{r3, pc}
    sz = 0U;
 800add6:	4610      	mov	r0, r2
  return (sz);
 800add8:	e7fc      	b.n	800add4 <osThreadGetStackSpace+0x30>
 800adda:	bf00      	nop
 800addc:	200001c8 	.word	0x200001c8

0800ade0 <osThreadGetStackSize>:
}
 800ade0:	2000      	movs	r0, #0
 800ade2:	4770      	bx	lr

0800ade4 <osThreadSetPriority>:
osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
 800ade4:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ade6:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800adea:	b9b3      	cbnz	r3, 800ae1a <osThreadSetPriority+0x36>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800adec:	f3ef 8310 	mrs	r3, PRIMASK
 800adf0:	b9b3      	cbnz	r3, 800ae20 <osThreadSetPriority+0x3c>
 800adf2:	4b11      	ldr	r3, [pc, #68]	; (800ae38 <osThreadSetPriority+0x54>)
 800adf4:	681b      	ldr	r3, [r3, #0]
 800adf6:	2b02      	cmp	r3, #2
 800adf8:	d008      	beq.n	800ae0c <osThreadSetPriority+0x28>
  else if ((hTask == NULL) || (priority < osPriorityIdle) || (priority > osPriorityISR)) {
 800adfa:	b1a0      	cbz	r0, 800ae26 <osThreadSetPriority+0x42>
 800adfc:	2900      	cmp	r1, #0
 800adfe:	dd15      	ble.n	800ae2c <osThreadSetPriority+0x48>
 800ae00:	2938      	cmp	r1, #56	; 0x38
 800ae02:	dc16      	bgt.n	800ae32 <osThreadSetPriority+0x4e>
    vTaskPrioritySet (hTask, (UBaseType_t)priority);
 800ae04:	f002 fd58 	bl	800d8b8 <vTaskPrioritySet>
    stat = osOK;
 800ae08:	2000      	movs	r0, #0
}
 800ae0a:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ae0c:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800ae10:	2b00      	cmp	r3, #0
 800ae12:	d0f2      	beq.n	800adfa <osThreadSetPriority+0x16>
    stat = osErrorISR;
 800ae14:	f06f 0005 	mvn.w	r0, #5
 800ae18:	e7f7      	b.n	800ae0a <osThreadSetPriority+0x26>
 800ae1a:	f06f 0005 	mvn.w	r0, #5
 800ae1e:	e7f4      	b.n	800ae0a <osThreadSetPriority+0x26>
 800ae20:	f06f 0005 	mvn.w	r0, #5
 800ae24:	e7f1      	b.n	800ae0a <osThreadSetPriority+0x26>
    stat = osErrorParameter;
 800ae26:	f06f 0003 	mvn.w	r0, #3
 800ae2a:	e7ee      	b.n	800ae0a <osThreadSetPriority+0x26>
 800ae2c:	f06f 0003 	mvn.w	r0, #3
 800ae30:	e7eb      	b.n	800ae0a <osThreadSetPriority+0x26>
 800ae32:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800ae36:	e7e8      	b.n	800ae0a <osThreadSetPriority+0x26>
 800ae38:	200001c8 	.word	0x200001c8

0800ae3c <osThreadGetPriority>:
osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
 800ae3c:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ae3e:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ() || (hTask == NULL)) {
 800ae42:	b98b      	cbnz	r3, 800ae68 <osThreadGetPriority+0x2c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ae44:	f3ef 8310 	mrs	r3, PRIMASK
 800ae48:	b98b      	cbnz	r3, 800ae6e <osThreadGetPriority+0x32>
 800ae4a:	4b0c      	ldr	r3, [pc, #48]	; (800ae7c <osThreadGetPriority+0x40>)
 800ae4c:	681b      	ldr	r3, [r3, #0]
 800ae4e:	2b02      	cmp	r3, #2
 800ae50:	d003      	beq.n	800ae5a <osThreadGetPriority+0x1e>
 800ae52:	b178      	cbz	r0, 800ae74 <osThreadGetPriority+0x38>
    prio = (osPriority_t)uxTaskPriorityGet (hTask);
 800ae54:	f002 fd08 	bl	800d868 <uxTaskPriorityGet>
}
 800ae58:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ae5a:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ() || (hTask == NULL)) {
 800ae5e:	2b00      	cmp	r3, #0
 800ae60:	d0f7      	beq.n	800ae52 <osThreadGetPriority+0x16>
    prio = osPriorityError;
 800ae62:	f04f 30ff 	mov.w	r0, #4294967295
 800ae66:	e7f7      	b.n	800ae58 <osThreadGetPriority+0x1c>
 800ae68:	f04f 30ff 	mov.w	r0, #4294967295
 800ae6c:	e7f4      	b.n	800ae58 <osThreadGetPriority+0x1c>
 800ae6e:	f04f 30ff 	mov.w	r0, #4294967295
 800ae72:	e7f1      	b.n	800ae58 <osThreadGetPriority+0x1c>
 800ae74:	f04f 30ff 	mov.w	r0, #4294967295
  return (prio);
 800ae78:	e7ee      	b.n	800ae58 <osThreadGetPriority+0x1c>
 800ae7a:	bf00      	nop
 800ae7c:	200001c8 	.word	0x200001c8

0800ae80 <osThreadYield>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ae80:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800ae84:	b9bb      	cbnz	r3, 800aeb6 <osThreadYield+0x36>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ae86:	f3ef 8310 	mrs	r3, PRIMASK
 800ae8a:	b9bb      	cbnz	r3, 800aebc <osThreadYield+0x3c>
 800ae8c:	4b0d      	ldr	r3, [pc, #52]	; (800aec4 <osThreadYield+0x44>)
 800ae8e:	681b      	ldr	r3, [r3, #0]
 800ae90:	2b02      	cmp	r3, #2
 800ae92:	d009      	beq.n	800aea8 <osThreadYield+0x28>
    taskYIELD();
 800ae94:	4b0c      	ldr	r3, [pc, #48]	; (800aec8 <osThreadYield+0x48>)
 800ae96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ae9a:	601a      	str	r2, [r3, #0]
 800ae9c:	f3bf 8f4f 	dsb	sy
 800aea0:	f3bf 8f6f 	isb	sy
    stat = osOK;
 800aea4:	2000      	movs	r0, #0
 800aea6:	4770      	bx	lr
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aea8:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800aeac:	2b00      	cmp	r3, #0
 800aeae:	d0f1      	beq.n	800ae94 <osThreadYield+0x14>
    stat = osErrorISR;
 800aeb0:	f06f 0005 	mvn.w	r0, #5
}
 800aeb4:	4770      	bx	lr
    stat = osErrorISR;
 800aeb6:	f06f 0005 	mvn.w	r0, #5
 800aeba:	4770      	bx	lr
 800aebc:	f06f 0005 	mvn.w	r0, #5
 800aec0:	4770      	bx	lr
 800aec2:	bf00      	nop
 800aec4:	200001c8 	.word	0x200001c8
 800aec8:	e000ed04 	.word	0xe000ed04

0800aecc <osThreadSuspend>:
osStatus_t osThreadSuspend (osThreadId_t thread_id) {
 800aecc:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800aece:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800aed2:	b993      	cbnz	r3, 800aefa <osThreadSuspend+0x2e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800aed4:	f3ef 8310 	mrs	r3, PRIMASK
 800aed8:	b993      	cbnz	r3, 800af00 <osThreadSuspend+0x34>
 800aeda:	4b0c      	ldr	r3, [pc, #48]	; (800af0c <osThreadSuspend+0x40>)
 800aedc:	681b      	ldr	r3, [r3, #0]
 800aede:	2b02      	cmp	r3, #2
 800aee0:	d004      	beq.n	800aeec <osThreadSuspend+0x20>
  else if (hTask == NULL) {
 800aee2:	b180      	cbz	r0, 800af06 <osThreadSuspend+0x3a>
    vTaskSuspend (hTask);
 800aee4:	f003 f83e 	bl	800df64 <vTaskSuspend>
    stat = osOK;
 800aee8:	2000      	movs	r0, #0
}
 800aeea:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aeec:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800aef0:	2b00      	cmp	r3, #0
 800aef2:	d0f6      	beq.n	800aee2 <osThreadSuspend+0x16>
    stat = osErrorISR;
 800aef4:	f06f 0005 	mvn.w	r0, #5
 800aef8:	e7f7      	b.n	800aeea <osThreadSuspend+0x1e>
 800aefa:	f06f 0005 	mvn.w	r0, #5
 800aefe:	e7f4      	b.n	800aeea <osThreadSuspend+0x1e>
 800af00:	f06f 0005 	mvn.w	r0, #5
 800af04:	e7f1      	b.n	800aeea <osThreadSuspend+0x1e>
    stat = osErrorParameter;
 800af06:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800af0a:	e7ee      	b.n	800aeea <osThreadSuspend+0x1e>
 800af0c:	200001c8 	.word	0x200001c8

0800af10 <osThreadResume>:
osStatus_t osThreadResume (osThreadId_t thread_id) {
 800af10:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800af12:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800af16:	b993      	cbnz	r3, 800af3e <osThreadResume+0x2e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800af18:	f3ef 8310 	mrs	r3, PRIMASK
 800af1c:	b993      	cbnz	r3, 800af44 <osThreadResume+0x34>
 800af1e:	4b0c      	ldr	r3, [pc, #48]	; (800af50 <osThreadResume+0x40>)
 800af20:	681b      	ldr	r3, [r3, #0]
 800af22:	2b02      	cmp	r3, #2
 800af24:	d004      	beq.n	800af30 <osThreadResume+0x20>
  else if (hTask == NULL) {
 800af26:	b180      	cbz	r0, 800af4a <osThreadResume+0x3a>
    vTaskResume (hTask);
 800af28:	f002 fd30 	bl	800d98c <vTaskResume>
    stat = osOK;
 800af2c:	2000      	movs	r0, #0
}
 800af2e:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800af30:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800af34:	2b00      	cmp	r3, #0
 800af36:	d0f6      	beq.n	800af26 <osThreadResume+0x16>
    stat = osErrorISR;
 800af38:	f06f 0005 	mvn.w	r0, #5
 800af3c:	e7f7      	b.n	800af2e <osThreadResume+0x1e>
 800af3e:	f06f 0005 	mvn.w	r0, #5
 800af42:	e7f4      	b.n	800af2e <osThreadResume+0x1e>
 800af44:	f06f 0005 	mvn.w	r0, #5
 800af48:	e7f1      	b.n	800af2e <osThreadResume+0x1e>
    stat = osErrorParameter;
 800af4a:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800af4e:	e7ee      	b.n	800af2e <osThreadResume+0x1e>
 800af50:	200001c8 	.word	0x200001c8

0800af54 <osThreadExit>:
__NO_RETURN void osThreadExit (void) {
 800af54:	b508      	push	{r3, lr}
  vTaskDelete (NULL);
 800af56:	2000      	movs	r0, #0
 800af58:	f002 fbeb 	bl	800d732 <vTaskDelete>
  for (;;);
 800af5c:	e7fe      	b.n	800af5c <osThreadExit+0x8>

0800af5e <osThreadTerminate>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800af5e:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800af62:	b9d3      	cbnz	r3, 800af9a <osThreadTerminate+0x3c>
osStatus_t osThreadTerminate (osThreadId_t thread_id) {
 800af64:	b510      	push	{r4, lr}
 800af66:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800af68:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800af6c:	b9c3      	cbnz	r3, 800afa0 <osThreadTerminate+0x42>
 800af6e:	4b11      	ldr	r3, [pc, #68]	; (800afb4 <osThreadTerminate+0x56>)
 800af70:	681b      	ldr	r3, [r3, #0]
 800af72:	2b02      	cmp	r3, #2
 800af74:	d00a      	beq.n	800af8c <osThreadTerminate+0x2e>
  else if (hTask == NULL) {
 800af76:	b1b4      	cbz	r4, 800afa6 <osThreadTerminate+0x48>
    tstate = eTaskGetState (hTask);
 800af78:	4620      	mov	r0, r4
 800af7a:	f002 fc35 	bl	800d7e8 <eTaskGetState>
    if (tstate != eDeleted) {
 800af7e:	2804      	cmp	r0, #4
 800af80:	d014      	beq.n	800afac <osThreadTerminate+0x4e>
      vTaskDelete (hTask);
 800af82:	4620      	mov	r0, r4
 800af84:	f002 fbd5 	bl	800d732 <vTaskDelete>
      stat = osOK;
 800af88:	2000      	movs	r0, #0
}
 800af8a:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800af8c:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800af90:	2b00      	cmp	r3, #0
 800af92:	d0f0      	beq.n	800af76 <osThreadTerminate+0x18>
    stat = osErrorISR;
 800af94:	f06f 0005 	mvn.w	r0, #5
 800af98:	e7f7      	b.n	800af8a <osThreadTerminate+0x2c>
 800af9a:	f06f 0005 	mvn.w	r0, #5
}
 800af9e:	4770      	bx	lr
    stat = osErrorISR;
 800afa0:	f06f 0005 	mvn.w	r0, #5
 800afa4:	e7f1      	b.n	800af8a <osThreadTerminate+0x2c>
    stat = osErrorParameter;
 800afa6:	f06f 0003 	mvn.w	r0, #3
 800afaa:	e7ee      	b.n	800af8a <osThreadTerminate+0x2c>
      stat = osErrorResource;
 800afac:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800afb0:	e7eb      	b.n	800af8a <osThreadTerminate+0x2c>
 800afb2:	bf00      	nop
 800afb4:	200001c8 	.word	0x200001c8

0800afb8 <osThreadGetCount>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800afb8:	f3ef 8005 	mrs	r0, IPSR
  if (IS_IRQ()) {
 800afbc:	b968      	cbnz	r0, 800afda <osThreadGetCount+0x22>
uint32_t osThreadGetCount (void) {
 800afbe:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800afc0:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800afc4:	b943      	cbnz	r3, 800afd8 <osThreadGetCount+0x20>
 800afc6:	4a07      	ldr	r2, [pc, #28]	; (800afe4 <osThreadGetCount+0x2c>)
 800afc8:	6812      	ldr	r2, [r2, #0]
 800afca:	2a02      	cmp	r2, #2
 800afcc:	d102      	bne.n	800afd4 <osThreadGetCount+0x1c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800afce:	f3ef 8211 	mrs	r2, BASEPRI
 800afd2:	b922      	cbnz	r2, 800afde <osThreadGetCount+0x26>
    count = uxTaskGetNumberOfTasks();
 800afd4:	f002 fde2 	bl	800db9c <uxTaskGetNumberOfTasks>
}
 800afd8:	bd08      	pop	{r3, pc}
    count = 0U;
 800afda:	2000      	movs	r0, #0
}
 800afdc:	4770      	bx	lr
    count = 0U;
 800afde:	4618      	mov	r0, r3
  return (count);
 800afe0:	e7fa      	b.n	800afd8 <osThreadGetCount+0x20>
 800afe2:	bf00      	nop
 800afe4:	200001c8 	.word	0x200001c8

0800afe8 <osThreadEnumerate>:
uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
 800afe8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800afec:	f3ef 8405 	mrs	r4, IPSR
  if (IS_IRQ() || (thread_array == NULL) || (array_items == 0U)) {
 800aff0:	bbac      	cbnz	r4, 800b05e <osThreadEnumerate+0x76>
 800aff2:	4606      	mov	r6, r0
 800aff4:	460d      	mov	r5, r1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800aff6:	f3ef 8710 	mrs	r7, PRIMASK
 800affa:	bb8f      	cbnz	r7, 800b060 <osThreadEnumerate+0x78>
 800affc:	4b1b      	ldr	r3, [pc, #108]	; (800b06c <osThreadEnumerate+0x84>)
 800affe:	681b      	ldr	r3, [r3, #0]
 800b000:	2b02      	cmp	r3, #2
 800b002:	d003      	beq.n	800b00c <osThreadEnumerate+0x24>
 800b004:	b37e      	cbz	r6, 800b066 <osThreadEnumerate+0x7e>
 800b006:	b93d      	cbnz	r5, 800b018 <osThreadEnumerate+0x30>
    count = 0U;
 800b008:	462c      	mov	r4, r5
  return (count);
 800b00a:	e029      	b.n	800b060 <osThreadEnumerate+0x78>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b00c:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ() || (thread_array == NULL) || (array_items == 0U)) {
 800b010:	2b00      	cmp	r3, #0
 800b012:	d0f7      	beq.n	800b004 <osThreadEnumerate+0x1c>
    count = 0U;
 800b014:	463c      	mov	r4, r7
 800b016:	e023      	b.n	800b060 <osThreadEnumerate+0x78>
    vTaskSuspendAll();
 800b018:	f002 fdaa 	bl	800db70 <vTaskSuspendAll>
    count = uxTaskGetNumberOfTasks();
 800b01c:	f002 fdbe 	bl	800db9c <uxTaskGetNumberOfTasks>
 800b020:	4604      	mov	r4, r0
    task  = pvPortMalloc (count * sizeof(TaskStatus_t));
 800b022:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800b026:	0080      	lsls	r0, r0, #2
 800b028:	f004 fa50 	bl	800f4cc <pvPortMalloc>
    if (task != NULL) {
 800b02c:	4680      	mov	r8, r0
 800b02e:	b180      	cbz	r0, 800b052 <osThreadEnumerate+0x6a>
      count = uxTaskGetSystemState (task, count, NULL);
 800b030:	2200      	movs	r2, #0
 800b032:	4621      	mov	r1, r4
 800b034:	f003 f9c5 	bl	800e3c2 <uxTaskGetSystemState>
      for (i = 0U; (i < count) && (i < array_items); i++) {
 800b038:	463c      	mov	r4, r7
 800b03a:	e006      	b.n	800b04a <osThreadEnumerate+0x62>
        thread_array[i] = (osThreadId_t)task[i].xHandle;
 800b03c:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 800b040:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 800b044:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
      for (i = 0U; (i < count) && (i < array_items); i++) {
 800b048:	3401      	adds	r4, #1
 800b04a:	4284      	cmp	r4, r0
 800b04c:	d201      	bcs.n	800b052 <osThreadEnumerate+0x6a>
 800b04e:	42ac      	cmp	r4, r5
 800b050:	d3f4      	bcc.n	800b03c <osThreadEnumerate+0x54>
    (void)xTaskResumeAll();
 800b052:	f002 fe49 	bl	800dce8 <xTaskResumeAll>
    vPortFree (task);
 800b056:	4640      	mov	r0, r8
 800b058:	f004 faba 	bl	800f5d0 <vPortFree>
 800b05c:	e000      	b.n	800b060 <osThreadEnumerate+0x78>
    count = 0U;
 800b05e:	2400      	movs	r4, #0
}
 800b060:	4620      	mov	r0, r4
 800b062:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    count = 0U;
 800b066:	463c      	mov	r4, r7
 800b068:	e7fa      	b.n	800b060 <osThreadEnumerate+0x78>
 800b06a:	bf00      	nop
 800b06c:	200001c8 	.word	0x200001c8

0800b070 <osThreadFlagsSet>:
uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
 800b070:	b530      	push	{r4, r5, lr}
 800b072:	b085      	sub	sp, #20
  if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
 800b074:	b368      	cbz	r0, 800b0d2 <osThreadFlagsSet+0x62>
 800b076:	4605      	mov	r5, r0
 800b078:	2900      	cmp	r1, #0
 800b07a:	db2a      	blt.n	800b0d2 <osThreadFlagsSet+0x62>
    rflags = (uint32_t)osError;
 800b07c:	f04f 33ff 	mov.w	r3, #4294967295
 800b080:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b082:	f3ef 8305 	mrs	r3, IPSR
    if (IS_IRQ()) {
 800b086:	b94b      	cbnz	r3, 800b09c <osThreadFlagsSet+0x2c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b088:	f3ef 8310 	mrs	r3, PRIMASK
 800b08c:	b933      	cbnz	r3, 800b09c <osThreadFlagsSet+0x2c>
 800b08e:	4b1a      	ldr	r3, [pc, #104]	; (800b0f8 <osThreadFlagsSet+0x88>)
 800b090:	681b      	ldr	r3, [r3, #0]
 800b092:	2b02      	cmp	r3, #2
 800b094:	d123      	bne.n	800b0de <osThreadFlagsSet+0x6e>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b096:	f3ef 8311 	mrs	r3, BASEPRI
 800b09a:	b303      	cbz	r3, 800b0de <osThreadFlagsSet+0x6e>
      yield = pdFALSE;
 800b09c:	2400      	movs	r4, #0
 800b09e:	9402      	str	r4, [sp, #8]
      (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
 800b0a0:	ab02      	add	r3, sp, #8
 800b0a2:	9300      	str	r3, [sp, #0]
 800b0a4:	4623      	mov	r3, r4
 800b0a6:	2201      	movs	r2, #1
 800b0a8:	4628      	mov	r0, r5
 800b0aa:	f003 fbfd 	bl	800e8a8 <xTaskGenericNotifyFromISR>
      (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
 800b0ae:	9400      	str	r4, [sp, #0]
 800b0b0:	ab03      	add	r3, sp, #12
 800b0b2:	4622      	mov	r2, r4
 800b0b4:	4621      	mov	r1, r4
 800b0b6:	4628      	mov	r0, r5
 800b0b8:	f003 fbf6 	bl	800e8a8 <xTaskGenericNotifyFromISR>
      portYIELD_FROM_ISR (yield);
 800b0bc:	9b02      	ldr	r3, [sp, #8]
 800b0be:	b15b      	cbz	r3, 800b0d8 <osThreadFlagsSet+0x68>
 800b0c0:	4b0e      	ldr	r3, [pc, #56]	; (800b0fc <osThreadFlagsSet+0x8c>)
 800b0c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b0c6:	601a      	str	r2, [r3, #0]
 800b0c8:	f3bf 8f4f 	dsb	sy
 800b0cc:	f3bf 8f6f 	isb	sy
 800b0d0:	e002      	b.n	800b0d8 <osThreadFlagsSet+0x68>
    rflags = (uint32_t)osErrorParameter;
 800b0d2:	f06f 0303 	mvn.w	r3, #3
 800b0d6:	9303      	str	r3, [sp, #12]
}
 800b0d8:	9803      	ldr	r0, [sp, #12]
 800b0da:	b005      	add	sp, #20
 800b0dc:	bd30      	pop	{r4, r5, pc}
      (void)xTaskNotify (hTask, flags, eSetBits);
 800b0de:	2300      	movs	r3, #0
 800b0e0:	2201      	movs	r2, #1
 800b0e2:	4628      	mov	r0, r5
 800b0e4:	f003 fb6e 	bl	800e7c4 <xTaskGenericNotify>
      (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
 800b0e8:	ab03      	add	r3, sp, #12
 800b0ea:	2200      	movs	r2, #0
 800b0ec:	4611      	mov	r1, r2
 800b0ee:	4628      	mov	r0, r5
 800b0f0:	f003 fb68 	bl	800e7c4 <xTaskGenericNotify>
 800b0f4:	e7f0      	b.n	800b0d8 <osThreadFlagsSet+0x68>
 800b0f6:	bf00      	nop
 800b0f8:	200001c8 	.word	0x200001c8
 800b0fc:	e000ed04 	.word	0xe000ed04

0800b100 <osThreadFlagsClear>:
uint32_t osThreadFlagsClear (uint32_t flags) {
 800b100:	b570      	push	{r4, r5, r6, lr}
 800b102:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b104:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800b108:	bb5b      	cbnz	r3, 800b162 <osThreadFlagsClear+0x62>
 800b10a:	4605      	mov	r5, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b10c:	f3ef 8310 	mrs	r3, PRIMASK
 800b110:	bb63      	cbnz	r3, 800b16c <osThreadFlagsClear+0x6c>
 800b112:	4b19      	ldr	r3, [pc, #100]	; (800b178 <osThreadFlagsClear+0x78>)
 800b114:	681b      	ldr	r3, [r3, #0]
 800b116:	2b02      	cmp	r3, #2
 800b118:	d00e      	beq.n	800b138 <osThreadFlagsClear+0x38>
  else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
 800b11a:	2d00      	cmp	r5, #0
 800b11c:	db29      	blt.n	800b172 <osThreadFlagsClear+0x72>
    hTask = xTaskGetCurrentTaskHandle();
 800b11e:	f003 f9b3 	bl	800e488 <xTaskGetCurrentTaskHandle>
 800b122:	4606      	mov	r6, r0
    if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &cflags) == pdPASS) {
 800b124:	ab01      	add	r3, sp, #4
 800b126:	2200      	movs	r2, #0
 800b128:	4611      	mov	r1, r2
 800b12a:	f003 fb4b 	bl	800e7c4 <xTaskGenericNotify>
 800b12e:	2801      	cmp	r0, #1
 800b130:	d009      	beq.n	800b146 <osThreadFlagsClear+0x46>
      rflags = (uint32_t)osError;
 800b132:	f04f 34ff 	mov.w	r4, #4294967295
 800b136:	e016      	b.n	800b166 <osThreadFlagsClear+0x66>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b138:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b13c:	2b00      	cmp	r3, #0
 800b13e:	d0ec      	beq.n	800b11a <osThreadFlagsClear+0x1a>
    rflags = (uint32_t)osErrorISR;
 800b140:	f06f 0405 	mvn.w	r4, #5
 800b144:	e00f      	b.n	800b166 <osThreadFlagsClear+0x66>
      rflags = cflags;
 800b146:	9c01      	ldr	r4, [sp, #4]
      cflags &= ~flags;
 800b148:	ea24 0105 	bic.w	r1, r4, r5
 800b14c:	9101      	str	r1, [sp, #4]
      if (xTaskNotify (hTask, cflags, eSetValueWithOverwrite) != pdPASS) {
 800b14e:	2300      	movs	r3, #0
 800b150:	2203      	movs	r2, #3
 800b152:	4630      	mov	r0, r6
 800b154:	f003 fb36 	bl	800e7c4 <xTaskGenericNotify>
 800b158:	2801      	cmp	r0, #1
 800b15a:	d004      	beq.n	800b166 <osThreadFlagsClear+0x66>
        rflags = (uint32_t)osError;
 800b15c:	f04f 34ff 	mov.w	r4, #4294967295
  return (rflags);
 800b160:	e001      	b.n	800b166 <osThreadFlagsClear+0x66>
    rflags = (uint32_t)osErrorISR;
 800b162:	f06f 0405 	mvn.w	r4, #5
}
 800b166:	4620      	mov	r0, r4
 800b168:	b002      	add	sp, #8
 800b16a:	bd70      	pop	{r4, r5, r6, pc}
    rflags = (uint32_t)osErrorISR;
 800b16c:	f06f 0405 	mvn.w	r4, #5
 800b170:	e7f9      	b.n	800b166 <osThreadFlagsClear+0x66>
    rflags = (uint32_t)osErrorParameter;
 800b172:	f06f 0403 	mvn.w	r4, #3
 800b176:	e7f6      	b.n	800b166 <osThreadFlagsClear+0x66>
 800b178:	200001c8 	.word	0x200001c8

0800b17c <osThreadFlagsGet>:
uint32_t osThreadFlagsGet (void) {
 800b17c:	b500      	push	{lr}
 800b17e:	b083      	sub	sp, #12
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b180:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800b184:	b94b      	cbnz	r3, 800b19a <osThreadFlagsGet+0x1e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b186:	f3ef 8310 	mrs	r3, PRIMASK
 800b18a:	b933      	cbnz	r3, 800b19a <osThreadFlagsGet+0x1e>
 800b18c:	4b0d      	ldr	r3, [pc, #52]	; (800b1c4 <osThreadFlagsGet+0x48>)
 800b18e:	681b      	ldr	r3, [r3, #0]
 800b190:	2b02      	cmp	r3, #2
 800b192:	d109      	bne.n	800b1a8 <osThreadFlagsGet+0x2c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b194:	f3ef 8311 	mrs	r3, BASEPRI
 800b198:	b133      	cbz	r3, 800b1a8 <osThreadFlagsGet+0x2c>
    rflags = (uint32_t)osErrorISR;
 800b19a:	f06f 0305 	mvn.w	r3, #5
 800b19e:	9301      	str	r3, [sp, #4]
}
 800b1a0:	9801      	ldr	r0, [sp, #4]
 800b1a2:	b003      	add	sp, #12
 800b1a4:	f85d fb04 	ldr.w	pc, [sp], #4
    hTask = xTaskGetCurrentTaskHandle();
 800b1a8:	f003 f96e 	bl	800e488 <xTaskGetCurrentTaskHandle>
    if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags) != pdPASS) {
 800b1ac:	ab01      	add	r3, sp, #4
 800b1ae:	2200      	movs	r2, #0
 800b1b0:	4611      	mov	r1, r2
 800b1b2:	f003 fb07 	bl	800e7c4 <xTaskGenericNotify>
 800b1b6:	2801      	cmp	r0, #1
 800b1b8:	d0f2      	beq.n	800b1a0 <osThreadFlagsGet+0x24>
      rflags = (uint32_t)osError;
 800b1ba:	f04f 33ff 	mov.w	r3, #4294967295
 800b1be:	9301      	str	r3, [sp, #4]
 800b1c0:	e7ee      	b.n	800b1a0 <osThreadFlagsGet+0x24>
 800b1c2:	bf00      	nop
 800b1c4:	200001c8 	.word	0x200001c8

0800b1c8 <osThreadFlagsWait>:
uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
 800b1c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b1cc:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b1ce:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800b1d2:	2b00      	cmp	r3, #0
 800b1d4:	d150      	bne.n	800b278 <osThreadFlagsWait+0xb0>
 800b1d6:	4680      	mov	r8, r0
 800b1d8:	468a      	mov	sl, r1
 800b1da:	4617      	mov	r7, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b1dc:	f3ef 8510 	mrs	r5, PRIMASK
 800b1e0:	9501      	str	r5, [sp, #4]
 800b1e2:	2d00      	cmp	r5, #0
 800b1e4:	d14e      	bne.n	800b284 <osThreadFlagsWait+0xbc>
 800b1e6:	4b2c      	ldr	r3, [pc, #176]	; (800b298 <osThreadFlagsWait+0xd0>)
 800b1e8:	681b      	ldr	r3, [r3, #0]
 800b1ea:	2b02      	cmp	r3, #2
 800b1ec:	d00b      	beq.n	800b206 <osThreadFlagsWait+0x3e>
  else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
 800b1ee:	f1b8 0f00 	cmp.w	r8, #0
 800b1f2:	db4a      	blt.n	800b28a <osThreadFlagsWait+0xc2>
    if ((options & osFlagsNoClear) == osFlagsNoClear) {
 800b1f4:	f01a 0f02 	tst.w	sl, #2
 800b1f8:	d00c      	beq.n	800b214 <osThreadFlagsWait+0x4c>
      clear = 0U;
 800b1fa:	46a9      	mov	r9, r5
    t0 = xTaskGetTickCount();
 800b1fc:	f002 fcc0 	bl	800db80 <xTaskGetTickCount>
 800b200:	4683      	mov	fp, r0
    tout   = timeout;
 800b202:	463e      	mov	r6, r7
 800b204:	e02a      	b.n	800b25c <osThreadFlagsWait+0x94>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b206:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b20a:	2b00      	cmp	r3, #0
 800b20c:	d0ef      	beq.n	800b1ee <osThreadFlagsWait+0x26>
    rflags = (uint32_t)osErrorISR;
 800b20e:	f06f 0505 	mvn.w	r5, #5
 800b212:	e033      	b.n	800b27c <osThreadFlagsWait+0xb4>
      clear = flags;
 800b214:	46c1      	mov	r9, r8
 800b216:	e7f1      	b.n	800b1fc <osThreadFlagsWait+0x34>
        rflags &= flags;
 800b218:	ea05 0508 	and.w	r5, r5, r8
        rflags |= nval;
 800b21c:	9b03      	ldr	r3, [sp, #12]
 800b21e:	431d      	orrs	r5, r3
        if ((options & osFlagsWaitAll) == osFlagsWaitAll) {
 800b220:	f01a 0f01 	tst.w	sl, #1
 800b224:	d00d      	beq.n	800b242 <osThreadFlagsWait+0x7a>
          if ((flags & rflags) == flags) {
 800b226:	ea38 0305 	bics.w	r3, r8, r5
 800b22a:	d027      	beq.n	800b27c <osThreadFlagsWait+0xb4>
            if (timeout == 0U) {
 800b22c:	b387      	cbz	r7, 800b290 <osThreadFlagsWait+0xc8>
        td = xTaskGetTickCount() - t0;
 800b22e:	f002 fca7 	bl	800db80 <xTaskGetTickCount>
 800b232:	eba0 030b 	sub.w	r3, r0, fp
        if (td > tout) {
 800b236:	429e      	cmp	r6, r3
 800b238:	d30b      	bcc.n	800b252 <osThreadFlagsWait+0x8a>
          tout -= td;
 800b23a:	ebab 0000 	sub.w	r0, fp, r0
 800b23e:	4406      	add	r6, r0
 800b240:	e00b      	b.n	800b25a <osThreadFlagsWait+0x92>
          if ((flags & rflags) != 0) {
 800b242:	ea18 0f05 	tst.w	r8, r5
 800b246:	d119      	bne.n	800b27c <osThreadFlagsWait+0xb4>
            if (timeout == 0U) {
 800b248:	2f00      	cmp	r7, #0
 800b24a:	d1f0      	bne.n	800b22e <osThreadFlagsWait+0x66>
              rflags = (uint32_t)osErrorResource;
 800b24c:	f06f 0502 	mvn.w	r5, #2
  return (rflags);
 800b250:	e014      	b.n	800b27c <osThreadFlagsWait+0xb4>
          tout  = 0;
 800b252:	9e01      	ldr	r6, [sp, #4]
 800b254:	e001      	b.n	800b25a <osThreadFlagsWait+0x92>
          rflags = (uint32_t)osErrorTimeout;
 800b256:	f06f 0501 	mvn.w	r5, #1
    while (rval != pdFAIL);
 800b25a:	b17c      	cbz	r4, 800b27c <osThreadFlagsWait+0xb4>
      rval = xTaskNotifyWait (0, clear, &nval, tout);
 800b25c:	4633      	mov	r3, r6
 800b25e:	aa03      	add	r2, sp, #12
 800b260:	4649      	mov	r1, r9
 800b262:	2000      	movs	r0, #0
 800b264:	f003 fa62 	bl	800e72c <xTaskNotifyWait>
 800b268:	4604      	mov	r4, r0
      if (rval == pdPASS) {
 800b26a:	2801      	cmp	r0, #1
 800b26c:	d0d4      	beq.n	800b218 <osThreadFlagsWait+0x50>
        if (timeout == 0) {
 800b26e:	2f00      	cmp	r7, #0
 800b270:	d1f1      	bne.n	800b256 <osThreadFlagsWait+0x8e>
          rflags = (uint32_t)osErrorResource;
 800b272:	f06f 0502 	mvn.w	r5, #2
 800b276:	e7f0      	b.n	800b25a <osThreadFlagsWait+0x92>
    rflags = (uint32_t)osErrorISR;
 800b278:	f06f 0505 	mvn.w	r5, #5
}
 800b27c:	4628      	mov	r0, r5
 800b27e:	b005      	add	sp, #20
 800b280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    rflags = (uint32_t)osErrorISR;
 800b284:	f06f 0505 	mvn.w	r5, #5
 800b288:	e7f8      	b.n	800b27c <osThreadFlagsWait+0xb4>
    rflags = (uint32_t)osErrorParameter;
 800b28a:	f06f 0503 	mvn.w	r5, #3
 800b28e:	e7f5      	b.n	800b27c <osThreadFlagsWait+0xb4>
              rflags = (uint32_t)osErrorResource;
 800b290:	f06f 0502 	mvn.w	r5, #2
 800b294:	e7f2      	b.n	800b27c <osThreadFlagsWait+0xb4>
 800b296:	bf00      	nop
 800b298:	200001c8 	.word	0x200001c8

0800b29c <osDelay>:
osStatus_t osDelay (uint32_t ticks) {
 800b29c:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b29e:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800b2a2:	b9a3      	cbnz	r3, 800b2ce <osDelay+0x32>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b2a4:	f3ef 8310 	mrs	r3, PRIMASK
 800b2a8:	b9a3      	cbnz	r3, 800b2d4 <osDelay+0x38>
 800b2aa:	4b0c      	ldr	r3, [pc, #48]	; (800b2dc <osDelay+0x40>)
 800b2ac:	681b      	ldr	r3, [r3, #0]
 800b2ae:	2b02      	cmp	r3, #2
 800b2b0:	d002      	beq.n	800b2b8 <osDelay+0x1c>
    if (ticks != 0U) {
 800b2b2:	b940      	cbnz	r0, 800b2c6 <osDelay+0x2a>
    stat = osOK;
 800b2b4:	2000      	movs	r0, #0
}
 800b2b6:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b2b8:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b2bc:	2b00      	cmp	r3, #0
 800b2be:	d0f8      	beq.n	800b2b2 <osDelay+0x16>
    stat = osErrorISR;
 800b2c0:	f06f 0005 	mvn.w	r0, #5
 800b2c4:	e7f7      	b.n	800b2b6 <osDelay+0x1a>
      vTaskDelay(ticks);
 800b2c6:	f002 fddd 	bl	800de84 <vTaskDelay>
    stat = osOK;
 800b2ca:	2000      	movs	r0, #0
 800b2cc:	e7f3      	b.n	800b2b6 <osDelay+0x1a>
    stat = osErrorISR;
 800b2ce:	f06f 0005 	mvn.w	r0, #5
 800b2d2:	e7f0      	b.n	800b2b6 <osDelay+0x1a>
 800b2d4:	f06f 0005 	mvn.w	r0, #5
 800b2d8:	e7ed      	b.n	800b2b6 <osDelay+0x1a>
 800b2da:	bf00      	nop
 800b2dc:	200001c8 	.word	0x200001c8

0800b2e0 <osDelayUntil>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b2e0:	f3ef 8305 	mrs	r3, IPSR
  if (IS_IRQ()) {
 800b2e4:	b9b3      	cbnz	r3, 800b314 <osDelayUntil+0x34>
osStatus_t osDelayUntil (uint32_t ticks) {
 800b2e6:	b510      	push	{r4, lr}
 800b2e8:	b082      	sub	sp, #8
 800b2ea:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b2ec:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800b2f0:	b99b      	cbnz	r3, 800b31a <osDelayUntil+0x3a>
 800b2f2:	4b0d      	ldr	r3, [pc, #52]	; (800b328 <osDelayUntil+0x48>)
 800b2f4:	681b      	ldr	r3, [r3, #0]
 800b2f6:	2b02      	cmp	r3, #2
 800b2f8:	d102      	bne.n	800b300 <osDelayUntil+0x20>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b2fa:	f3ef 8311 	mrs	r3, BASEPRI
 800b2fe:	b97b      	cbnz	r3, 800b320 <osDelayUntil+0x40>
    tcnt = xTaskGetTickCount();
 800b300:	f002 fc3e 	bl	800db80 <xTaskGetTickCount>
 800b304:	9001      	str	r0, [sp, #4]
    vTaskDelayUntil (&tcnt, (TickType_t)(ticks - tcnt));
 800b306:	1a21      	subs	r1, r4, r0
 800b308:	a801      	add	r0, sp, #4
 800b30a:	f002 fd69 	bl	800dde0 <vTaskDelayUntil>
    stat = osOK;
 800b30e:	2000      	movs	r0, #0
}
 800b310:	b002      	add	sp, #8
 800b312:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 800b314:	f06f 0005 	mvn.w	r0, #5
}
 800b318:	4770      	bx	lr
    stat = osErrorISR;
 800b31a:	f06f 0005 	mvn.w	r0, #5
 800b31e:	e7f7      	b.n	800b310 <osDelayUntil+0x30>
 800b320:	f06f 0005 	mvn.w	r0, #5
  return (stat);
 800b324:	e7f4      	b.n	800b310 <osDelayUntil+0x30>
 800b326:	bf00      	nop
 800b328:	200001c8 	.word	0x200001c8

0800b32c <osTimerNew>:

osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
 800b32c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b330:	b083      	sub	sp, #12
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b332:	f3ef 8405 	mrs	r4, IPSR
  UBaseType_t reload;
  int32_t mem;

  hTimer = NULL;

  if (!IS_IRQ() && (func != NULL)) {
 800b336:	2c00      	cmp	r4, #0
 800b338:	d147      	bne.n	800b3ca <osTimerNew+0x9e>
 800b33a:	4606      	mov	r6, r0
 800b33c:	460f      	mov	r7, r1
 800b33e:	4690      	mov	r8, r2
 800b340:	461d      	mov	r5, r3
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b342:	f3ef 8410 	mrs	r4, PRIMASK
 800b346:	46a1      	mov	r9, r4
 800b348:	2c00      	cmp	r4, #0
 800b34a:	d142      	bne.n	800b3d2 <osTimerNew+0xa6>
 800b34c:	4b24      	ldr	r3, [pc, #144]	; (800b3e0 <osTimerNew+0xb4>)
 800b34e:	681b      	ldr	r3, [r3, #0]
 800b350:	2b02      	cmp	r3, #2
 800b352:	d020      	beq.n	800b396 <osTimerNew+0x6a>
 800b354:	2e00      	cmp	r6, #0
 800b356:	d03e      	beq.n	800b3d6 <osTimerNew+0xaa>
    /* Allocate memory to store callback function and argument */
    callb = pvPortMalloc (sizeof(TimerCallback_t));
 800b358:	2008      	movs	r0, #8
 800b35a:	f004 f8b7 	bl	800f4cc <pvPortMalloc>

    if (callb != NULL) {
 800b35e:	2800      	cmp	r0, #0
 800b360:	d034      	beq.n	800b3cc <osTimerNew+0xa0>
      callb->func = func;
 800b362:	6006      	str	r6, [r0, #0]
      callb->arg  = argument;
 800b364:	f8c0 8004 	str.w	r8, [r0, #4]

      if (type == osTimerOnce) {
 800b368:	b10f      	cbz	r7, 800b36e <osTimerNew+0x42>
        reload = pdFALSE;
      } else {
        reload = pdTRUE;
 800b36a:	f04f 0901 	mov.w	r9, #1
      }

      mem  = -1;
      name = NULL;

      if (attr != NULL) {
 800b36e:	b33d      	cbz	r5, 800b3c0 <osTimerNew+0x94>
        if (attr->name != NULL) {
 800b370:	682c      	ldr	r4, [r5, #0]
          name = attr->name;
        }

        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticTimer_t))) {
 800b372:	68ab      	ldr	r3, [r5, #8]
 800b374:	b113      	cbz	r3, 800b37c <osTimerNew+0x50>
 800b376:	68ea      	ldr	r2, [r5, #12]
 800b378:	2a2f      	cmp	r2, #47	; 0x2f
 800b37a:	d817      	bhi.n	800b3ac <osTimerNew+0x80>
          mem = 1;
        }
        else {
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800b37c:	b18b      	cbz	r3, 800b3a2 <osTimerNew+0x76>
      mem  = -1;
 800b37e:	f04f 33ff 	mov.w	r3, #4294967295

      if (mem == 1) {
        hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
      }
      else {
        if (mem == 0) {
 800b382:	bb53      	cbnz	r3, 800b3da <osTimerNew+0xae>
          hTimer = xTimerCreate (name, 1, reload, callb, TimerCallback);
 800b384:	4b17      	ldr	r3, [pc, #92]	; (800b3e4 <osTimerNew+0xb8>)
 800b386:	9300      	str	r3, [sp, #0]
 800b388:	4603      	mov	r3, r0
 800b38a:	464a      	mov	r2, r9
 800b38c:	2101      	movs	r1, #1
 800b38e:	4620      	mov	r0, r4
 800b390:	f003 fc5c 	bl	800ec4c <xTimerCreate>
 800b394:	e01a      	b.n	800b3cc <osTimerNew+0xa0>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b396:	f3ef 8311 	mrs	r3, BASEPRI
  if (!IS_IRQ() && (func != NULL)) {
 800b39a:	2b00      	cmp	r3, #0
 800b39c:	d0da      	beq.n	800b354 <osTimerNew+0x28>
  hTimer = NULL;
 800b39e:	2000      	movs	r0, #0
 800b3a0:	e014      	b.n	800b3cc <osTimerNew+0xa0>
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800b3a2:	68eb      	ldr	r3, [r5, #12]
 800b3a4:	b17b      	cbz	r3, 800b3c6 <osTimerNew+0x9a>
      mem  = -1;
 800b3a6:	f04f 33ff 	mov.w	r3, #4294967295
 800b3aa:	e7ea      	b.n	800b382 <osTimerNew+0x56>
        hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
 800b3ac:	9301      	str	r3, [sp, #4]
 800b3ae:	4b0d      	ldr	r3, [pc, #52]	; (800b3e4 <osTimerNew+0xb8>)
 800b3b0:	9300      	str	r3, [sp, #0]
 800b3b2:	4603      	mov	r3, r0
 800b3b4:	464a      	mov	r2, r9
 800b3b6:	2101      	movs	r1, #1
 800b3b8:	4620      	mov	r0, r4
 800b3ba:	f003 fc63 	bl	800ec84 <xTimerCreateStatic>
 800b3be:	e005      	b.n	800b3cc <osTimerNew+0xa0>
      name = NULL;
 800b3c0:	462c      	mov	r4, r5
        mem = 0;
 800b3c2:	2300      	movs	r3, #0
 800b3c4:	e7dd      	b.n	800b382 <osTimerNew+0x56>
            mem = 0;
 800b3c6:	2300      	movs	r3, #0
 800b3c8:	e7db      	b.n	800b382 <osTimerNew+0x56>
  hTimer = NULL;
 800b3ca:	2000      	movs	r0, #0
      }
    }
  }

  return ((osTimerId_t)hTimer);
}
 800b3cc:	b003      	add	sp, #12
 800b3ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  hTimer = NULL;
 800b3d2:	2000      	movs	r0, #0
 800b3d4:	e7fa      	b.n	800b3cc <osTimerNew+0xa0>
 800b3d6:	2000      	movs	r0, #0
 800b3d8:	e7f8      	b.n	800b3cc <osTimerNew+0xa0>
 800b3da:	2000      	movs	r0, #0
  return ((osTimerId_t)hTimer);
 800b3dc:	e7f6      	b.n	800b3cc <osTimerNew+0xa0>
 800b3de:	bf00      	nop
 800b3e0:	200001c8 	.word	0x200001c8
 800b3e4:	0800a965 	.word	0x0800a965

0800b3e8 <osTimerGetName>:

const char *osTimerGetName (osTimerId_t timer_id) {
 800b3e8:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b3ea:	f3ef 8305 	mrs	r3, IPSR
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
  const char *p;

  if (IS_IRQ() || (hTimer == NULL)) {
 800b3ee:	b983      	cbnz	r3, 800b412 <osTimerGetName+0x2a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b3f0:	f3ef 8310 	mrs	r3, PRIMASK
 800b3f4:	b97b      	cbnz	r3, 800b416 <osTimerGetName+0x2e>
 800b3f6:	4b09      	ldr	r3, [pc, #36]	; (800b41c <osTimerGetName+0x34>)
 800b3f8:	681b      	ldr	r3, [r3, #0]
 800b3fa:	2b02      	cmp	r3, #2
 800b3fc:	d003      	beq.n	800b406 <osTimerGetName+0x1e>
 800b3fe:	b108      	cbz	r0, 800b404 <osTimerGetName+0x1c>
    p = NULL;
  } else {
    p = pcTimerGetName (hTimer);
 800b400:	f003 fe06 	bl	800f010 <pcTimerGetName>
  }

  return (p);
}
 800b404:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b406:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ() || (hTimer == NULL)) {
 800b40a:	2b00      	cmp	r3, #0
 800b40c:	d0f7      	beq.n	800b3fe <osTimerGetName+0x16>
    p = NULL;
 800b40e:	2000      	movs	r0, #0
 800b410:	e7f8      	b.n	800b404 <osTimerGetName+0x1c>
 800b412:	2000      	movs	r0, #0
 800b414:	e7f6      	b.n	800b404 <osTimerGetName+0x1c>
 800b416:	2000      	movs	r0, #0
 800b418:	e7f4      	b.n	800b404 <osTimerGetName+0x1c>
 800b41a:	bf00      	nop
 800b41c:	200001c8 	.word	0x200001c8

0800b420 <osTimerStart>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b420:	f3ef 8305 	mrs	r3, IPSR

osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
  osStatus_t stat;

  if (IS_IRQ()) {
 800b424:	b9e3      	cbnz	r3, 800b460 <osTimerStart+0x40>
 800b426:	460a      	mov	r2, r1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b428:	f3ef 8310 	mrs	r3, PRIMASK
 800b42c:	b9db      	cbnz	r3, 800b466 <osTimerStart+0x46>
 800b42e:	4b12      	ldr	r3, [pc, #72]	; (800b478 <osTimerStart+0x58>)
 800b430:	681b      	ldr	r3, [r3, #0]
 800b432:	2b02      	cmp	r3, #2
 800b434:	d00d      	beq.n	800b452 <osTimerStart+0x32>
    stat = osErrorISR;
  }
  else if (hTimer == NULL) {
 800b436:	b1c8      	cbz	r0, 800b46c <osTimerStart+0x4c>
osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
 800b438:	b500      	push	{lr}
 800b43a:	b083      	sub	sp, #12
    stat = osErrorParameter;
  }
  else {
    if (xTimerChangePeriod (hTimer, ticks, 0) == pdPASS) {
 800b43c:	2300      	movs	r3, #0
 800b43e:	9300      	str	r3, [sp, #0]
 800b440:	2104      	movs	r1, #4
 800b442:	f003 fc45 	bl	800ecd0 <xTimerGenericCommand>
 800b446:	2801      	cmp	r0, #1
 800b448:	d113      	bne.n	800b472 <osTimerStart+0x52>
      stat = osOK;
 800b44a:	2000      	movs	r0, #0
      stat = osErrorResource;
    }
  }

  return (stat);
}
 800b44c:	b003      	add	sp, #12
 800b44e:	f85d fb04 	ldr.w	pc, [sp], #4
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b452:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b456:	2b00      	cmp	r3, #0
 800b458:	d0ed      	beq.n	800b436 <osTimerStart+0x16>
    stat = osErrorISR;
 800b45a:	f06f 0005 	mvn.w	r0, #5
 800b45e:	4770      	bx	lr
 800b460:	f06f 0005 	mvn.w	r0, #5
 800b464:	4770      	bx	lr
 800b466:	f06f 0005 	mvn.w	r0, #5
 800b46a:	4770      	bx	lr
    stat = osErrorParameter;
 800b46c:	f06f 0003 	mvn.w	r0, #3
}
 800b470:	4770      	bx	lr
      stat = osErrorResource;
 800b472:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800b476:	e7e9      	b.n	800b44c <osTimerStart+0x2c>
 800b478:	200001c8 	.word	0x200001c8

0800b47c <osTimerStop>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b47c:	f3ef 8305 	mrs	r3, IPSR

osStatus_t osTimerStop (osTimerId_t timer_id) {
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
  osStatus_t stat;

  if (IS_IRQ()) {
 800b480:	bb0b      	cbnz	r3, 800b4c6 <osTimerStop+0x4a>
osStatus_t osTimerStop (osTimerId_t timer_id) {
 800b482:	b510      	push	{r4, lr}
 800b484:	b082      	sub	sp, #8
 800b486:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b488:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800b48c:	b9f3      	cbnz	r3, 800b4cc <osTimerStop+0x50>
 800b48e:	4b15      	ldr	r3, [pc, #84]	; (800b4e4 <osTimerStop+0x68>)
 800b490:	681b      	ldr	r3, [r3, #0]
 800b492:	2b02      	cmp	r3, #2
 800b494:	d010      	beq.n	800b4b8 <osTimerStop+0x3c>
    stat = osErrorISR;
  }
  else if (hTimer == NULL) {
 800b496:	b1e4      	cbz	r4, 800b4d2 <osTimerStop+0x56>
    stat = osErrorParameter;
  }
  else {
    if (xTimerIsTimerActive (hTimer) == pdFALSE) {
 800b498:	4620      	mov	r0, r4
 800b49a:	f003 fdc5 	bl	800f028 <xTimerIsTimerActive>
 800b49e:	b1d8      	cbz	r0, 800b4d8 <osTimerStop+0x5c>
      stat = osErrorResource;
    }
    else {
      if (xTimerStop (hTimer, 0) == pdPASS) {
 800b4a0:	2200      	movs	r2, #0
 800b4a2:	9200      	str	r2, [sp, #0]
 800b4a4:	4613      	mov	r3, r2
 800b4a6:	2103      	movs	r1, #3
 800b4a8:	4620      	mov	r0, r4
 800b4aa:	f003 fc11 	bl	800ecd0 <xTimerGenericCommand>
 800b4ae:	2801      	cmp	r0, #1
 800b4b0:	d115      	bne.n	800b4de <osTimerStop+0x62>
        stat = osOK;
 800b4b2:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 800b4b4:	b002      	add	sp, #8
 800b4b6:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b4b8:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b4bc:	2b00      	cmp	r3, #0
 800b4be:	d0ea      	beq.n	800b496 <osTimerStop+0x1a>
    stat = osErrorISR;
 800b4c0:	f06f 0005 	mvn.w	r0, #5
 800b4c4:	e7f6      	b.n	800b4b4 <osTimerStop+0x38>
 800b4c6:	f06f 0005 	mvn.w	r0, #5
}
 800b4ca:	4770      	bx	lr
    stat = osErrorISR;
 800b4cc:	f06f 0005 	mvn.w	r0, #5
 800b4d0:	e7f0      	b.n	800b4b4 <osTimerStop+0x38>
    stat = osErrorParameter;
 800b4d2:	f06f 0003 	mvn.w	r0, #3
 800b4d6:	e7ed      	b.n	800b4b4 <osTimerStop+0x38>
      stat = osErrorResource;
 800b4d8:	f06f 0002 	mvn.w	r0, #2
 800b4dc:	e7ea      	b.n	800b4b4 <osTimerStop+0x38>
        stat = osError;
 800b4de:	f04f 30ff 	mov.w	r0, #4294967295
  return (stat);
 800b4e2:	e7e7      	b.n	800b4b4 <osTimerStop+0x38>
 800b4e4:	200001c8 	.word	0x200001c8

0800b4e8 <osTimerIsRunning>:

uint32_t osTimerIsRunning (osTimerId_t timer_id) {
 800b4e8:	b508      	push	{r3, lr}
 800b4ea:	4603      	mov	r3, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b4ec:	f3ef 8005 	mrs	r0, IPSR
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
  uint32_t running;

  if (IS_IRQ() || (hTimer == NULL)) {
 800b4f0:	b988      	cbnz	r0, 800b516 <osTimerIsRunning+0x2e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b4f2:	f3ef 8210 	mrs	r2, PRIMASK
 800b4f6:	b97a      	cbnz	r2, 800b518 <osTimerIsRunning+0x30>
 800b4f8:	4909      	ldr	r1, [pc, #36]	; (800b520 <osTimerIsRunning+0x38>)
 800b4fa:	6809      	ldr	r1, [r1, #0]
 800b4fc:	2902      	cmp	r1, #2
 800b4fe:	d004      	beq.n	800b50a <osTimerIsRunning+0x22>
 800b500:	b15b      	cbz	r3, 800b51a <osTimerIsRunning+0x32>
    running = 0U;
  } else {
    running = (uint32_t)xTimerIsTimerActive (hTimer);
 800b502:	4618      	mov	r0, r3
 800b504:	f003 fd90 	bl	800f028 <xTimerIsTimerActive>
 800b508:	e006      	b.n	800b518 <osTimerIsRunning+0x30>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b50a:	f3ef 8111 	mrs	r1, BASEPRI
  if (IS_IRQ() || (hTimer == NULL)) {
 800b50e:	2900      	cmp	r1, #0
 800b510:	d0f6      	beq.n	800b500 <osTimerIsRunning+0x18>
    running = 0U;
 800b512:	4610      	mov	r0, r2
 800b514:	e000      	b.n	800b518 <osTimerIsRunning+0x30>
 800b516:	2000      	movs	r0, #0
  }

  return (running);
}
 800b518:	bd08      	pop	{r3, pc}
    running = 0U;
 800b51a:	4610      	mov	r0, r2
  return (running);
 800b51c:	e7fc      	b.n	800b518 <osTimerIsRunning+0x30>
 800b51e:	bf00      	nop
 800b520:	200001c8 	.word	0x200001c8

0800b524 <osTimerDelete>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b524:	f3ef 8305 	mrs	r3, IPSR
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
  osStatus_t stat;
#ifndef USE_FreeRTOS_HEAP_1
  TimerCallback_t *callb;

  if (IS_IRQ()) {
 800b528:	bb23      	cbnz	r3, 800b574 <osTimerDelete+0x50>
osStatus_t osTimerDelete (osTimerId_t timer_id) {
 800b52a:	b530      	push	{r4, r5, lr}
 800b52c:	b083      	sub	sp, #12
 800b52e:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b530:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800b534:	bb0b      	cbnz	r3, 800b57a <osTimerDelete+0x56>
 800b536:	4b15      	ldr	r3, [pc, #84]	; (800b58c <osTimerDelete+0x68>)
 800b538:	681b      	ldr	r3, [r3, #0]
 800b53a:	2b02      	cmp	r3, #2
 800b53c:	d013      	beq.n	800b566 <osTimerDelete+0x42>
    stat = osErrorISR;
  }
  else if (hTimer == NULL) {
 800b53e:	b1fc      	cbz	r4, 800b580 <osTimerDelete+0x5c>
    stat = osErrorParameter;
  }
  else {
    callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
 800b540:	4620      	mov	r0, r4
 800b542:	f003 fd87 	bl	800f054 <pvTimerGetTimerID>
 800b546:	4605      	mov	r5, r0

    if (xTimerDelete (hTimer, 0) == pdPASS) {
 800b548:	2200      	movs	r2, #0
 800b54a:	9200      	str	r2, [sp, #0]
 800b54c:	4613      	mov	r3, r2
 800b54e:	2105      	movs	r1, #5
 800b550:	4620      	mov	r0, r4
 800b552:	f003 fbbd 	bl	800ecd0 <xTimerGenericCommand>
 800b556:	2801      	cmp	r0, #1
 800b558:	d115      	bne.n	800b586 <osTimerDelete+0x62>
      vPortFree (callb);
 800b55a:	4628      	mov	r0, r5
 800b55c:	f004 f838 	bl	800f5d0 <vPortFree>
      stat = osOK;
 800b560:	2000      	movs	r0, #0
#else
  stat = osError;
#endif

  return (stat);
}
 800b562:	b003      	add	sp, #12
 800b564:	bd30      	pop	{r4, r5, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b566:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b56a:	2b00      	cmp	r3, #0
 800b56c:	d0e7      	beq.n	800b53e <osTimerDelete+0x1a>
    stat = osErrorISR;
 800b56e:	f06f 0005 	mvn.w	r0, #5
 800b572:	e7f6      	b.n	800b562 <osTimerDelete+0x3e>
 800b574:	f06f 0005 	mvn.w	r0, #5
}
 800b578:	4770      	bx	lr
    stat = osErrorISR;
 800b57a:	f06f 0005 	mvn.w	r0, #5
 800b57e:	e7f0      	b.n	800b562 <osTimerDelete+0x3e>
    stat = osErrorParameter;
 800b580:	f06f 0003 	mvn.w	r0, #3
 800b584:	e7ed      	b.n	800b562 <osTimerDelete+0x3e>
      stat = osErrorResource;
 800b586:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800b58a:	e7ea      	b.n	800b562 <osTimerDelete+0x3e>
 800b58c:	200001c8 	.word	0x200001c8

0800b590 <osEventFlagsNew>:

/*---------------------------------------------------------------------------*/

osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
 800b590:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b592:	f3ef 8305 	mrs	r3, IPSR
  EventGroupHandle_t hEventGroup;
  int32_t mem;

  hEventGroup = NULL;

  if (!IS_IRQ()) {
 800b596:	bb33      	cbnz	r3, 800b5e6 <osEventFlagsNew+0x56>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b598:	f3ef 8310 	mrs	r3, PRIMASK
 800b59c:	bb2b      	cbnz	r3, 800b5ea <osEventFlagsNew+0x5a>
 800b59e:	4b15      	ldr	r3, [pc, #84]	; (800b5f4 <osEventFlagsNew+0x64>)
 800b5a0:	681b      	ldr	r3, [r3, #0]
 800b5a2:	2b02      	cmp	r3, #2
 800b5a4:	d00c      	beq.n	800b5c0 <osEventFlagsNew+0x30>
    mem = -1;

    if (attr != NULL) {
 800b5a6:	b1d0      	cbz	r0, 800b5de <osEventFlagsNew+0x4e>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticEventGroup_t))) {
 800b5a8:	6883      	ldr	r3, [r0, #8]
 800b5aa:	b113      	cbz	r3, 800b5b2 <osEventFlagsNew+0x22>
 800b5ac:	68c2      	ldr	r2, [r0, #12]
 800b5ae:	2a1f      	cmp	r2, #31
 800b5b0:	d811      	bhi.n	800b5d6 <osEventFlagsNew+0x46>
        mem = 1;
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800b5b2:	b15b      	cbz	r3, 800b5cc <osEventFlagsNew+0x3c>
    mem = -1;
 800b5b4:	f04f 33ff 	mov.w	r3, #4294967295

    if (mem == 1) {
      hEventGroup = xEventGroupCreateStatic (attr->cb_mem);
    }
    else {
      if (mem == 0) {
 800b5b8:	b9cb      	cbnz	r3, 800b5ee <osEventFlagsNew+0x5e>
        hEventGroup = xEventGroupCreate();
 800b5ba:	f000 fd4e 	bl	800c05a <xEventGroupCreate>
 800b5be:	e013      	b.n	800b5e8 <osEventFlagsNew+0x58>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b5c0:	f3ef 8311 	mrs	r3, BASEPRI
  if (!IS_IRQ()) {
 800b5c4:	2b00      	cmp	r3, #0
 800b5c6:	d0ee      	beq.n	800b5a6 <osEventFlagsNew+0x16>
  hEventGroup = NULL;
 800b5c8:	2000      	movs	r0, #0
 800b5ca:	e00d      	b.n	800b5e8 <osEventFlagsNew+0x58>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800b5cc:	68c3      	ldr	r3, [r0, #12]
 800b5ce:	b143      	cbz	r3, 800b5e2 <osEventFlagsNew+0x52>
    mem = -1;
 800b5d0:	f04f 33ff 	mov.w	r3, #4294967295
 800b5d4:	e7f0      	b.n	800b5b8 <osEventFlagsNew+0x28>
      hEventGroup = xEventGroupCreateStatic (attr->cb_mem);
 800b5d6:	4618      	mov	r0, r3
 800b5d8:	f000 fd1a 	bl	800c010 <xEventGroupCreateStatic>
 800b5dc:	e004      	b.n	800b5e8 <osEventFlagsNew+0x58>
      mem = 0;
 800b5de:	2300      	movs	r3, #0
 800b5e0:	e7ea      	b.n	800b5b8 <osEventFlagsNew+0x28>
          mem = 0;
 800b5e2:	2300      	movs	r3, #0
 800b5e4:	e7e8      	b.n	800b5b8 <osEventFlagsNew+0x28>
  hEventGroup = NULL;
 800b5e6:	2000      	movs	r0, #0
      }
    }
  }

  return ((osEventFlagsId_t)hEventGroup);
}
 800b5e8:	bd08      	pop	{r3, pc}
  hEventGroup = NULL;
 800b5ea:	2000      	movs	r0, #0
 800b5ec:	e7fc      	b.n	800b5e8 <osEventFlagsNew+0x58>
 800b5ee:	2000      	movs	r0, #0
  return ((osEventFlagsId_t)hEventGroup);
 800b5f0:	e7fa      	b.n	800b5e8 <osEventFlagsNew+0x58>
 800b5f2:	bf00      	nop
 800b5f4:	200001c8 	.word	0x200001c8

0800b5f8 <osEventFlagsSet>:
uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
  EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
  uint32_t rflags;
  BaseType_t yield;

  if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
 800b5f8:	b360      	cbz	r0, 800b654 <osEventFlagsSet+0x5c>
uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
 800b5fa:	b510      	push	{r4, lr}
 800b5fc:	b082      	sub	sp, #8
 800b5fe:	460c      	mov	r4, r1
 800b600:	4603      	mov	r3, r0
  if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
 800b602:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 800b606:	d128      	bne.n	800b65a <osEventFlagsSet+0x62>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b608:	f3ef 8205 	mrs	r2, IPSR
    rflags = (uint32_t)osErrorParameter;
  }
  else if (IS_IRQ()) {
 800b60c:	b94a      	cbnz	r2, 800b622 <osEventFlagsSet+0x2a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b60e:	f3ef 8210 	mrs	r2, PRIMASK
 800b612:	b932      	cbnz	r2, 800b622 <osEventFlagsSet+0x2a>
 800b614:	4a15      	ldr	r2, [pc, #84]	; (800b66c <osEventFlagsSet+0x74>)
 800b616:	6812      	ldr	r2, [r2, #0]
 800b618:	2a02      	cmp	r2, #2
 800b61a:	d116      	bne.n	800b64a <osEventFlagsSet+0x52>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b61c:	f3ef 8211 	mrs	r2, BASEPRI
 800b620:	b19a      	cbz	r2, 800b64a <osEventFlagsSet+0x52>
    yield = pdFALSE;
 800b622:	2200      	movs	r2, #0
 800b624:	9201      	str	r2, [sp, #4]

    if (xEventGroupSetBitsFromISR (hEventGroup, (EventBits_t)flags, &yield) != pdFAIL) {
 800b626:	aa01      	add	r2, sp, #4
 800b628:	4621      	mov	r1, r4
 800b62a:	4618      	mov	r0, r3
 800b62c:	f000 fec2 	bl	800c3b4 <xEventGroupSetBitsFromISR>
 800b630:	b9b8      	cbnz	r0, 800b662 <osEventFlagsSet+0x6a>
      rflags = (uint32_t)osErrorResource;
    } else {
      rflags = flags;
      portYIELD_FROM_ISR (yield);
 800b632:	9b01      	ldr	r3, [sp, #4]
 800b634:	b1c3      	cbz	r3, 800b668 <osEventFlagsSet+0x70>
 800b636:	4b0e      	ldr	r3, [pc, #56]	; (800b670 <osEventFlagsSet+0x78>)
 800b638:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b63c:	601a      	str	r2, [r3, #0]
 800b63e:	f3bf 8f4f 	dsb	sy
 800b642:	f3bf 8f6f 	isb	sy
      rflags = flags;
 800b646:	4620      	mov	r0, r4
 800b648:	e009      	b.n	800b65e <osEventFlagsSet+0x66>
    }
  }
  else {
    rflags = xEventGroupSetBits (hEventGroup, (EventBits_t)flags);
 800b64a:	4621      	mov	r1, r4
 800b64c:	4618      	mov	r0, r3
 800b64e:	f000 fdd9 	bl	800c204 <xEventGroupSetBits>
 800b652:	e004      	b.n	800b65e <osEventFlagsSet+0x66>
    rflags = (uint32_t)osErrorParameter;
 800b654:	f06f 0003 	mvn.w	r0, #3
  }

  return (rflags);
}
 800b658:	4770      	bx	lr
    rflags = (uint32_t)osErrorParameter;
 800b65a:	f06f 0003 	mvn.w	r0, #3
}
 800b65e:	b002      	add	sp, #8
 800b660:	bd10      	pop	{r4, pc}
      rflags = (uint32_t)osErrorResource;
 800b662:	f06f 0002 	mvn.w	r0, #2
 800b666:	e7fa      	b.n	800b65e <osEventFlagsSet+0x66>
      rflags = flags;
 800b668:	4620      	mov	r0, r4
  return (rflags);
 800b66a:	e7f8      	b.n	800b65e <osEventFlagsSet+0x66>
 800b66c:	200001c8 	.word	0x200001c8
 800b670:	e000ed04 	.word	0xe000ed04

0800b674 <osEventFlagsClear>:

uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
 800b674:	b570      	push	{r4, r5, r6, lr}
  EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
  uint32_t rflags;

  if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
 800b676:	b318      	cbz	r0, 800b6c0 <osEventFlagsClear+0x4c>
 800b678:	460c      	mov	r4, r1
 800b67a:	4606      	mov	r6, r0
 800b67c:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 800b680:	d121      	bne.n	800b6c6 <osEventFlagsClear+0x52>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b682:	f3ef 8305 	mrs	r3, IPSR
    rflags = (uint32_t)osErrorParameter;
  }
  else if (IS_IRQ()) {
 800b686:	b94b      	cbnz	r3, 800b69c <osEventFlagsClear+0x28>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b688:	f3ef 8310 	mrs	r3, PRIMASK
 800b68c:	b933      	cbnz	r3, 800b69c <osEventFlagsClear+0x28>
 800b68e:	4b10      	ldr	r3, [pc, #64]	; (800b6d0 <osEventFlagsClear+0x5c>)
 800b690:	681b      	ldr	r3, [r3, #0]
 800b692:	2b02      	cmp	r3, #2
 800b694:	d10e      	bne.n	800b6b4 <osEventFlagsClear+0x40>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b696:	f3ef 8311 	mrs	r3, BASEPRI
 800b69a:	b15b      	cbz	r3, 800b6b4 <osEventFlagsClear+0x40>
    rflags = xEventGroupGetBitsFromISR (hEventGroup);
 800b69c:	4630      	mov	r0, r6
 800b69e:	f000 fda3 	bl	800c1e8 <xEventGroupGetBitsFromISR>
 800b6a2:	4605      	mov	r5, r0

    if (xEventGroupClearBitsFromISR (hEventGroup, (EventBits_t)flags) == pdFAIL) {
 800b6a4:	4621      	mov	r1, r4
 800b6a6:	4630      	mov	r0, r6
 800b6a8:	f000 fd93 	bl	800c1d2 <xEventGroupClearBitsFromISR>
 800b6ac:	b968      	cbnz	r0, 800b6ca <osEventFlagsClear+0x56>
      rflags = (uint32_t)osErrorResource;
 800b6ae:	f06f 0502 	mvn.w	r5, #2
  }
  else {
    rflags = xEventGroupClearBits (hEventGroup, (EventBits_t)flags);
  }

  return (rflags);
 800b6b2:	e00a      	b.n	800b6ca <osEventFlagsClear+0x56>
    rflags = xEventGroupClearBits (hEventGroup, (EventBits_t)flags);
 800b6b4:	4621      	mov	r1, r4
 800b6b6:	4630      	mov	r0, r6
 800b6b8:	f000 fd64 	bl	800c184 <xEventGroupClearBits>
 800b6bc:	4605      	mov	r5, r0
 800b6be:	e004      	b.n	800b6ca <osEventFlagsClear+0x56>
    rflags = (uint32_t)osErrorParameter;
 800b6c0:	f06f 0503 	mvn.w	r5, #3
 800b6c4:	e001      	b.n	800b6ca <osEventFlagsClear+0x56>
 800b6c6:	f06f 0503 	mvn.w	r5, #3
}
 800b6ca:	4628      	mov	r0, r5
 800b6cc:	bd70      	pop	{r4, r5, r6, pc}
 800b6ce:	bf00      	nop
 800b6d0:	200001c8 	.word	0x200001c8

0800b6d4 <osEventFlagsGet>:

uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
  EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
  uint32_t rflags;

  if (ef_id == NULL) {
 800b6d4:	b1b8      	cbz	r0, 800b706 <osEventFlagsGet+0x32>
uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
 800b6d6:	b508      	push	{r3, lr}
 800b6d8:	4603      	mov	r3, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b6da:	f3ef 8205 	mrs	r2, IPSR
    rflags = 0U;
  }
  else if (IS_IRQ()) {
 800b6de:	b94a      	cbnz	r2, 800b6f4 <osEventFlagsGet+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b6e0:	f3ef 8210 	mrs	r2, PRIMASK
 800b6e4:	b932      	cbnz	r2, 800b6f4 <osEventFlagsGet+0x20>
 800b6e6:	4a09      	ldr	r2, [pc, #36]	; (800b70c <osEventFlagsGet+0x38>)
 800b6e8:	6812      	ldr	r2, [r2, #0]
 800b6ea:	2a02      	cmp	r2, #2
 800b6ec:	d106      	bne.n	800b6fc <osEventFlagsGet+0x28>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b6ee:	f3ef 8211 	mrs	r2, BASEPRI
 800b6f2:	b11a      	cbz	r2, 800b6fc <osEventFlagsGet+0x28>
    rflags = xEventGroupGetBitsFromISR (hEventGroup);
 800b6f4:	4618      	mov	r0, r3
 800b6f6:	f000 fd77 	bl	800c1e8 <xEventGroupGetBitsFromISR>
  else {
    rflags = xEventGroupGetBits (hEventGroup);
  }

  return (rflags);
}
 800b6fa:	bd08      	pop	{r3, pc}
    rflags = xEventGroupGetBits (hEventGroup);
 800b6fc:	2100      	movs	r1, #0
 800b6fe:	4618      	mov	r0, r3
 800b700:	f000 fd40 	bl	800c184 <xEventGroupClearBits>
 800b704:	e7f9      	b.n	800b6fa <osEventFlagsGet+0x26>
    rflags = 0U;
 800b706:	2000      	movs	r0, #0
}
 800b708:	4770      	bx	lr
 800b70a:	bf00      	nop
 800b70c:	200001c8 	.word	0x200001c8

0800b710 <osEventFlagsWait>:
  EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
  BaseType_t wait_all;
  BaseType_t exit_clr;
  uint32_t rflags;

  if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
 800b710:	b3b0      	cbz	r0, 800b780 <osEventFlagsWait+0x70>
uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
 800b712:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b714:	b083      	sub	sp, #12
 800b716:	460c      	mov	r4, r1
 800b718:	461d      	mov	r5, r3
 800b71a:	4606      	mov	r6, r0
  if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
 800b71c:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 800b720:	d131      	bne.n	800b786 <osEventFlagsWait+0x76>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b722:	f3ef 8305 	mrs	r3, IPSR
    rflags = (uint32_t)osErrorParameter;
  }
  else if (IS_IRQ()) {
 800b726:	bb93      	cbnz	r3, 800b78e <osEventFlagsWait+0x7e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b728:	f3ef 8310 	mrs	r3, PRIMASK
 800b72c:	bb93      	cbnz	r3, 800b794 <osEventFlagsWait+0x84>
 800b72e:	4b1e      	ldr	r3, [pc, #120]	; (800b7a8 <osEventFlagsWait+0x98>)
 800b730:	681b      	ldr	r3, [r3, #0]
 800b732:	2b02      	cmp	r3, #2
 800b734:	d013      	beq.n	800b75e <osEventFlagsWait+0x4e>
    rflags = (uint32_t)osErrorISR;
  }
  else {
    if (options & osFlagsWaitAll) {
 800b736:	f012 0701 	ands.w	r7, r2, #1
 800b73a:	d017      	beq.n	800b76c <osEventFlagsWait+0x5c>
      wait_all = pdTRUE;
 800b73c:	2301      	movs	r3, #1
    } else {
      wait_all = pdFAIL;
    }

    if (options & osFlagsNoClear) {
 800b73e:	f012 0f02 	tst.w	r2, #2
 800b742:	d015      	beq.n	800b770 <osEventFlagsWait+0x60>
      exit_clr = pdFAIL;
 800b744:	2200      	movs	r2, #0
    } else {
      exit_clr = pdTRUE;
    }

    rflags = xEventGroupWaitBits (hEventGroup, (EventBits_t)flags, exit_clr, wait_all, (TickType_t)timeout);
 800b746:	9500      	str	r5, [sp, #0]
 800b748:	4621      	mov	r1, r4
 800b74a:	4630      	mov	r0, r6
 800b74c:	f000 fc93 	bl	800c076 <xEventGroupWaitBits>

    if (options & osFlagsWaitAll) {
 800b750:	b187      	cbz	r7, 800b774 <osEventFlagsWait+0x64>
      if (flags != rflags) {
 800b752:	4284      	cmp	r4, r0
 800b754:	d019      	beq.n	800b78a <osEventFlagsWait+0x7a>
        if (timeout > 0U) {
 800b756:	b305      	cbz	r5, 800b79a <osEventFlagsWait+0x8a>
          rflags = (uint32_t)osErrorTimeout;
 800b758:	f06f 0001 	mvn.w	r0, #1
 800b75c:	e015      	b.n	800b78a <osEventFlagsWait+0x7a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b75e:	f3ef 8311 	mrs	r3, BASEPRI
  else if (IS_IRQ()) {
 800b762:	2b00      	cmp	r3, #0
 800b764:	d0e7      	beq.n	800b736 <osEventFlagsWait+0x26>
    rflags = (uint32_t)osErrorISR;
 800b766:	f06f 0005 	mvn.w	r0, #5
 800b76a:	e00e      	b.n	800b78a <osEventFlagsWait+0x7a>
      wait_all = pdFAIL;
 800b76c:	2300      	movs	r3, #0
 800b76e:	e7e6      	b.n	800b73e <osEventFlagsWait+0x2e>
      exit_clr = pdTRUE;
 800b770:	2201      	movs	r2, #1
 800b772:	e7e8      	b.n	800b746 <osEventFlagsWait+0x36>
          rflags = (uint32_t)osErrorResource;
        }
      }
    }
    else {
      if ((flags & rflags) == 0U) {
 800b774:	4204      	tst	r4, r0
 800b776:	d108      	bne.n	800b78a <osEventFlagsWait+0x7a>
        if (timeout > 0U) {
 800b778:	b195      	cbz	r5, 800b7a0 <osEventFlagsWait+0x90>
          rflags = (uint32_t)osErrorTimeout;
 800b77a:	f06f 0001 	mvn.w	r0, #1
 800b77e:	e004      	b.n	800b78a <osEventFlagsWait+0x7a>
    rflags = (uint32_t)osErrorParameter;
 800b780:	f06f 0003 	mvn.w	r0, #3
      }
    }
  }

  return (rflags);
}
 800b784:	4770      	bx	lr
    rflags = (uint32_t)osErrorParameter;
 800b786:	f06f 0003 	mvn.w	r0, #3
}
 800b78a:	b003      	add	sp, #12
 800b78c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rflags = (uint32_t)osErrorISR;
 800b78e:	f06f 0005 	mvn.w	r0, #5
 800b792:	e7fa      	b.n	800b78a <osEventFlagsWait+0x7a>
 800b794:	f06f 0005 	mvn.w	r0, #5
 800b798:	e7f7      	b.n	800b78a <osEventFlagsWait+0x7a>
          rflags = (uint32_t)osErrorResource;
 800b79a:	f06f 0002 	mvn.w	r0, #2
 800b79e:	e7f4      	b.n	800b78a <osEventFlagsWait+0x7a>
          rflags = (uint32_t)osErrorResource;
 800b7a0:	f06f 0002 	mvn.w	r0, #2
  return (rflags);
 800b7a4:	e7f1      	b.n	800b78a <osEventFlagsWait+0x7a>
 800b7a6:	bf00      	nop
 800b7a8:	200001c8 	.word	0x200001c8

0800b7ac <osEventFlagsDelete>:

osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
 800b7ac:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b7ae:	f3ef 8305 	mrs	r3, IPSR
  EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
  osStatus_t stat;

#ifndef USE_FreeRTOS_HEAP_1
  if (IS_IRQ()) {
 800b7b2:	b993      	cbnz	r3, 800b7da <osEventFlagsDelete+0x2e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b7b4:	f3ef 8310 	mrs	r3, PRIMASK
 800b7b8:	b993      	cbnz	r3, 800b7e0 <osEventFlagsDelete+0x34>
 800b7ba:	4b0c      	ldr	r3, [pc, #48]	; (800b7ec <osEventFlagsDelete+0x40>)
 800b7bc:	681b      	ldr	r3, [r3, #0]
 800b7be:	2b02      	cmp	r3, #2
 800b7c0:	d004      	beq.n	800b7cc <osEventFlagsDelete+0x20>
    stat = osErrorISR;
  }
  else if (hEventGroup == NULL) {
 800b7c2:	b180      	cbz	r0, 800b7e6 <osEventFlagsDelete+0x3a>
    stat = osErrorParameter;
  }
  else {
    stat = osOK;
    vEventGroupDelete (hEventGroup);
 800b7c4:	f000 fdd4 	bl	800c370 <vEventGroupDelete>
    stat = osOK;
 800b7c8:	2000      	movs	r0, #0
#else
  stat = osError;
#endif

  return (stat);
}
 800b7ca:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b7cc:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800b7d0:	2b00      	cmp	r3, #0
 800b7d2:	d0f6      	beq.n	800b7c2 <osEventFlagsDelete+0x16>
    stat = osErrorISR;
 800b7d4:	f06f 0005 	mvn.w	r0, #5
 800b7d8:	e7f7      	b.n	800b7ca <osEventFlagsDelete+0x1e>
 800b7da:	f06f 0005 	mvn.w	r0, #5
 800b7de:	e7f4      	b.n	800b7ca <osEventFlagsDelete+0x1e>
 800b7e0:	f06f 0005 	mvn.w	r0, #5
 800b7e4:	e7f1      	b.n	800b7ca <osEventFlagsDelete+0x1e>
    stat = osErrorParameter;
 800b7e6:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800b7ea:	e7ee      	b.n	800b7ca <osEventFlagsDelete+0x1e>
 800b7ec:	200001c8 	.word	0x200001c8

0800b7f0 <osMutexNew>:

/*---------------------------------------------------------------------------*/

osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
 800b7f0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b7f2:	f3ef 8305 	mrs	r3, IPSR
  const char *name;
  #endif

  hMutex = NULL;

  if (!IS_IRQ()) {
 800b7f6:	2b00      	cmp	r3, #0
 800b7f8:	d14e      	bne.n	800b898 <osMutexNew+0xa8>
 800b7fa:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b7fc:	f3ef 8210 	mrs	r2, PRIMASK
 800b800:	4613      	mov	r3, r2
 800b802:	2a00      	cmp	r2, #0
 800b804:	d14b      	bne.n	800b89e <osMutexNew+0xae>
 800b806:	4a28      	ldr	r2, [pc, #160]	; (800b8a8 <osMutexNew+0xb8>)
 800b808:	6812      	ldr	r2, [r2, #0]
 800b80a:	2a02      	cmp	r2, #2
 800b80c:	d023      	beq.n	800b856 <osMutexNew+0x66>
    if (attr != NULL) {
 800b80e:	b104      	cbz	r4, 800b812 <osMutexNew+0x22>
      type = attr->attr_bits;
 800b810:	6863      	ldr	r3, [r4, #4]
    } else {
      type = 0U;
    }

    if ((type & osMutexRecursive) == osMutexRecursive) {
 800b812:	f013 0601 	ands.w	r6, r3, #1
 800b816:	d000      	beq.n	800b81a <osMutexNew+0x2a>
      rmtx = 1U;
 800b818:	2601      	movs	r6, #1
    } else {
      rmtx = 0U;
    }

    if ((type & osMutexRobust) != osMutexRobust) {
 800b81a:	f013 0f08 	tst.w	r3, #8
 800b81e:	d140      	bne.n	800b8a2 <osMutexNew+0xb2>
      mem = -1;

      if (attr != NULL) {
 800b820:	b37c      	cbz	r4, 800b882 <osMutexNew+0x92>
        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 800b822:	68a1      	ldr	r1, [r4, #8]
 800b824:	b111      	cbz	r1, 800b82c <osMutexNew+0x3c>
 800b826:	68e3      	ldr	r3, [r4, #12]
 800b828:	2b4f      	cmp	r3, #79	; 0x4f
 800b82a:	d81f      	bhi.n	800b86c <osMutexNew+0x7c>
          mem = 1;
        }
        else {
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800b82c:	b1c9      	cbz	r1, 800b862 <osMutexNew+0x72>
      mem = -1;
 800b82e:	f04f 33ff 	mov.w	r3, #4294967295
        else {
          hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
        }
      }
      else {
        if (mem == 0) {
 800b832:	bb7b      	cbnz	r3, 800b894 <osMutexNew+0xa4>
          if (rmtx != 0U) {
 800b834:	b34e      	cbz	r6, 800b88a <osMutexNew+0x9a>
            hMutex = xSemaphoreCreateRecursiveMutex ();
 800b836:	2004      	movs	r0, #4
 800b838:	f001 f8ae 	bl	800c998 <xQueueCreateMutex>
 800b83c:	4605      	mov	r5, r0
          }
        }
      }

      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hMutex != NULL) {
 800b83e:	b12d      	cbz	r5, 800b84c <osMutexNew+0x5c>
        if (attr != NULL) {
 800b840:	b104      	cbz	r4, 800b844 <osMutexNew+0x54>
          name = attr->name;
 800b842:	6824      	ldr	r4, [r4, #0]
        } else {
          name = NULL;
        }
        vQueueAddToRegistry (hMutex, name);
 800b844:	4621      	mov	r1, r4
 800b846:	4628      	mov	r0, r5
 800b848:	f001 fce2 	bl	800d210 <vQueueAddToRegistry>
      }
      #endif

      if ((hMutex != NULL) && (rmtx != 0U)) {
 800b84c:	b32d      	cbz	r5, 800b89a <osMutexNew+0xaa>
 800b84e:	b326      	cbz	r6, 800b89a <osMutexNew+0xaa>
        hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
 800b850:	f045 0501 	orr.w	r5, r5, #1
 800b854:	e021      	b.n	800b89a <osMutexNew+0xaa>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b856:	f3ef 8211 	mrs	r2, BASEPRI
  if (!IS_IRQ()) {
 800b85a:	2a00      	cmp	r2, #0
 800b85c:	d0d7      	beq.n	800b80e <osMutexNew+0x1e>
  hMutex = NULL;
 800b85e:	2500      	movs	r5, #0
 800b860:	e01b      	b.n	800b89a <osMutexNew+0xaa>
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800b862:	68e3      	ldr	r3, [r4, #12]
 800b864:	b17b      	cbz	r3, 800b886 <osMutexNew+0x96>
      mem = -1;
 800b866:	f04f 33ff 	mov.w	r3, #4294967295
 800b86a:	e7e2      	b.n	800b832 <osMutexNew+0x42>
        if (rmtx != 0U) {
 800b86c:	b126      	cbz	r6, 800b878 <osMutexNew+0x88>
          hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
 800b86e:	2004      	movs	r0, #4
 800b870:	f001 f89d 	bl	800c9ae <xQueueCreateMutexStatic>
 800b874:	4605      	mov	r5, r0
 800b876:	e7e2      	b.n	800b83e <osMutexNew+0x4e>
          hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
 800b878:	2001      	movs	r0, #1
 800b87a:	f001 f898 	bl	800c9ae <xQueueCreateMutexStatic>
 800b87e:	4605      	mov	r5, r0
 800b880:	e7dd      	b.n	800b83e <osMutexNew+0x4e>
        mem = 0;
 800b882:	2300      	movs	r3, #0
 800b884:	e7d5      	b.n	800b832 <osMutexNew+0x42>
            mem = 0;
 800b886:	2300      	movs	r3, #0
 800b888:	e7d3      	b.n	800b832 <osMutexNew+0x42>
            hMutex = xSemaphoreCreateMutex ();
 800b88a:	2001      	movs	r0, #1
 800b88c:	f001 f884 	bl	800c998 <xQueueCreateMutex>
 800b890:	4605      	mov	r5, r0
 800b892:	e7d4      	b.n	800b83e <osMutexNew+0x4e>
  hMutex = NULL;
 800b894:	2500      	movs	r5, #0
 800b896:	e7d9      	b.n	800b84c <osMutexNew+0x5c>
 800b898:	2500      	movs	r5, #0
      }
    }
  }

  return ((osMutexId_t)hMutex);
}
 800b89a:	4628      	mov	r0, r5
 800b89c:	bd70      	pop	{r4, r5, r6, pc}
  hMutex = NULL;
 800b89e:	2500      	movs	r5, #0
 800b8a0:	e7fb      	b.n	800b89a <osMutexNew+0xaa>
 800b8a2:	2500      	movs	r5, #0
  return ((osMutexId_t)hMutex);
 800b8a4:	e7f9      	b.n	800b89a <osMutexNew+0xaa>
 800b8a6:	bf00      	nop
 800b8a8:	200001c8 	.word	0x200001c8

0800b8ac <osMutexAcquire>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b8ac:	f3ef 8205 	mrs	r2, IPSR

  rmtx = (uint32_t)mutex_id & 1U;

  stat = osOK;

  if (IS_IRQ()) {
 800b8b0:	bb42      	cbnz	r2, 800b904 <osMutexAcquire+0x58>
osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
 800b8b2:	b510      	push	{r4, lr}
 800b8b4:	4603      	mov	r3, r0
 800b8b6:	460c      	mov	r4, r1
 800b8b8:	f020 0001 	bic.w	r0, r0, #1
 800b8bc:	f003 0301 	and.w	r3, r3, #1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b8c0:	f3ef 8210 	mrs	r2, PRIMASK
  if (IS_IRQ()) {
 800b8c4:	bb0a      	cbnz	r2, 800b90a <osMutexAcquire+0x5e>
 800b8c6:	4a19      	ldr	r2, [pc, #100]	; (800b92c <osMutexAcquire+0x80>)
 800b8c8:	6812      	ldr	r2, [r2, #0]
 800b8ca:	2a02      	cmp	r2, #2
 800b8cc:	d00a      	beq.n	800b8e4 <osMutexAcquire+0x38>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
 800b8ce:	b1f8      	cbz	r0, 800b910 <osMutexAcquire+0x64>
    stat = osErrorParameter;
  }
  else {
    if (rmtx != 0U) {
 800b8d0:	b17b      	cbz	r3, 800b8f2 <osMutexAcquire+0x46>
      if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
 800b8d2:	4621      	mov	r1, r4
 800b8d4:	f001 fada 	bl	800ce8c <xQueueTakeMutexRecursive>
 800b8d8:	2801      	cmp	r0, #1
 800b8da:	d01c      	beq.n	800b916 <osMutexAcquire+0x6a>
        if (timeout != 0U) {
 800b8dc:	b1ec      	cbz	r4, 800b91a <osMutexAcquire+0x6e>
          stat = osErrorTimeout;
 800b8de:	f06f 0001 	mvn.w	r0, #1
 800b8e2:	e019      	b.n	800b918 <osMutexAcquire+0x6c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b8e4:	f3ef 8211 	mrs	r2, BASEPRI
  if (IS_IRQ()) {
 800b8e8:	2a00      	cmp	r2, #0
 800b8ea:	d0f0      	beq.n	800b8ce <osMutexAcquire+0x22>
    stat = osErrorISR;
 800b8ec:	f06f 0005 	mvn.w	r0, #5
 800b8f0:	e012      	b.n	800b918 <osMutexAcquire+0x6c>
          stat = osErrorResource;
        }
      }
    }
    else {
      if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
 800b8f2:	4621      	mov	r1, r4
 800b8f4:	f001 f9f8 	bl	800cce8 <xQueueSemaphoreTake>
 800b8f8:	2801      	cmp	r0, #1
 800b8fa:	d011      	beq.n	800b920 <osMutexAcquire+0x74>
        if (timeout != 0U) {
 800b8fc:	b194      	cbz	r4, 800b924 <osMutexAcquire+0x78>
          stat = osErrorTimeout;
 800b8fe:	f06f 0001 	mvn.w	r0, #1
 800b902:	e009      	b.n	800b918 <osMutexAcquire+0x6c>
    stat = osErrorISR;
 800b904:	f06f 0005 	mvn.w	r0, #5
      }
    }
  }

  return (stat);
}
 800b908:	4770      	bx	lr
    stat = osErrorISR;
 800b90a:	f06f 0005 	mvn.w	r0, #5
 800b90e:	e003      	b.n	800b918 <osMutexAcquire+0x6c>
    stat = osErrorParameter;
 800b910:	f06f 0003 	mvn.w	r0, #3
 800b914:	e000      	b.n	800b918 <osMutexAcquire+0x6c>
  stat = osOK;
 800b916:	2000      	movs	r0, #0
}
 800b918:	bd10      	pop	{r4, pc}
          stat = osErrorResource;
 800b91a:	f06f 0002 	mvn.w	r0, #2
 800b91e:	e7fb      	b.n	800b918 <osMutexAcquire+0x6c>
  stat = osOK;
 800b920:	2000      	movs	r0, #0
 800b922:	e7f9      	b.n	800b918 <osMutexAcquire+0x6c>
          stat = osErrorResource;
 800b924:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800b928:	e7f6      	b.n	800b918 <osMutexAcquire+0x6c>
 800b92a:	bf00      	nop
 800b92c:	200001c8 	.word	0x200001c8

0800b930 <osMutexRelease>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b930:	f3ef 8205 	mrs	r2, IPSR

  rmtx = (uint32_t)mutex_id & 1U;

  stat = osOK;

  if (IS_IRQ()) {
 800b934:	bb22      	cbnz	r2, 800b980 <osMutexRelease+0x50>
osStatus_t osMutexRelease (osMutexId_t mutex_id) {
 800b936:	b508      	push	{r3, lr}
 800b938:	4603      	mov	r3, r0
 800b93a:	f020 0001 	bic.w	r0, r0, #1
 800b93e:	f003 0301 	and.w	r3, r3, #1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b942:	f3ef 8210 	mrs	r2, PRIMASK
  if (IS_IRQ()) {
 800b946:	b9f2      	cbnz	r2, 800b986 <osMutexRelease+0x56>
 800b948:	4a15      	ldr	r2, [pc, #84]	; (800b9a0 <osMutexRelease+0x70>)
 800b94a:	6812      	ldr	r2, [r2, #0]
 800b94c:	2a02      	cmp	r2, #2
 800b94e:	d007      	beq.n	800b960 <osMutexRelease+0x30>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
 800b950:	b1e0      	cbz	r0, 800b98c <osMutexRelease+0x5c>
    stat = osErrorParameter;
  }
  else {
    if (rmtx != 0U) {
 800b952:	b163      	cbz	r3, 800b96e <osMutexRelease+0x3e>
      if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
 800b954:	f001 f83a 	bl	800c9cc <xQueueGiveMutexRecursive>
 800b958:	2801      	cmp	r0, #1
 800b95a:	d11a      	bne.n	800b992 <osMutexRelease+0x62>
  stat = osOK;
 800b95c:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 800b95e:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b960:	f3ef 8211 	mrs	r2, BASEPRI
  if (IS_IRQ()) {
 800b964:	2a00      	cmp	r2, #0
 800b966:	d0f3      	beq.n	800b950 <osMutexRelease+0x20>
    stat = osErrorISR;
 800b968:	f06f 0005 	mvn.w	r0, #5
 800b96c:	e7f7      	b.n	800b95e <osMutexRelease+0x2e>
      if (xSemaphoreGive (hMutex) != pdPASS) {
 800b96e:	2300      	movs	r3, #0
 800b970:	461a      	mov	r2, r3
 800b972:	4619      	mov	r1, r3
 800b974:	f000 ff43 	bl	800c7fe <xQueueGenericSend>
 800b978:	2801      	cmp	r0, #1
 800b97a:	d10d      	bne.n	800b998 <osMutexRelease+0x68>
  stat = osOK;
 800b97c:	2000      	movs	r0, #0
 800b97e:	e7ee      	b.n	800b95e <osMutexRelease+0x2e>
    stat = osErrorISR;
 800b980:	f06f 0005 	mvn.w	r0, #5
}
 800b984:	4770      	bx	lr
    stat = osErrorISR;
 800b986:	f06f 0005 	mvn.w	r0, #5
 800b98a:	e7e8      	b.n	800b95e <osMutexRelease+0x2e>
    stat = osErrorParameter;
 800b98c:	f06f 0003 	mvn.w	r0, #3
 800b990:	e7e5      	b.n	800b95e <osMutexRelease+0x2e>
        stat = osErrorResource;
 800b992:	f06f 0002 	mvn.w	r0, #2
 800b996:	e7e2      	b.n	800b95e <osMutexRelease+0x2e>
        stat = osErrorResource;
 800b998:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800b99c:	e7df      	b.n	800b95e <osMutexRelease+0x2e>
 800b99e:	bf00      	nop
 800b9a0:	200001c8 	.word	0x200001c8

0800b9a4 <osMutexGetOwner>:

osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
 800b9a4:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b9a6:	f3ef 8305 	mrs	r3, IPSR
  SemaphoreHandle_t hMutex;
  osThreadId_t owner;

  hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);

  if (IS_IRQ() || (hMutex == NULL)) {
 800b9aa:	b993      	cbnz	r3, 800b9d2 <osMutexGetOwner+0x2e>
 800b9ac:	f020 0001 	bic.w	r0, r0, #1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b9b0:	f3ef 8310 	mrs	r3, PRIMASK
 800b9b4:	b97b      	cbnz	r3, 800b9d6 <osMutexGetOwner+0x32>
 800b9b6:	4b0a      	ldr	r3, [pc, #40]	; (800b9e0 <osMutexGetOwner+0x3c>)
 800b9b8:	681b      	ldr	r3, [r3, #0]
 800b9ba:	2b02      	cmp	r3, #2
 800b9bc:	d003      	beq.n	800b9c6 <osMutexGetOwner+0x22>
 800b9be:	b160      	cbz	r0, 800b9da <osMutexGetOwner+0x36>
    owner = NULL;
  } else {
    owner = (osThreadId_t)xSemaphoreGetMutexHolder (hMutex);
 800b9c0:	f000 febb 	bl	800c73a <xQueueGetMutexHolder>
 800b9c4:	e006      	b.n	800b9d4 <osMutexGetOwner+0x30>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b9c6:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ() || (hMutex == NULL)) {
 800b9ca:	2b00      	cmp	r3, #0
 800b9cc:	d0f7      	beq.n	800b9be <osMutexGetOwner+0x1a>
    owner = NULL;
 800b9ce:	2000      	movs	r0, #0
 800b9d0:	e000      	b.n	800b9d4 <osMutexGetOwner+0x30>
 800b9d2:	2000      	movs	r0, #0
  }

  return (owner);
}
 800b9d4:	bd08      	pop	{r3, pc}
    owner = NULL;
 800b9d6:	2000      	movs	r0, #0
 800b9d8:	e7fc      	b.n	800b9d4 <osMutexGetOwner+0x30>
 800b9da:	2000      	movs	r0, #0
  return (owner);
 800b9dc:	e7fa      	b.n	800b9d4 <osMutexGetOwner+0x30>
 800b9de:	bf00      	nop
 800b9e0:	200001c8 	.word	0x200001c8

0800b9e4 <osMutexDelete>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b9e4:	f3ef 8305 	mrs	r3, IPSR
#ifndef USE_FreeRTOS_HEAP_1
  SemaphoreHandle_t hMutex;

  hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);

  if (IS_IRQ()) {
 800b9e8:	b9cb      	cbnz	r3, 800ba1e <osMutexDelete+0x3a>
osStatus_t osMutexDelete (osMutexId_t mutex_id) {
 800b9ea:	b510      	push	{r4, lr}
 800b9ec:	f020 0401 	bic.w	r4, r0, #1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800b9f0:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800b9f4:	b9b3      	cbnz	r3, 800ba24 <osMutexDelete+0x40>
 800b9f6:	4b0e      	ldr	r3, [pc, #56]	; (800ba30 <osMutexDelete+0x4c>)
 800b9f8:	681b      	ldr	r3, [r3, #0]
 800b9fa:	2b02      	cmp	r3, #2
 800b9fc:	d008      	beq.n	800ba10 <osMutexDelete+0x2c>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
 800b9fe:	b1a4      	cbz	r4, 800ba2a <osMutexDelete+0x46>
    stat = osErrorParameter;
  }
  else {
    #if (configQUEUE_REGISTRY_SIZE > 0)
    vQueueUnregisterQueue (hMutex);
 800ba00:	4620      	mov	r0, r4
 800ba02:	f001 fc2d 	bl	800d260 <vQueueUnregisterQueue>
    #endif
    stat = osOK;
    vSemaphoreDelete (hMutex);
 800ba06:	4620      	mov	r0, r4
 800ba08:	f001 fc40 	bl	800d28c <vQueueDelete>
    stat = osOK;
 800ba0c:	2000      	movs	r0, #0
#else
  stat = osError;
#endif

  return (stat);
}
 800ba0e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ba10:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800ba14:	2b00      	cmp	r3, #0
 800ba16:	d0f2      	beq.n	800b9fe <osMutexDelete+0x1a>
    stat = osErrorISR;
 800ba18:	f06f 0005 	mvn.w	r0, #5
 800ba1c:	e7f7      	b.n	800ba0e <osMutexDelete+0x2a>
 800ba1e:	f06f 0005 	mvn.w	r0, #5
}
 800ba22:	4770      	bx	lr
    stat = osErrorISR;
 800ba24:	f06f 0005 	mvn.w	r0, #5
 800ba28:	e7f1      	b.n	800ba0e <osMutexDelete+0x2a>
    stat = osErrorParameter;
 800ba2a:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800ba2e:	e7ee      	b.n	800ba0e <osMutexDelete+0x2a>
 800ba30:	200001c8 	.word	0x200001c8

0800ba34 <osSemaphoreNew>:

/*---------------------------------------------------------------------------*/

osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
 800ba34:	b570      	push	{r4, r5, r6, lr}
 800ba36:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ba38:	f3ef 8305 	mrs	r3, IPSR
  const char *name;
  #endif

  hSemaphore = NULL;

  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
 800ba3c:	2b00      	cmp	r3, #0
 800ba3e:	d157      	bne.n	800baf0 <osSemaphoreNew+0xbc>
 800ba40:	460e      	mov	r6, r1
 800ba42:	4615      	mov	r5, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ba44:	f3ef 8310 	mrs	r3, PRIMASK
 800ba48:	2b00      	cmp	r3, #0
 800ba4a:	d155      	bne.n	800baf8 <osSemaphoreNew+0xc4>
 800ba4c:	4b2e      	ldr	r3, [pc, #184]	; (800bb08 <osSemaphoreNew+0xd4>)
 800ba4e:	681b      	ldr	r3, [r3, #0]
 800ba50:	2b02      	cmp	r3, #2
 800ba52:	d00e      	beq.n	800ba72 <osSemaphoreNew+0x3e>
 800ba54:	2800      	cmp	r0, #0
 800ba56:	d051      	beq.n	800bafc <osSemaphoreNew+0xc8>
 800ba58:	42b0      	cmp	r0, r6
 800ba5a:	d351      	bcc.n	800bb00 <osSemaphoreNew+0xcc>
    mem = -1;

    if (attr != NULL) {
 800ba5c:	b17d      	cbz	r5, 800ba7e <osSemaphoreNew+0x4a>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 800ba5e:	68ac      	ldr	r4, [r5, #8]
 800ba60:	b114      	cbz	r4, 800ba68 <osSemaphoreNew+0x34>
 800ba62:	68eb      	ldr	r3, [r5, #12]
 800ba64:	2b4f      	cmp	r3, #79	; 0x4f
 800ba66:	d81a      	bhi.n	800ba9e <osSemaphoreNew+0x6a>
        mem = 1;
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 800ba68:	2c00      	cmp	r4, #0
 800ba6a:	d14b      	bne.n	800bb04 <osSemaphoreNew+0xd0>
 800ba6c:	68eb      	ldr	r3, [r5, #12]
 800ba6e:	b13b      	cbz	r3, 800ba80 <osSemaphoreNew+0x4c>
 800ba70:	e03f      	b.n	800baf2 <osSemaphoreNew+0xbe>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ba72:	f3ef 8311 	mrs	r3, BASEPRI
  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
 800ba76:	2b00      	cmp	r3, #0
 800ba78:	d0ec      	beq.n	800ba54 <osSemaphoreNew+0x20>
  hSemaphore = NULL;
 800ba7a:	2400      	movs	r4, #0
 800ba7c:	e039      	b.n	800baf2 <osSemaphoreNew+0xbe>
          mem = 0;
        }
      }
    }
    else {
      mem = 0;
 800ba7e:	2300      	movs	r3, #0
    }

    if (mem != -1) {
      if (max_count == 1U) {
 800ba80:	2801      	cmp	r0, #1
 800ba82:	d00e      	beq.n	800baa2 <osSemaphoreNew+0x6e>
            hSemaphore = NULL;
          }
        }
      }
      else {
        if (mem == 1) {
 800ba84:	bb73      	cbnz	r3, 800bae4 <osSemaphoreNew+0xb0>
          hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
        }
        else {
          hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
 800ba86:	4631      	mov	r1, r6
 800ba88:	f000 fe99 	bl	800c7be <xQueueCreateCountingSemaphore>
 800ba8c:	4604      	mov	r4, r0
        }
      }

      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hSemaphore != NULL) {
 800ba8e:	b384      	cbz	r4, 800baf2 <osSemaphoreNew+0xbe>
        if (attr != NULL) {
 800ba90:	b105      	cbz	r5, 800ba94 <osSemaphoreNew+0x60>
          name = attr->name;
 800ba92:	682d      	ldr	r5, [r5, #0]
        } else {
          name = NULL;
        }
        vQueueAddToRegistry (hSemaphore, name);
 800ba94:	4629      	mov	r1, r5
 800ba96:	4620      	mov	r0, r4
 800ba98:	f001 fbba 	bl	800d210 <vQueueAddToRegistry>
 800ba9c:	e029      	b.n	800baf2 <osSemaphoreNew+0xbe>
        mem = 1;
 800ba9e:	2301      	movs	r3, #1
 800baa0:	e7ee      	b.n	800ba80 <osSemaphoreNew+0x4c>
        if (mem == 1) {
 800baa2:	b9b3      	cbnz	r3, 800bad2 <osSemaphoreNew+0x9e>
          hSemaphore = xSemaphoreCreateBinary();
 800baa4:	2203      	movs	r2, #3
 800baa6:	2100      	movs	r1, #0
 800baa8:	2001      	movs	r0, #1
 800baaa:	f000 fe1f 	bl	800c6ec <xQueueGenericCreate>
 800baae:	4604      	mov	r4, r0
        if ((hSemaphore != NULL) && (initial_count != 0U)) {
 800bab0:	2c00      	cmp	r4, #0
 800bab2:	d0ec      	beq.n	800ba8e <osSemaphoreNew+0x5a>
 800bab4:	2e00      	cmp	r6, #0
 800bab6:	d0ea      	beq.n	800ba8e <osSemaphoreNew+0x5a>
          if (xSemaphoreGive (hSemaphore) != pdPASS) {
 800bab8:	2300      	movs	r3, #0
 800baba:	461a      	mov	r2, r3
 800babc:	4619      	mov	r1, r3
 800babe:	4620      	mov	r0, r4
 800bac0:	f000 fe9d 	bl	800c7fe <xQueueGenericSend>
 800bac4:	2801      	cmp	r0, #1
 800bac6:	d0e2      	beq.n	800ba8e <osSemaphoreNew+0x5a>
            vSemaphoreDelete (hSemaphore);
 800bac8:	4620      	mov	r0, r4
 800baca:	f001 fbdf 	bl	800d28c <vQueueDelete>
            hSemaphore = NULL;
 800bace:	2400      	movs	r4, #0
 800bad0:	e00f      	b.n	800baf2 <osSemaphoreNew+0xbe>
          hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
 800bad2:	68ab      	ldr	r3, [r5, #8]
 800bad4:	2203      	movs	r2, #3
 800bad6:	9200      	str	r2, [sp, #0]
 800bad8:	2200      	movs	r2, #0
 800bada:	4611      	mov	r1, r2
 800badc:	f000 fdbd 	bl	800c65a <xQueueGenericCreateStatic>
 800bae0:	4604      	mov	r4, r0
 800bae2:	e7e5      	b.n	800bab0 <osSemaphoreNew+0x7c>
          hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
 800bae4:	68aa      	ldr	r2, [r5, #8]
 800bae6:	4631      	mov	r1, r6
 800bae8:	f000 fe44 	bl	800c774 <xQueueCreateCountingSemaphoreStatic>
 800baec:	4604      	mov	r4, r0
 800baee:	e7ce      	b.n	800ba8e <osSemaphoreNew+0x5a>
  hSemaphore = NULL;
 800baf0:	2400      	movs	r4, #0
      #endif
    }
  }

  return ((osSemaphoreId_t)hSemaphore);
}
 800baf2:	4620      	mov	r0, r4
 800baf4:	b002      	add	sp, #8
 800baf6:	bd70      	pop	{r4, r5, r6, pc}
  hSemaphore = NULL;
 800baf8:	2400      	movs	r4, #0
 800bafa:	e7fa      	b.n	800baf2 <osSemaphoreNew+0xbe>
 800bafc:	2400      	movs	r4, #0
 800bafe:	e7f8      	b.n	800baf2 <osSemaphoreNew+0xbe>
 800bb00:	2400      	movs	r4, #0
 800bb02:	e7f6      	b.n	800baf2 <osSemaphoreNew+0xbe>
 800bb04:	2400      	movs	r4, #0
  return ((osSemaphoreId_t)hSemaphore);
 800bb06:	e7f4      	b.n	800baf2 <osSemaphoreNew+0xbe>
 800bb08:	200001c8 	.word	0x200001c8

0800bb0c <osSemaphoreAcquire>:
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;

  if (hSemaphore == NULL) {
 800bb0c:	b380      	cbz	r0, 800bb70 <osSemaphoreAcquire+0x64>
osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
 800bb0e:	b530      	push	{r4, r5, lr}
 800bb10:	b083      	sub	sp, #12
 800bb12:	460c      	mov	r4, r1
 800bb14:	4605      	mov	r5, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bb16:	f3ef 8305 	mrs	r3, IPSR
    stat = osErrorParameter;
  }
  else if (IS_IRQ()) {
 800bb1a:	b94b      	cbnz	r3, 800bb30 <osSemaphoreAcquire+0x24>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bb1c:	f3ef 8310 	mrs	r3, PRIMASK
 800bb20:	b933      	cbnz	r3, 800bb30 <osSemaphoreAcquire+0x24>
 800bb22:	4b1a      	ldr	r3, [pc, #104]	; (800bb8c <osSemaphoreAcquire+0x80>)
 800bb24:	681b      	ldr	r3, [r3, #0]
 800bb26:	2b02      	cmp	r3, #2
 800bb28:	d118      	bne.n	800bb5c <osSemaphoreAcquire+0x50>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bb2a:	f3ef 8311 	mrs	r3, BASEPRI
 800bb2e:	b1ab      	cbz	r3, 800bb5c <osSemaphoreAcquire+0x50>
    if (timeout != 0U) {
 800bb30:	bb0c      	cbnz	r4, 800bb76 <osSemaphoreAcquire+0x6a>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;
 800bb32:	2100      	movs	r1, #0
 800bb34:	9101      	str	r1, [sp, #4]

      if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
 800bb36:	aa01      	add	r2, sp, #4
 800bb38:	4628      	mov	r0, r5
 800bb3a:	f001 fa77 	bl	800d02c <xQueueReceiveFromISR>
 800bb3e:	2801      	cmp	r0, #1
 800bb40:	d11c      	bne.n	800bb7c <osSemaphoreAcquire+0x70>
        stat = osErrorResource;
      } else {
        portYIELD_FROM_ISR (yield);
 800bb42:	9801      	ldr	r0, [sp, #4]
 800bb44:	b140      	cbz	r0, 800bb58 <osSemaphoreAcquire+0x4c>
 800bb46:	4b12      	ldr	r3, [pc, #72]	; (800bb90 <osSemaphoreAcquire+0x84>)
 800bb48:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800bb4c:	601a      	str	r2, [r3, #0]
 800bb4e:	f3bf 8f4f 	dsb	sy
 800bb52:	f3bf 8f6f 	isb	sy
  stat = osOK;
 800bb56:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 800bb58:	b003      	add	sp, #12
 800bb5a:	bd30      	pop	{r4, r5, pc}
    if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
 800bb5c:	4621      	mov	r1, r4
 800bb5e:	4628      	mov	r0, r5
 800bb60:	f001 f8c2 	bl	800cce8 <xQueueSemaphoreTake>
 800bb64:	2801      	cmp	r0, #1
 800bb66:	d00c      	beq.n	800bb82 <osSemaphoreAcquire+0x76>
      if (timeout != 0U) {
 800bb68:	b16c      	cbz	r4, 800bb86 <osSemaphoreAcquire+0x7a>
        stat = osErrorTimeout;
 800bb6a:	f06f 0001 	mvn.w	r0, #1
 800bb6e:	e7f3      	b.n	800bb58 <osSemaphoreAcquire+0x4c>
    stat = osErrorParameter;
 800bb70:	f06f 0003 	mvn.w	r0, #3
}
 800bb74:	4770      	bx	lr
      stat = osErrorParameter;
 800bb76:	f06f 0003 	mvn.w	r0, #3
 800bb7a:	e7ed      	b.n	800bb58 <osSemaphoreAcquire+0x4c>
        stat = osErrorResource;
 800bb7c:	f06f 0002 	mvn.w	r0, #2
 800bb80:	e7ea      	b.n	800bb58 <osSemaphoreAcquire+0x4c>
  stat = osOK;
 800bb82:	2000      	movs	r0, #0
 800bb84:	e7e8      	b.n	800bb58 <osSemaphoreAcquire+0x4c>
        stat = osErrorResource;
 800bb86:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800bb8a:	e7e5      	b.n	800bb58 <osSemaphoreAcquire+0x4c>
 800bb8c:	200001c8 	.word	0x200001c8
 800bb90:	e000ed04 	.word	0xe000ed04

0800bb94 <osSemaphoreRelease>:
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;

  if (hSemaphore == NULL) {
 800bb94:	b370      	cbz	r0, 800bbf4 <osSemaphoreRelease+0x60>
osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
 800bb96:	b510      	push	{r4, lr}
 800bb98:	b082      	sub	sp, #8
 800bb9a:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bb9c:	f3ef 8305 	mrs	r3, IPSR
    stat = osErrorParameter;
  }
  else if (IS_IRQ()) {
 800bba0:	b94b      	cbnz	r3, 800bbb6 <osSemaphoreRelease+0x22>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bba2:	f3ef 8310 	mrs	r3, PRIMASK
 800bba6:	b933      	cbnz	r3, 800bbb6 <osSemaphoreRelease+0x22>
 800bba8:	4b17      	ldr	r3, [pc, #92]	; (800bc08 <osSemaphoreRelease+0x74>)
 800bbaa:	681b      	ldr	r3, [r3, #0]
 800bbac:	2b02      	cmp	r3, #2
 800bbae:	d117      	bne.n	800bbe0 <osSemaphoreRelease+0x4c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bbb0:	f3ef 8311 	mrs	r3, BASEPRI
 800bbb4:	b1a3      	cbz	r3, 800bbe0 <osSemaphoreRelease+0x4c>
    yield = pdFALSE;
 800bbb6:	2300      	movs	r3, #0
 800bbb8:	9301      	str	r3, [sp, #4]

    if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
 800bbba:	a901      	add	r1, sp, #4
 800bbbc:	4620      	mov	r0, r4
 800bbbe:	f000 ff8c 	bl	800cada <xQueueGiveFromISR>
 800bbc2:	2801      	cmp	r0, #1
 800bbc4:	d119      	bne.n	800bbfa <osSemaphoreRelease+0x66>
      stat = osErrorResource;
    } else {
      portYIELD_FROM_ISR (yield);
 800bbc6:	9801      	ldr	r0, [sp, #4]
 800bbc8:	b140      	cbz	r0, 800bbdc <osSemaphoreRelease+0x48>
 800bbca:	4b10      	ldr	r3, [pc, #64]	; (800bc0c <osSemaphoreRelease+0x78>)
 800bbcc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800bbd0:	601a      	str	r2, [r3, #0]
 800bbd2:	f3bf 8f4f 	dsb	sy
 800bbd6:	f3bf 8f6f 	isb	sy
  stat = osOK;
 800bbda:	2000      	movs	r0, #0
      stat = osErrorResource;
    }
  }

  return (stat);
}
 800bbdc:	b002      	add	sp, #8
 800bbde:	bd10      	pop	{r4, pc}
    if (xSemaphoreGive (hSemaphore) != pdPASS) {
 800bbe0:	2300      	movs	r3, #0
 800bbe2:	461a      	mov	r2, r3
 800bbe4:	4619      	mov	r1, r3
 800bbe6:	4620      	mov	r0, r4
 800bbe8:	f000 fe09 	bl	800c7fe <xQueueGenericSend>
 800bbec:	2801      	cmp	r0, #1
 800bbee:	d107      	bne.n	800bc00 <osSemaphoreRelease+0x6c>
  stat = osOK;
 800bbf0:	2000      	movs	r0, #0
 800bbf2:	e7f3      	b.n	800bbdc <osSemaphoreRelease+0x48>
    stat = osErrorParameter;
 800bbf4:	f06f 0003 	mvn.w	r0, #3
}
 800bbf8:	4770      	bx	lr
      stat = osErrorResource;
 800bbfa:	f06f 0002 	mvn.w	r0, #2
 800bbfe:	e7ed      	b.n	800bbdc <osSemaphoreRelease+0x48>
      stat = osErrorResource;
 800bc00:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800bc04:	e7ea      	b.n	800bbdc <osSemaphoreRelease+0x48>
 800bc06:	bf00      	nop
 800bc08:	200001c8 	.word	0x200001c8
 800bc0c:	e000ed04 	.word	0xe000ed04

0800bc10 <osSemaphoreGetCount>:

uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
  SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
  uint32_t count;

  if (hSemaphore == NULL) {
 800bc10:	b1b0      	cbz	r0, 800bc40 <osSemaphoreGetCount+0x30>
uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
 800bc12:	b508      	push	{r3, lr}
 800bc14:	4603      	mov	r3, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bc16:	f3ef 8205 	mrs	r2, IPSR
    count = 0U;
  }
  else if (IS_IRQ()) {
 800bc1a:	b94a      	cbnz	r2, 800bc30 <osSemaphoreGetCount+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bc1c:	f3ef 8210 	mrs	r2, PRIMASK
 800bc20:	b932      	cbnz	r2, 800bc30 <osSemaphoreGetCount+0x20>
 800bc22:	4a08      	ldr	r2, [pc, #32]	; (800bc44 <osSemaphoreGetCount+0x34>)
 800bc24:	6812      	ldr	r2, [r2, #0]
 800bc26:	2a02      	cmp	r2, #2
 800bc28:	d106      	bne.n	800bc38 <osSemaphoreGetCount+0x28>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bc2a:	f3ef 8211 	mrs	r2, BASEPRI
 800bc2e:	b11a      	cbz	r2, 800bc38 <osSemaphoreGetCount+0x28>
    count = uxQueueMessagesWaitingFromISR (hSemaphore);
 800bc30:	4618      	mov	r0, r3
 800bc32:	f001 fab8 	bl	800d1a6 <uxQueueMessagesWaitingFromISR>
  } else {
    count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
  }

  return (count);
}
 800bc36:	bd08      	pop	{r3, pc}
    count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
 800bc38:	4618      	mov	r0, r3
 800bc3a:	f001 fa8c 	bl	800d156 <uxQueueMessagesWaiting>
 800bc3e:	e7fa      	b.n	800bc36 <osSemaphoreGetCount+0x26>
    count = 0U;
 800bc40:	2000      	movs	r0, #0
}
 800bc42:	4770      	bx	lr
 800bc44:	200001c8 	.word	0x200001c8

0800bc48 <osSemaphoreDelete>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bc48:	f3ef 8305 	mrs	r3, IPSR
osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
  SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
  osStatus_t stat;

#ifndef USE_FreeRTOS_HEAP_1
  if (IS_IRQ()) {
 800bc4c:	b9c3      	cbnz	r3, 800bc80 <osSemaphoreDelete+0x38>
osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
 800bc4e:	b510      	push	{r4, lr}
 800bc50:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bc52:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800bc56:	b9b3      	cbnz	r3, 800bc86 <osSemaphoreDelete+0x3e>
 800bc58:	4b0e      	ldr	r3, [pc, #56]	; (800bc94 <osSemaphoreDelete+0x4c>)
 800bc5a:	681b      	ldr	r3, [r3, #0]
 800bc5c:	2b02      	cmp	r3, #2
 800bc5e:	d008      	beq.n	800bc72 <osSemaphoreDelete+0x2a>
    stat = osErrorISR;
  }
  else if (hSemaphore == NULL) {
 800bc60:	b1a4      	cbz	r4, 800bc8c <osSemaphoreDelete+0x44>
    stat = osErrorParameter;
  }
  else {
    #if (configQUEUE_REGISTRY_SIZE > 0)
    vQueueUnregisterQueue (hSemaphore);
 800bc62:	4620      	mov	r0, r4
 800bc64:	f001 fafc 	bl	800d260 <vQueueUnregisterQueue>
    #endif

    stat = osOK;
    vSemaphoreDelete (hSemaphore);
 800bc68:	4620      	mov	r0, r4
 800bc6a:	f001 fb0f 	bl	800d28c <vQueueDelete>
    stat = osOK;
 800bc6e:	2000      	movs	r0, #0
#else
  stat = osError;
#endif

  return (stat);
}
 800bc70:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bc72:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800bc76:	2b00      	cmp	r3, #0
 800bc78:	d0f2      	beq.n	800bc60 <osSemaphoreDelete+0x18>
    stat = osErrorISR;
 800bc7a:	f06f 0005 	mvn.w	r0, #5
 800bc7e:	e7f7      	b.n	800bc70 <osSemaphoreDelete+0x28>
 800bc80:	f06f 0005 	mvn.w	r0, #5
}
 800bc84:	4770      	bx	lr
    stat = osErrorISR;
 800bc86:	f06f 0005 	mvn.w	r0, #5
 800bc8a:	e7f1      	b.n	800bc70 <osSemaphoreDelete+0x28>
    stat = osErrorParameter;
 800bc8c:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800bc90:	e7ee      	b.n	800bc70 <osSemaphoreDelete+0x28>
 800bc92:	bf00      	nop
 800bc94:	200001c8 	.word	0x200001c8

0800bc98 <osMessageQueueNew>:

/*---------------------------------------------------------------------------*/

osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
 800bc98:	b570      	push	{r4, r5, r6, lr}
 800bc9a:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bc9c:	f3ef 8305 	mrs	r3, IPSR
  const char *name;
  #endif

  hQueue = NULL;

  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 800bca0:	2b00      	cmp	r3, #0
 800bca2:	d148      	bne.n	800bd36 <osMessageQueueNew+0x9e>
 800bca4:	4615      	mov	r5, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bca6:	f3ef 8310 	mrs	r3, PRIMASK
 800bcaa:	2b00      	cmp	r3, #0
 800bcac:	d147      	bne.n	800bd3e <osMessageQueueNew+0xa6>
 800bcae:	4b28      	ldr	r3, [pc, #160]	; (800bd50 <osMessageQueueNew+0xb8>)
 800bcb0:	681b      	ldr	r3, [r3, #0]
 800bcb2:	2b02      	cmp	r3, #2
 800bcb4:	d020      	beq.n	800bcf8 <osMessageQueueNew+0x60>
 800bcb6:	2800      	cmp	r0, #0
 800bcb8:	d043      	beq.n	800bd42 <osMessageQueueNew+0xaa>
 800bcba:	2900      	cmp	r1, #0
 800bcbc:	d043      	beq.n	800bd46 <osMessageQueueNew+0xae>
    mem = -1;

    if (attr != NULL) {
 800bcbe:	b39d      	cbz	r5, 800bd28 <osMessageQueueNew+0x90>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 800bcc0:	68ab      	ldr	r3, [r5, #8]
 800bcc2:	b14b      	cbz	r3, 800bcd8 <osMessageQueueNew+0x40>
 800bcc4:	68ea      	ldr	r2, [r5, #12]
 800bcc6:	2a4f      	cmp	r2, #79	; 0x4f
 800bcc8:	d906      	bls.n	800bcd8 <osMessageQueueNew+0x40>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 800bcca:	692a      	ldr	r2, [r5, #16]
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 800bccc:	b122      	cbz	r2, 800bcd8 <osMessageQueueNew+0x40>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 800bcce:	696e      	ldr	r6, [r5, #20]
 800bcd0:	fb01 f400 	mul.w	r4, r1, r0
 800bcd4:	42a6      	cmp	r6, r4
 800bcd6:	d221      	bcs.n	800bd1c <osMessageQueueNew+0x84>
        mem = 1;
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 800bcd8:	b1a3      	cbz	r3, 800bd04 <osMessageQueueNew+0x6c>
    mem = -1;
 800bcda:	f04f 33ff 	mov.w	r3, #4294967295

    if (mem == 1) {
      hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
    }
    else {
      if (mem == 0) {
 800bcde:	bba3      	cbnz	r3, 800bd4a <osMessageQueueNew+0xb2>
        hQueue = xQueueCreate (msg_count, msg_size);
 800bce0:	2200      	movs	r2, #0
 800bce2:	f000 fd03 	bl	800c6ec <xQueueGenericCreate>
 800bce6:	4604      	mov	r4, r0
      }
    }

    #if (configQUEUE_REGISTRY_SIZE > 0)
    if (hQueue != NULL) {
 800bce8:	b334      	cbz	r4, 800bd38 <osMessageQueueNew+0xa0>
      if (attr != NULL) {
 800bcea:	b105      	cbz	r5, 800bcee <osMessageQueueNew+0x56>
        name = attr->name;
 800bcec:	682d      	ldr	r5, [r5, #0]
      } else {
        name = NULL;
      }
      vQueueAddToRegistry (hQueue, name);
 800bcee:	4629      	mov	r1, r5
 800bcf0:	4620      	mov	r0, r4
 800bcf2:	f001 fa8d 	bl	800d210 <vQueueAddToRegistry>
 800bcf6:	e01f      	b.n	800bd38 <osMessageQueueNew+0xa0>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bcf8:	f3ef 8311 	mrs	r3, BASEPRI
  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 800bcfc:	2b00      	cmp	r3, #0
 800bcfe:	d0da      	beq.n	800bcb6 <osMessageQueueNew+0x1e>
  hQueue = NULL;
 800bd00:	2400      	movs	r4, #0
 800bd02:	e019      	b.n	800bd38 <osMessageQueueNew+0xa0>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 800bd04:	68eb      	ldr	r3, [r5, #12]
 800bd06:	b98b      	cbnz	r3, 800bd2c <osMessageQueueNew+0x94>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 800bd08:	692b      	ldr	r3, [r5, #16]
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 800bd0a:	b113      	cbz	r3, 800bd12 <osMessageQueueNew+0x7a>
    mem = -1;
 800bd0c:	f04f 33ff 	mov.w	r3, #4294967295
 800bd10:	e7e5      	b.n	800bcde <osMessageQueueNew+0x46>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 800bd12:	696b      	ldr	r3, [r5, #20]
 800bd14:	b16b      	cbz	r3, 800bd32 <osMessageQueueNew+0x9a>
    mem = -1;
 800bd16:	f04f 33ff 	mov.w	r3, #4294967295
 800bd1a:	e7e0      	b.n	800bcde <osMessageQueueNew+0x46>
      hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
 800bd1c:	2400      	movs	r4, #0
 800bd1e:	9400      	str	r4, [sp, #0]
 800bd20:	f000 fc9b 	bl	800c65a <xQueueGenericCreateStatic>
 800bd24:	4604      	mov	r4, r0
 800bd26:	e7df      	b.n	800bce8 <osMessageQueueNew+0x50>
      mem = 0;
 800bd28:	2300      	movs	r3, #0
 800bd2a:	e7d8      	b.n	800bcde <osMessageQueueNew+0x46>
    mem = -1;
 800bd2c:	f04f 33ff 	mov.w	r3, #4294967295
 800bd30:	e7d5      	b.n	800bcde <osMessageQueueNew+0x46>
          mem = 0;
 800bd32:	2300      	movs	r3, #0
 800bd34:	e7d3      	b.n	800bcde <osMessageQueueNew+0x46>
  hQueue = NULL;
 800bd36:	2400      	movs	r4, #0
    #endif

  }

  return ((osMessageQueueId_t)hQueue);
}
 800bd38:	4620      	mov	r0, r4
 800bd3a:	b002      	add	sp, #8
 800bd3c:	bd70      	pop	{r4, r5, r6, pc}
  hQueue = NULL;
 800bd3e:	2400      	movs	r4, #0
 800bd40:	e7fa      	b.n	800bd38 <osMessageQueueNew+0xa0>
 800bd42:	2400      	movs	r4, #0
 800bd44:	e7f8      	b.n	800bd38 <osMessageQueueNew+0xa0>
 800bd46:	2400      	movs	r4, #0
 800bd48:	e7f6      	b.n	800bd38 <osMessageQueueNew+0xa0>
 800bd4a:	2400      	movs	r4, #0
  return ((osMessageQueueId_t)hQueue);
 800bd4c:	e7f4      	b.n	800bd38 <osMessageQueueNew+0xa0>
 800bd4e:	bf00      	nop
 800bd50:	200001c8 	.word	0x200001c8

0800bd54 <osMessageQueuePut>:

osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
 800bd54:	b510      	push	{r4, lr}
 800bd56:	b082      	sub	sp, #8
 800bd58:	461c      	mov	r4, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bd5a:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
 800bd5e:	b9b3      	cbnz	r3, 800bd8e <osMessageQueuePut+0x3a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bd60:	f3ef 8310 	mrs	r3, PRIMASK
 800bd64:	b99b      	cbnz	r3, 800bd8e <osMessageQueuePut+0x3a>
 800bd66:	4b21      	ldr	r3, [pc, #132]	; (800bdec <osMessageQueuePut+0x98>)
 800bd68:	681b      	ldr	r3, [r3, #0]
 800bd6a:	2b02      	cmp	r3, #2
 800bd6c:	d00b      	beq.n	800bd86 <osMessageQueuePut+0x32>
        portYIELD_FROM_ISR (yield);
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 800bd6e:	b388      	cbz	r0, 800bdd4 <osMessageQueuePut+0x80>
 800bd70:	b399      	cbz	r1, 800bdda <osMessageQueuePut+0x86>
      stat = osErrorParameter;
    }
    else {
      if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 800bd72:	2300      	movs	r3, #0
 800bd74:	4622      	mov	r2, r4
 800bd76:	f000 fd42 	bl	800c7fe <xQueueGenericSend>
 800bd7a:	2801      	cmp	r0, #1
 800bd7c:	d030      	beq.n	800bde0 <osMessageQueuePut+0x8c>
        if (timeout != 0U) {
 800bd7e:	b38c      	cbz	r4, 800bde4 <osMessageQueuePut+0x90>
          stat = osErrorTimeout;
 800bd80:	f06f 0001 	mvn.w	r0, #1
 800bd84:	e018      	b.n	800bdb8 <osMessageQueuePut+0x64>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bd86:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800bd8a:	2b00      	cmp	r3, #0
 800bd8c:	d0ef      	beq.n	800bd6e <osMessageQueuePut+0x1a>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 800bd8e:	b1a8      	cbz	r0, 800bdbc <osMessageQueuePut+0x68>
 800bd90:	b1b9      	cbz	r1, 800bdc2 <osMessageQueuePut+0x6e>
 800bd92:	b9cc      	cbnz	r4, 800bdc8 <osMessageQueuePut+0x74>
      yield = pdFALSE;
 800bd94:	2300      	movs	r3, #0
 800bd96:	9301      	str	r3, [sp, #4]
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 800bd98:	aa01      	add	r2, sp, #4
 800bd9a:	f000 fe37 	bl	800ca0c <xQueueGenericSendFromISR>
 800bd9e:	2801      	cmp	r0, #1
 800bda0:	d115      	bne.n	800bdce <osMessageQueuePut+0x7a>
        portYIELD_FROM_ISR (yield);
 800bda2:	9801      	ldr	r0, [sp, #4]
 800bda4:	b140      	cbz	r0, 800bdb8 <osMessageQueuePut+0x64>
 800bda6:	4b12      	ldr	r3, [pc, #72]	; (800bdf0 <osMessageQueuePut+0x9c>)
 800bda8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800bdac:	601a      	str	r2, [r3, #0]
 800bdae:	f3bf 8f4f 	dsb	sy
 800bdb2:	f3bf 8f6f 	isb	sy
  stat = osOK;
 800bdb6:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 800bdb8:	b002      	add	sp, #8
 800bdba:	bd10      	pop	{r4, pc}
      stat = osErrorParameter;
 800bdbc:	f06f 0003 	mvn.w	r0, #3
 800bdc0:	e7fa      	b.n	800bdb8 <osMessageQueuePut+0x64>
 800bdc2:	f06f 0003 	mvn.w	r0, #3
 800bdc6:	e7f7      	b.n	800bdb8 <osMessageQueuePut+0x64>
 800bdc8:	f06f 0003 	mvn.w	r0, #3
 800bdcc:	e7f4      	b.n	800bdb8 <osMessageQueuePut+0x64>
        stat = osErrorResource;
 800bdce:	f06f 0002 	mvn.w	r0, #2
 800bdd2:	e7f1      	b.n	800bdb8 <osMessageQueuePut+0x64>
      stat = osErrorParameter;
 800bdd4:	f06f 0003 	mvn.w	r0, #3
 800bdd8:	e7ee      	b.n	800bdb8 <osMessageQueuePut+0x64>
 800bdda:	f06f 0003 	mvn.w	r0, #3
 800bdde:	e7eb      	b.n	800bdb8 <osMessageQueuePut+0x64>
  stat = osOK;
 800bde0:	2000      	movs	r0, #0
 800bde2:	e7e9      	b.n	800bdb8 <osMessageQueuePut+0x64>
          stat = osErrorResource;
 800bde4:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800bde8:	e7e6      	b.n	800bdb8 <osMessageQueuePut+0x64>
 800bdea:	bf00      	nop
 800bdec:	200001c8 	.word	0x200001c8
 800bdf0:	e000ed04 	.word	0xe000ed04

0800bdf4 <osMessageQueueGet>:

osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
 800bdf4:	b510      	push	{r4, lr}
 800bdf6:	b082      	sub	sp, #8
 800bdf8:	461c      	mov	r4, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bdfa:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
 800bdfe:	b9ab      	cbnz	r3, 800be2c <osMessageQueueGet+0x38>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800be00:	f3ef 8310 	mrs	r3, PRIMASK
 800be04:	b993      	cbnz	r3, 800be2c <osMessageQueueGet+0x38>
 800be06:	4b20      	ldr	r3, [pc, #128]	; (800be88 <osMessageQueueGet+0x94>)
 800be08:	681b      	ldr	r3, [r3, #0]
 800be0a:	2b02      	cmp	r3, #2
 800be0c:	d00a      	beq.n	800be24 <osMessageQueueGet+0x30>
        portYIELD_FROM_ISR (yield);
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 800be0e:	b380      	cbz	r0, 800be72 <osMessageQueueGet+0x7e>
 800be10:	b391      	cbz	r1, 800be78 <osMessageQueueGet+0x84>
      stat = osErrorParameter;
    }
    else {
      if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 800be12:	4622      	mov	r2, r4
 800be14:	f000 feba 	bl	800cb8c <xQueueReceive>
 800be18:	2801      	cmp	r0, #1
 800be1a:	d030      	beq.n	800be7e <osMessageQueueGet+0x8a>
        if (timeout != 0U) {
 800be1c:	b38c      	cbz	r4, 800be82 <osMessageQueueGet+0x8e>
          stat = osErrorTimeout;
 800be1e:	f06f 0001 	mvn.w	r0, #1
 800be22:	e018      	b.n	800be56 <osMessageQueueGet+0x62>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800be24:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800be28:	2b00      	cmp	r3, #0
 800be2a:	d0f0      	beq.n	800be0e <osMessageQueueGet+0x1a>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 800be2c:	b1a8      	cbz	r0, 800be5a <osMessageQueueGet+0x66>
 800be2e:	b1b9      	cbz	r1, 800be60 <osMessageQueueGet+0x6c>
 800be30:	b9cc      	cbnz	r4, 800be66 <osMessageQueueGet+0x72>
      yield = pdFALSE;
 800be32:	2300      	movs	r3, #0
 800be34:	9301      	str	r3, [sp, #4]
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 800be36:	aa01      	add	r2, sp, #4
 800be38:	f001 f8f8 	bl	800d02c <xQueueReceiveFromISR>
 800be3c:	2801      	cmp	r0, #1
 800be3e:	d115      	bne.n	800be6c <osMessageQueueGet+0x78>
        portYIELD_FROM_ISR (yield);
 800be40:	9801      	ldr	r0, [sp, #4]
 800be42:	b140      	cbz	r0, 800be56 <osMessageQueueGet+0x62>
 800be44:	4b11      	ldr	r3, [pc, #68]	; (800be8c <osMessageQueueGet+0x98>)
 800be46:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800be4a:	601a      	str	r2, [r3, #0]
 800be4c:	f3bf 8f4f 	dsb	sy
 800be50:	f3bf 8f6f 	isb	sy
  stat = osOK;
 800be54:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 800be56:	b002      	add	sp, #8
 800be58:	bd10      	pop	{r4, pc}
      stat = osErrorParameter;
 800be5a:	f06f 0003 	mvn.w	r0, #3
 800be5e:	e7fa      	b.n	800be56 <osMessageQueueGet+0x62>
 800be60:	f06f 0003 	mvn.w	r0, #3
 800be64:	e7f7      	b.n	800be56 <osMessageQueueGet+0x62>
 800be66:	f06f 0003 	mvn.w	r0, #3
 800be6a:	e7f4      	b.n	800be56 <osMessageQueueGet+0x62>
        stat = osErrorResource;
 800be6c:	f06f 0002 	mvn.w	r0, #2
 800be70:	e7f1      	b.n	800be56 <osMessageQueueGet+0x62>
      stat = osErrorParameter;
 800be72:	f06f 0003 	mvn.w	r0, #3
 800be76:	e7ee      	b.n	800be56 <osMessageQueueGet+0x62>
 800be78:	f06f 0003 	mvn.w	r0, #3
 800be7c:	e7eb      	b.n	800be56 <osMessageQueueGet+0x62>
  stat = osOK;
 800be7e:	2000      	movs	r0, #0
 800be80:	e7e9      	b.n	800be56 <osMessageQueueGet+0x62>
          stat = osErrorResource;
 800be82:	f06f 0002 	mvn.w	r0, #2
  return (stat);
 800be86:	e7e6      	b.n	800be56 <osMessageQueueGet+0x62>
 800be88:	200001c8 	.word	0x200001c8
 800be8c:	e000ed04 	.word	0xe000ed04

0800be90 <osMessageQueueGetCapacity>:

uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
  StaticQueue_t *mq = (StaticQueue_t *)mq_id;
  uint32_t capacity;

  if (mq == NULL) {
 800be90:	b108      	cbz	r0, 800be96 <osMessageQueueGetCapacity+0x6>
    capacity = 0U;
  } else {
    /* capacity = pxQueue->uxLength */
    capacity = mq->uxDummy4[1];
 800be92:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 800be94:	4770      	bx	lr
    capacity = 0U;
 800be96:	2000      	movs	r0, #0
  }

  return (capacity);
}
 800be98:	4770      	bx	lr

0800be9a <osMessageQueueGetMsgSize>:

uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
  StaticQueue_t *mq = (StaticQueue_t *)mq_id;
  uint32_t size;

  if (mq == NULL) {
 800be9a:	b108      	cbz	r0, 800bea0 <osMessageQueueGetMsgSize+0x6>
    size = 0U;
  } else {
    /* size = pxQueue->uxItemSize */
    size = mq->uxDummy4[2];
 800be9c:	6c00      	ldr	r0, [r0, #64]	; 0x40
 800be9e:	4770      	bx	lr
    size = 0U;
 800bea0:	2000      	movs	r0, #0
  }

  return (size);
}
 800bea2:	4770      	bx	lr

0800bea4 <osMessageQueueGetCount>:

uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
  QueueHandle_t hQueue = (QueueHandle_t)mq_id;
  UBaseType_t count;

  if (hQueue == NULL) {
 800bea4:	b1b0      	cbz	r0, 800bed4 <osMessageQueueGetCount+0x30>
uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
 800bea6:	b508      	push	{r3, lr}
 800bea8:	4603      	mov	r3, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800beaa:	f3ef 8205 	mrs	r2, IPSR
    count = 0U;
  }
  else if (IS_IRQ()) {
 800beae:	b94a      	cbnz	r2, 800bec4 <osMessageQueueGetCount+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800beb0:	f3ef 8210 	mrs	r2, PRIMASK
 800beb4:	b932      	cbnz	r2, 800bec4 <osMessageQueueGetCount+0x20>
 800beb6:	4a08      	ldr	r2, [pc, #32]	; (800bed8 <osMessageQueueGetCount+0x34>)
 800beb8:	6812      	ldr	r2, [r2, #0]
 800beba:	2a02      	cmp	r2, #2
 800bebc:	d106      	bne.n	800becc <osMessageQueueGetCount+0x28>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bebe:	f3ef 8211 	mrs	r2, BASEPRI
 800bec2:	b11a      	cbz	r2, 800becc <osMessageQueueGetCount+0x28>
    count = uxQueueMessagesWaitingFromISR (hQueue);
 800bec4:	4618      	mov	r0, r3
 800bec6:	f001 f96e 	bl	800d1a6 <uxQueueMessagesWaitingFromISR>
  else {
    count = uxQueueMessagesWaiting (hQueue);
  }

  return ((uint32_t)count);
}
 800beca:	bd08      	pop	{r3, pc}
    count = uxQueueMessagesWaiting (hQueue);
 800becc:	4618      	mov	r0, r3
 800bece:	f001 f942 	bl	800d156 <uxQueueMessagesWaiting>
 800bed2:	e7fa      	b.n	800beca <osMessageQueueGetCount+0x26>
    count = 0U;
 800bed4:	2000      	movs	r0, #0
}
 800bed6:	4770      	bx	lr
 800bed8:	200001c8 	.word	0x200001c8

0800bedc <osMessageQueueGetSpace>:
uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
  StaticQueue_t *mq = (StaticQueue_t *)mq_id;
  uint32_t space;
  uint32_t isrm;

  if (mq == NULL) {
 800bedc:	b310      	cbz	r0, 800bf24 <osMessageQueueGetSpace+0x48>
uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
 800bede:	b508      	push	{r3, lr}
 800bee0:	4602      	mov	r2, r0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bee2:	f3ef 8305 	mrs	r3, IPSR
    space = 0U;
  }
  else if (IS_IRQ()) {
 800bee6:	b94b      	cbnz	r3, 800befc <osMessageQueueGetSpace+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bee8:	f3ef 8310 	mrs	r3, PRIMASK
 800beec:	b933      	cbnz	r3, 800befc <osMessageQueueGetSpace+0x20>
 800beee:	4b0e      	ldr	r3, [pc, #56]	; (800bf28 <osMessageQueueGetSpace+0x4c>)
 800bef0:	681b      	ldr	r3, [r3, #0]
 800bef2:	2b02      	cmp	r3, #2
 800bef4:	d112      	bne.n	800bf1c <osMessageQueueGetSpace+0x40>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bef6:	f3ef 8311 	mrs	r3, BASEPRI
 800befa:	b17b      	cbz	r3, 800bf1c <osMessageQueueGetSpace+0x40>
	__asm volatile
 800befc:	f3ef 8111 	mrs	r1, BASEPRI
 800bf00:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bf04:	f383 8811 	msr	BASEPRI, r3
 800bf08:	f3bf 8f6f 	isb	sy
 800bf0c:	f3bf 8f4f 	dsb	sy
    isrm = taskENTER_CRITICAL_FROM_ISR();

    /* space = pxQueue->uxLength - pxQueue->uxMessagesWaiting; */
    space = mq->uxDummy4[1] - mq->uxDummy4[0];
 800bf10:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800bf12:	6b90      	ldr	r0, [r2, #56]	; 0x38
 800bf14:	1a18      	subs	r0, r3, r0
	__asm volatile
 800bf16:	f381 8811 	msr	BASEPRI, r1
  else {
    space = (uint32_t)uxQueueSpacesAvailable ((QueueHandle_t)mq);
  }

  return (space);
}
 800bf1a:	bd08      	pop	{r3, pc}
    space = (uint32_t)uxQueueSpacesAvailable ((QueueHandle_t)mq);
 800bf1c:	4610      	mov	r0, r2
 800bf1e:	f001 f92d 	bl	800d17c <uxQueueSpacesAvailable>
 800bf22:	e7fa      	b.n	800bf1a <osMessageQueueGetSpace+0x3e>
    space = 0U;
 800bf24:	2000      	movs	r0, #0
}
 800bf26:	4770      	bx	lr
 800bf28:	200001c8 	.word	0x200001c8

0800bf2c <osMessageQueueReset>:

osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
 800bf2c:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bf2e:	f3ef 8305 	mrs	r3, IPSR
  QueueHandle_t hQueue = (QueueHandle_t)mq_id;
  osStatus_t stat;

  if (IS_IRQ()) {
 800bf32:	b99b      	cbnz	r3, 800bf5c <osMessageQueueReset+0x30>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bf34:	f3ef 8310 	mrs	r3, PRIMASK
 800bf38:	b99b      	cbnz	r3, 800bf62 <osMessageQueueReset+0x36>
 800bf3a:	4b0d      	ldr	r3, [pc, #52]	; (800bf70 <osMessageQueueReset+0x44>)
 800bf3c:	681b      	ldr	r3, [r3, #0]
 800bf3e:	2b02      	cmp	r3, #2
 800bf40:	d005      	beq.n	800bf4e <osMessageQueueReset+0x22>
    stat = osErrorISR;
  }
  else if (hQueue == NULL) {
 800bf42:	b188      	cbz	r0, 800bf68 <osMessageQueueReset+0x3c>
    stat = osErrorParameter;
  }
  else {
    stat = osOK;
    (void)xQueueReset (hQueue);
 800bf44:	2100      	movs	r1, #0
 800bf46:	f000 fb35 	bl	800c5b4 <xQueueGenericReset>
    stat = osOK;
 800bf4a:	2000      	movs	r0, #0
  }

  return (stat);
}
 800bf4c:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bf4e:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800bf52:	2b00      	cmp	r3, #0
 800bf54:	d0f5      	beq.n	800bf42 <osMessageQueueReset+0x16>
    stat = osErrorISR;
 800bf56:	f06f 0005 	mvn.w	r0, #5
 800bf5a:	e7f7      	b.n	800bf4c <osMessageQueueReset+0x20>
 800bf5c:	f06f 0005 	mvn.w	r0, #5
 800bf60:	e7f4      	b.n	800bf4c <osMessageQueueReset+0x20>
 800bf62:	f06f 0005 	mvn.w	r0, #5
 800bf66:	e7f1      	b.n	800bf4c <osMessageQueueReset+0x20>
    stat = osErrorParameter;
 800bf68:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800bf6c:	e7ee      	b.n	800bf4c <osMessageQueueReset+0x20>
 800bf6e:	bf00      	nop
 800bf70:	200001c8 	.word	0x200001c8

0800bf74 <osMessageQueueDelete>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800bf74:	f3ef 8305 	mrs	r3, IPSR
osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
  QueueHandle_t hQueue = (QueueHandle_t)mq_id;
  osStatus_t stat;

#ifndef USE_FreeRTOS_HEAP_1
  if (IS_IRQ()) {
 800bf78:	b9c3      	cbnz	r3, 800bfac <osMessageQueueDelete+0x38>
osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
 800bf7a:	b510      	push	{r4, lr}
 800bf7c:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bf7e:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800bf82:	b9b3      	cbnz	r3, 800bfb2 <osMessageQueueDelete+0x3e>
 800bf84:	4b0e      	ldr	r3, [pc, #56]	; (800bfc0 <osMessageQueueDelete+0x4c>)
 800bf86:	681b      	ldr	r3, [r3, #0]
 800bf88:	2b02      	cmp	r3, #2
 800bf8a:	d008      	beq.n	800bf9e <osMessageQueueDelete+0x2a>
    stat = osErrorISR;
  }
  else if (hQueue == NULL) {
 800bf8c:	b1a4      	cbz	r4, 800bfb8 <osMessageQueueDelete+0x44>
    stat = osErrorParameter;
  }
  else {
    #if (configQUEUE_REGISTRY_SIZE > 0)
    vQueueUnregisterQueue (hQueue);
 800bf8e:	4620      	mov	r0, r4
 800bf90:	f001 f966 	bl	800d260 <vQueueUnregisterQueue>
    #endif

    stat = osOK;
    vQueueDelete (hQueue);
 800bf94:	4620      	mov	r0, r4
 800bf96:	f001 f979 	bl	800d28c <vQueueDelete>
    stat = osOK;
 800bf9a:	2000      	movs	r0, #0
#else
  stat = osError;
#endif

  return (stat);
}
 800bf9c:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bf9e:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800bfa2:	2b00      	cmp	r3, #0
 800bfa4:	d0f2      	beq.n	800bf8c <osMessageQueueDelete+0x18>
    stat = osErrorISR;
 800bfa6:	f06f 0005 	mvn.w	r0, #5
 800bfaa:	e7f7      	b.n	800bf9c <osMessageQueueDelete+0x28>
 800bfac:	f06f 0005 	mvn.w	r0, #5
}
 800bfb0:	4770      	bx	lr
    stat = osErrorISR;
 800bfb2:	f06f 0005 	mvn.w	r0, #5
 800bfb6:	e7f1      	b.n	800bf9c <osMessageQueueDelete+0x28>
    stat = osErrorParameter;
 800bfb8:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 800bfbc:	e7ee      	b.n	800bf9c <osMessageQueueDelete+0x28>
 800bfbe:	bf00      	nop
 800bfc0:	200001c8 	.word	0x200001c8

/**
  Dummy implementation of the callback function vApplicationMallocFailedHook().
*/
#if (configUSE_MALLOC_FAILED_HOOK == 1)
__WEAK void vApplicationMallocFailedHook (void){}
 800bfc4:	4770      	bx	lr

0800bfc6 <vApplicationGetIdleTaskMemory>:
/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 800bfc6:	4b03      	ldr	r3, [pc, #12]	; (800bfd4 <vApplicationGetIdleTaskMemory+0xe>)
 800bfc8:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 800bfca:	4b03      	ldr	r3, [pc, #12]	; (800bfd8 <vApplicationGetIdleTaskMemory+0x12>)
 800bfcc:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 800bfce:	2340      	movs	r3, #64	; 0x40
 800bfd0:	6013      	str	r3, [r2, #0]
}
 800bfd2:	4770      	bx	lr
 800bfd4:	2000015c 	.word	0x2000015c
 800bfd8:	2000005c 	.word	0x2000005c

0800bfdc <vApplicationGetTimerTaskMemory>:
/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 800bfdc:	4b03      	ldr	r3, [pc, #12]	; (800bfec <vApplicationGetTimerTaskMemory+0x10>)
 800bfde:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 800bfe0:	4b03      	ldr	r3, [pc, #12]	; (800bff0 <vApplicationGetTimerTaskMemory+0x14>)
 800bfe2:	600b      	str	r3, [r1, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 800bfe4:	2380      	movs	r3, #128	; 0x80
 800bfe6:	6013      	str	r3, [r2, #0]
}
 800bfe8:	4770      	bx	lr
 800bfea:	bf00      	nop
 800bfec:	200003cc 	.word	0x200003cc
 800bff0:	200001cc 	.word	0x200001cc

0800bff4 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
 800bff4:	b91a      	cbnz	r2, 800bffe <prvTestWaitCondition+0xa>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 800bff6:	4208      	tst	r0, r1
 800bff8:	d106      	bne.n	800c008 <prvTestWaitCondition+0x14>
BaseType_t xWaitConditionMet = pdFALSE;
 800bffa:	4610      	mov	r0, r2
 800bffc:	4770      	bx	lr
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800bffe:	ea31 0300 	bics.w	r3, r1, r0
 800c002:	d003      	beq.n	800c00c <prvTestWaitCondition+0x18>
BaseType_t xWaitConditionMet = pdFALSE;
 800c004:	2000      	movs	r0, #0
 800c006:	4770      	bx	lr
			xWaitConditionMet = pdTRUE;
 800c008:	2001      	movs	r0, #1
 800c00a:	4770      	bx	lr
		{
			xWaitConditionMet = pdTRUE;
 800c00c:	2001      	movs	r0, #1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
 800c00e:	4770      	bx	lr

0800c010 <xEventGroupCreateStatic>:
		configASSERT( pxEventGroupBuffer );
 800c010:	b180      	cbz	r0, 800c034 <xEventGroupCreateStatic+0x24>
	{
 800c012:	b510      	push	{r4, lr}
 800c014:	b082      	sub	sp, #8
 800c016:	4604      	mov	r4, r0
			volatile size_t xSize = sizeof( StaticEventGroup_t );
 800c018:	2320      	movs	r3, #32
 800c01a:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( EventGroup_t ) );
 800c01c:	9b01      	ldr	r3, [sp, #4]
 800c01e:	2b20      	cmp	r3, #32
 800c020:	d011      	beq.n	800c046 <xEventGroupCreateStatic+0x36>
	__asm volatile
 800c022:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c026:	f383 8811 	msr	BASEPRI, r3
 800c02a:	f3bf 8f6f 	isb	sy
 800c02e:	f3bf 8f4f 	dsb	sy
 800c032:	e7fe      	b.n	800c032 <xEventGroupCreateStatic+0x22>
 800c034:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c038:	f383 8811 	msr	BASEPRI, r3
 800c03c:	f3bf 8f6f 	isb	sy
 800c040:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventGroupBuffer );
 800c044:	e7fe      	b.n	800c044 <xEventGroupCreateStatic+0x34>
			pxEventBits->uxEventBits = 0;
 800c046:	2300      	movs	r3, #0
 800c048:	f840 3b04 	str.w	r3, [r0], #4
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 800c04c:	f000 f9c4 	bl	800c3d8 <vListInitialise>
				pxEventBits->ucStaticallyAllocated = pdTRUE;
 800c050:	2301      	movs	r3, #1
 800c052:	7723      	strb	r3, [r4, #28]
	}
 800c054:	4620      	mov	r0, r4
 800c056:	b002      	add	sp, #8
 800c058:	bd10      	pop	{r4, pc}

0800c05a <xEventGroupCreate>:
	{
 800c05a:	b538      	push	{r3, r4, r5, lr}
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
 800c05c:	2020      	movs	r0, #32
 800c05e:	f003 fa35 	bl	800f4cc <pvPortMalloc>
		if( pxEventBits != NULL )
 800c062:	4604      	mov	r4, r0
 800c064:	b128      	cbz	r0, 800c072 <xEventGroupCreate+0x18>
			pxEventBits->uxEventBits = 0;
 800c066:	2500      	movs	r5, #0
 800c068:	f840 5b04 	str.w	r5, [r0], #4
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 800c06c:	f000 f9b4 	bl	800c3d8 <vListInitialise>
				pxEventBits->ucStaticallyAllocated = pdFALSE;
 800c070:	7725      	strb	r5, [r4, #28]
	}
 800c072:	4620      	mov	r0, r4
 800c074:	bd38      	pop	{r3, r4, r5, pc}

0800c076 <xEventGroupWaitBits>:
{
 800c076:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c07a:	f8dd a020 	ldr.w	sl, [sp, #32]
	configASSERT( xEventGroup );
 800c07e:	b178      	cbz	r0, 800c0a0 <xEventGroupWaitBits+0x2a>
 800c080:	460d      	mov	r5, r1
 800c082:	4617      	mov	r7, r2
 800c084:	4698      	mov	r8, r3
 800c086:	4606      	mov	r6, r0
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800c088:	f011 497f 	ands.w	r9, r1, #4278190080	; 0xff000000
 800c08c:	d011      	beq.n	800c0b2 <xEventGroupWaitBits+0x3c>
 800c08e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c092:	f383 8811 	msr	BASEPRI, r3
 800c096:	f3bf 8f6f 	isb	sy
 800c09a:	f3bf 8f4f 	dsb	sy
 800c09e:	e7fe      	b.n	800c09e <xEventGroupWaitBits+0x28>
 800c0a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c0a4:	f383 8811 	msr	BASEPRI, r3
 800c0a8:	f3bf 8f6f 	isb	sy
 800c0ac:	f3bf 8f4f 	dsb	sy
	configASSERT( xEventGroup );
 800c0b0:	e7fe      	b.n	800c0b0 <xEventGroupWaitBits+0x3a>
	configASSERT( uxBitsToWaitFor != 0 );
 800c0b2:	b941      	cbnz	r1, 800c0c6 <xEventGroupWaitBits+0x50>
 800c0b4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c0b8:	f383 8811 	msr	BASEPRI, r3
 800c0bc:	f3bf 8f6f 	isb	sy
 800c0c0:	f3bf 8f4f 	dsb	sy
 800c0c4:	e7fe      	b.n	800c0c4 <xEventGroupWaitBits+0x4e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800c0c6:	f002 f9e5 	bl	800e494 <xTaskGetSchedulerState>
 800c0ca:	b958      	cbnz	r0, 800c0e4 <xEventGroupWaitBits+0x6e>
 800c0cc:	f1ba 0f00 	cmp.w	sl, #0
 800c0d0:	d008      	beq.n	800c0e4 <xEventGroupWaitBits+0x6e>
 800c0d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c0d6:	f383 8811 	msr	BASEPRI, r3
 800c0da:	f3bf 8f6f 	isb	sy
 800c0de:	f3bf 8f4f 	dsb	sy
 800c0e2:	e7fe      	b.n	800c0e2 <xEventGroupWaitBits+0x6c>
	vTaskSuspendAll();
 800c0e4:	f001 fd44 	bl	800db70 <vTaskSuspendAll>
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 800c0e8:	6834      	ldr	r4, [r6, #0]
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 800c0ea:	4642      	mov	r2, r8
 800c0ec:	4629      	mov	r1, r5
 800c0ee:	4620      	mov	r0, r4
 800c0f0:	f7ff ff80 	bl	800bff4 <prvTestWaitCondition>
		if( xWaitConditionMet != pdFALSE )
 800c0f4:	b1e0      	cbz	r0, 800c130 <xEventGroupWaitBits+0xba>
			if( xClearOnExit != pdFALSE )
 800c0f6:	b117      	cbz	r7, 800c0fe <xEventGroupWaitBits+0x88>
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800c0f8:	ea24 0305 	bic.w	r3, r4, r5
 800c0fc:	6033      	str	r3, [r6, #0]
	xAlreadyYielded = xTaskResumeAll();
 800c0fe:	f001 fdf3 	bl	800dce8 <xTaskResumeAll>
	if( xTicksToWait != ( TickType_t ) 0 )
 800c102:	f1b9 0f00 	cmp.w	r9, #0
 800c106:	d010      	beq.n	800c12a <xEventGroupWaitBits+0xb4>
		if( xAlreadyYielded == pdFALSE )
 800c108:	b938      	cbnz	r0, 800c11a <xEventGroupWaitBits+0xa4>
			portYIELD_WITHIN_API();
 800c10a:	4b1d      	ldr	r3, [pc, #116]	; (800c180 <xEventGroupWaitBits+0x10a>)
 800c10c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c110:	601a      	str	r2, [r3, #0]
 800c112:	f3bf 8f4f 	dsb	sy
 800c116:	f3bf 8f6f 	isb	sy
		uxReturn = uxTaskResetEventItemValue();
 800c11a:	f002 fab1 	bl	800e680 <uxTaskResetEventItemValue>
 800c11e:	4604      	mov	r4, r0
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 800c120:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 800c124:	d01b      	beq.n	800c15e <xEventGroupWaitBits+0xe8>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 800c126:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
}
 800c12a:	4620      	mov	r0, r4
 800c12c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		else if( xTicksToWait == ( TickType_t ) 0 )
 800c130:	f1ba 0f00 	cmp.w	sl, #0
 800c134:	d011      	beq.n	800c15a <xEventGroupWaitBits+0xe4>
			if( xClearOnExit != pdFALSE )
 800c136:	b96f      	cbnz	r7, 800c154 <xEventGroupWaitBits+0xde>
EventBits_t uxReturn, uxControlBits = 0;
 800c138:	4649      	mov	r1, r9
			if( xWaitForAllBits != pdFALSE )
 800c13a:	f1b8 0f00 	cmp.w	r8, #0
 800c13e:	d001      	beq.n	800c144 <xEventGroupWaitBits+0xce>
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 800c140:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 800c144:	4652      	mov	r2, sl
 800c146:	4329      	orrs	r1, r5
 800c148:	1d30      	adds	r0, r6, #4
 800c14a:	f001 ff85 	bl	800e058 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;
 800c14e:	464c      	mov	r4, r9
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 800c150:	46d1      	mov	r9, sl
 800c152:	e7d4      	b.n	800c0fe <xEventGroupWaitBits+0x88>
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 800c154:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 800c158:	e7ef      	b.n	800c13a <xEventGroupWaitBits+0xc4>
 800c15a:	46d1      	mov	r9, sl
 800c15c:	e7cf      	b.n	800c0fe <xEventGroupWaitBits+0x88>
			taskENTER_CRITICAL();
 800c15e:	f003 f83b 	bl	800f1d8 <vPortEnterCritical>
				uxReturn = pxEventBits->uxEventBits;
 800c162:	6834      	ldr	r4, [r6, #0]
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 800c164:	4642      	mov	r2, r8
 800c166:	4629      	mov	r1, r5
 800c168:	4620      	mov	r0, r4
 800c16a:	f7ff ff43 	bl	800bff4 <prvTestWaitCondition>
 800c16e:	b118      	cbz	r0, 800c178 <xEventGroupWaitBits+0x102>
					if( xClearOnExit != pdFALSE )
 800c170:	b117      	cbz	r7, 800c178 <xEventGroupWaitBits+0x102>
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800c172:	ea24 0505 	bic.w	r5, r4, r5
 800c176:	6035      	str	r5, [r6, #0]
			taskEXIT_CRITICAL();
 800c178:	f003 f850 	bl	800f21c <vPortExitCritical>
 800c17c:	e7d3      	b.n	800c126 <xEventGroupWaitBits+0xb0>
 800c17e:	bf00      	nop
 800c180:	e000ed04 	.word	0xe000ed04

0800c184 <xEventGroupClearBits>:
	configASSERT( xEventGroup );
 800c184:	b170      	cbz	r0, 800c1a4 <xEventGroupClearBits+0x20>
{
 800c186:	b570      	push	{r4, r5, r6, lr}
 800c188:	460c      	mov	r4, r1
 800c18a:	4606      	mov	r6, r0
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800c18c:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 800c190:	d011      	beq.n	800c1b6 <xEventGroupClearBits+0x32>
 800c192:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c196:	f383 8811 	msr	BASEPRI, r3
 800c19a:	f3bf 8f6f 	isb	sy
 800c19e:	f3bf 8f4f 	dsb	sy
 800c1a2:	e7fe      	b.n	800c1a2 <xEventGroupClearBits+0x1e>
 800c1a4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c1a8:	f383 8811 	msr	BASEPRI, r3
 800c1ac:	f3bf 8f6f 	isb	sy
 800c1b0:	f3bf 8f4f 	dsb	sy
	configASSERT( xEventGroup );
 800c1b4:	e7fe      	b.n	800c1b4 <xEventGroupClearBits+0x30>
	taskENTER_CRITICAL();
 800c1b6:	f003 f80f 	bl	800f1d8 <vPortEnterCritical>
		uxReturn = pxEventBits->uxEventBits;
 800c1ba:	6835      	ldr	r5, [r6, #0]
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 800c1bc:	ea25 0404 	bic.w	r4, r5, r4
 800c1c0:	6034      	str	r4, [r6, #0]
	taskEXIT_CRITICAL();
 800c1c2:	f003 f82b 	bl	800f21c <vPortExitCritical>
}
 800c1c6:	4628      	mov	r0, r5
 800c1c8:	bd70      	pop	{r4, r5, r6, pc}

0800c1ca <vEventGroupClearBitsCallback>:
{
 800c1ca:	b508      	push	{r3, lr}
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
 800c1cc:	f7ff ffda 	bl	800c184 <xEventGroupClearBits>
}
 800c1d0:	bd08      	pop	{r3, pc}

0800c1d2 <xEventGroupClearBitsFromISR>:
	{
 800c1d2:	b508      	push	{r3, lr}
 800c1d4:	460a      	mov	r2, r1
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
 800c1d6:	2300      	movs	r3, #0
 800c1d8:	4601      	mov	r1, r0
 800c1da:	4802      	ldr	r0, [pc, #8]	; (800c1e4 <xEventGroupClearBitsFromISR+0x12>)
 800c1dc:	f002 ff60 	bl	800f0a0 <xTimerPendFunctionCallFromISR>
	}
 800c1e0:	bd08      	pop	{r3, pc}
 800c1e2:	bf00      	nop
 800c1e4:	0800c1cb 	.word	0x0800c1cb

0800c1e8 <xEventGroupGetBitsFromISR>:
	__asm volatile
 800c1e8:	f3ef 8311 	mrs	r3, BASEPRI
 800c1ec:	f04f 0250 	mov.w	r2, #80	; 0x50
 800c1f0:	f382 8811 	msr	BASEPRI, r2
 800c1f4:	f3bf 8f6f 	isb	sy
 800c1f8:	f3bf 8f4f 	dsb	sy
		uxReturn = pxEventBits->uxEventBits;
 800c1fc:	6800      	ldr	r0, [r0, #0]
	__asm volatile
 800c1fe:	f383 8811 	msr	BASEPRI, r3
}
 800c202:	4770      	bx	lr

0800c204 <xEventGroupSetBits>:
{
 800c204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( xEventGroup );
 800c206:	b168      	cbz	r0, 800c224 <xEventGroupSetBits+0x20>
 800c208:	460d      	mov	r5, r1
 800c20a:	4604      	mov	r4, r0
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800c20c:	f011 467f 	ands.w	r6, r1, #4278190080	; 0xff000000
 800c210:	d011      	beq.n	800c236 <xEventGroupSetBits+0x32>
	__asm volatile
 800c212:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c216:	f383 8811 	msr	BASEPRI, r3
 800c21a:	f3bf 8f6f 	isb	sy
 800c21e:	f3bf 8f4f 	dsb	sy
 800c222:	e7fe      	b.n	800c222 <xEventGroupSetBits+0x1e>
 800c224:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c228:	f383 8811 	msr	BASEPRI, r3
 800c22c:	f3bf 8f6f 	isb	sy
 800c230:	f3bf 8f4f 	dsb	sy
	configASSERT( xEventGroup );
 800c234:	e7fe      	b.n	800c234 <xEventGroupSetBits+0x30>
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800c236:	f100 070c 	add.w	r7, r0, #12
	vTaskSuspendAll();
 800c23a:	f001 fc99 	bl	800db70 <vTaskSuspendAll>
		pxListItem = listGET_HEAD_ENTRY( pxList );
 800c23e:	6920      	ldr	r0, [r4, #16]
		pxEventBits->uxEventBits |= uxBitsToSet;
 800c240:	6823      	ldr	r3, [r4, #0]
 800c242:	432b      	orrs	r3, r5
 800c244:	6023      	str	r3, [r4, #0]
		while( pxListItem != pxListEnd )
 800c246:	e00a      	b.n	800c25e <xEventGroupSetBits+0x5a>
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 800c248:	6821      	ldr	r1, [r4, #0]
 800c24a:	ea33 0101 	bics.w	r1, r3, r1
 800c24e:	d105      	bne.n	800c25c <xEventGroupSetBits+0x58>
 800c250:	e011      	b.n	800c276 <xEventGroupSetBits+0x72>
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 800c252:	6821      	ldr	r1, [r4, #0]
 800c254:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800c258:	f001 ff8c 	bl	800e174 <vTaskRemoveFromUnorderedEventList>
{
 800c25c:	4628      	mov	r0, r5
		while( pxListItem != pxListEnd )
 800c25e:	42b8      	cmp	r0, r7
 800c260:	d00e      	beq.n	800c280 <xEventGroupSetBits+0x7c>
			pxNext = listGET_NEXT( pxListItem );
 800c262:	6845      	ldr	r5, [r0, #4]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 800c264:	6802      	ldr	r2, [r0, #0]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 800c266:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 800c26a:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
 800c26e:	d1eb      	bne.n	800c248 <xEventGroupSetBits+0x44>
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 800c270:	6821      	ldr	r1, [r4, #0]
 800c272:	4219      	tst	r1, r3
 800c274:	d0f2      	beq.n	800c25c <xEventGroupSetBits+0x58>
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 800c276:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 800c27a:	d0ea      	beq.n	800c252 <xEventGroupSetBits+0x4e>
					uxBitsToClear |= uxBitsWaitedFor;
 800c27c:	431e      	orrs	r6, r3
 800c27e:	e7e8      	b.n	800c252 <xEventGroupSetBits+0x4e>
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 800c280:	6823      	ldr	r3, [r4, #0]
 800c282:	ea23 0306 	bic.w	r3, r3, r6
 800c286:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 800c288:	f001 fd2e 	bl	800dce8 <xTaskResumeAll>
}
 800c28c:	6820      	ldr	r0, [r4, #0]
 800c28e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800c290 <xEventGroupSync>:
{
 800c290:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800c294:	f012 487f 	ands.w	r8, r2, #4278190080	; 0xff000000
 800c298:	d008      	beq.n	800c2ac <xEventGroupSync+0x1c>
 800c29a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c29e:	f383 8811 	msr	BASEPRI, r3
 800c2a2:	f3bf 8f6f 	isb	sy
 800c2a6:	f3bf 8f4f 	dsb	sy
 800c2aa:	e7fe      	b.n	800c2aa <xEventGroupSync+0x1a>
 800c2ac:	4606      	mov	r6, r0
 800c2ae:	460c      	mov	r4, r1
 800c2b0:	4615      	mov	r5, r2
 800c2b2:	461f      	mov	r7, r3
	configASSERT( uxBitsToWaitFor != 0 );
 800c2b4:	b942      	cbnz	r2, 800c2c8 <xEventGroupSync+0x38>
 800c2b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c2ba:	f383 8811 	msr	BASEPRI, r3
 800c2be:	f3bf 8f6f 	isb	sy
 800c2c2:	f3bf 8f4f 	dsb	sy
 800c2c6:	e7fe      	b.n	800c2c6 <xEventGroupSync+0x36>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800c2c8:	f002 f8e4 	bl	800e494 <xTaskGetSchedulerState>
 800c2cc:	b948      	cbnz	r0, 800c2e2 <xEventGroupSync+0x52>
 800c2ce:	b147      	cbz	r7, 800c2e2 <xEventGroupSync+0x52>
 800c2d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c2d4:	f383 8811 	msr	BASEPRI, r3
 800c2d8:	f3bf 8f6f 	isb	sy
 800c2dc:	f3bf 8f4f 	dsb	sy
 800c2e0:	e7fe      	b.n	800c2e0 <xEventGroupSync+0x50>
	vTaskSuspendAll();
 800c2e2:	f001 fc45 	bl	800db70 <vTaskSuspendAll>
		uxOriginalBitValue = pxEventBits->uxEventBits;
 800c2e6:	f8d6 9000 	ldr.w	r9, [r6]
		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 800c2ea:	4621      	mov	r1, r4
 800c2ec:	4630      	mov	r0, r6
 800c2ee:	f7ff ff89 	bl	800c204 <xEventGroupSetBits>
		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800c2f2:	ea49 0404 	orr.w	r4, r9, r4
 800c2f6:	ea35 0304 	bics.w	r3, r5, r4
 800c2fa:	d018      	beq.n	800c32e <xEventGroupSync+0x9e>
			if( xTicksToWait != ( TickType_t ) 0 )
 800c2fc:	b9ef      	cbnz	r7, 800c33a <xEventGroupSync+0xaa>
				uxReturn = pxEventBits->uxEventBits;
 800c2fe:	6834      	ldr	r4, [r6, #0]
	xAlreadyYielded = xTaskResumeAll();
 800c300:	f001 fcf2 	bl	800dce8 <xTaskResumeAll>
	if( xTicksToWait != ( TickType_t ) 0 )
 800c304:	b187      	cbz	r7, 800c328 <xEventGroupSync+0x98>
		if( xAlreadyYielded == pdFALSE )
 800c306:	b938      	cbnz	r0, 800c318 <xEventGroupSync+0x88>
			portYIELD_WITHIN_API();
 800c308:	4b16      	ldr	r3, [pc, #88]	; (800c364 <xEventGroupSync+0xd4>)
 800c30a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c30e:	601a      	str	r2, [r3, #0]
 800c310:	f3bf 8f4f 	dsb	sy
 800c314:	f3bf 8f6f 	isb	sy
		uxReturn = uxTaskResetEventItemValue();
 800c318:	f002 f9b2 	bl	800e680 <uxTaskResetEventItemValue>
 800c31c:	4604      	mov	r4, r0
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 800c31e:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 800c322:	d012      	beq.n	800c34a <xEventGroupSync+0xba>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 800c324:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
}
 800c328:	4620      	mov	r0, r4
 800c32a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800c32e:	6833      	ldr	r3, [r6, #0]
 800c330:	ea23 0305 	bic.w	r3, r3, r5
 800c334:	6033      	str	r3, [r6, #0]
			xTicksToWait = 0;
 800c336:	4647      	mov	r7, r8
 800c338:	e7e2      	b.n	800c300 <xEventGroupSync+0x70>
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 800c33a:	463a      	mov	r2, r7
 800c33c:	f045 61a0 	orr.w	r1, r5, #83886080	; 0x5000000
 800c340:	1d30      	adds	r0, r6, #4
 800c342:	f001 fe89 	bl	800e058 <vTaskPlaceOnUnorderedEventList>
				uxReturn = 0;
 800c346:	4644      	mov	r4, r8
 800c348:	e7da      	b.n	800c300 <xEventGroupSync+0x70>
			taskENTER_CRITICAL();
 800c34a:	f002 ff45 	bl	800f1d8 <vPortEnterCritical>
				uxReturn = pxEventBits->uxEventBits;
 800c34e:	6834      	ldr	r4, [r6, #0]
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800c350:	ea35 0304 	bics.w	r3, r5, r4
 800c354:	d002      	beq.n	800c35c <xEventGroupSync+0xcc>
			taskEXIT_CRITICAL();
 800c356:	f002 ff61 	bl	800f21c <vPortExitCritical>
			xTimeoutOccurred = pdTRUE;
 800c35a:	e7e3      	b.n	800c324 <xEventGroupSync+0x94>
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800c35c:	ea24 0505 	bic.w	r5, r4, r5
 800c360:	6035      	str	r5, [r6, #0]
 800c362:	e7f8      	b.n	800c356 <xEventGroupSync+0xc6>
 800c364:	e000ed04 	.word	0xe000ed04

0800c368 <vEventGroupSetBitsCallback>:
{
 800c368:	b508      	push	{r3, lr}
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
 800c36a:	f7ff ff4b 	bl	800c204 <xEventGroupSetBits>
}
 800c36e:	bd08      	pop	{r3, pc}

0800c370 <vEventGroupDelete>:
{
 800c370:	b510      	push	{r4, lr}
 800c372:	4604      	mov	r4, r0
	vTaskSuspendAll();
 800c374:	f001 fbfc 	bl	800db70 <vTaskSuspendAll>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 800c378:	6863      	ldr	r3, [r4, #4]
 800c37a:	b193      	cbz	r3, 800c3a2 <vEventGroupDelete+0x32>
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 800c37c:	6920      	ldr	r0, [r4, #16]
 800c37e:	f104 030c 	add.w	r3, r4, #12
 800c382:	4298      	cmp	r0, r3
 800c384:	d004      	beq.n	800c390 <vEventGroupDelete+0x20>
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 800c386:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 800c38a:	f001 fef3 	bl	800e174 <vTaskRemoveFromUnorderedEventList>
 800c38e:	e7f3      	b.n	800c378 <vEventGroupDelete+0x8>
 800c390:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c394:	f383 8811 	msr	BASEPRI, r3
 800c398:	f3bf 8f6f 	isb	sy
 800c39c:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 800c3a0:	e7fe      	b.n	800c3a0 <vEventGroupDelete+0x30>
			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 800c3a2:	7f23      	ldrb	r3, [r4, #28]
 800c3a4:	b113      	cbz	r3, 800c3ac <vEventGroupDelete+0x3c>
	( void ) xTaskResumeAll();
 800c3a6:	f001 fc9f 	bl	800dce8 <xTaskResumeAll>
}
 800c3aa:	bd10      	pop	{r4, pc}
				vPortFree( pxEventBits );
 800c3ac:	4620      	mov	r0, r4
 800c3ae:	f003 f90f 	bl	800f5d0 <vPortFree>
 800c3b2:	e7f8      	b.n	800c3a6 <vEventGroupDelete+0x36>

0800c3b4 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
 800c3b4:	b508      	push	{r3, lr}
 800c3b6:	4613      	mov	r3, r2
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
 800c3b8:	460a      	mov	r2, r1
 800c3ba:	4601      	mov	r1, r0
 800c3bc:	4801      	ldr	r0, [pc, #4]	; (800c3c4 <xEventGroupSetBitsFromISR+0x10>)
 800c3be:	f002 fe6f 	bl	800f0a0 <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
 800c3c2:	bd08      	pop	{r3, pc}
 800c3c4:	0800c369 	.word	0x0800c369

0800c3c8 <uxEventGroupGetNumber>:
	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
	{
	UBaseType_t xReturn;
	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;

		if( xEventGroup == NULL )
 800c3c8:	b108      	cbz	r0, 800c3ce <uxEventGroupGetNumber+0x6>
		{
			xReturn = 0;
		}
		else
		{
			xReturn = pxEventBits->uxEventGroupNumber;
 800c3ca:	6980      	ldr	r0, [r0, #24]
 800c3cc:	4770      	bx	lr
			xReturn = 0;
 800c3ce:	2000      	movs	r0, #0
		}

		return xReturn;
	}
 800c3d0:	4770      	bx	lr

0800c3d2 <vEventGroupSetNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
	{
		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber;
 800c3d2:	6181      	str	r1, [r0, #24]
	}
 800c3d4:	4770      	bx	lr
 800c3d6:	bf00      	nop

0800c3d8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800c3d8:	f100 0308 	add.w	r3, r0, #8
 800c3dc:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800c3de:	f04f 32ff 	mov.w	r2, #4294967295
 800c3e2:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800c3e4:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800c3e6:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800c3e8:	2300      	movs	r3, #0
 800c3ea:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800c3ec:	4770      	bx	lr

0800c3ee <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800c3ee:	2300      	movs	r3, #0
 800c3f0:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800c3f2:	4770      	bx	lr

0800c3f4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800c3f4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 800c3f6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800c3f8:	689a      	ldr	r2, [r3, #8]
 800c3fa:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800c3fc:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800c3fe:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800c400:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800c402:	6803      	ldr	r3, [r0, #0]
 800c404:	3301      	adds	r3, #1
 800c406:	6003      	str	r3, [r0, #0]
}
 800c408:	4770      	bx	lr

0800c40a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800c40a:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800c40c:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800c40e:	f1b5 3fff 	cmp.w	r5, #4294967295
 800c412:	d011      	beq.n	800c438 <vListInsert+0x2e>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800c414:	f100 0308 	add.w	r3, r0, #8
 800c418:	461c      	mov	r4, r3
 800c41a:	685b      	ldr	r3, [r3, #4]
 800c41c:	681a      	ldr	r2, [r3, #0]
 800c41e:	42aa      	cmp	r2, r5
 800c420:	d9fa      	bls.n	800c418 <vListInsert+0xe>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800c422:	6863      	ldr	r3, [r4, #4]
 800c424:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800c426:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800c428:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800c42a:	6061      	str	r1, [r4, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800c42c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800c42e:	6803      	ldr	r3, [r0, #0]
 800c430:	3301      	adds	r3, #1
 800c432:	6003      	str	r3, [r0, #0]
}
 800c434:	bc30      	pop	{r4, r5}
 800c436:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 800c438:	6904      	ldr	r4, [r0, #16]
 800c43a:	e7f2      	b.n	800c422 <vListInsert+0x18>

0800c43c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800c43c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800c43e:	6841      	ldr	r1, [r0, #4]
 800c440:	6882      	ldr	r2, [r0, #8]
 800c442:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800c444:	6841      	ldr	r1, [r0, #4]
 800c446:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800c448:	685a      	ldr	r2, [r3, #4]
 800c44a:	4282      	cmp	r2, r0
 800c44c:	d006      	beq.n	800c45c <uxListRemove+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800c44e:	2200      	movs	r2, #0
 800c450:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800c452:	681a      	ldr	r2, [r3, #0]
 800c454:	3a01      	subs	r2, #1
 800c456:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 800c458:	6818      	ldr	r0, [r3, #0]
}
 800c45a:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800c45c:	6882      	ldr	r2, [r0, #8]
 800c45e:	605a      	str	r2, [r3, #4]
 800c460:	e7f5      	b.n	800c44e <uxListRemove+0x12>
	...

0800c464 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 800c464:	4603      	mov	r3, r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 800c466:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800c468:	b118      	cbz	r0, 800c472 <prvGetDisinheritPriorityAfterTimeout+0xe>
		{
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 800c46a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c46c:	6818      	ldr	r0, [r3, #0]
 800c46e:	f1c0 0038 	rsb	r0, r0, #56	; 0x38
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
		}

		return uxHighestPriorityOfWaitingTasks;
	}
 800c472:	4770      	bx	lr

0800c474 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 800c474:	b510      	push	{r4, lr}
 800c476:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800c478:	f002 feae 	bl	800f1d8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800c47c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800c47e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c480:	429a      	cmp	r2, r3
 800c482:	d004      	beq.n	800c48e <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 800c484:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
 800c486:	f002 fec9 	bl	800f21c <vPortExitCritical>

	return xReturn;
}
 800c48a:	4620      	mov	r0, r4
 800c48c:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 800c48e:	2401      	movs	r4, #1
 800c490:	e7f9      	b.n	800c486 <prvIsQueueFull+0x12>

0800c492 <prvIsQueueEmpty>:
{
 800c492:	b510      	push	{r4, lr}
 800c494:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800c496:	f002 fe9f 	bl	800f1d8 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800c49a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c49c:	b923      	cbnz	r3, 800c4a8 <prvIsQueueEmpty+0x16>
			xReturn = pdTRUE;
 800c49e:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 800c4a0:	f002 febc 	bl	800f21c <vPortExitCritical>
}
 800c4a4:	4620      	mov	r0, r4
 800c4a6:	bd10      	pop	{r4, pc}
			xReturn = pdFALSE;
 800c4a8:	2400      	movs	r4, #0
 800c4aa:	e7f9      	b.n	800c4a0 <prvIsQueueEmpty+0xe>

0800c4ac <prvCopyDataToQueue>:
{
 800c4ac:	b570      	push	{r4, r5, r6, lr}
 800c4ae:	4604      	mov	r4, r0
 800c4b0:	4615      	mov	r5, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800c4b2:	6b86      	ldr	r6, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800c4b4:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800c4b6:	b95a      	cbnz	r2, 800c4d0 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800c4b8:	6803      	ldr	r3, [r0, #0]
 800c4ba:	b11b      	cbz	r3, 800c4c4 <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
 800c4bc:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800c4be:	3601      	adds	r6, #1
 800c4c0:	63a6      	str	r6, [r4, #56]	; 0x38
}
 800c4c2:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 800c4c4:	6840      	ldr	r0, [r0, #4]
 800c4c6:	f002 f841 	bl	800e54c <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 800c4ca:	2300      	movs	r3, #0
 800c4cc:	6063      	str	r3, [r4, #4]
 800c4ce:	e7f6      	b.n	800c4be <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 800c4d0:	b96d      	cbnz	r5, 800c4ee <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800c4d2:	6880      	ldr	r0, [r0, #8]
 800c4d4:	f003 fadc 	bl	800fa90 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800c4d8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800c4da:	68a3      	ldr	r3, [r4, #8]
 800c4dc:	4413      	add	r3, r2
 800c4de:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800c4e0:	6862      	ldr	r2, [r4, #4]
 800c4e2:	4293      	cmp	r3, r2
 800c4e4:	d319      	bcc.n	800c51a <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800c4e6:	6823      	ldr	r3, [r4, #0]
 800c4e8:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 800c4ea:	4628      	mov	r0, r5
 800c4ec:	e7e7      	b.n	800c4be <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c4ee:	68c0      	ldr	r0, [r0, #12]
 800c4f0:	f003 face 	bl	800fa90 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800c4f4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800c4f6:	4251      	negs	r1, r2
 800c4f8:	68e3      	ldr	r3, [r4, #12]
 800c4fa:	1a9b      	subs	r3, r3, r2
 800c4fc:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800c4fe:	6822      	ldr	r2, [r4, #0]
 800c500:	4293      	cmp	r3, r2
 800c502:	d202      	bcs.n	800c50a <prvCopyDataToQueue+0x5e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800c504:	6863      	ldr	r3, [r4, #4]
 800c506:	440b      	add	r3, r1
 800c508:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800c50a:	2d02      	cmp	r5, #2
 800c50c:	d001      	beq.n	800c512 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 800c50e:	2000      	movs	r0, #0
 800c510:	e7d5      	b.n	800c4be <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800c512:	b126      	cbz	r6, 800c51e <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 800c514:	3e01      	subs	r6, #1
BaseType_t xReturn = pdFALSE;
 800c516:	2000      	movs	r0, #0
 800c518:	e7d1      	b.n	800c4be <prvCopyDataToQueue+0x12>
 800c51a:	4628      	mov	r0, r5
 800c51c:	e7cf      	b.n	800c4be <prvCopyDataToQueue+0x12>
 800c51e:	2000      	movs	r0, #0
 800c520:	e7cd      	b.n	800c4be <prvCopyDataToQueue+0x12>

0800c522 <prvCopyDataFromQueue>:
{
 800c522:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800c524:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800c526:	b16a      	cbz	r2, 800c544 <prvCopyDataFromQueue+0x22>
{
 800c528:	b510      	push	{r4, lr}
 800c52a:	4608      	mov	r0, r1
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800c52c:	68d9      	ldr	r1, [r3, #12]
 800c52e:	4411      	add	r1, r2
 800c530:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800c532:	685c      	ldr	r4, [r3, #4]
 800c534:	42a1      	cmp	r1, r4
 800c536:	d301      	bcc.n	800c53c <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800c538:	6819      	ldr	r1, [r3, #0]
 800c53a:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800c53c:	68d9      	ldr	r1, [r3, #12]
 800c53e:	f003 faa7 	bl	800fa90 <memcpy>
}
 800c542:	bd10      	pop	{r4, pc}
 800c544:	4770      	bx	lr

0800c546 <prvUnlockQueue>:
{
 800c546:	b538      	push	{r3, r4, r5, lr}
 800c548:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 800c54a:	f002 fe45 	bl	800f1d8 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800c54e:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 800c552:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800c554:	e003      	b.n	800c55e <prvUnlockQueue+0x18>
						vTaskMissedYield();
 800c556:	f001 febb 	bl	800e2d0 <vTaskMissedYield>
			--cTxLock;
 800c55a:	3c01      	subs	r4, #1
 800c55c:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800c55e:	2c00      	cmp	r4, #0
 800c560:	dd08      	ble.n	800c574 <prvUnlockQueue+0x2e>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800c562:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800c564:	b133      	cbz	r3, 800c574 <prvUnlockQueue+0x2e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800c566:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800c56a:	f001 fdbd 	bl	800e0e8 <xTaskRemoveFromEventList>
 800c56e:	2800      	cmp	r0, #0
 800c570:	d0f3      	beq.n	800c55a <prvUnlockQueue+0x14>
 800c572:	e7f0      	b.n	800c556 <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
 800c574:	23ff      	movs	r3, #255	; 0xff
 800c576:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
 800c57a:	f002 fe4f 	bl	800f21c <vPortExitCritical>
	taskENTER_CRITICAL();
 800c57e:	f002 fe2b 	bl	800f1d8 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800c582:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 800c586:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800c588:	e003      	b.n	800c592 <prvUnlockQueue+0x4c>
					vTaskMissedYield();
 800c58a:	f001 fea1 	bl	800e2d0 <vTaskMissedYield>
				--cRxLock;
 800c58e:	3c01      	subs	r4, #1
 800c590:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800c592:	2c00      	cmp	r4, #0
 800c594:	dd08      	ble.n	800c5a8 <prvUnlockQueue+0x62>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800c596:	692b      	ldr	r3, [r5, #16]
 800c598:	b133      	cbz	r3, 800c5a8 <prvUnlockQueue+0x62>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800c59a:	f105 0010 	add.w	r0, r5, #16
 800c59e:	f001 fda3 	bl	800e0e8 <xTaskRemoveFromEventList>
 800c5a2:	2800      	cmp	r0, #0
 800c5a4:	d0f3      	beq.n	800c58e <prvUnlockQueue+0x48>
 800c5a6:	e7f0      	b.n	800c58a <prvUnlockQueue+0x44>
		pxQueue->cRxLock = queueUNLOCKED;
 800c5a8:	23ff      	movs	r3, #255	; 0xff
 800c5aa:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
 800c5ae:	f002 fe35 	bl	800f21c <vPortExitCritical>
}
 800c5b2:	bd38      	pop	{r3, r4, r5, pc}

0800c5b4 <xQueueGenericReset>:
{
 800c5b4:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 800c5b6:	b1e0      	cbz	r0, 800c5f2 <xQueueGenericReset+0x3e>
 800c5b8:	460d      	mov	r5, r1
 800c5ba:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800c5bc:	f002 fe0c 	bl	800f1d8 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800c5c0:	6821      	ldr	r1, [r4, #0]
 800c5c2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800c5c4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800c5c6:	fb03 1002 	mla	r0, r3, r2, r1
 800c5ca:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800c5cc:	2000      	movs	r0, #0
 800c5ce:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800c5d0:	60a1      	str	r1, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800c5d2:	3a01      	subs	r2, #1
 800c5d4:	fb02 1303 	mla	r3, r2, r3, r1
 800c5d8:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800c5da:	23ff      	movs	r3, #255	; 0xff
 800c5dc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800c5e0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 800c5e4:	b9ed      	cbnz	r5, 800c622 <xQueueGenericReset+0x6e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800c5e6:	6923      	ldr	r3, [r4, #16]
 800c5e8:	b963      	cbnz	r3, 800c604 <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
 800c5ea:	f002 fe17 	bl	800f21c <vPortExitCritical>
}
 800c5ee:	2001      	movs	r0, #1
 800c5f0:	bd38      	pop	{r3, r4, r5, pc}
 800c5f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c5f6:	f383 8811 	msr	BASEPRI, r3
 800c5fa:	f3bf 8f6f 	isb	sy
 800c5fe:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800c602:	e7fe      	b.n	800c602 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800c604:	f104 0010 	add.w	r0, r4, #16
 800c608:	f001 fd6e 	bl	800e0e8 <xTaskRemoveFromEventList>
 800c60c:	2800      	cmp	r0, #0
 800c60e:	d0ec      	beq.n	800c5ea <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 800c610:	4b08      	ldr	r3, [pc, #32]	; (800c634 <xQueueGenericReset+0x80>)
 800c612:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c616:	601a      	str	r2, [r3, #0]
 800c618:	f3bf 8f4f 	dsb	sy
 800c61c:	f3bf 8f6f 	isb	sy
 800c620:	e7e3      	b.n	800c5ea <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800c622:	f104 0010 	add.w	r0, r4, #16
 800c626:	f7ff fed7 	bl	800c3d8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800c62a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800c62e:	f7ff fed3 	bl	800c3d8 <vListInitialise>
 800c632:	e7da      	b.n	800c5ea <xQueueGenericReset+0x36>
 800c634:	e000ed04 	.word	0xe000ed04

0800c638 <prvInitialiseNewQueue>:
{
 800c638:	b538      	push	{r3, r4, r5, lr}
 800c63a:	461d      	mov	r5, r3
 800c63c:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
 800c63e:	460b      	mov	r3, r1
 800c640:	b949      	cbnz	r1, 800c656 <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800c642:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800c644:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800c646:	6423      	str	r3, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800c648:	2101      	movs	r1, #1
 800c64a:	4620      	mov	r0, r4
 800c64c:	f7ff ffb2 	bl	800c5b4 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 800c650:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
}
 800c654:	bd38      	pop	{r3, r4, r5, pc}
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800c656:	6022      	str	r2, [r4, #0]
 800c658:	e7f4      	b.n	800c644 <prvInitialiseNewQueue+0xc>

0800c65a <xQueueGenericCreateStatic>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800c65a:	b940      	cbnz	r0, 800c66e <xQueueGenericCreateStatic+0x14>
 800c65c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c660:	f383 8811 	msr	BASEPRI, r3
 800c664:	f3bf 8f6f 	isb	sy
 800c668:	f3bf 8f4f 	dsb	sy
 800c66c:	e7fe      	b.n	800c66c <xQueueGenericCreateStatic+0x12>
	{
 800c66e:	b530      	push	{r4, r5, lr}
 800c670:	b085      	sub	sp, #20
 800c672:	461c      	mov	r4, r3
 800c674:	4605      	mov	r5, r0
		configASSERT( pxStaticQueue != NULL );
 800c676:	b153      	cbz	r3, 800c68e <xQueueGenericCreateStatic+0x34>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 800c678:	b192      	cbz	r2, 800c6a0 <xQueueGenericCreateStatic+0x46>
 800c67a:	b989      	cbnz	r1, 800c6a0 <xQueueGenericCreateStatic+0x46>
 800c67c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c680:	f383 8811 	msr	BASEPRI, r3
 800c684:	f3bf 8f6f 	isb	sy
 800c688:	f3bf 8f4f 	dsb	sy
 800c68c:	e7fe      	b.n	800c68c <xQueueGenericCreateStatic+0x32>
 800c68e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c692:	f383 8811 	msr	BASEPRI, r3
 800c696:	f3bf 8f6f 	isb	sy
 800c69a:	f3bf 8f4f 	dsb	sy
		configASSERT( pxStaticQueue != NULL );
 800c69e:	e7fe      	b.n	800c69e <xQueueGenericCreateStatic+0x44>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 800c6a0:	b16a      	cbz	r2, 800c6be <xQueueGenericCreateStatic+0x64>
			volatile size_t xSize = sizeof( StaticQueue_t );
 800c6a2:	2350      	movs	r3, #80	; 0x50
 800c6a4:	9303      	str	r3, [sp, #12]
			configASSERT( xSize == sizeof( Queue_t ) );
 800c6a6:	9b03      	ldr	r3, [sp, #12]
 800c6a8:	2b50      	cmp	r3, #80	; 0x50
 800c6aa:	d013      	beq.n	800c6d4 <xQueueGenericCreateStatic+0x7a>
 800c6ac:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c6b0:	f383 8811 	msr	BASEPRI, r3
 800c6b4:	f3bf 8f6f 	isb	sy
 800c6b8:	f3bf 8f4f 	dsb	sy
 800c6bc:	e7fe      	b.n	800c6bc <xQueueGenericCreateStatic+0x62>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 800c6be:	2900      	cmp	r1, #0
 800c6c0:	d0ef      	beq.n	800c6a2 <xQueueGenericCreateStatic+0x48>
 800c6c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c6c6:	f383 8811 	msr	BASEPRI, r3
 800c6ca:	f3bf 8f6f 	isb	sy
 800c6ce:	f3bf 8f4f 	dsb	sy
 800c6d2:	e7fe      	b.n	800c6d2 <xQueueGenericCreateStatic+0x78>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800c6d4:	2301      	movs	r3, #1
 800c6d6:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 800c6da:	9400      	str	r4, [sp, #0]
 800c6dc:	f89d 3020 	ldrb.w	r3, [sp, #32]
 800c6e0:	4628      	mov	r0, r5
 800c6e2:	f7ff ffa9 	bl	800c638 <prvInitialiseNewQueue>
	}
 800c6e6:	4620      	mov	r0, r4
 800c6e8:	b005      	add	sp, #20
 800c6ea:	bd30      	pop	{r4, r5, pc}

0800c6ec <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800c6ec:	b940      	cbnz	r0, 800c700 <xQueueGenericCreate+0x14>
 800c6ee:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c6f2:	f383 8811 	msr	BASEPRI, r3
 800c6f6:	f3bf 8f6f 	isb	sy
 800c6fa:	f3bf 8f4f 	dsb	sy
 800c6fe:	e7fe      	b.n	800c6fe <xQueueGenericCreate+0x12>
	{
 800c700:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c702:	b083      	sub	sp, #12
 800c704:	460c      	mov	r4, r1
 800c706:	4616      	mov	r6, r2
 800c708:	4607      	mov	r7, r0
		if( uxItemSize == ( UBaseType_t ) 0 )
 800c70a:	b1a1      	cbz	r1, 800c736 <xQueueGenericCreate+0x4a>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c70c:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800c710:	3050      	adds	r0, #80	; 0x50
 800c712:	f002 fedb 	bl	800f4cc <pvPortMalloc>
		if( pxNewQueue != NULL )
 800c716:	4605      	mov	r5, r0
 800c718:	b150      	cbz	r0, 800c730 <xQueueGenericCreate+0x44>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800c71a:	2300      	movs	r3, #0
 800c71c:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 800c720:	9000      	str	r0, [sp, #0]
 800c722:	4633      	mov	r3, r6
 800c724:	f100 0250 	add.w	r2, r0, #80	; 0x50
 800c728:	4621      	mov	r1, r4
 800c72a:	4638      	mov	r0, r7
 800c72c:	f7ff ff84 	bl	800c638 <prvInitialiseNewQueue>
	}
 800c730:	4628      	mov	r0, r5
 800c732:	b003      	add	sp, #12
 800c734:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xQueueSizeInBytes = ( size_t ) 0;
 800c736:	4608      	mov	r0, r1
 800c738:	e7ea      	b.n	800c710 <xQueueGenericCreate+0x24>

0800c73a <xQueueGetMutexHolder>:
	{
 800c73a:	b510      	push	{r4, lr}
 800c73c:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 800c73e:	f002 fd4b 	bl	800f1d8 <vPortEnterCritical>
			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 800c742:	6823      	ldr	r3, [r4, #0]
 800c744:	b923      	cbnz	r3, 800c750 <xQueueGetMutexHolder+0x16>
				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 800c746:	6864      	ldr	r4, [r4, #4]
		taskEXIT_CRITICAL();
 800c748:	f002 fd68 	bl	800f21c <vPortExitCritical>
	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 800c74c:	4620      	mov	r0, r4
 800c74e:	bd10      	pop	{r4, pc}
				pxReturn = NULL;
 800c750:	2400      	movs	r4, #0
 800c752:	e7f9      	b.n	800c748 <xQueueGetMutexHolder+0xe>

0800c754 <xQueueGetMutexHolderFromISR>:
		configASSERT( xSemaphore );
 800c754:	b118      	cbz	r0, 800c75e <xQueueGetMutexHolderFromISR+0xa>
		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 800c756:	6802      	ldr	r2, [r0, #0]
 800c758:	b952      	cbnz	r2, 800c770 <xQueueGetMutexHolderFromISR+0x1c>
			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 800c75a:	6840      	ldr	r0, [r0, #4]
 800c75c:	4770      	bx	lr
 800c75e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c762:	f383 8811 	msr	BASEPRI, r3
 800c766:	f3bf 8f6f 	isb	sy
 800c76a:	f3bf 8f4f 	dsb	sy
		configASSERT( xSemaphore );
 800c76e:	e7fe      	b.n	800c76e <xQueueGetMutexHolderFromISR+0x1a>
			pxReturn = NULL;
 800c770:	2000      	movs	r0, #0
	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 800c772:	4770      	bx	lr

0800c774 <xQueueCreateCountingSemaphoreStatic>:
	{
 800c774:	b530      	push	{r4, r5, lr}
 800c776:	b083      	sub	sp, #12
		configASSERT( uxMaxCount != 0 );
 800c778:	b940      	cbnz	r0, 800c78c <xQueueCreateCountingSemaphoreStatic+0x18>
 800c77a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c77e:	f383 8811 	msr	BASEPRI, r3
 800c782:	f3bf 8f6f 	isb	sy
 800c786:	f3bf 8f4f 	dsb	sy
 800c78a:	e7fe      	b.n	800c78a <xQueueCreateCountingSemaphoreStatic+0x16>
 800c78c:	460c      	mov	r4, r1
 800c78e:	4613      	mov	r3, r2
		configASSERT( uxInitialCount <= uxMaxCount );
 800c790:	4288      	cmp	r0, r1
 800c792:	d208      	bcs.n	800c7a6 <xQueueCreateCountingSemaphoreStatic+0x32>
 800c794:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c798:	f383 8811 	msr	BASEPRI, r3
 800c79c:	f3bf 8f6f 	isb	sy
 800c7a0:	f3bf 8f4f 	dsb	sy
 800c7a4:	e7fe      	b.n	800c7a4 <xQueueCreateCountingSemaphoreStatic+0x30>
		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 800c7a6:	2202      	movs	r2, #2
 800c7a8:	9200      	str	r2, [sp, #0]
 800c7aa:	2200      	movs	r2, #0
 800c7ac:	4611      	mov	r1, r2
 800c7ae:	f7ff ff54 	bl	800c65a <xQueueGenericCreateStatic>
		if( xHandle != NULL )
 800c7b2:	4603      	mov	r3, r0
 800c7b4:	b100      	cbz	r0, 800c7b8 <xQueueCreateCountingSemaphoreStatic+0x44>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800c7b6:	6384      	str	r4, [r0, #56]	; 0x38
	}
 800c7b8:	4618      	mov	r0, r3
 800c7ba:	b003      	add	sp, #12
 800c7bc:	bd30      	pop	{r4, r5, pc}

0800c7be <xQueueCreateCountingSemaphore>:
		configASSERT( uxMaxCount != 0 );
 800c7be:	b940      	cbnz	r0, 800c7d2 <xQueueCreateCountingSemaphore+0x14>
 800c7c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c7c4:	f383 8811 	msr	BASEPRI, r3
 800c7c8:	f3bf 8f6f 	isb	sy
 800c7cc:	f3bf 8f4f 	dsb	sy
 800c7d0:	e7fe      	b.n	800c7d0 <xQueueCreateCountingSemaphore+0x12>
	{
 800c7d2:	b510      	push	{r4, lr}
 800c7d4:	460c      	mov	r4, r1
		configASSERT( uxInitialCount <= uxMaxCount );
 800c7d6:	4288      	cmp	r0, r1
 800c7d8:	d208      	bcs.n	800c7ec <xQueueCreateCountingSemaphore+0x2e>
 800c7da:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c7de:	f383 8811 	msr	BASEPRI, r3
 800c7e2:	f3bf 8f6f 	isb	sy
 800c7e6:	f3bf 8f4f 	dsb	sy
 800c7ea:	e7fe      	b.n	800c7ea <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 800c7ec:	2202      	movs	r2, #2
 800c7ee:	2100      	movs	r1, #0
 800c7f0:	f7ff ff7c 	bl	800c6ec <xQueueGenericCreate>
		if( xHandle != NULL )
 800c7f4:	4603      	mov	r3, r0
 800c7f6:	b100      	cbz	r0, 800c7fa <xQueueCreateCountingSemaphore+0x3c>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800c7f8:	6384      	str	r4, [r0, #56]	; 0x38
	}
 800c7fa:	4618      	mov	r0, r3
 800c7fc:	bd10      	pop	{r4, pc}

0800c7fe <xQueueGenericSend>:
{
 800c7fe:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c800:	b085      	sub	sp, #20
 800c802:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 800c804:	b188      	cbz	r0, 800c82a <xQueueGenericSend+0x2c>
 800c806:	460e      	mov	r6, r1
 800c808:	461d      	mov	r5, r3
 800c80a:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800c80c:	b1b1      	cbz	r1, 800c83c <xQueueGenericSend+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800c80e:	2d02      	cmp	r5, #2
 800c810:	d120      	bne.n	800c854 <xQueueGenericSend+0x56>
 800c812:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c814:	2b01      	cmp	r3, #1
 800c816:	d01d      	beq.n	800c854 <xQueueGenericSend+0x56>
 800c818:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c81c:	f383 8811 	msr	BASEPRI, r3
 800c820:	f3bf 8f6f 	isb	sy
 800c824:	f3bf 8f4f 	dsb	sy
 800c828:	e7fe      	b.n	800c828 <xQueueGenericSend+0x2a>
 800c82a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c82e:	f383 8811 	msr	BASEPRI, r3
 800c832:	f3bf 8f6f 	isb	sy
 800c836:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800c83a:	e7fe      	b.n	800c83a <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800c83c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800c83e:	2b00      	cmp	r3, #0
 800c840:	d0e5      	beq.n	800c80e <xQueueGenericSend+0x10>
 800c842:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c846:	f383 8811 	msr	BASEPRI, r3
 800c84a:	f3bf 8f6f 	isb	sy
 800c84e:	f3bf 8f4f 	dsb	sy
 800c852:	e7fe      	b.n	800c852 <xQueueGenericSend+0x54>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800c854:	f001 fe1e 	bl	800e494 <xTaskGetSchedulerState>
 800c858:	4607      	mov	r7, r0
 800c85a:	b958      	cbnz	r0, 800c874 <xQueueGenericSend+0x76>
 800c85c:	9b01      	ldr	r3, [sp, #4]
 800c85e:	2b00      	cmp	r3, #0
 800c860:	d044      	beq.n	800c8ec <xQueueGenericSend+0xee>
 800c862:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c866:	f383 8811 	msr	BASEPRI, r3
 800c86a:	f3bf 8f6f 	isb	sy
 800c86e:	f3bf 8f4f 	dsb	sy
 800c872:	e7fe      	b.n	800c872 <xQueueGenericSend+0x74>
 800c874:	2700      	movs	r7, #0
 800c876:	e039      	b.n	800c8ec <xQueueGenericSend+0xee>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800c878:	462a      	mov	r2, r5
 800c87a:	4631      	mov	r1, r6
 800c87c:	4620      	mov	r0, r4
 800c87e:	f7ff fe15 	bl	800c4ac <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800c882:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800c884:	b96a      	cbnz	r2, 800c8a2 <xQueueGenericSend+0xa4>
					else if( xYieldRequired != pdFALSE )
 800c886:	b138      	cbz	r0, 800c898 <xQueueGenericSend+0x9a>
						queueYIELD_IF_USING_PREEMPTION();
 800c888:	4b3c      	ldr	r3, [pc, #240]	; (800c97c <xQueueGenericSend+0x17e>)
 800c88a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c88e:	601a      	str	r2, [r3, #0]
 800c890:	f3bf 8f4f 	dsb	sy
 800c894:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 800c898:	f002 fcc0 	bl	800f21c <vPortExitCritical>
				return pdPASS;
 800c89c:	2001      	movs	r0, #1
}
 800c89e:	b005      	add	sp, #20
 800c8a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800c8a2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800c8a6:	f001 fc1f 	bl	800e0e8 <xTaskRemoveFromEventList>
 800c8aa:	2800      	cmp	r0, #0
 800c8ac:	d0f4      	beq.n	800c898 <xQueueGenericSend+0x9a>
							queueYIELD_IF_USING_PREEMPTION();
 800c8ae:	4b33      	ldr	r3, [pc, #204]	; (800c97c <xQueueGenericSend+0x17e>)
 800c8b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c8b4:	601a      	str	r2, [r3, #0]
 800c8b6:	f3bf 8f4f 	dsb	sy
 800c8ba:	f3bf 8f6f 	isb	sy
 800c8be:	e7eb      	b.n	800c898 <xQueueGenericSend+0x9a>
					taskEXIT_CRITICAL();
 800c8c0:	f002 fcac 	bl	800f21c <vPortExitCritical>
					return errQUEUE_FULL;
 800c8c4:	2000      	movs	r0, #0
 800c8c6:	e7ea      	b.n	800c89e <xQueueGenericSend+0xa0>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800c8c8:	a802      	add	r0, sp, #8
 800c8ca:	f001 fcb3 	bl	800e234 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800c8ce:	2701      	movs	r7, #1
 800c8d0:	e019      	b.n	800c906 <xQueueGenericSend+0x108>
		prvLockQueue( pxQueue );
 800c8d2:	2300      	movs	r3, #0
 800c8d4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800c8d8:	e021      	b.n	800c91e <xQueueGenericSend+0x120>
 800c8da:	2300      	movs	r3, #0
 800c8dc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800c8e0:	e023      	b.n	800c92a <xQueueGenericSend+0x12c>
				prvUnlockQueue( pxQueue );
 800c8e2:	4620      	mov	r0, r4
 800c8e4:	f7ff fe2f 	bl	800c546 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800c8e8:	f001 f9fe 	bl	800dce8 <xTaskResumeAll>
		taskENTER_CRITICAL();
 800c8ec:	f002 fc74 	bl	800f1d8 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800c8f0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800c8f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c8f4:	429a      	cmp	r2, r3
 800c8f6:	d3bf      	bcc.n	800c878 <xQueueGenericSend+0x7a>
 800c8f8:	2d02      	cmp	r5, #2
 800c8fa:	d0bd      	beq.n	800c878 <xQueueGenericSend+0x7a>
				if( xTicksToWait == ( TickType_t ) 0 )
 800c8fc:	9b01      	ldr	r3, [sp, #4]
 800c8fe:	2b00      	cmp	r3, #0
 800c900:	d0de      	beq.n	800c8c0 <xQueueGenericSend+0xc2>
				else if( xEntryTimeSet == pdFALSE )
 800c902:	2f00      	cmp	r7, #0
 800c904:	d0e0      	beq.n	800c8c8 <xQueueGenericSend+0xca>
		taskEXIT_CRITICAL();
 800c906:	f002 fc89 	bl	800f21c <vPortExitCritical>
		vTaskSuspendAll();
 800c90a:	f001 f931 	bl	800db70 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800c90e:	f002 fc63 	bl	800f1d8 <vPortEnterCritical>
 800c912:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800c916:	b25b      	sxtb	r3, r3
 800c918:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c91c:	d0d9      	beq.n	800c8d2 <xQueueGenericSend+0xd4>
 800c91e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800c922:	b25b      	sxtb	r3, r3
 800c924:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c928:	d0d7      	beq.n	800c8da <xQueueGenericSend+0xdc>
 800c92a:	f002 fc77 	bl	800f21c <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800c92e:	a901      	add	r1, sp, #4
 800c930:	a802      	add	r0, sp, #8
 800c932:	f001 fc8b 	bl	800e24c <xTaskCheckForTimeOut>
 800c936:	b9c8      	cbnz	r0, 800c96c <xQueueGenericSend+0x16e>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800c938:	4620      	mov	r0, r4
 800c93a:	f7ff fd9b 	bl	800c474 <prvIsQueueFull>
 800c93e:	2800      	cmp	r0, #0
 800c940:	d0cf      	beq.n	800c8e2 <xQueueGenericSend+0xe4>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800c942:	9901      	ldr	r1, [sp, #4]
 800c944:	f104 0010 	add.w	r0, r4, #16
 800c948:	f001 fb6e 	bl	800e028 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800c94c:	4620      	mov	r0, r4
 800c94e:	f7ff fdfa 	bl	800c546 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800c952:	f001 f9c9 	bl	800dce8 <xTaskResumeAll>
 800c956:	2800      	cmp	r0, #0
 800c958:	d1c8      	bne.n	800c8ec <xQueueGenericSend+0xee>
					portYIELD_WITHIN_API();
 800c95a:	4b08      	ldr	r3, [pc, #32]	; (800c97c <xQueueGenericSend+0x17e>)
 800c95c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c960:	601a      	str	r2, [r3, #0]
 800c962:	f3bf 8f4f 	dsb	sy
 800c966:	f3bf 8f6f 	isb	sy
 800c96a:	e7bf      	b.n	800c8ec <xQueueGenericSend+0xee>
			prvUnlockQueue( pxQueue );
 800c96c:	4620      	mov	r0, r4
 800c96e:	f7ff fdea 	bl	800c546 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800c972:	f001 f9b9 	bl	800dce8 <xTaskResumeAll>
			return errQUEUE_FULL;
 800c976:	2000      	movs	r0, #0
 800c978:	e791      	b.n	800c89e <xQueueGenericSend+0xa0>
 800c97a:	bf00      	nop
 800c97c:	e000ed04 	.word	0xe000ed04

0800c980 <prvInitialiseMutex>:
		if( pxNewQueue != NULL )
 800c980:	b148      	cbz	r0, 800c996 <prvInitialiseMutex+0x16>
	{
 800c982:	b510      	push	{r4, lr}
			pxNewQueue->pxMutexHolder = NULL;
 800c984:	2100      	movs	r1, #0
 800c986:	6041      	str	r1, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800c988:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
 800c98a:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800c98c:	460b      	mov	r3, r1
 800c98e:	460a      	mov	r2, r1
 800c990:	f7ff ff35 	bl	800c7fe <xQueueGenericSend>
	}
 800c994:	bd10      	pop	{r4, pc}
 800c996:	4770      	bx	lr

0800c998 <xQueueCreateMutex>:
	{
 800c998:	b510      	push	{r4, lr}
 800c99a:	4602      	mov	r2, r0
		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 800c99c:	2100      	movs	r1, #0
 800c99e:	2001      	movs	r0, #1
 800c9a0:	f7ff fea4 	bl	800c6ec <xQueueGenericCreate>
 800c9a4:	4604      	mov	r4, r0
		prvInitialiseMutex( pxNewQueue );
 800c9a6:	f7ff ffeb 	bl	800c980 <prvInitialiseMutex>
	}
 800c9aa:	4620      	mov	r0, r4
 800c9ac:	bd10      	pop	{r4, pc}

0800c9ae <xQueueCreateMutexStatic>:
	{
 800c9ae:	b510      	push	{r4, lr}
 800c9b0:	b082      	sub	sp, #8
 800c9b2:	460b      	mov	r3, r1
		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
 800c9b4:	9000      	str	r0, [sp, #0]
 800c9b6:	2200      	movs	r2, #0
 800c9b8:	4611      	mov	r1, r2
 800c9ba:	2001      	movs	r0, #1
 800c9bc:	f7ff fe4d 	bl	800c65a <xQueueGenericCreateStatic>
 800c9c0:	4604      	mov	r4, r0
		prvInitialiseMutex( pxNewQueue );
 800c9c2:	f7ff ffdd 	bl	800c980 <prvInitialiseMutex>
	}
 800c9c6:	4620      	mov	r0, r4
 800c9c8:	b002      	add	sp, #8
 800c9ca:	bd10      	pop	{r4, pc}

0800c9cc <xQueueGiveMutexRecursive>:
	{
 800c9cc:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxMutex );
 800c9ce:	b138      	cbz	r0, 800c9e0 <xQueueGiveMutexRecursive+0x14>
 800c9d0:	4604      	mov	r4, r0
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 800c9d2:	6845      	ldr	r5, [r0, #4]
 800c9d4:	f001 fd58 	bl	800e488 <xTaskGetCurrentTaskHandle>
 800c9d8:	4285      	cmp	r5, r0
 800c9da:	d00a      	beq.n	800c9f2 <xQueueGiveMutexRecursive+0x26>
			xReturn = pdFAIL;
 800c9dc:	2000      	movs	r0, #0
	}
 800c9de:	bd38      	pop	{r3, r4, r5, pc}
 800c9e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c9e4:	f383 8811 	msr	BASEPRI, r3
 800c9e8:	f3bf 8f6f 	isb	sy
 800c9ec:	f3bf 8f4f 	dsb	sy
		configASSERT( pxMutex );
 800c9f0:	e7fe      	b.n	800c9f0 <xQueueGiveMutexRecursive+0x24>
			( pxMutex->u.uxRecursiveCallCount )--;
 800c9f2:	68e3      	ldr	r3, [r4, #12]
 800c9f4:	3b01      	subs	r3, #1
 800c9f6:	60e3      	str	r3, [r4, #12]
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 800c9f8:	b10b      	cbz	r3, 800c9fe <xQueueGiveMutexRecursive+0x32>
			xReturn = pdPASS;
 800c9fa:	2001      	movs	r0, #1
		return xReturn;
 800c9fc:	e7ef      	b.n	800c9de <xQueueGiveMutexRecursive+0x12>
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 800c9fe:	461a      	mov	r2, r3
 800ca00:	4619      	mov	r1, r3
 800ca02:	4620      	mov	r0, r4
 800ca04:	f7ff fefb 	bl	800c7fe <xQueueGenericSend>
			xReturn = pdPASS;
 800ca08:	2001      	movs	r0, #1
 800ca0a:	e7e8      	b.n	800c9de <xQueueGiveMutexRecursive+0x12>

0800ca0c <xQueueGenericSendFromISR>:
{
 800ca0c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 800ca10:	b190      	cbz	r0, 800ca38 <xQueueGenericSendFromISR+0x2c>
 800ca12:	4689      	mov	r9, r1
 800ca14:	4690      	mov	r8, r2
 800ca16:	461f      	mov	r7, r3
 800ca18:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800ca1a:	b1b1      	cbz	r1, 800ca4a <xQueueGenericSendFromISR+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800ca1c:	2f02      	cmp	r7, #2
 800ca1e:	d120      	bne.n	800ca62 <xQueueGenericSendFromISR+0x56>
 800ca20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800ca22:	2b01      	cmp	r3, #1
 800ca24:	d01d      	beq.n	800ca62 <xQueueGenericSendFromISR+0x56>
 800ca26:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ca2a:	f383 8811 	msr	BASEPRI, r3
 800ca2e:	f3bf 8f6f 	isb	sy
 800ca32:	f3bf 8f4f 	dsb	sy
 800ca36:	e7fe      	b.n	800ca36 <xQueueGenericSendFromISR+0x2a>
 800ca38:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ca3c:	f383 8811 	msr	BASEPRI, r3
 800ca40:	f3bf 8f6f 	isb	sy
 800ca44:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800ca48:	e7fe      	b.n	800ca48 <xQueueGenericSendFromISR+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800ca4a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800ca4c:	2b00      	cmp	r3, #0
 800ca4e:	d0e5      	beq.n	800ca1c <xQueueGenericSendFromISR+0x10>
 800ca50:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ca54:	f383 8811 	msr	BASEPRI, r3
 800ca58:	f3bf 8f6f 	isb	sy
 800ca5c:	f3bf 8f4f 	dsb	sy
 800ca60:	e7fe      	b.n	800ca60 <xQueueGenericSendFromISR+0x54>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800ca62:	f002 fca5 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800ca66:	f3ef 8611 	mrs	r6, BASEPRI
 800ca6a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ca6e:	f383 8811 	msr	BASEPRI, r3
 800ca72:	f3bf 8f6f 	isb	sy
 800ca76:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800ca7a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800ca7c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800ca7e:	429a      	cmp	r2, r3
 800ca80:	d306      	bcc.n	800ca90 <xQueueGenericSendFromISR+0x84>
 800ca82:	2f02      	cmp	r7, #2
 800ca84:	d004      	beq.n	800ca90 <xQueueGenericSendFromISR+0x84>
			xReturn = errQUEUE_FULL;
 800ca86:	2000      	movs	r0, #0
	__asm volatile
 800ca88:	f386 8811 	msr	BASEPRI, r6
}
 800ca8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			const int8_t cTxLock = pxQueue->cTxLock;
 800ca90:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 800ca94:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800ca96:	463a      	mov	r2, r7
 800ca98:	4649      	mov	r1, r9
 800ca9a:	4620      	mov	r0, r4
 800ca9c:	f7ff fd06 	bl	800c4ac <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 800caa0:	f1b5 3fff 	cmp.w	r5, #4294967295
 800caa4:	d005      	beq.n	800cab2 <xQueueGenericSendFromISR+0xa6>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800caa6:	1c6b      	adds	r3, r5, #1
 800caa8:	b25b      	sxtb	r3, r3
 800caaa:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 800caae:	2001      	movs	r0, #1
 800cab0:	e7ea      	b.n	800ca88 <xQueueGenericSendFromISR+0x7c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800cab2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800cab4:	b90b      	cbnz	r3, 800caba <xQueueGenericSendFromISR+0xae>
			xReturn = pdPASS;
 800cab6:	2001      	movs	r0, #1
 800cab8:	e7e6      	b.n	800ca88 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800caba:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800cabe:	f001 fb13 	bl	800e0e8 <xTaskRemoveFromEventList>
 800cac2:	b130      	cbz	r0, 800cad2 <xQueueGenericSendFromISR+0xc6>
							if( pxHigherPriorityTaskWoken != NULL )
 800cac4:	f1b8 0f00 	cmp.w	r8, #0
 800cac8:	d005      	beq.n	800cad6 <xQueueGenericSendFromISR+0xca>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800caca:	2001      	movs	r0, #1
 800cacc:	f8c8 0000 	str.w	r0, [r8]
 800cad0:	e7da      	b.n	800ca88 <xQueueGenericSendFromISR+0x7c>
			xReturn = pdPASS;
 800cad2:	2001      	movs	r0, #1
 800cad4:	e7d8      	b.n	800ca88 <xQueueGenericSendFromISR+0x7c>
 800cad6:	2001      	movs	r0, #1
 800cad8:	e7d6      	b.n	800ca88 <xQueueGenericSendFromISR+0x7c>

0800cada <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 800cada:	b168      	cbz	r0, 800caf8 <xQueueGiveFromISR+0x1e>
{
 800cadc:	b570      	push	{r4, r5, r6, lr}
 800cade:	460e      	mov	r6, r1
 800cae0:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 800cae2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800cae4:	b18b      	cbz	r3, 800cb0a <xQueueGiveFromISR+0x30>
	__asm volatile
 800cae6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800caea:	f383 8811 	msr	BASEPRI, r3
 800caee:	f3bf 8f6f 	isb	sy
 800caf2:	f3bf 8f4f 	dsb	sy
 800caf6:	e7fe      	b.n	800caf6 <xQueueGiveFromISR+0x1c>
 800caf8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cafc:	f383 8811 	msr	BASEPRI, r3
 800cb00:	f3bf 8f6f 	isb	sy
 800cb04:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800cb08:	e7fe      	b.n	800cb08 <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 800cb0a:	6803      	ldr	r3, [r0, #0]
 800cb0c:	b1eb      	cbz	r3, 800cb4a <xQueueGiveFromISR+0x70>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800cb0e:	f002 fc4f 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800cb12:	f3ef 8511 	mrs	r5, BASEPRI
 800cb16:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cb1a:	f383 8811 	msr	BASEPRI, r3
 800cb1e:	f3bf 8f6f 	isb	sy
 800cb22:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800cb26:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 800cb28:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800cb2a:	4293      	cmp	r3, r2
 800cb2c:	d926      	bls.n	800cb7c <xQueueGiveFromISR+0xa2>
			const int8_t cTxLock = pxQueue->cTxLock;
 800cb2e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800cb32:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800cb34:	3201      	adds	r2, #1
 800cb36:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 800cb38:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cb3c:	d011      	beq.n	800cb62 <xQueueGiveFromISR+0x88>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800cb3e:	3301      	adds	r3, #1
 800cb40:	b25b      	sxtb	r3, r3
 800cb42:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 800cb46:	2001      	movs	r0, #1
 800cb48:	e019      	b.n	800cb7e <xQueueGiveFromISR+0xa4>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 800cb4a:	6843      	ldr	r3, [r0, #4]
 800cb4c:	2b00      	cmp	r3, #0
 800cb4e:	d0de      	beq.n	800cb0e <xQueueGiveFromISR+0x34>
	__asm volatile
 800cb50:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cb54:	f383 8811 	msr	BASEPRI, r3
 800cb58:	f3bf 8f6f 	isb	sy
 800cb5c:	f3bf 8f4f 	dsb	sy
 800cb60:	e7fe      	b.n	800cb60 <xQueueGiveFromISR+0x86>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800cb62:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800cb64:	b90b      	cbnz	r3, 800cb6a <xQueueGiveFromISR+0x90>
			xReturn = pdPASS;
 800cb66:	2001      	movs	r0, #1
 800cb68:	e009      	b.n	800cb7e <xQueueGiveFromISR+0xa4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800cb6a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800cb6e:	f001 fabb 	bl	800e0e8 <xTaskRemoveFromEventList>
 800cb72:	b138      	cbz	r0, 800cb84 <xQueueGiveFromISR+0xaa>
							if( pxHigherPriorityTaskWoken != NULL )
 800cb74:	b146      	cbz	r6, 800cb88 <xQueueGiveFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800cb76:	2001      	movs	r0, #1
 800cb78:	6030      	str	r0, [r6, #0]
 800cb7a:	e000      	b.n	800cb7e <xQueueGiveFromISR+0xa4>
			xReturn = errQUEUE_FULL;
 800cb7c:	2000      	movs	r0, #0
	__asm volatile
 800cb7e:	f385 8811 	msr	BASEPRI, r5
}
 800cb82:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdPASS;
 800cb84:	2001      	movs	r0, #1
 800cb86:	e7fa      	b.n	800cb7e <xQueueGiveFromISR+0xa4>
 800cb88:	2001      	movs	r0, #1
 800cb8a:	e7f8      	b.n	800cb7e <xQueueGiveFromISR+0xa4>

0800cb8c <xQueueReceive>:
{
 800cb8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cb8e:	b085      	sub	sp, #20
 800cb90:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 800cb92:	b190      	cbz	r0, 800cbba <xQueueReceive+0x2e>
 800cb94:	460e      	mov	r6, r1
 800cb96:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800cb98:	b1c1      	cbz	r1, 800cbcc <xQueueReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800cb9a:	f001 fc7b 	bl	800e494 <xTaskGetSchedulerState>
 800cb9e:	4607      	mov	r7, r0
 800cba0:	bb00      	cbnz	r0, 800cbe4 <xQueueReceive+0x58>
 800cba2:	9b01      	ldr	r3, [sp, #4]
 800cba4:	2b00      	cmp	r3, #0
 800cba6:	d05c      	beq.n	800cc62 <xQueueReceive+0xd6>
	__asm volatile
 800cba8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cbac:	f383 8811 	msr	BASEPRI, r3
 800cbb0:	f3bf 8f6f 	isb	sy
 800cbb4:	f3bf 8f4f 	dsb	sy
 800cbb8:	e7fe      	b.n	800cbb8 <xQueueReceive+0x2c>
 800cbba:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cbbe:	f383 8811 	msr	BASEPRI, r3
 800cbc2:	f3bf 8f6f 	isb	sy
 800cbc6:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 800cbca:	e7fe      	b.n	800cbca <xQueueReceive+0x3e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800cbcc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800cbce:	2b00      	cmp	r3, #0
 800cbd0:	d0e3      	beq.n	800cb9a <xQueueReceive+0xe>
 800cbd2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cbd6:	f383 8811 	msr	BASEPRI, r3
 800cbda:	f3bf 8f6f 	isb	sy
 800cbde:	f3bf 8f4f 	dsb	sy
 800cbe2:	e7fe      	b.n	800cbe2 <xQueueReceive+0x56>
 800cbe4:	2700      	movs	r7, #0
 800cbe6:	e03c      	b.n	800cc62 <xQueueReceive+0xd6>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800cbe8:	4631      	mov	r1, r6
 800cbea:	4620      	mov	r0, r4
 800cbec:	f7ff fc99 	bl	800c522 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800cbf0:	3d01      	subs	r5, #1
 800cbf2:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800cbf4:	6923      	ldr	r3, [r4, #16]
 800cbf6:	b923      	cbnz	r3, 800cc02 <xQueueReceive+0x76>
				taskEXIT_CRITICAL();
 800cbf8:	f002 fb10 	bl	800f21c <vPortExitCritical>
				return pdPASS;
 800cbfc:	2001      	movs	r0, #1
}
 800cbfe:	b005      	add	sp, #20
 800cc00:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800cc02:	f104 0010 	add.w	r0, r4, #16
 800cc06:	f001 fa6f 	bl	800e0e8 <xTaskRemoveFromEventList>
 800cc0a:	2800      	cmp	r0, #0
 800cc0c:	d0f4      	beq.n	800cbf8 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
 800cc0e:	4b35      	ldr	r3, [pc, #212]	; (800cce4 <xQueueReceive+0x158>)
 800cc10:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800cc14:	601a      	str	r2, [r3, #0]
 800cc16:	f3bf 8f4f 	dsb	sy
 800cc1a:	f3bf 8f6f 	isb	sy
 800cc1e:	e7eb      	b.n	800cbf8 <xQueueReceive+0x6c>
					taskEXIT_CRITICAL();
 800cc20:	f002 fafc 	bl	800f21c <vPortExitCritical>
					return errQUEUE_EMPTY;
 800cc24:	2000      	movs	r0, #0
 800cc26:	e7ea      	b.n	800cbfe <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800cc28:	a802      	add	r0, sp, #8
 800cc2a:	f001 fb03 	bl	800e234 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800cc2e:	2701      	movs	r7, #1
 800cc30:	e021      	b.n	800cc76 <xQueueReceive+0xea>
		prvLockQueue( pxQueue );
 800cc32:	2300      	movs	r3, #0
 800cc34:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800cc38:	e029      	b.n	800cc8e <xQueueReceive+0x102>
 800cc3a:	2300      	movs	r3, #0
 800cc3c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800cc40:	e02b      	b.n	800cc9a <xQueueReceive+0x10e>
				prvUnlockQueue( pxQueue );
 800cc42:	4620      	mov	r0, r4
 800cc44:	f7ff fc7f 	bl	800c546 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800cc48:	f001 f84e 	bl	800dce8 <xTaskResumeAll>
 800cc4c:	e009      	b.n	800cc62 <xQueueReceive+0xd6>
			prvUnlockQueue( pxQueue );
 800cc4e:	4620      	mov	r0, r4
 800cc50:	f7ff fc79 	bl	800c546 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800cc54:	f001 f848 	bl	800dce8 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800cc58:	4620      	mov	r0, r4
 800cc5a:	f7ff fc1a 	bl	800c492 <prvIsQueueEmpty>
 800cc5e:	2800      	cmp	r0, #0
 800cc60:	d13d      	bne.n	800ccde <xQueueReceive+0x152>
		taskENTER_CRITICAL();
 800cc62:	f002 fab9 	bl	800f1d8 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800cc66:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800cc68:	2d00      	cmp	r5, #0
 800cc6a:	d1bd      	bne.n	800cbe8 <xQueueReceive+0x5c>
				if( xTicksToWait == ( TickType_t ) 0 )
 800cc6c:	9b01      	ldr	r3, [sp, #4]
 800cc6e:	2b00      	cmp	r3, #0
 800cc70:	d0d6      	beq.n	800cc20 <xQueueReceive+0x94>
				else if( xEntryTimeSet == pdFALSE )
 800cc72:	2f00      	cmp	r7, #0
 800cc74:	d0d8      	beq.n	800cc28 <xQueueReceive+0x9c>
		taskEXIT_CRITICAL();
 800cc76:	f002 fad1 	bl	800f21c <vPortExitCritical>
		vTaskSuspendAll();
 800cc7a:	f000 ff79 	bl	800db70 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800cc7e:	f002 faab 	bl	800f1d8 <vPortEnterCritical>
 800cc82:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800cc86:	b25b      	sxtb	r3, r3
 800cc88:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cc8c:	d0d1      	beq.n	800cc32 <xQueueReceive+0xa6>
 800cc8e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800cc92:	b25b      	sxtb	r3, r3
 800cc94:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cc98:	d0cf      	beq.n	800cc3a <xQueueReceive+0xae>
 800cc9a:	f002 fabf 	bl	800f21c <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800cc9e:	a901      	add	r1, sp, #4
 800cca0:	a802      	add	r0, sp, #8
 800cca2:	f001 fad3 	bl	800e24c <xTaskCheckForTimeOut>
 800cca6:	2800      	cmp	r0, #0
 800cca8:	d1d1      	bne.n	800cc4e <xQueueReceive+0xc2>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800ccaa:	4620      	mov	r0, r4
 800ccac:	f7ff fbf1 	bl	800c492 <prvIsQueueEmpty>
 800ccb0:	2800      	cmp	r0, #0
 800ccb2:	d0c6      	beq.n	800cc42 <xQueueReceive+0xb6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800ccb4:	9901      	ldr	r1, [sp, #4]
 800ccb6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ccba:	f001 f9b5 	bl	800e028 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800ccbe:	4620      	mov	r0, r4
 800ccc0:	f7ff fc41 	bl	800c546 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800ccc4:	f001 f810 	bl	800dce8 <xTaskResumeAll>
 800ccc8:	2800      	cmp	r0, #0
 800ccca:	d1ca      	bne.n	800cc62 <xQueueReceive+0xd6>
					portYIELD_WITHIN_API();
 800cccc:	4b05      	ldr	r3, [pc, #20]	; (800cce4 <xQueueReceive+0x158>)
 800ccce:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ccd2:	601a      	str	r2, [r3, #0]
 800ccd4:	f3bf 8f4f 	dsb	sy
 800ccd8:	f3bf 8f6f 	isb	sy
 800ccdc:	e7c1      	b.n	800cc62 <xQueueReceive+0xd6>
				return errQUEUE_EMPTY;
 800ccde:	2000      	movs	r0, #0
 800cce0:	e78d      	b.n	800cbfe <xQueueReceive+0x72>
 800cce2:	bf00      	nop
 800cce4:	e000ed04 	.word	0xe000ed04

0800cce8 <xQueueSemaphoreTake>:
{
 800cce8:	b570      	push	{r4, r5, r6, lr}
 800ccea:	b084      	sub	sp, #16
 800ccec:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 800ccee:	b158      	cbz	r0, 800cd08 <xQueueSemaphoreTake+0x20>
 800ccf0:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 800ccf2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800ccf4:	b18b      	cbz	r3, 800cd1a <xQueueSemaphoreTake+0x32>
 800ccf6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ccfa:	f383 8811 	msr	BASEPRI, r3
 800ccfe:	f3bf 8f6f 	isb	sy
 800cd02:	f3bf 8f4f 	dsb	sy
 800cd06:	e7fe      	b.n	800cd06 <xQueueSemaphoreTake+0x1e>
 800cd08:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cd0c:	f383 8811 	msr	BASEPRI, r3
 800cd10:	f3bf 8f6f 	isb	sy
 800cd14:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 800cd18:	e7fe      	b.n	800cd18 <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800cd1a:	f001 fbbb 	bl	800e494 <xTaskGetSchedulerState>
 800cd1e:	4606      	mov	r6, r0
 800cd20:	b950      	cbnz	r0, 800cd38 <xQueueSemaphoreTake+0x50>
 800cd22:	9b01      	ldr	r3, [sp, #4]
 800cd24:	b15b      	cbz	r3, 800cd3e <xQueueSemaphoreTake+0x56>
 800cd26:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cd2a:	f383 8811 	msr	BASEPRI, r3
 800cd2e:	f3bf 8f6f 	isb	sy
 800cd32:	f3bf 8f4f 	dsb	sy
 800cd36:	e7fe      	b.n	800cd36 <xQueueSemaphoreTake+0x4e>
 800cd38:	2500      	movs	r5, #0
 800cd3a:	462e      	mov	r6, r5
 800cd3c:	e053      	b.n	800cde6 <xQueueSemaphoreTake+0xfe>
 800cd3e:	4605      	mov	r5, r0
 800cd40:	e051      	b.n	800cde6 <xQueueSemaphoreTake+0xfe>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800cd42:	3b01      	subs	r3, #1
 800cd44:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800cd46:	6823      	ldr	r3, [r4, #0]
 800cd48:	b13b      	cbz	r3, 800cd5a <xQueueSemaphoreTake+0x72>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800cd4a:	6923      	ldr	r3, [r4, #16]
 800cd4c:	b94b      	cbnz	r3, 800cd62 <xQueueSemaphoreTake+0x7a>
				taskEXIT_CRITICAL();
 800cd4e:	f002 fa65 	bl	800f21c <vPortExitCritical>
				return pdPASS;
 800cd52:	2501      	movs	r5, #1
}
 800cd54:	4628      	mov	r0, r5
 800cd56:	b004      	add	sp, #16
 800cd58:	bd70      	pop	{r4, r5, r6, pc}
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 800cd5a:	f001 fc9d 	bl	800e698 <pvTaskIncrementMutexHeldCount>
 800cd5e:	6060      	str	r0, [r4, #4]
 800cd60:	e7f3      	b.n	800cd4a <xQueueSemaphoreTake+0x62>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800cd62:	f104 0010 	add.w	r0, r4, #16
 800cd66:	f001 f9bf 	bl	800e0e8 <xTaskRemoveFromEventList>
 800cd6a:	2800      	cmp	r0, #0
 800cd6c:	d0ef      	beq.n	800cd4e <xQueueSemaphoreTake+0x66>
						queueYIELD_IF_USING_PREEMPTION();
 800cd6e:	4b46      	ldr	r3, [pc, #280]	; (800ce88 <xQueueSemaphoreTake+0x1a0>)
 800cd70:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800cd74:	601a      	str	r2, [r3, #0]
 800cd76:	f3bf 8f4f 	dsb	sy
 800cd7a:	f3bf 8f6f 	isb	sy
 800cd7e:	e7e6      	b.n	800cd4e <xQueueSemaphoreTake+0x66>
						configASSERT( xInheritanceOccurred == pdFALSE );
 800cd80:	b145      	cbz	r5, 800cd94 <xQueueSemaphoreTake+0xac>
 800cd82:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cd86:	f383 8811 	msr	BASEPRI, r3
 800cd8a:	f3bf 8f6f 	isb	sy
 800cd8e:	f3bf 8f4f 	dsb	sy
 800cd92:	e7fe      	b.n	800cd92 <xQueueSemaphoreTake+0xaa>
					taskEXIT_CRITICAL();
 800cd94:	f002 fa42 	bl	800f21c <vPortExitCritical>
					return errQUEUE_EMPTY;
 800cd98:	e7dc      	b.n	800cd54 <xQueueSemaphoreTake+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800cd9a:	a802      	add	r0, sp, #8
 800cd9c:	f001 fa4a 	bl	800e234 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800cda0:	2601      	movs	r6, #1
 800cda2:	e02a      	b.n	800cdfa <xQueueSemaphoreTake+0x112>
		prvLockQueue( pxQueue );
 800cda4:	2300      	movs	r3, #0
 800cda6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800cdaa:	e032      	b.n	800ce12 <xQueueSemaphoreTake+0x12a>
 800cdac:	2300      	movs	r3, #0
 800cdae:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800cdb2:	e034      	b.n	800ce1e <xQueueSemaphoreTake+0x136>
						taskENTER_CRITICAL();
 800cdb4:	f002 fa10 	bl	800f1d8 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800cdb8:	6860      	ldr	r0, [r4, #4]
 800cdba:	f001 fb7b 	bl	800e4b4 <xTaskPriorityInherit>
 800cdbe:	4605      	mov	r5, r0
						taskEXIT_CRITICAL();
 800cdc0:	f002 fa2c 	bl	800f21c <vPortExitCritical>
 800cdc4:	e03b      	b.n	800ce3e <xQueueSemaphoreTake+0x156>
				prvUnlockQueue( pxQueue );
 800cdc6:	4620      	mov	r0, r4
 800cdc8:	f7ff fbbd 	bl	800c546 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800cdcc:	f000 ff8c 	bl	800dce8 <xTaskResumeAll>
 800cdd0:	e009      	b.n	800cde6 <xQueueSemaphoreTake+0xfe>
			prvUnlockQueue( pxQueue );
 800cdd2:	4620      	mov	r0, r4
 800cdd4:	f7ff fbb7 	bl	800c546 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800cdd8:	f000 ff86 	bl	800dce8 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800cddc:	4620      	mov	r0, r4
 800cdde:	f7ff fb58 	bl	800c492 <prvIsQueueEmpty>
 800cde2:	2800      	cmp	r0, #0
 800cde4:	d140      	bne.n	800ce68 <xQueueSemaphoreTake+0x180>
		taskENTER_CRITICAL();
 800cde6:	f002 f9f7 	bl	800f1d8 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 800cdea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 800cdec:	2b00      	cmp	r3, #0
 800cdee:	d1a8      	bne.n	800cd42 <xQueueSemaphoreTake+0x5a>
				if( xTicksToWait == ( TickType_t ) 0 )
 800cdf0:	9b01      	ldr	r3, [sp, #4]
 800cdf2:	2b00      	cmp	r3, #0
 800cdf4:	d0c4      	beq.n	800cd80 <xQueueSemaphoreTake+0x98>
				else if( xEntryTimeSet == pdFALSE )
 800cdf6:	2e00      	cmp	r6, #0
 800cdf8:	d0cf      	beq.n	800cd9a <xQueueSemaphoreTake+0xb2>
		taskEXIT_CRITICAL();
 800cdfa:	f002 fa0f 	bl	800f21c <vPortExitCritical>
		vTaskSuspendAll();
 800cdfe:	f000 feb7 	bl	800db70 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800ce02:	f002 f9e9 	bl	800f1d8 <vPortEnterCritical>
 800ce06:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800ce0a:	b25b      	sxtb	r3, r3
 800ce0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ce10:	d0c8      	beq.n	800cda4 <xQueueSemaphoreTake+0xbc>
 800ce12:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800ce16:	b25b      	sxtb	r3, r3
 800ce18:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ce1c:	d0c6      	beq.n	800cdac <xQueueSemaphoreTake+0xc4>
 800ce1e:	f002 f9fd 	bl	800f21c <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800ce22:	a901      	add	r1, sp, #4
 800ce24:	a802      	add	r0, sp, #8
 800ce26:	f001 fa11 	bl	800e24c <xTaskCheckForTimeOut>
 800ce2a:	2800      	cmp	r0, #0
 800ce2c:	d1d1      	bne.n	800cdd2 <xQueueSemaphoreTake+0xea>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800ce2e:	4620      	mov	r0, r4
 800ce30:	f7ff fb2f 	bl	800c492 <prvIsQueueEmpty>
 800ce34:	2800      	cmp	r0, #0
 800ce36:	d0c6      	beq.n	800cdc6 <xQueueSemaphoreTake+0xde>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800ce38:	6823      	ldr	r3, [r4, #0]
 800ce3a:	2b00      	cmp	r3, #0
 800ce3c:	d0ba      	beq.n	800cdb4 <xQueueSemaphoreTake+0xcc>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800ce3e:	9901      	ldr	r1, [sp, #4]
 800ce40:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ce44:	f001 f8f0 	bl	800e028 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800ce48:	4620      	mov	r0, r4
 800ce4a:	f7ff fb7c 	bl	800c546 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800ce4e:	f000 ff4b 	bl	800dce8 <xTaskResumeAll>
 800ce52:	2800      	cmp	r0, #0
 800ce54:	d1c7      	bne.n	800cde6 <xQueueSemaphoreTake+0xfe>
					portYIELD_WITHIN_API();
 800ce56:	4b0c      	ldr	r3, [pc, #48]	; (800ce88 <xQueueSemaphoreTake+0x1a0>)
 800ce58:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ce5c:	601a      	str	r2, [r3, #0]
 800ce5e:	f3bf 8f4f 	dsb	sy
 800ce62:	f3bf 8f6f 	isb	sy
 800ce66:	e7be      	b.n	800cde6 <xQueueSemaphoreTake+0xfe>
					if( xInheritanceOccurred != pdFALSE )
 800ce68:	b90d      	cbnz	r5, 800ce6e <xQueueSemaphoreTake+0x186>
				return errQUEUE_EMPTY;
 800ce6a:	2500      	movs	r5, #0
 800ce6c:	e772      	b.n	800cd54 <xQueueSemaphoreTake+0x6c>
						taskENTER_CRITICAL();
 800ce6e:	f002 f9b3 	bl	800f1d8 <vPortEnterCritical>
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 800ce72:	4620      	mov	r0, r4
 800ce74:	f7ff faf6 	bl	800c464 <prvGetDisinheritPriorityAfterTimeout>
 800ce78:	4601      	mov	r1, r0
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
 800ce7a:	6860      	ldr	r0, [r4, #4]
 800ce7c:	f001 fbae 	bl	800e5dc <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 800ce80:	f002 f9cc 	bl	800f21c <vPortExitCritical>
 800ce84:	e7f1      	b.n	800ce6a <xQueueSemaphoreTake+0x182>
 800ce86:	bf00      	nop
 800ce88:	e000ed04 	.word	0xe000ed04

0800ce8c <xQueueTakeMutexRecursive>:
		configASSERT( pxMutex );
 800ce8c:	b188      	cbz	r0, 800ceb2 <xQueueTakeMutexRecursive+0x26>
	{
 800ce8e:	b570      	push	{r4, r5, r6, lr}
 800ce90:	460d      	mov	r5, r1
 800ce92:	4604      	mov	r4, r0
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 800ce94:	6846      	ldr	r6, [r0, #4]
 800ce96:	f001 faf7 	bl	800e488 <xTaskGetCurrentTaskHandle>
 800ce9a:	4286      	cmp	r6, r0
 800ce9c:	d012      	beq.n	800cec4 <xQueueTakeMutexRecursive+0x38>
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 800ce9e:	4629      	mov	r1, r5
 800cea0:	4620      	mov	r0, r4
 800cea2:	f7ff ff21 	bl	800cce8 <xQueueSemaphoreTake>
			if( xReturn != pdFAIL )
 800cea6:	4602      	mov	r2, r0
 800cea8:	b180      	cbz	r0, 800cecc <xQueueTakeMutexRecursive+0x40>
				( pxMutex->u.uxRecursiveCallCount )++;
 800ceaa:	68e3      	ldr	r3, [r4, #12]
 800ceac:	3301      	adds	r3, #1
 800ceae:	60e3      	str	r3, [r4, #12]
		return xReturn;
 800ceb0:	e00c      	b.n	800cecc <xQueueTakeMutexRecursive+0x40>
 800ceb2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ceb6:	f383 8811 	msr	BASEPRI, r3
 800ceba:	f3bf 8f6f 	isb	sy
 800cebe:	f3bf 8f4f 	dsb	sy
		configASSERT( pxMutex );
 800cec2:	e7fe      	b.n	800cec2 <xQueueTakeMutexRecursive+0x36>
			( pxMutex->u.uxRecursiveCallCount )++;
 800cec4:	68e3      	ldr	r3, [r4, #12]
 800cec6:	3301      	adds	r3, #1
 800cec8:	60e3      	str	r3, [r4, #12]
			xReturn = pdPASS;
 800ceca:	2201      	movs	r2, #1
	}
 800cecc:	4610      	mov	r0, r2
 800cece:	bd70      	pop	{r4, r5, r6, pc}

0800ced0 <xQueuePeek>:
{
 800ced0:	b570      	push	{r4, r5, r6, lr}
 800ced2:	b084      	sub	sp, #16
 800ced4:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 800ced6:	b190      	cbz	r0, 800cefe <xQueuePeek+0x2e>
 800ced8:	460d      	mov	r5, r1
 800ceda:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800cedc:	b1c1      	cbz	r1, 800cf10 <xQueuePeek+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800cede:	f001 fad9 	bl	800e494 <xTaskGetSchedulerState>
 800cee2:	4606      	mov	r6, r0
 800cee4:	bb00      	cbnz	r0, 800cf28 <xQueuePeek+0x58>
 800cee6:	9b01      	ldr	r3, [sp, #4]
 800cee8:	2b00      	cmp	r3, #0
 800ceea:	d05c      	beq.n	800cfa6 <xQueuePeek+0xd6>
 800ceec:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cef0:	f383 8811 	msr	BASEPRI, r3
 800cef4:	f3bf 8f6f 	isb	sy
 800cef8:	f3bf 8f4f 	dsb	sy
 800cefc:	e7fe      	b.n	800cefc <xQueuePeek+0x2c>
 800cefe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cf02:	f383 8811 	msr	BASEPRI, r3
 800cf06:	f3bf 8f6f 	isb	sy
 800cf0a:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 800cf0e:	e7fe      	b.n	800cf0e <xQueuePeek+0x3e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800cf10:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800cf12:	2b00      	cmp	r3, #0
 800cf14:	d0e3      	beq.n	800cede <xQueuePeek+0xe>
 800cf16:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cf1a:	f383 8811 	msr	BASEPRI, r3
 800cf1e:	f3bf 8f6f 	isb	sy
 800cf22:	f3bf 8f4f 	dsb	sy
 800cf26:	e7fe      	b.n	800cf26 <xQueuePeek+0x56>
 800cf28:	2600      	movs	r6, #0
 800cf2a:	e03c      	b.n	800cfa6 <xQueuePeek+0xd6>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800cf2c:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800cf2e:	4629      	mov	r1, r5
 800cf30:	4620      	mov	r0, r4
 800cf32:	f7ff faf6 	bl	800c522 <prvCopyDataFromQueue>
				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800cf36:	60e6      	str	r6, [r4, #12]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800cf38:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800cf3a:	b923      	cbnz	r3, 800cf46 <xQueuePeek+0x76>
				taskEXIT_CRITICAL();
 800cf3c:	f002 f96e 	bl	800f21c <vPortExitCritical>
				return pdPASS;
 800cf40:	2001      	movs	r0, #1
}
 800cf42:	b004      	add	sp, #16
 800cf44:	bd70      	pop	{r4, r5, r6, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800cf46:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800cf4a:	f001 f8cd 	bl	800e0e8 <xTaskRemoveFromEventList>
 800cf4e:	2800      	cmp	r0, #0
 800cf50:	d0f4      	beq.n	800cf3c <xQueuePeek+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
 800cf52:	4b35      	ldr	r3, [pc, #212]	; (800d028 <xQueuePeek+0x158>)
 800cf54:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800cf58:	601a      	str	r2, [r3, #0]
 800cf5a:	f3bf 8f4f 	dsb	sy
 800cf5e:	f3bf 8f6f 	isb	sy
 800cf62:	e7eb      	b.n	800cf3c <xQueuePeek+0x6c>
					taskEXIT_CRITICAL();
 800cf64:	f002 f95a 	bl	800f21c <vPortExitCritical>
					return errQUEUE_EMPTY;
 800cf68:	2000      	movs	r0, #0
 800cf6a:	e7ea      	b.n	800cf42 <xQueuePeek+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800cf6c:	a802      	add	r0, sp, #8
 800cf6e:	f001 f961 	bl	800e234 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800cf72:	2601      	movs	r6, #1
 800cf74:	e021      	b.n	800cfba <xQueuePeek+0xea>
		prvLockQueue( pxQueue );
 800cf76:	2300      	movs	r3, #0
 800cf78:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800cf7c:	e029      	b.n	800cfd2 <xQueuePeek+0x102>
 800cf7e:	2300      	movs	r3, #0
 800cf80:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800cf84:	e02b      	b.n	800cfde <xQueuePeek+0x10e>
				prvUnlockQueue( pxQueue );
 800cf86:	4620      	mov	r0, r4
 800cf88:	f7ff fadd 	bl	800c546 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800cf8c:	f000 feac 	bl	800dce8 <xTaskResumeAll>
 800cf90:	e009      	b.n	800cfa6 <xQueuePeek+0xd6>
			prvUnlockQueue( pxQueue );
 800cf92:	4620      	mov	r0, r4
 800cf94:	f7ff fad7 	bl	800c546 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800cf98:	f000 fea6 	bl	800dce8 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800cf9c:	4620      	mov	r0, r4
 800cf9e:	f7ff fa78 	bl	800c492 <prvIsQueueEmpty>
 800cfa2:	2800      	cmp	r0, #0
 800cfa4:	d13d      	bne.n	800d022 <xQueuePeek+0x152>
		taskENTER_CRITICAL();
 800cfa6:	f002 f917 	bl	800f1d8 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800cfaa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800cfac:	2b00      	cmp	r3, #0
 800cfae:	d1bd      	bne.n	800cf2c <xQueuePeek+0x5c>
				if( xTicksToWait == ( TickType_t ) 0 )
 800cfb0:	9b01      	ldr	r3, [sp, #4]
 800cfb2:	2b00      	cmp	r3, #0
 800cfb4:	d0d6      	beq.n	800cf64 <xQueuePeek+0x94>
				else if( xEntryTimeSet == pdFALSE )
 800cfb6:	2e00      	cmp	r6, #0
 800cfb8:	d0d8      	beq.n	800cf6c <xQueuePeek+0x9c>
		taskEXIT_CRITICAL();
 800cfba:	f002 f92f 	bl	800f21c <vPortExitCritical>
		vTaskSuspendAll();
 800cfbe:	f000 fdd7 	bl	800db70 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800cfc2:	f002 f909 	bl	800f1d8 <vPortEnterCritical>
 800cfc6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800cfca:	b25b      	sxtb	r3, r3
 800cfcc:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cfd0:	d0d1      	beq.n	800cf76 <xQueuePeek+0xa6>
 800cfd2:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800cfd6:	b25b      	sxtb	r3, r3
 800cfd8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cfdc:	d0cf      	beq.n	800cf7e <xQueuePeek+0xae>
 800cfde:	f002 f91d 	bl	800f21c <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800cfe2:	a901      	add	r1, sp, #4
 800cfe4:	a802      	add	r0, sp, #8
 800cfe6:	f001 f931 	bl	800e24c <xTaskCheckForTimeOut>
 800cfea:	2800      	cmp	r0, #0
 800cfec:	d1d1      	bne.n	800cf92 <xQueuePeek+0xc2>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800cfee:	4620      	mov	r0, r4
 800cff0:	f7ff fa4f 	bl	800c492 <prvIsQueueEmpty>
 800cff4:	2800      	cmp	r0, #0
 800cff6:	d0c6      	beq.n	800cf86 <xQueuePeek+0xb6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800cff8:	9901      	ldr	r1, [sp, #4]
 800cffa:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800cffe:	f001 f813 	bl	800e028 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800d002:	4620      	mov	r0, r4
 800d004:	f7ff fa9f 	bl	800c546 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800d008:	f000 fe6e 	bl	800dce8 <xTaskResumeAll>
 800d00c:	2800      	cmp	r0, #0
 800d00e:	d1ca      	bne.n	800cfa6 <xQueuePeek+0xd6>
					portYIELD_WITHIN_API();
 800d010:	4b05      	ldr	r3, [pc, #20]	; (800d028 <xQueuePeek+0x158>)
 800d012:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d016:	601a      	str	r2, [r3, #0]
 800d018:	f3bf 8f4f 	dsb	sy
 800d01c:	f3bf 8f6f 	isb	sy
 800d020:	e7c1      	b.n	800cfa6 <xQueuePeek+0xd6>
				return errQUEUE_EMPTY;
 800d022:	2000      	movs	r0, #0
 800d024:	e78d      	b.n	800cf42 <xQueuePeek+0x72>
 800d026:	bf00      	nop
 800d028:	e000ed04 	.word	0xe000ed04

0800d02c <xQueueReceiveFromISR>:
{
 800d02c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 800d030:	b1c8      	cbz	r0, 800d066 <xQueueReceiveFromISR+0x3a>
 800d032:	4689      	mov	r9, r1
 800d034:	4617      	mov	r7, r2
 800d036:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800d038:	b1f1      	cbz	r1, 800d078 <xQueueReceiveFromISR+0x4c>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800d03a:	f002 f9b9 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800d03e:	f3ef 8611 	mrs	r6, BASEPRI
 800d042:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d046:	f383 8811 	msr	BASEPRI, r3
 800d04a:	f3bf 8f6f 	isb	sy
 800d04e:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800d052:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800d056:	f1b8 0f00 	cmp.w	r8, #0
 800d05a:	d119      	bne.n	800d090 <xQueueReceiveFromISR+0x64>
			xReturn = pdFAIL;
 800d05c:	2000      	movs	r0, #0
	__asm volatile
 800d05e:	f386 8811 	msr	BASEPRI, r6
}
 800d062:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile
 800d066:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d06a:	f383 8811 	msr	BASEPRI, r3
 800d06e:	f3bf 8f6f 	isb	sy
 800d072:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800d076:	e7fe      	b.n	800d076 <xQueueReceiveFromISR+0x4a>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800d078:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800d07a:	2b00      	cmp	r3, #0
 800d07c:	d0dd      	beq.n	800d03a <xQueueReceiveFromISR+0xe>
 800d07e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d082:	f383 8811 	msr	BASEPRI, r3
 800d086:	f3bf 8f6f 	isb	sy
 800d08a:	f3bf 8f4f 	dsb	sy
 800d08e:	e7fe      	b.n	800d08e <xQueueReceiveFromISR+0x62>
			const int8_t cRxLock = pxQueue->cRxLock;
 800d090:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 800d094:	b26d      	sxtb	r5, r5
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800d096:	4649      	mov	r1, r9
 800d098:	4620      	mov	r0, r4
 800d09a:	f7ff fa42 	bl	800c522 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800d09e:	f108 33ff 	add.w	r3, r8, #4294967295
 800d0a2:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800d0a4:	f1b5 3fff 	cmp.w	r5, #4294967295
 800d0a8:	d005      	beq.n	800d0b6 <xQueueReceiveFromISR+0x8a>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800d0aa:	1c6b      	adds	r3, r5, #1
 800d0ac:	b25b      	sxtb	r3, r3
 800d0ae:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
			xReturn = pdPASS;
 800d0b2:	2001      	movs	r0, #1
 800d0b4:	e7d3      	b.n	800d05e <xQueueReceiveFromISR+0x32>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800d0b6:	6923      	ldr	r3, [r4, #16]
 800d0b8:	b90b      	cbnz	r3, 800d0be <xQueueReceiveFromISR+0x92>
			xReturn = pdPASS;
 800d0ba:	2001      	movs	r0, #1
 800d0bc:	e7cf      	b.n	800d05e <xQueueReceiveFromISR+0x32>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800d0be:	f104 0010 	add.w	r0, r4, #16
 800d0c2:	f001 f811 	bl	800e0e8 <xTaskRemoveFromEventList>
 800d0c6:	b118      	cbz	r0, 800d0d0 <xQueueReceiveFromISR+0xa4>
						if( pxHigherPriorityTaskWoken != NULL )
 800d0c8:	b127      	cbz	r7, 800d0d4 <xQueueReceiveFromISR+0xa8>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800d0ca:	2001      	movs	r0, #1
 800d0cc:	6038      	str	r0, [r7, #0]
 800d0ce:	e7c6      	b.n	800d05e <xQueueReceiveFromISR+0x32>
			xReturn = pdPASS;
 800d0d0:	2001      	movs	r0, #1
 800d0d2:	e7c4      	b.n	800d05e <xQueueReceiveFromISR+0x32>
 800d0d4:	2001      	movs	r0, #1
 800d0d6:	e7c2      	b.n	800d05e <xQueueReceiveFromISR+0x32>

0800d0d8 <xQueuePeekFromISR>:
{
 800d0d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxQueue );
 800d0da:	b168      	cbz	r0, 800d0f8 <xQueuePeekFromISR+0x20>
 800d0dc:	460d      	mov	r5, r1
 800d0de:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800d0e0:	b199      	cbz	r1, 800d10a <xQueuePeekFromISR+0x32>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 800d0e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d0e4:	b9eb      	cbnz	r3, 800d122 <xQueuePeekFromISR+0x4a>
 800d0e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d0ea:	f383 8811 	msr	BASEPRI, r3
 800d0ee:	f3bf 8f6f 	isb	sy
 800d0f2:	f3bf 8f4f 	dsb	sy
 800d0f6:	e7fe      	b.n	800d0f6 <xQueuePeekFromISR+0x1e>
 800d0f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d0fc:	f383 8811 	msr	BASEPRI, r3
 800d100:	f3bf 8f6f 	isb	sy
 800d104:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800d108:	e7fe      	b.n	800d108 <xQueuePeekFromISR+0x30>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800d10a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800d10c:	2b00      	cmp	r3, #0
 800d10e:	d0e8      	beq.n	800d0e2 <xQueuePeekFromISR+0xa>
 800d110:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d114:	f383 8811 	msr	BASEPRI, r3
 800d118:	f3bf 8f6f 	isb	sy
 800d11c:	f3bf 8f4f 	dsb	sy
 800d120:	e7fe      	b.n	800d120 <xQueuePeekFromISR+0x48>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800d122:	f002 f945 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800d126:	f3ef 8611 	mrs	r6, BASEPRI
 800d12a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d12e:	f383 8811 	msr	BASEPRI, r3
 800d132:	f3bf 8f6f 	isb	sy
 800d136:	f3bf 8f4f 	dsb	sy
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 800d13a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d13c:	b91b      	cbnz	r3, 800d146 <xQueuePeekFromISR+0x6e>
			xReturn = pdFAIL;
 800d13e:	2000      	movs	r0, #0
	__asm volatile
 800d140:	f386 8811 	msr	BASEPRI, r6
}
 800d144:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800d146:	68e7      	ldr	r7, [r4, #12]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800d148:	4629      	mov	r1, r5
 800d14a:	4620      	mov	r0, r4
 800d14c:	f7ff f9e9 	bl	800c522 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800d150:	60e7      	str	r7, [r4, #12]
			xReturn = pdPASS;
 800d152:	2001      	movs	r0, #1
 800d154:	e7f4      	b.n	800d140 <xQueuePeekFromISR+0x68>

0800d156 <uxQueueMessagesWaiting>:
	configASSERT( xQueue );
 800d156:	b140      	cbz	r0, 800d16a <uxQueueMessagesWaiting+0x14>
{
 800d158:	b510      	push	{r4, lr}
 800d15a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800d15c:	f002 f83c 	bl	800f1d8 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 800d160:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 800d162:	f002 f85b 	bl	800f21c <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 800d166:	4620      	mov	r0, r4
 800d168:	bd10      	pop	{r4, pc}
	__asm volatile
 800d16a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d16e:	f383 8811 	msr	BASEPRI, r3
 800d172:	f3bf 8f6f 	isb	sy
 800d176:	f3bf 8f4f 	dsb	sy
	configASSERT( xQueue );
 800d17a:	e7fe      	b.n	800d17a <uxQueueMessagesWaiting+0x24>

0800d17c <uxQueueSpacesAvailable>:
{
 800d17c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 800d17e:	b148      	cbz	r0, 800d194 <uxQueueSpacesAvailable+0x18>
 800d180:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 800d182:	f002 f829 	bl	800f1d8 <vPortEnterCritical>
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 800d186:	6bec      	ldr	r4, [r5, #60]	; 0x3c
 800d188:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800d18a:	1ae4      	subs	r4, r4, r3
	taskEXIT_CRITICAL();
 800d18c:	f002 f846 	bl	800f21c <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 800d190:	4620      	mov	r0, r4
 800d192:	bd38      	pop	{r3, r4, r5, pc}
 800d194:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d198:	f383 8811 	msr	BASEPRI, r3
 800d19c:	f3bf 8f6f 	isb	sy
 800d1a0:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800d1a4:	e7fe      	b.n	800d1a4 <uxQueueSpacesAvailable+0x28>

0800d1a6 <uxQueueMessagesWaitingFromISR>:
	configASSERT( xQueue );
 800d1a6:	b108      	cbz	r0, 800d1ac <uxQueueMessagesWaitingFromISR+0x6>
	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 800d1a8:	6b80      	ldr	r0, [r0, #56]	; 0x38
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 800d1aa:	4770      	bx	lr
 800d1ac:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d1b0:	f383 8811 	msr	BASEPRI, r3
 800d1b4:	f3bf 8f6f 	isb	sy
 800d1b8:	f3bf 8f4f 	dsb	sy
	configASSERT( xQueue );
 800d1bc:	e7fe      	b.n	800d1bc <uxQueueMessagesWaitingFromISR+0x16>

0800d1be <uxQueueGetQueueNumber>:
	}
 800d1be:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800d1c0:	4770      	bx	lr

0800d1c2 <vQueueSetQueueNumber>:
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 800d1c2:	6481      	str	r1, [r0, #72]	; 0x48
	}
 800d1c4:	4770      	bx	lr

0800d1c6 <ucQueueGetQueueType>:
	}
 800d1c6:	f890 004c 	ldrb.w	r0, [r0, #76]	; 0x4c
 800d1ca:	4770      	bx	lr

0800d1cc <xQueueIsQueueEmptyFromISR>:
	configASSERT( xQueue );
 800d1cc:	b118      	cbz	r0, 800d1d6 <xQueueIsQueueEmptyFromISR+0xa>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 800d1ce:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800d1d0:	b953      	cbnz	r3, 800d1e8 <xQueueIsQueueEmptyFromISR+0x1c>
		xReturn = pdTRUE;
 800d1d2:	2001      	movs	r0, #1
 800d1d4:	4770      	bx	lr
 800d1d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d1da:	f383 8811 	msr	BASEPRI, r3
 800d1de:	f3bf 8f6f 	isb	sy
 800d1e2:	f3bf 8f4f 	dsb	sy
	configASSERT( xQueue );
 800d1e6:	e7fe      	b.n	800d1e6 <xQueueIsQueueEmptyFromISR+0x1a>
		xReturn = pdFALSE;
 800d1e8:	2000      	movs	r0, #0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800d1ea:	4770      	bx	lr

0800d1ec <xQueueIsQueueFullFromISR>:

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
 800d1ec:	b128      	cbz	r0, 800d1fa <xQueueIsQueueFullFromISR+0xe>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 800d1ee:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800d1f0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800d1f2:	429a      	cmp	r2, r3
 800d1f4:	d00a      	beq.n	800d20c <xQueueIsQueueFullFromISR+0x20>
	{
		xReturn = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
 800d1f6:	2000      	movs	r0, #0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800d1f8:	4770      	bx	lr
 800d1fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d1fe:	f383 8811 	msr	BASEPRI, r3
 800d202:	f3bf 8f6f 	isb	sy
 800d206:	f3bf 8f4f 	dsb	sy
	configASSERT( xQueue );
 800d20a:	e7fe      	b.n	800d20a <xQueueIsQueueFullFromISR+0x1e>
		xReturn = pdTRUE;
 800d20c:	2001      	movs	r0, #1
 800d20e:	4770      	bx	lr

0800d210 <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800d210:	2300      	movs	r3, #0
 800d212:	e000      	b.n	800d216 <vQueueAddToRegistry+0x6>
 800d214:	3301      	adds	r3, #1
 800d216:	2b07      	cmp	r3, #7
 800d218:	d80b      	bhi.n	800d232 <vQueueAddToRegistry+0x22>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800d21a:	4a06      	ldr	r2, [pc, #24]	; (800d234 <vQueueAddToRegistry+0x24>)
 800d21c:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 800d220:	2a00      	cmp	r2, #0
 800d222:	d1f7      	bne.n	800d214 <vQueueAddToRegistry+0x4>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 800d224:	4a03      	ldr	r2, [pc, #12]	; (800d234 <vQueueAddToRegistry+0x24>)
 800d226:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 800d22a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800d22e:	6058      	str	r0, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 800d230:	4770      	bx	lr
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 800d232:	4770      	bx	lr
 800d234:	20004550 	.word	0x20004550

0800d238 <pcQueueGetName>:
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800d238:	2300      	movs	r3, #0
 800d23a:	e000      	b.n	800d23e <pcQueueGetName+0x6>
 800d23c:	3301      	adds	r3, #1
 800d23e:	2b07      	cmp	r3, #7
 800d240:	d809      	bhi.n	800d256 <pcQueueGetName+0x1e>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 800d242:	4a06      	ldr	r2, [pc, #24]	; (800d25c <pcQueueGetName+0x24>)
 800d244:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800d248:	6852      	ldr	r2, [r2, #4]
 800d24a:	4282      	cmp	r2, r0
 800d24c:	d1f6      	bne.n	800d23c <pcQueueGetName+0x4>
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 800d24e:	4a03      	ldr	r2, [pc, #12]	; (800d25c <pcQueueGetName+0x24>)
 800d250:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
				break;
 800d254:	4770      	bx	lr
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 800d256:	2000      	movs	r0, #0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 800d258:	4770      	bx	lr
 800d25a:	bf00      	nop
 800d25c:	20004550 	.word	0x20004550

0800d260 <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800d260:	2300      	movs	r3, #0
 800d262:	e000      	b.n	800d266 <vQueueUnregisterQueue+0x6>
 800d264:	3301      	adds	r3, #1
 800d266:	2b07      	cmp	r3, #7
 800d268:	d80d      	bhi.n	800d286 <vQueueUnregisterQueue+0x26>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 800d26a:	4a07      	ldr	r2, [pc, #28]	; (800d288 <vQueueUnregisterQueue+0x28>)
 800d26c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800d270:	6852      	ldr	r2, [r2, #4]
 800d272:	4282      	cmp	r2, r0
 800d274:	d1f6      	bne.n	800d264 <vQueueUnregisterQueue+0x4>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 800d276:	4a04      	ldr	r2, [pc, #16]	; (800d288 <vQueueUnregisterQueue+0x28>)
 800d278:	2100      	movs	r1, #0
 800d27a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 800d27e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800d282:	6059      	str	r1, [r3, #4]
				break;
 800d284:	4770      	bx	lr
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800d286:	4770      	bx	lr
 800d288:	20004550 	.word	0x20004550

0800d28c <vQueueDelete>:
	configASSERT( pxQueue );
 800d28c:	b138      	cbz	r0, 800d29e <vQueueDelete+0x12>
{
 800d28e:	b510      	push	{r4, lr}
 800d290:	4604      	mov	r4, r0
		vQueueUnregisterQueue( pxQueue );
 800d292:	f7ff ffe5 	bl	800d260 <vQueueUnregisterQueue>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 800d296:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800d29a:	b14b      	cbz	r3, 800d2b0 <vQueueDelete+0x24>
}
 800d29c:	bd10      	pop	{r4, pc}
 800d29e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d2a2:	f383 8811 	msr	BASEPRI, r3
 800d2a6:	f3bf 8f6f 	isb	sy
 800d2aa:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800d2ae:	e7fe      	b.n	800d2ae <vQueueDelete+0x22>
			vPortFree( pxQueue );
 800d2b0:	4620      	mov	r0, r4
 800d2b2:	f002 f98d 	bl	800f5d0 <vPortFree>
}
 800d2b6:	e7f1      	b.n	800d29c <vQueueDelete+0x10>

0800d2b8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800d2b8:	b570      	push	{r4, r5, r6, lr}
 800d2ba:	4604      	mov	r4, r0
 800d2bc:	460d      	mov	r5, r1
 800d2be:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800d2c0:	f001 ff8a 	bl	800f1d8 <vPortEnterCritical>
 800d2c4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800d2c8:	b25b      	sxtb	r3, r3
 800d2ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d2ce:	d00d      	beq.n	800d2ec <vQueueWaitForMessageRestricted+0x34>
 800d2d0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800d2d4:	b25b      	sxtb	r3, r3
 800d2d6:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d2da:	d00b      	beq.n	800d2f4 <vQueueWaitForMessageRestricted+0x3c>
 800d2dc:	f001 ff9e 	bl	800f21c <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800d2e0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d2e2:	b15b      	cbz	r3, 800d2fc <vQueueWaitForMessageRestricted+0x44>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 800d2e4:	4620      	mov	r0, r4
 800d2e6:	f7ff f92e 	bl	800c546 <prvUnlockQueue>
	}
 800d2ea:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
 800d2ec:	2300      	movs	r3, #0
 800d2ee:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800d2f2:	e7ed      	b.n	800d2d0 <vQueueWaitForMessageRestricted+0x18>
 800d2f4:	2300      	movs	r3, #0
 800d2f6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800d2fa:	e7ef      	b.n	800d2dc <vQueueWaitForMessageRestricted+0x24>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 800d2fc:	4632      	mov	r2, r6
 800d2fe:	4629      	mov	r1, r5
 800d300:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800d304:	f000 fed4 	bl	800e0b0 <vTaskPlaceOnEventListRestricted>
 800d308:	e7ec      	b.n	800d2e4 <vQueueWaitForMessageRestricted+0x2c>
 800d30a:	bf00      	nop

0800d30c <prvTaskIsTaskSuspended>:

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
 800d30c:	b128      	cbz	r0, 800d31a <prvTaskIsTaskSuspended+0xe>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 800d30e:	6941      	ldr	r1, [r0, #20]
 800d310:	4a0c      	ldr	r2, [pc, #48]	; (800d344 <prvTaskIsTaskSuspended+0x38>)
 800d312:	4291      	cmp	r1, r2
 800d314:	d00a      	beq.n	800d32c <prvTaskIsTaskSuspended+0x20>
	BaseType_t xReturn = pdFALSE;
 800d316:	2000      	movs	r0, #0
 800d318:	4770      	bx	lr
 800d31a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d31e:	f383 8811 	msr	BASEPRI, r3
 800d322:	f3bf 8f6f 	isb	sy
 800d326:	f3bf 8f4f 	dsb	sy
		configASSERT( xTask );
 800d32a:	e7fe      	b.n	800d32a <prvTaskIsTaskSuspended+0x1e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 800d32c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800d32e:	4a06      	ldr	r2, [pc, #24]	; (800d348 <prvTaskIsTaskSuspended+0x3c>)
 800d330:	4293      	cmp	r3, r2
 800d332:	d002      	beq.n	800d33a <prvTaskIsTaskSuspended+0x2e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 800d334:	b11b      	cbz	r3, 800d33e <prvTaskIsTaskSuspended+0x32>
	BaseType_t xReturn = pdFALSE;
 800d336:	2000      	movs	r0, #0
 800d338:	4770      	bx	lr
 800d33a:	2000      	movs	r0, #0
 800d33c:	4770      	bx	lr
				{
					xReturn = pdTRUE;
 800d33e:	2001      	movs	r0, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 800d340:	4770      	bx	lr
 800d342:	bf00      	nop
 800d344:	20000904 	.word	0x20000904
 800d348:	200008ec 	.word	0x200008ec

0800d34c <prvTaskCheckFreeStackSpace>:

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;
 800d34c:	2300      	movs	r3, #0

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800d34e:	7802      	ldrb	r2, [r0, #0]
 800d350:	2aa5      	cmp	r2, #165	; 0xa5
 800d352:	d102      	bne.n	800d35a <prvTaskCheckFreeStackSpace+0xe>
		{
			pucStackByte -= portSTACK_GROWTH;
 800d354:	3001      	adds	r0, #1
			ulCount++;
 800d356:	3301      	adds	r3, #1
 800d358:	e7f9      	b.n	800d34e <prvTaskCheckFreeStackSpace+0x2>
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

		return ( uint16_t ) ulCount;
	}
 800d35a:	f3c3 008f 	ubfx	r0, r3, #2, #16
 800d35e:	4770      	bx	lr

0800d360 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800d360:	4b08      	ldr	r3, [pc, #32]	; (800d384 <prvResetNextTaskUnblockTime+0x24>)
 800d362:	681b      	ldr	r3, [r3, #0]
 800d364:	681b      	ldr	r3, [r3, #0]
 800d366:	b923      	cbnz	r3, 800d372 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800d368:	4b07      	ldr	r3, [pc, #28]	; (800d388 <prvResetNextTaskUnblockTime+0x28>)
 800d36a:	f04f 32ff 	mov.w	r2, #4294967295
 800d36e:	601a      	str	r2, [r3, #0]
 800d370:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800d372:	4b04      	ldr	r3, [pc, #16]	; (800d384 <prvResetNextTaskUnblockTime+0x24>)
 800d374:	681b      	ldr	r3, [r3, #0]
 800d376:	68db      	ldr	r3, [r3, #12]
 800d378:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800d37a:	685a      	ldr	r2, [r3, #4]
 800d37c:	4b02      	ldr	r3, [pc, #8]	; (800d388 <prvResetNextTaskUnblockTime+0x28>)
 800d37e:	601a      	str	r2, [r3, #0]
	}
}
 800d380:	4770      	bx	lr
 800d382:	bf00      	nop
 800d384:	2000043c 	.word	0x2000043c
 800d388:	200008e4 	.word	0x200008e4

0800d38c <prvInitialiseNewTask>:
{
 800d38c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d390:	4680      	mov	r8, r0
 800d392:	460d      	mov	r5, r1
 800d394:	4617      	mov	r7, r2
 800d396:	4699      	mov	r9, r3
 800d398:	9e08      	ldr	r6, [sp, #32]
 800d39a:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 800d39e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800d3a0:	0092      	lsls	r2, r2, #2
 800d3a2:	21a5      	movs	r1, #165	; 0xa5
 800d3a4:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800d3a6:	f002 fb81 	bl	800faac <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800d3aa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800d3ac:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
 800d3b0:	3a01      	subs	r2, #1
 800d3b2:	eb03 0782 	add.w	r7, r3, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800d3b6:	f027 0707 	bic.w	r7, r7, #7
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800d3ba:	2200      	movs	r2, #0
 800d3bc:	2a1f      	cmp	r2, #31
 800d3be:	d807      	bhi.n	800d3d0 <prvInitialiseNewTask+0x44>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800d3c0:	5ca9      	ldrb	r1, [r5, r2]
 800d3c2:	18a3      	adds	r3, r4, r2
 800d3c4:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
 800d3c8:	5cab      	ldrb	r3, [r5, r2]
 800d3ca:	b10b      	cbz	r3, 800d3d0 <prvInitialiseNewTask+0x44>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800d3cc:	3201      	adds	r2, #1
 800d3ce:	e7f5      	b.n	800d3bc <prvInitialiseNewTask+0x30>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800d3d0:	2300      	movs	r3, #0
 800d3d2:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 800d3d6:	2e37      	cmp	r6, #55	; 0x37
 800d3d8:	d900      	bls.n	800d3dc <prvInitialiseNewTask+0x50>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 800d3da:	2637      	movs	r6, #55	; 0x37
	pxNewTCB->uxPriority = uxPriority;
 800d3dc:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 800d3de:	65e6      	str	r6, [r4, #92]	; 0x5c
		pxNewTCB->uxMutexesHeld = 0;
 800d3e0:	2500      	movs	r5, #0
 800d3e2:	6625      	str	r5, [r4, #96]	; 0x60
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800d3e4:	1d20      	adds	r0, r4, #4
 800d3e6:	f7ff f802 	bl	800c3ee <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800d3ea:	f104 0018 	add.w	r0, r4, #24
 800d3ee:	f7fe fffe 	bl	800c3ee <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800d3f2:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800d3f4:	f1c6 0638 	rsb	r6, r6, #56	; 0x38
 800d3f8:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800d3fa:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 800d3fc:	6665      	str	r5, [r4, #100]	; 0x64
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800d3fe:	f884 5068 	strb.w	r5, [r4, #104]	; 0x68
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800d402:	464a      	mov	r2, r9
 800d404:	4641      	mov	r1, r8
 800d406:	4638      	mov	r0, r7
 800d408:	f001 feaf 	bl	800f16a <pxPortInitialiseStack>
 800d40c:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800d40e:	f1ba 0f00 	cmp.w	sl, #0
 800d412:	d001      	beq.n	800d418 <prvInitialiseNewTask+0x8c>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800d414:	f8ca 4000 	str.w	r4, [sl]
}
 800d418:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800d41c <prvInitialiseTaskLists>:
{
 800d41c:	b538      	push	{r3, r4, r5, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800d41e:	2400      	movs	r4, #0
 800d420:	2c37      	cmp	r4, #55	; 0x37
 800d422:	d808      	bhi.n	800d436 <prvInitialiseTaskLists+0x1a>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800d424:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 800d428:	0093      	lsls	r3, r2, #2
 800d42a:	480e      	ldr	r0, [pc, #56]	; (800d464 <prvInitialiseTaskLists+0x48>)
 800d42c:	4418      	add	r0, r3
 800d42e:	f7fe ffd3 	bl	800c3d8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800d432:	3401      	adds	r4, #1
 800d434:	e7f4      	b.n	800d420 <prvInitialiseTaskLists+0x4>
	vListInitialise( &xDelayedTaskList1 );
 800d436:	4d0c      	ldr	r5, [pc, #48]	; (800d468 <prvInitialiseTaskLists+0x4c>)
 800d438:	4628      	mov	r0, r5
 800d43a:	f7fe ffcd 	bl	800c3d8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800d43e:	4c0b      	ldr	r4, [pc, #44]	; (800d46c <prvInitialiseTaskLists+0x50>)
 800d440:	4620      	mov	r0, r4
 800d442:	f7fe ffc9 	bl	800c3d8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800d446:	480a      	ldr	r0, [pc, #40]	; (800d470 <prvInitialiseTaskLists+0x54>)
 800d448:	f7fe ffc6 	bl	800c3d8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 800d44c:	4809      	ldr	r0, [pc, #36]	; (800d474 <prvInitialiseTaskLists+0x58>)
 800d44e:	f7fe ffc3 	bl	800c3d8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800d452:	4809      	ldr	r0, [pc, #36]	; (800d478 <prvInitialiseTaskLists+0x5c>)
 800d454:	f7fe ffc0 	bl	800c3d8 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 800d458:	4b08      	ldr	r3, [pc, #32]	; (800d47c <prvInitialiseTaskLists+0x60>)
 800d45a:	601d      	str	r5, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800d45c:	4b08      	ldr	r3, [pc, #32]	; (800d480 <prvInitialiseTaskLists+0x64>)
 800d45e:	601c      	str	r4, [r3, #0]
}
 800d460:	bd38      	pop	{r3, r4, r5, pc}
 800d462:	bf00      	nop
 800d464:	20000444 	.word	0x20000444
 800d468:	200008bc 	.word	0x200008bc
 800d46c:	200008d0 	.word	0x200008d0
 800d470:	200008ec 	.word	0x200008ec
 800d474:	20000918 	.word	0x20000918
 800d478:	20000904 	.word	0x20000904
 800d47c:	2000043c 	.word	0x2000043c
 800d480:	20000440 	.word	0x20000440

0800d484 <prvAddNewTaskToReadyList>:
{
 800d484:	b510      	push	{r4, lr}
 800d486:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800d488:	f001 fea6 	bl	800f1d8 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800d48c:	4a21      	ldr	r2, [pc, #132]	; (800d514 <prvAddNewTaskToReadyList+0x90>)
 800d48e:	6813      	ldr	r3, [r2, #0]
 800d490:	3301      	adds	r3, #1
 800d492:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 800d494:	4b20      	ldr	r3, [pc, #128]	; (800d518 <prvAddNewTaskToReadyList+0x94>)
 800d496:	681b      	ldr	r3, [r3, #0]
 800d498:	b15b      	cbz	r3, 800d4b2 <prvAddNewTaskToReadyList+0x2e>
			if( xSchedulerRunning == pdFALSE )
 800d49a:	4b20      	ldr	r3, [pc, #128]	; (800d51c <prvAddNewTaskToReadyList+0x98>)
 800d49c:	681b      	ldr	r3, [r3, #0]
 800d49e:	b96b      	cbnz	r3, 800d4bc <prvAddNewTaskToReadyList+0x38>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800d4a0:	4b1d      	ldr	r3, [pc, #116]	; (800d518 <prvAddNewTaskToReadyList+0x94>)
 800d4a2:	681b      	ldr	r3, [r3, #0]
 800d4a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d4a6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800d4a8:	429a      	cmp	r2, r3
 800d4aa:	d807      	bhi.n	800d4bc <prvAddNewTaskToReadyList+0x38>
					pxCurrentTCB = pxNewTCB;
 800d4ac:	4b1a      	ldr	r3, [pc, #104]	; (800d518 <prvAddNewTaskToReadyList+0x94>)
 800d4ae:	601c      	str	r4, [r3, #0]
 800d4b0:	e004      	b.n	800d4bc <prvAddNewTaskToReadyList+0x38>
			pxCurrentTCB = pxNewTCB;
 800d4b2:	4b19      	ldr	r3, [pc, #100]	; (800d518 <prvAddNewTaskToReadyList+0x94>)
 800d4b4:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800d4b6:	6813      	ldr	r3, [r2, #0]
 800d4b8:	2b01      	cmp	r3, #1
 800d4ba:	d027      	beq.n	800d50c <prvAddNewTaskToReadyList+0x88>
		uxTaskNumber++;
 800d4bc:	4a18      	ldr	r2, [pc, #96]	; (800d520 <prvAddNewTaskToReadyList+0x9c>)
 800d4be:	6813      	ldr	r3, [r2, #0]
 800d4c0:	3301      	adds	r3, #1
 800d4c2:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 800d4c4:	6563      	str	r3, [r4, #84]	; 0x54
		prvAddTaskToReadyList( pxNewTCB );
 800d4c6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800d4c8:	4b16      	ldr	r3, [pc, #88]	; (800d524 <prvAddNewTaskToReadyList+0xa0>)
 800d4ca:	681b      	ldr	r3, [r3, #0]
 800d4cc:	4298      	cmp	r0, r3
 800d4ce:	d901      	bls.n	800d4d4 <prvAddNewTaskToReadyList+0x50>
 800d4d0:	4b14      	ldr	r3, [pc, #80]	; (800d524 <prvAddNewTaskToReadyList+0xa0>)
 800d4d2:	6018      	str	r0, [r3, #0]
 800d4d4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800d4d8:	1d21      	adds	r1, r4, #4
 800d4da:	4b13      	ldr	r3, [pc, #76]	; (800d528 <prvAddNewTaskToReadyList+0xa4>)
 800d4dc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800d4e0:	f7fe ff88 	bl	800c3f4 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800d4e4:	f001 fe9a 	bl	800f21c <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800d4e8:	4b0c      	ldr	r3, [pc, #48]	; (800d51c <prvAddNewTaskToReadyList+0x98>)
 800d4ea:	681b      	ldr	r3, [r3, #0]
 800d4ec:	b16b      	cbz	r3, 800d50a <prvAddNewTaskToReadyList+0x86>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800d4ee:	4b0a      	ldr	r3, [pc, #40]	; (800d518 <prvAddNewTaskToReadyList+0x94>)
 800d4f0:	681b      	ldr	r3, [r3, #0]
 800d4f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d4f4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800d4f6:	429a      	cmp	r2, r3
 800d4f8:	d207      	bcs.n	800d50a <prvAddNewTaskToReadyList+0x86>
			taskYIELD_IF_USING_PREEMPTION();
 800d4fa:	4b0c      	ldr	r3, [pc, #48]	; (800d52c <prvAddNewTaskToReadyList+0xa8>)
 800d4fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d500:	601a      	str	r2, [r3, #0]
 800d502:	f3bf 8f4f 	dsb	sy
 800d506:	f3bf 8f6f 	isb	sy
}
 800d50a:	bd10      	pop	{r4, pc}
				prvInitialiseTaskLists();
 800d50c:	f7ff ff86 	bl	800d41c <prvInitialiseTaskLists>
 800d510:	e7d4      	b.n	800d4bc <prvAddNewTaskToReadyList+0x38>
 800d512:	bf00      	nop
 800d514:	200008a4 	.word	0x200008a4
 800d518:	20000438 	.word	0x20000438
 800d51c:	20000900 	.word	0x20000900
 800d520:	200008b4 	.word	0x200008b4
 800d524:	200008b8 	.word	0x200008b8
 800d528:	20000444 	.word	0x20000444
 800d52c:	e000ed04 	.word	0xe000ed04

0800d530 <prvDeleteTCB>:
	{
 800d530:	b510      	push	{r4, lr}
 800d532:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800d534:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
 800d538:	b163      	cbz	r3, 800d554 <prvDeleteTCB+0x24>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800d53a:	2b01      	cmp	r3, #1
 800d53c:	d011      	beq.n	800d562 <prvDeleteTCB+0x32>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 800d53e:	2b02      	cmp	r3, #2
 800d540:	d00e      	beq.n	800d560 <prvDeleteTCB+0x30>
 800d542:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d546:	f383 8811 	msr	BASEPRI, r3
 800d54a:	f3bf 8f6f 	isb	sy
 800d54e:	f3bf 8f4f 	dsb	sy
 800d552:	e7fe      	b.n	800d552 <prvDeleteTCB+0x22>
				vPortFree( pxTCB->pxStack );
 800d554:	6b00      	ldr	r0, [r0, #48]	; 0x30
 800d556:	f002 f83b 	bl	800f5d0 <vPortFree>
				vPortFree( pxTCB );
 800d55a:	4620      	mov	r0, r4
 800d55c:	f002 f838 	bl	800f5d0 <vPortFree>
	}
 800d560:	bd10      	pop	{r4, pc}
				vPortFree( pxTCB );
 800d562:	f002 f835 	bl	800f5d0 <vPortFree>
 800d566:	e7fb      	b.n	800d560 <prvDeleteTCB+0x30>

0800d568 <prvCheckTasksWaitingTermination>:
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800d568:	4b0f      	ldr	r3, [pc, #60]	; (800d5a8 <prvCheckTasksWaitingTermination+0x40>)
 800d56a:	681b      	ldr	r3, [r3, #0]
 800d56c:	b1d3      	cbz	r3, 800d5a4 <prvCheckTasksWaitingTermination+0x3c>
{
 800d56e:	b510      	push	{r4, lr}
			taskENTER_CRITICAL();
 800d570:	f001 fe32 	bl	800f1d8 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800d574:	4b0d      	ldr	r3, [pc, #52]	; (800d5ac <prvCheckTasksWaitingTermination+0x44>)
 800d576:	68db      	ldr	r3, [r3, #12]
 800d578:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800d57a:	1d20      	adds	r0, r4, #4
 800d57c:	f7fe ff5e 	bl	800c43c <uxListRemove>
				--uxCurrentNumberOfTasks;
 800d580:	4a0b      	ldr	r2, [pc, #44]	; (800d5b0 <prvCheckTasksWaitingTermination+0x48>)
 800d582:	6813      	ldr	r3, [r2, #0]
 800d584:	3b01      	subs	r3, #1
 800d586:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 800d588:	4a07      	ldr	r2, [pc, #28]	; (800d5a8 <prvCheckTasksWaitingTermination+0x40>)
 800d58a:	6813      	ldr	r3, [r2, #0]
 800d58c:	3b01      	subs	r3, #1
 800d58e:	6013      	str	r3, [r2, #0]
			taskEXIT_CRITICAL();
 800d590:	f001 fe44 	bl	800f21c <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 800d594:	4620      	mov	r0, r4
 800d596:	f7ff ffcb 	bl	800d530 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800d59a:	4b03      	ldr	r3, [pc, #12]	; (800d5a8 <prvCheckTasksWaitingTermination+0x40>)
 800d59c:	681b      	ldr	r3, [r3, #0]
 800d59e:	2b00      	cmp	r3, #0
 800d5a0:	d1e6      	bne.n	800d570 <prvCheckTasksWaitingTermination+0x8>
}
 800d5a2:	bd10      	pop	{r4, pc}
 800d5a4:	4770      	bx	lr
 800d5a6:	bf00      	nop
 800d5a8:	200008a8 	.word	0x200008a8
 800d5ac:	20000918 	.word	0x20000918
 800d5b0:	200008a4 	.word	0x200008a4

0800d5b4 <prvIdleTask>:
{
 800d5b4:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 800d5b6:	f7ff ffd7 	bl	800d568 <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800d5ba:	4b06      	ldr	r3, [pc, #24]	; (800d5d4 <prvIdleTask+0x20>)
 800d5bc:	681b      	ldr	r3, [r3, #0]
 800d5be:	2b01      	cmp	r3, #1
 800d5c0:	d9f9      	bls.n	800d5b6 <prvIdleTask+0x2>
				taskYIELD();
 800d5c2:	4b05      	ldr	r3, [pc, #20]	; (800d5d8 <prvIdleTask+0x24>)
 800d5c4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d5c8:	601a      	str	r2, [r3, #0]
 800d5ca:	f3bf 8f4f 	dsb	sy
 800d5ce:	f3bf 8f6f 	isb	sy
 800d5d2:	e7f0      	b.n	800d5b6 <prvIdleTask+0x2>
 800d5d4:	20000444 	.word	0x20000444
 800d5d8:	e000ed04 	.word	0xe000ed04

0800d5dc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800d5dc:	b570      	push	{r4, r5, r6, lr}
 800d5de:	4604      	mov	r4, r0
 800d5e0:	460d      	mov	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800d5e2:	4b17      	ldr	r3, [pc, #92]	; (800d640 <prvAddCurrentTaskToDelayedList+0x64>)
 800d5e4:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800d5e6:	4b17      	ldr	r3, [pc, #92]	; (800d644 <prvAddCurrentTaskToDelayedList+0x68>)
 800d5e8:	6818      	ldr	r0, [r3, #0]
 800d5ea:	3004      	adds	r0, #4
 800d5ec:	f7fe ff26 	bl	800c43c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800d5f0:	f1b4 3fff 	cmp.w	r4, #4294967295
 800d5f4:	d00d      	beq.n	800d612 <prvAddCurrentTaskToDelayedList+0x36>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 800d5f6:	4434      	add	r4, r6

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800d5f8:	4b12      	ldr	r3, [pc, #72]	; (800d644 <prvAddCurrentTaskToDelayedList+0x68>)
 800d5fa:	681b      	ldr	r3, [r3, #0]
 800d5fc:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 800d5fe:	42a6      	cmp	r6, r4
 800d600:	d910      	bls.n	800d624 <prvAddCurrentTaskToDelayedList+0x48>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800d602:	4b11      	ldr	r3, [pc, #68]	; (800d648 <prvAddCurrentTaskToDelayedList+0x6c>)
 800d604:	6818      	ldr	r0, [r3, #0]
 800d606:	4b0f      	ldr	r3, [pc, #60]	; (800d644 <prvAddCurrentTaskToDelayedList+0x68>)
 800d608:	6819      	ldr	r1, [r3, #0]
 800d60a:	3104      	adds	r1, #4
 800d60c:	f7fe fefd 	bl	800c40a <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800d610:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800d612:	2d00      	cmp	r5, #0
 800d614:	d0ef      	beq.n	800d5f6 <prvAddCurrentTaskToDelayedList+0x1a>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800d616:	4b0b      	ldr	r3, [pc, #44]	; (800d644 <prvAddCurrentTaskToDelayedList+0x68>)
 800d618:	6819      	ldr	r1, [r3, #0]
 800d61a:	3104      	adds	r1, #4
 800d61c:	480b      	ldr	r0, [pc, #44]	; (800d64c <prvAddCurrentTaskToDelayedList+0x70>)
 800d61e:	f7fe fee9 	bl	800c3f4 <vListInsertEnd>
 800d622:	e7f5      	b.n	800d610 <prvAddCurrentTaskToDelayedList+0x34>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800d624:	4b0a      	ldr	r3, [pc, #40]	; (800d650 <prvAddCurrentTaskToDelayedList+0x74>)
 800d626:	6818      	ldr	r0, [r3, #0]
 800d628:	4b06      	ldr	r3, [pc, #24]	; (800d644 <prvAddCurrentTaskToDelayedList+0x68>)
 800d62a:	6819      	ldr	r1, [r3, #0]
 800d62c:	3104      	adds	r1, #4
 800d62e:	f7fe feec 	bl	800c40a <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800d632:	4b08      	ldr	r3, [pc, #32]	; (800d654 <prvAddCurrentTaskToDelayedList+0x78>)
 800d634:	681b      	ldr	r3, [r3, #0]
 800d636:	42a3      	cmp	r3, r4
 800d638:	d9ea      	bls.n	800d610 <prvAddCurrentTaskToDelayedList+0x34>
					xNextTaskUnblockTime = xTimeToWake;
 800d63a:	4b06      	ldr	r3, [pc, #24]	; (800d654 <prvAddCurrentTaskToDelayedList+0x78>)
 800d63c:	601c      	str	r4, [r3, #0]
}
 800d63e:	e7e7      	b.n	800d610 <prvAddCurrentTaskToDelayedList+0x34>
 800d640:	2000092c 	.word	0x2000092c
 800d644:	20000438 	.word	0x20000438
 800d648:	20000440 	.word	0x20000440
 800d64c:	20000904 	.word	0x20000904
 800d650:	2000043c 	.word	0x2000043c
 800d654:	200008e4 	.word	0x200008e4

0800d658 <xTaskCreateStatic>:
	{
 800d658:	b570      	push	{r4, r5, r6, lr}
 800d65a:	b086      	sub	sp, #24
 800d65c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800d65e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		configASSERT( puxStackBuffer != NULL );
 800d660:	b175      	cbz	r5, 800d680 <xTaskCreateStatic+0x28>
		configASSERT( pxTaskBuffer != NULL );
 800d662:	b1b4      	cbz	r4, 800d692 <xTaskCreateStatic+0x3a>
			volatile size_t xSize = sizeof( StaticTask_t );
 800d664:	266c      	movs	r6, #108	; 0x6c
 800d666:	9604      	str	r6, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 800d668:	9e04      	ldr	r6, [sp, #16]
 800d66a:	2e6c      	cmp	r6, #108	; 0x6c
 800d66c:	d01a      	beq.n	800d6a4 <xTaskCreateStatic+0x4c>
 800d66e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d672:	f383 8811 	msr	BASEPRI, r3
 800d676:	f3bf 8f6f 	isb	sy
 800d67a:	f3bf 8f4f 	dsb	sy
 800d67e:	e7fe      	b.n	800d67e <xTaskCreateStatic+0x26>
 800d680:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d684:	f383 8811 	msr	BASEPRI, r3
 800d688:	f3bf 8f6f 	isb	sy
 800d68c:	f3bf 8f4f 	dsb	sy
		configASSERT( puxStackBuffer != NULL );
 800d690:	e7fe      	b.n	800d690 <xTaskCreateStatic+0x38>
 800d692:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d696:	f383 8811 	msr	BASEPRI, r3
 800d69a:	f3bf 8f6f 	isb	sy
 800d69e:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 800d6a2:	e7fe      	b.n	800d6a2 <xTaskCreateStatic+0x4a>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800d6a4:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800d6a6:	2502      	movs	r5, #2
 800d6a8:	f884 5069 	strb.w	r5, [r4, #105]	; 0x69
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800d6ac:	2500      	movs	r5, #0
 800d6ae:	9503      	str	r5, [sp, #12]
 800d6b0:	9402      	str	r4, [sp, #8]
 800d6b2:	ad05      	add	r5, sp, #20
 800d6b4:	9501      	str	r5, [sp, #4]
 800d6b6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800d6b8:	9500      	str	r5, [sp, #0]
 800d6ba:	f7ff fe67 	bl	800d38c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800d6be:	4620      	mov	r0, r4
 800d6c0:	f7ff fee0 	bl	800d484 <prvAddNewTaskToReadyList>
	}
 800d6c4:	9805      	ldr	r0, [sp, #20]
 800d6c6:	b006      	add	sp, #24
 800d6c8:	bd70      	pop	{r4, r5, r6, pc}

0800d6ca <xTaskCreate>:
	{
 800d6ca:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d6ce:	b085      	sub	sp, #20
 800d6d0:	4607      	mov	r7, r0
 800d6d2:	4688      	mov	r8, r1
 800d6d4:	4614      	mov	r4, r2
 800d6d6:	461e      	mov	r6, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800d6d8:	0090      	lsls	r0, r2, #2
 800d6da:	f001 fef7 	bl	800f4cc <pvPortMalloc>
			if( pxStack != NULL )
 800d6de:	b300      	cbz	r0, 800d722 <xTaskCreate+0x58>
 800d6e0:	4681      	mov	r9, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800d6e2:	206c      	movs	r0, #108	; 0x6c
 800d6e4:	f001 fef2 	bl	800f4cc <pvPortMalloc>
				if( pxNewTCB != NULL )
 800d6e8:	4605      	mov	r5, r0
 800d6ea:	b1b0      	cbz	r0, 800d71a <xTaskCreate+0x50>
					pxNewTCB->pxStack = pxStack;
 800d6ec:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
 800d6f0:	b1e5      	cbz	r5, 800d72c <xTaskCreate+0x62>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800d6f2:	2300      	movs	r3, #0
 800d6f4:	f885 3069 	strb.w	r3, [r5, #105]	; 0x69
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800d6f8:	9303      	str	r3, [sp, #12]
 800d6fa:	9502      	str	r5, [sp, #8]
 800d6fc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d6fe:	9301      	str	r3, [sp, #4]
 800d700:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d702:	9300      	str	r3, [sp, #0]
 800d704:	4633      	mov	r3, r6
 800d706:	4622      	mov	r2, r4
 800d708:	4641      	mov	r1, r8
 800d70a:	4638      	mov	r0, r7
 800d70c:	f7ff fe3e 	bl	800d38c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800d710:	4628      	mov	r0, r5
 800d712:	f7ff feb7 	bl	800d484 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 800d716:	2001      	movs	r0, #1
 800d718:	e005      	b.n	800d726 <xTaskCreate+0x5c>
					vPortFree( pxStack );
 800d71a:	4648      	mov	r0, r9
 800d71c:	f001 ff58 	bl	800f5d0 <vPortFree>
 800d720:	e7e6      	b.n	800d6f0 <xTaskCreate+0x26>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800d722:	f04f 30ff 	mov.w	r0, #4294967295
	}
 800d726:	b005      	add	sp, #20
 800d728:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800d72c:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 800d730:	e7f9      	b.n	800d726 <xTaskCreate+0x5c>

0800d732 <vTaskDelete>:
	{
 800d732:	b538      	push	{r3, r4, r5, lr}
 800d734:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 800d736:	f001 fd4f 	bl	800f1d8 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800d73a:	b324      	cbz	r4, 800d786 <vTaskDelete+0x54>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800d73c:	1d25      	adds	r5, r4, #4
 800d73e:	4628      	mov	r0, r5
 800d740:	f7fe fe7c 	bl	800c43c <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800d744:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800d746:	b11b      	cbz	r3, 800d750 <vTaskDelete+0x1e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800d748:	f104 0018 	add.w	r0, r4, #24
 800d74c:	f7fe fe76 	bl	800c43c <uxListRemove>
			uxTaskNumber++;
 800d750:	4a1d      	ldr	r2, [pc, #116]	; (800d7c8 <vTaskDelete+0x96>)
 800d752:	6813      	ldr	r3, [r2, #0]
 800d754:	3301      	adds	r3, #1
 800d756:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 800d758:	4b1c      	ldr	r3, [pc, #112]	; (800d7cc <vTaskDelete+0x9a>)
 800d75a:	681b      	ldr	r3, [r3, #0]
 800d75c:	42a3      	cmp	r3, r4
 800d75e:	d015      	beq.n	800d78c <vTaskDelete+0x5a>
				--uxCurrentNumberOfTasks;
 800d760:	4a1b      	ldr	r2, [pc, #108]	; (800d7d0 <vTaskDelete+0x9e>)
 800d762:	6813      	ldr	r3, [r2, #0]
 800d764:	3b01      	subs	r3, #1
 800d766:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 800d768:	4620      	mov	r0, r4
 800d76a:	f7ff fee1 	bl	800d530 <prvDeleteTCB>
				prvResetNextTaskUnblockTime();
 800d76e:	f7ff fdf7 	bl	800d360 <prvResetNextTaskUnblockTime>
		taskEXIT_CRITICAL();
 800d772:	f001 fd53 	bl	800f21c <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800d776:	4b17      	ldr	r3, [pc, #92]	; (800d7d4 <vTaskDelete+0xa2>)
 800d778:	681b      	ldr	r3, [r3, #0]
 800d77a:	b11b      	cbz	r3, 800d784 <vTaskDelete+0x52>
			if( pxTCB == pxCurrentTCB )
 800d77c:	4b13      	ldr	r3, [pc, #76]	; (800d7cc <vTaskDelete+0x9a>)
 800d77e:	681b      	ldr	r3, [r3, #0]
 800d780:	42a3      	cmp	r3, r4
 800d782:	d00c      	beq.n	800d79e <vTaskDelete+0x6c>
	}
 800d784:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800d786:	4b11      	ldr	r3, [pc, #68]	; (800d7cc <vTaskDelete+0x9a>)
 800d788:	681c      	ldr	r4, [r3, #0]
 800d78a:	e7d7      	b.n	800d73c <vTaskDelete+0xa>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 800d78c:	4629      	mov	r1, r5
 800d78e:	4812      	ldr	r0, [pc, #72]	; (800d7d8 <vTaskDelete+0xa6>)
 800d790:	f7fe fe30 	bl	800c3f4 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 800d794:	4a11      	ldr	r2, [pc, #68]	; (800d7dc <vTaskDelete+0xaa>)
 800d796:	6813      	ldr	r3, [r2, #0]
 800d798:	3301      	adds	r3, #1
 800d79a:	6013      	str	r3, [r2, #0]
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 800d79c:	e7e9      	b.n	800d772 <vTaskDelete+0x40>
				configASSERT( uxSchedulerSuspended == 0 );
 800d79e:	4b10      	ldr	r3, [pc, #64]	; (800d7e0 <vTaskDelete+0xae>)
 800d7a0:	681b      	ldr	r3, [r3, #0]
 800d7a2:	b143      	cbz	r3, 800d7b6 <vTaskDelete+0x84>
 800d7a4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d7a8:	f383 8811 	msr	BASEPRI, r3
 800d7ac:	f3bf 8f6f 	isb	sy
 800d7b0:	f3bf 8f4f 	dsb	sy
 800d7b4:	e7fe      	b.n	800d7b4 <vTaskDelete+0x82>
				portYIELD_WITHIN_API();
 800d7b6:	4b0b      	ldr	r3, [pc, #44]	; (800d7e4 <vTaskDelete+0xb2>)
 800d7b8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d7bc:	601a      	str	r2, [r3, #0]
 800d7be:	f3bf 8f4f 	dsb	sy
 800d7c2:	f3bf 8f6f 	isb	sy
	}
 800d7c6:	e7dd      	b.n	800d784 <vTaskDelete+0x52>
 800d7c8:	200008b4 	.word	0x200008b4
 800d7cc:	20000438 	.word	0x20000438
 800d7d0:	200008a4 	.word	0x200008a4
 800d7d4:	20000900 	.word	0x20000900
 800d7d8:	20000918 	.word	0x20000918
 800d7dc:	200008a8 	.word	0x200008a8
 800d7e0:	200008b0 	.word	0x200008b0
 800d7e4:	e000ed04 	.word	0xe000ed04

0800d7e8 <eTaskGetState>:
	{
 800d7e8:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxTCB );
 800d7ea:	b1d0      	cbz	r0, 800d822 <eTaskGetState+0x3a>
 800d7ec:	4605      	mov	r5, r0
		if( pxTCB == pxCurrentTCB )
 800d7ee:	4b19      	ldr	r3, [pc, #100]	; (800d854 <eTaskGetState+0x6c>)
 800d7f0:	681b      	ldr	r3, [r3, #0]
 800d7f2:	4283      	cmp	r3, r0
 800d7f4:	d026      	beq.n	800d844 <eTaskGetState+0x5c>
			taskENTER_CRITICAL();
 800d7f6:	f001 fcef 	bl	800f1d8 <vPortEnterCritical>
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 800d7fa:	696c      	ldr	r4, [r5, #20]
			taskEXIT_CRITICAL();
 800d7fc:	f001 fd0e 	bl	800f21c <vPortExitCritical>
			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 800d800:	4b15      	ldr	r3, [pc, #84]	; (800d858 <eTaskGetState+0x70>)
 800d802:	681b      	ldr	r3, [r3, #0]
 800d804:	42a3      	cmp	r3, r4
 800d806:	d01f      	beq.n	800d848 <eTaskGetState+0x60>
 800d808:	4b14      	ldr	r3, [pc, #80]	; (800d85c <eTaskGetState+0x74>)
 800d80a:	681b      	ldr	r3, [r3, #0]
 800d80c:	42a3      	cmp	r3, r4
 800d80e:	d01d      	beq.n	800d84c <eTaskGetState+0x64>
				else if( pxStateList == &xSuspendedTaskList )
 800d810:	4b13      	ldr	r3, [pc, #76]	; (800d860 <eTaskGetState+0x78>)
 800d812:	429c      	cmp	r4, r3
 800d814:	d00e      	beq.n	800d834 <eTaskGetState+0x4c>
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 800d816:	4b13      	ldr	r3, [pc, #76]	; (800d864 <eTaskGetState+0x7c>)
 800d818:	429c      	cmp	r4, r3
 800d81a:	d019      	beq.n	800d850 <eTaskGetState+0x68>
 800d81c:	b184      	cbz	r4, 800d840 <eTaskGetState+0x58>
				eReturn = eReady;
 800d81e:	2001      	movs	r0, #1
 800d820:	e011      	b.n	800d846 <eTaskGetState+0x5e>
 800d822:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d826:	f383 8811 	msr	BASEPRI, r3
 800d82a:	f3bf 8f6f 	isb	sy
 800d82e:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTCB );
 800d832:	e7fe      	b.n	800d832 <eTaskGetState+0x4a>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 800d834:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800d836:	b10b      	cbz	r3, 800d83c <eTaskGetState+0x54>
						eReturn = eBlocked;
 800d838:	2002      	movs	r0, #2
 800d83a:	e004      	b.n	800d846 <eTaskGetState+0x5e>
						eReturn = eSuspended;
 800d83c:	2003      	movs	r0, #3
 800d83e:	e002      	b.n	800d846 <eTaskGetState+0x5e>
					eReturn = eDeleted;
 800d840:	2004      	movs	r0, #4
 800d842:	e000      	b.n	800d846 <eTaskGetState+0x5e>
			eReturn = eRunning;
 800d844:	2000      	movs	r0, #0
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 800d846:	bd38      	pop	{r3, r4, r5, pc}
				eReturn = eBlocked;
 800d848:	2002      	movs	r0, #2
 800d84a:	e7fc      	b.n	800d846 <eTaskGetState+0x5e>
 800d84c:	2002      	movs	r0, #2
 800d84e:	e7fa      	b.n	800d846 <eTaskGetState+0x5e>
					eReturn = eDeleted;
 800d850:	2004      	movs	r0, #4
 800d852:	e7f8      	b.n	800d846 <eTaskGetState+0x5e>
 800d854:	20000438 	.word	0x20000438
 800d858:	2000043c 	.word	0x2000043c
 800d85c:	20000440 	.word	0x20000440
 800d860:	20000904 	.word	0x20000904
 800d864:	20000918 	.word	0x20000918

0800d868 <uxTaskPriorityGet>:
	{
 800d868:	b510      	push	{r4, lr}
 800d86a:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 800d86c:	f001 fcb4 	bl	800f1d8 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 800d870:	b124      	cbz	r4, 800d87c <uxTaskPriorityGet+0x14>
			uxReturn = pxTCB->uxPriority;
 800d872:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		taskEXIT_CRITICAL();
 800d874:	f001 fcd2 	bl	800f21c <vPortExitCritical>
	}
 800d878:	4620      	mov	r0, r4
 800d87a:	bd10      	pop	{r4, pc}
			pxTCB = prvGetTCBFromHandle( xTask );
 800d87c:	4b01      	ldr	r3, [pc, #4]	; (800d884 <uxTaskPriorityGet+0x1c>)
 800d87e:	681c      	ldr	r4, [r3, #0]
 800d880:	e7f7      	b.n	800d872 <uxTaskPriorityGet+0xa>
 800d882:	bf00      	nop
 800d884:	20000438 	.word	0x20000438

0800d888 <uxTaskPriorityGetFromISR>:
	{
 800d888:	b510      	push	{r4, lr}
 800d88a:	4604      	mov	r4, r0
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800d88c:	f001 fd90 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800d890:	f3ef 8311 	mrs	r3, BASEPRI
 800d894:	f04f 0250 	mov.w	r2, #80	; 0x50
 800d898:	f382 8811 	msr	BASEPRI, r2
 800d89c:	f3bf 8f6f 	isb	sy
 800d8a0:	f3bf 8f4f 	dsb	sy
			pxTCB = prvGetTCBFromHandle( xTask );
 800d8a4:	b11c      	cbz	r4, 800d8ae <uxTaskPriorityGetFromISR+0x26>
			uxReturn = pxTCB->uxPriority;
 800d8a6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	__asm volatile
 800d8a8:	f383 8811 	msr	BASEPRI, r3
	}
 800d8ac:	bd10      	pop	{r4, pc}
			pxTCB = prvGetTCBFromHandle( xTask );
 800d8ae:	4a01      	ldr	r2, [pc, #4]	; (800d8b4 <uxTaskPriorityGetFromISR+0x2c>)
 800d8b0:	6814      	ldr	r4, [r2, #0]
 800d8b2:	e7f8      	b.n	800d8a6 <uxTaskPriorityGetFromISR+0x1e>
 800d8b4:	20000438 	.word	0x20000438

0800d8b8 <vTaskPrioritySet>:
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 800d8b8:	2937      	cmp	r1, #55	; 0x37
 800d8ba:	d908      	bls.n	800d8ce <vTaskPrioritySet+0x16>
	__asm volatile
 800d8bc:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d8c0:	f383 8811 	msr	BASEPRI, r3
 800d8c4:	f3bf 8f6f 	isb	sy
 800d8c8:	f3bf 8f4f 	dsb	sy
 800d8cc:	e7fe      	b.n	800d8cc <vTaskPrioritySet+0x14>
	{
 800d8ce:	b570      	push	{r4, r5, r6, lr}
 800d8d0:	4604      	mov	r4, r0
 800d8d2:	460d      	mov	r5, r1
		taskENTER_CRITICAL();
 800d8d4:	f001 fc80 	bl	800f1d8 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 800d8d8:	b174      	cbz	r4, 800d8f8 <vTaskPrioritySet+0x40>
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 800d8da:	6de2      	ldr	r2, [r4, #92]	; 0x5c
			if( uxCurrentBasePriority != uxNewPriority )
 800d8dc:	4295      	cmp	r5, r2
 800d8de:	d02e      	beq.n	800d93e <vTaskPrioritySet+0x86>
				if( uxNewPriority > uxCurrentBasePriority )
 800d8e0:	d90d      	bls.n	800d8fe <vTaskPrioritySet+0x46>
					if( pxTCB != pxCurrentTCB )
 800d8e2:	4b26      	ldr	r3, [pc, #152]	; (800d97c <vTaskPrioritySet+0xc4>)
 800d8e4:	681b      	ldr	r3, [r3, #0]
 800d8e6:	42a3      	cmp	r3, r4
 800d8e8:	d02c      	beq.n	800d944 <vTaskPrioritySet+0x8c>
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 800d8ea:	4b24      	ldr	r3, [pc, #144]	; (800d97c <vTaskPrioritySet+0xc4>)
 800d8ec:	681b      	ldr	r3, [r3, #0]
 800d8ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d8f0:	42ab      	cmp	r3, r5
 800d8f2:	d929      	bls.n	800d948 <vTaskPrioritySet+0x90>
	BaseType_t xYieldRequired = pdFALSE;
 800d8f4:	2600      	movs	r6, #0
 800d8f6:	e007      	b.n	800d908 <vTaskPrioritySet+0x50>
			pxTCB = prvGetTCBFromHandle( xTask );
 800d8f8:	4b20      	ldr	r3, [pc, #128]	; (800d97c <vTaskPrioritySet+0xc4>)
 800d8fa:	681c      	ldr	r4, [r3, #0]
 800d8fc:	e7ed      	b.n	800d8da <vTaskPrioritySet+0x22>
				else if( pxTCB == pxCurrentTCB )
 800d8fe:	4b1f      	ldr	r3, [pc, #124]	; (800d97c <vTaskPrioritySet+0xc4>)
 800d900:	681b      	ldr	r3, [r3, #0]
 800d902:	42a3      	cmp	r3, r4
 800d904:	d022      	beq.n	800d94c <vTaskPrioritySet+0x94>
	BaseType_t xYieldRequired = pdFALSE;
 800d906:	2600      	movs	r6, #0
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 800d908:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 800d90a:	429a      	cmp	r2, r3
 800d90c:	d020      	beq.n	800d950 <vTaskPrioritySet+0x98>
					pxTCB->uxBasePriority = uxNewPriority;
 800d90e:	65e5      	str	r5, [r4, #92]	; 0x5c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800d910:	69a2      	ldr	r2, [r4, #24]
 800d912:	2a00      	cmp	r2, #0
 800d914:	db02      	blt.n	800d91c <vTaskPrioritySet+0x64>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800d916:	f1c5 0538 	rsb	r5, r5, #56	; 0x38
 800d91a:	61a5      	str	r5, [r4, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800d91c:	6961      	ldr	r1, [r4, #20]
 800d91e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800d922:	4a17      	ldr	r2, [pc, #92]	; (800d980 <vTaskPrioritySet+0xc8>)
 800d924:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800d928:	4299      	cmp	r1, r3
 800d92a:	d013      	beq.n	800d954 <vTaskPrioritySet+0x9c>
				if( xYieldRequired != pdFALSE )
 800d92c:	b13e      	cbz	r6, 800d93e <vTaskPrioritySet+0x86>
					taskYIELD_IF_USING_PREEMPTION();
 800d92e:	4b15      	ldr	r3, [pc, #84]	; (800d984 <vTaskPrioritySet+0xcc>)
 800d930:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d934:	601a      	str	r2, [r3, #0]
 800d936:	f3bf 8f4f 	dsb	sy
 800d93a:	f3bf 8f6f 	isb	sy
		taskEXIT_CRITICAL();
 800d93e:	f001 fc6d 	bl	800f21c <vPortExitCritical>
	}
 800d942:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xYieldRequired = pdFALSE;
 800d944:	2600      	movs	r6, #0
 800d946:	e7df      	b.n	800d908 <vTaskPrioritySet+0x50>
							xYieldRequired = pdTRUE;
 800d948:	2601      	movs	r6, #1
 800d94a:	e7dd      	b.n	800d908 <vTaskPrioritySet+0x50>
					xYieldRequired = pdTRUE;
 800d94c:	2601      	movs	r6, #1
 800d94e:	e7db      	b.n	800d908 <vTaskPrioritySet+0x50>
						pxTCB->uxPriority = uxNewPriority;
 800d950:	62e5      	str	r5, [r4, #44]	; 0x2c
 800d952:	e7dc      	b.n	800d90e <vTaskPrioritySet+0x56>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800d954:	1d25      	adds	r5, r4, #4
 800d956:	4628      	mov	r0, r5
 800d958:	f7fe fd70 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800d95c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800d95e:	4b0a      	ldr	r3, [pc, #40]	; (800d988 <vTaskPrioritySet+0xd0>)
 800d960:	681b      	ldr	r3, [r3, #0]
 800d962:	4298      	cmp	r0, r3
 800d964:	d901      	bls.n	800d96a <vTaskPrioritySet+0xb2>
 800d966:	4b08      	ldr	r3, [pc, #32]	; (800d988 <vTaskPrioritySet+0xd0>)
 800d968:	6018      	str	r0, [r3, #0]
 800d96a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800d96e:	4629      	mov	r1, r5
 800d970:	4b03      	ldr	r3, [pc, #12]	; (800d980 <vTaskPrioritySet+0xc8>)
 800d972:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800d976:	f7fe fd3d 	bl	800c3f4 <vListInsertEnd>
 800d97a:	e7d7      	b.n	800d92c <vTaskPrioritySet+0x74>
 800d97c:	20000438 	.word	0x20000438
 800d980:	20000444 	.word	0x20000444
 800d984:	e000ed04 	.word	0xe000ed04
 800d988:	200008b8 	.word	0x200008b8

0800d98c <vTaskResume>:
	{
 800d98c:	b538      	push	{r3, r4, r5, lr}
		configASSERT( xTaskToResume );
 800d98e:	b168      	cbz	r0, 800d9ac <vTaskResume+0x20>
 800d990:	4604      	mov	r4, r0
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 800d992:	4b1c      	ldr	r3, [pc, #112]	; (800da04 <vTaskResume+0x78>)
 800d994:	681b      	ldr	r3, [r3, #0]
 800d996:	4283      	cmp	r3, r0
 800d998:	d007      	beq.n	800d9aa <vTaskResume+0x1e>
			taskENTER_CRITICAL();
 800d99a:	f001 fc1d 	bl	800f1d8 <vPortEnterCritical>
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 800d99e:	4620      	mov	r0, r4
 800d9a0:	f7ff fcb4 	bl	800d30c <prvTaskIsTaskSuspended>
 800d9a4:	b958      	cbnz	r0, 800d9be <vTaskResume+0x32>
			taskEXIT_CRITICAL();
 800d9a6:	f001 fc39 	bl	800f21c <vPortExitCritical>
	}
 800d9aa:	bd38      	pop	{r3, r4, r5, pc}
 800d9ac:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d9b0:	f383 8811 	msr	BASEPRI, r3
 800d9b4:	f3bf 8f6f 	isb	sy
 800d9b8:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToResume );
 800d9bc:	e7fe      	b.n	800d9bc <vTaskResume+0x30>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 800d9be:	1d25      	adds	r5, r4, #4
 800d9c0:	4628      	mov	r0, r5
 800d9c2:	f7fe fd3b 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800d9c6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800d9c8:	4b0f      	ldr	r3, [pc, #60]	; (800da08 <vTaskResume+0x7c>)
 800d9ca:	681b      	ldr	r3, [r3, #0]
 800d9cc:	4298      	cmp	r0, r3
 800d9ce:	d901      	bls.n	800d9d4 <vTaskResume+0x48>
 800d9d0:	4b0d      	ldr	r3, [pc, #52]	; (800da08 <vTaskResume+0x7c>)
 800d9d2:	6018      	str	r0, [r3, #0]
 800d9d4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800d9d8:	4629      	mov	r1, r5
 800d9da:	4b0c      	ldr	r3, [pc, #48]	; (800da0c <vTaskResume+0x80>)
 800d9dc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800d9e0:	f7fe fd08 	bl	800c3f4 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800d9e4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800d9e6:	4b07      	ldr	r3, [pc, #28]	; (800da04 <vTaskResume+0x78>)
 800d9e8:	681b      	ldr	r3, [r3, #0]
 800d9ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d9ec:	429a      	cmp	r2, r3
 800d9ee:	d3da      	bcc.n	800d9a6 <vTaskResume+0x1a>
						taskYIELD_IF_USING_PREEMPTION();
 800d9f0:	4b07      	ldr	r3, [pc, #28]	; (800da10 <vTaskResume+0x84>)
 800d9f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d9f6:	601a      	str	r2, [r3, #0]
 800d9f8:	f3bf 8f4f 	dsb	sy
 800d9fc:	f3bf 8f6f 	isb	sy
 800da00:	e7d1      	b.n	800d9a6 <vTaskResume+0x1a>
 800da02:	bf00      	nop
 800da04:	20000438 	.word	0x20000438
 800da08:	200008b8 	.word	0x200008b8
 800da0c:	20000444 	.word	0x20000444
 800da10:	e000ed04 	.word	0xe000ed04

0800da14 <xTaskResumeFromISR>:
	{
 800da14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( xTaskToResume );
 800da16:	2800      	cmp	r0, #0
 800da18:	d032      	beq.n	800da80 <xTaskResumeFromISR+0x6c>
 800da1a:	4604      	mov	r4, r0
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800da1c:	f001 fcc8 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800da20:	f3ef 8711 	mrs	r7, BASEPRI
 800da24:	f04f 0350 	mov.w	r3, #80	; 0x50
 800da28:	f383 8811 	msr	BASEPRI, r3
 800da2c:	f3bf 8f6f 	isb	sy
 800da30:	f3bf 8f4f 	dsb	sy
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 800da34:	4620      	mov	r0, r4
 800da36:	f7ff fc69 	bl	800d30c <prvTaskIsTaskSuspended>
 800da3a:	4605      	mov	r5, r0
 800da3c:	b1e0      	cbz	r0, 800da78 <xTaskResumeFromISR+0x64>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800da3e:	4b19      	ldr	r3, [pc, #100]	; (800daa4 <xTaskResumeFromISR+0x90>)
 800da40:	681b      	ldr	r3, [r3, #0]
 800da42:	bb43      	cbnz	r3, 800da96 <xTaskResumeFromISR+0x82>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800da44:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800da46:	4b18      	ldr	r3, [pc, #96]	; (800daa8 <xTaskResumeFromISR+0x94>)
 800da48:	681b      	ldr	r3, [r3, #0]
 800da4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800da4c:	429a      	cmp	r2, r3
 800da4e:	d220      	bcs.n	800da92 <xTaskResumeFromISR+0x7e>
	BaseType_t xYieldRequired = pdFALSE;
 800da50:	2500      	movs	r5, #0
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800da52:	1d26      	adds	r6, r4, #4
 800da54:	4630      	mov	r0, r6
 800da56:	f7fe fcf1 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800da5a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800da5c:	4b13      	ldr	r3, [pc, #76]	; (800daac <xTaskResumeFromISR+0x98>)
 800da5e:	681b      	ldr	r3, [r3, #0]
 800da60:	4298      	cmp	r0, r3
 800da62:	d901      	bls.n	800da68 <xTaskResumeFromISR+0x54>
 800da64:	4b11      	ldr	r3, [pc, #68]	; (800daac <xTaskResumeFromISR+0x98>)
 800da66:	6018      	str	r0, [r3, #0]
 800da68:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800da6c:	4631      	mov	r1, r6
 800da6e:	4b10      	ldr	r3, [pc, #64]	; (800dab0 <xTaskResumeFromISR+0x9c>)
 800da70:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800da74:	f7fe fcbe 	bl	800c3f4 <vListInsertEnd>
	__asm volatile
 800da78:	f387 8811 	msr	BASEPRI, r7
	}
 800da7c:	4628      	mov	r0, r5
 800da7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__asm volatile
 800da80:	f04f 0350 	mov.w	r3, #80	; 0x50
 800da84:	f383 8811 	msr	BASEPRI, r3
 800da88:	f3bf 8f6f 	isb	sy
 800da8c:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToResume );
 800da90:	e7fe      	b.n	800da90 <xTaskResumeFromISR+0x7c>
						xYieldRequired = pdTRUE;
 800da92:	2501      	movs	r5, #1
 800da94:	e7dd      	b.n	800da52 <xTaskResumeFromISR+0x3e>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800da96:	f104 0118 	add.w	r1, r4, #24
 800da9a:	4806      	ldr	r0, [pc, #24]	; (800dab4 <xTaskResumeFromISR+0xa0>)
 800da9c:	f7fe fcaa 	bl	800c3f4 <vListInsertEnd>
	BaseType_t xYieldRequired = pdFALSE;
 800daa0:	2500      	movs	r5, #0
 800daa2:	e7e9      	b.n	800da78 <xTaskResumeFromISR+0x64>
 800daa4:	200008b0 	.word	0x200008b0
 800daa8:	20000438 	.word	0x20000438
 800daac:	200008b8 	.word	0x200008b8
 800dab0:	20000444 	.word	0x20000444
 800dab4:	200008ec 	.word	0x200008ec

0800dab8 <vTaskStartScheduler>:
{
 800dab8:	b510      	push	{r4, lr}
 800daba:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 800dabc:	2400      	movs	r4, #0
 800dabe:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 800dac0:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800dac2:	aa07      	add	r2, sp, #28
 800dac4:	a906      	add	r1, sp, #24
 800dac6:	a805      	add	r0, sp, #20
 800dac8:	f7fe fa7d 	bl	800bfc6 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 800dacc:	9b05      	ldr	r3, [sp, #20]
 800dace:	9302      	str	r3, [sp, #8]
 800dad0:	9b06      	ldr	r3, [sp, #24]
 800dad2:	9301      	str	r3, [sp, #4]
 800dad4:	9400      	str	r4, [sp, #0]
 800dad6:	4623      	mov	r3, r4
 800dad8:	9a07      	ldr	r2, [sp, #28]
 800dada:	4917      	ldr	r1, [pc, #92]	; (800db38 <vTaskStartScheduler+0x80>)
 800dadc:	4817      	ldr	r0, [pc, #92]	; (800db3c <vTaskStartScheduler+0x84>)
 800dade:	f7ff fdbb 	bl	800d658 <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
 800dae2:	b148      	cbz	r0, 800daf8 <vTaskStartScheduler+0x40>
			xReturn = xTimerCreateTimerTask();
 800dae4:	f001 f880 	bl	800ebe8 <xTimerCreateTimerTask>
 800dae8:	4603      	mov	r3, r0
	if( xReturn == pdPASS )
 800daea:	2b01      	cmp	r3, #1
 800daec:	d006      	beq.n	800dafc <vTaskStartScheduler+0x44>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800daee:	f1b3 3fff 	cmp.w	r3, #4294967295
 800daf2:	d018      	beq.n	800db26 <vTaskStartScheduler+0x6e>
}
 800daf4:	b008      	add	sp, #32
 800daf6:	bd10      	pop	{r4, pc}
			xReturn = pdFAIL;
 800daf8:	2300      	movs	r3, #0
 800dafa:	e7f6      	b.n	800daea <vTaskStartScheduler+0x32>
 800dafc:	f04f 0350 	mov.w	r3, #80	; 0x50
 800db00:	f383 8811 	msr	BASEPRI, r3
 800db04:	f3bf 8f6f 	isb	sy
 800db08:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 800db0c:	4b0c      	ldr	r3, [pc, #48]	; (800db40 <vTaskStartScheduler+0x88>)
 800db0e:	f04f 32ff 	mov.w	r2, #4294967295
 800db12:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800db14:	4b0b      	ldr	r3, [pc, #44]	; (800db44 <vTaskStartScheduler+0x8c>)
 800db16:	2201      	movs	r2, #1
 800db18:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 800db1a:	4b0b      	ldr	r3, [pc, #44]	; (800db48 <vTaskStartScheduler+0x90>)
 800db1c:	2200      	movs	r2, #0
 800db1e:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 800db20:	f001 fbea 	bl	800f2f8 <xPortStartScheduler>
 800db24:	e7e6      	b.n	800daf4 <vTaskStartScheduler+0x3c>
 800db26:	f04f 0350 	mov.w	r3, #80	; 0x50
 800db2a:	f383 8811 	msr	BASEPRI, r3
 800db2e:	f3bf 8f6f 	isb	sy
 800db32:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800db36:	e7fe      	b.n	800db36 <vTaskStartScheduler+0x7e>
 800db38:	0800fea8 	.word	0x0800fea8
 800db3c:	0800d5b5 	.word	0x0800d5b5
 800db40:	200008e4 	.word	0x200008e4
 800db44:	20000900 	.word	0x20000900
 800db48:	2000092c 	.word	0x2000092c

0800db4c <vTaskEndScheduler>:
{
 800db4c:	b508      	push	{r3, lr}
 800db4e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800db52:	f383 8811 	msr	BASEPRI, r3
 800db56:	f3bf 8f6f 	isb	sy
 800db5a:	f3bf 8f4f 	dsb	sy
	xSchedulerRunning = pdFALSE;
 800db5e:	4b03      	ldr	r3, [pc, #12]	; (800db6c <vTaskEndScheduler+0x20>)
 800db60:	2200      	movs	r2, #0
 800db62:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
 800db64:	f001 fb26 	bl	800f1b4 <vPortEndScheduler>
}
 800db68:	bd08      	pop	{r3, pc}
 800db6a:	bf00      	nop
 800db6c:	20000900 	.word	0x20000900

0800db70 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800db70:	4a02      	ldr	r2, [pc, #8]	; (800db7c <vTaskSuspendAll+0xc>)
 800db72:	6813      	ldr	r3, [r2, #0]
 800db74:	3301      	adds	r3, #1
 800db76:	6013      	str	r3, [r2, #0]
}
 800db78:	4770      	bx	lr
 800db7a:	bf00      	nop
 800db7c:	200008b0 	.word	0x200008b0

0800db80 <xTaskGetTickCount>:
		xTicks = xTickCount;
 800db80:	4b01      	ldr	r3, [pc, #4]	; (800db88 <xTaskGetTickCount+0x8>)
 800db82:	6818      	ldr	r0, [r3, #0]
}
 800db84:	4770      	bx	lr
 800db86:	bf00      	nop
 800db88:	2000092c 	.word	0x2000092c

0800db8c <xTaskGetTickCountFromISR>:
{
 800db8c:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800db8e:	f001 fc0f 	bl	800f3b0 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800db92:	4b01      	ldr	r3, [pc, #4]	; (800db98 <xTaskGetTickCountFromISR+0xc>)
 800db94:	6818      	ldr	r0, [r3, #0]
}
 800db96:	bd08      	pop	{r3, pc}
 800db98:	2000092c 	.word	0x2000092c

0800db9c <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
 800db9c:	4b01      	ldr	r3, [pc, #4]	; (800dba4 <uxTaskGetNumberOfTasks+0x8>)
 800db9e:	6818      	ldr	r0, [r3, #0]
}
 800dba0:	4770      	bx	lr
 800dba2:	bf00      	nop
 800dba4:	200008a4 	.word	0x200008a4

0800dba8 <pcTaskGetName>:
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800dba8:	4603      	mov	r3, r0
 800dbaa:	b118      	cbz	r0, 800dbb4 <pcTaskGetName+0xc>
	configASSERT( pxTCB );
 800dbac:	b12b      	cbz	r3, 800dbba <pcTaskGetName+0x12>
}
 800dbae:	f103 0034 	add.w	r0, r3, #52	; 0x34
 800dbb2:	4770      	bx	lr
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800dbb4:	4b05      	ldr	r3, [pc, #20]	; (800dbcc <pcTaskGetName+0x24>)
 800dbb6:	681b      	ldr	r3, [r3, #0]
 800dbb8:	e7f8      	b.n	800dbac <pcTaskGetName+0x4>
 800dbba:	f04f 0350 	mov.w	r3, #80	; 0x50
 800dbbe:	f383 8811 	msr	BASEPRI, r3
 800dbc2:	f3bf 8f6f 	isb	sy
 800dbc6:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTCB );
 800dbca:	e7fe      	b.n	800dbca <pcTaskGetName+0x22>
 800dbcc:	20000438 	.word	0x20000438

0800dbd0 <xTaskIncrementTick>:
{
 800dbd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800dbd2:	4b3a      	ldr	r3, [pc, #232]	; (800dcbc <xTaskIncrementTick+0xec>)
 800dbd4:	681b      	ldr	r3, [r3, #0]
 800dbd6:	2b00      	cmp	r3, #0
 800dbd8:	d165      	bne.n	800dca6 <xTaskIncrementTick+0xd6>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800dbda:	4b39      	ldr	r3, [pc, #228]	; (800dcc0 <xTaskIncrementTick+0xf0>)
 800dbdc:	681d      	ldr	r5, [r3, #0]
 800dbde:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 800dbe0:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800dbe2:	b9c5      	cbnz	r5, 800dc16 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 800dbe4:	4b37      	ldr	r3, [pc, #220]	; (800dcc4 <xTaskIncrementTick+0xf4>)
 800dbe6:	681b      	ldr	r3, [r3, #0]
 800dbe8:	681b      	ldr	r3, [r3, #0]
 800dbea:	b143      	cbz	r3, 800dbfe <xTaskIncrementTick+0x2e>
 800dbec:	f04f 0350 	mov.w	r3, #80	; 0x50
 800dbf0:	f383 8811 	msr	BASEPRI, r3
 800dbf4:	f3bf 8f6f 	isb	sy
 800dbf8:	f3bf 8f4f 	dsb	sy
 800dbfc:	e7fe      	b.n	800dbfc <xTaskIncrementTick+0x2c>
 800dbfe:	4a31      	ldr	r2, [pc, #196]	; (800dcc4 <xTaskIncrementTick+0xf4>)
 800dc00:	6811      	ldr	r1, [r2, #0]
 800dc02:	4b31      	ldr	r3, [pc, #196]	; (800dcc8 <xTaskIncrementTick+0xf8>)
 800dc04:	6818      	ldr	r0, [r3, #0]
 800dc06:	6010      	str	r0, [r2, #0]
 800dc08:	6019      	str	r1, [r3, #0]
 800dc0a:	4a30      	ldr	r2, [pc, #192]	; (800dccc <xTaskIncrementTick+0xfc>)
 800dc0c:	6813      	ldr	r3, [r2, #0]
 800dc0e:	3301      	adds	r3, #1
 800dc10:	6013      	str	r3, [r2, #0]
 800dc12:	f7ff fba5 	bl	800d360 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800dc16:	4b2e      	ldr	r3, [pc, #184]	; (800dcd0 <xTaskIncrementTick+0x100>)
 800dc18:	681b      	ldr	r3, [r3, #0]
 800dc1a:	42ab      	cmp	r3, r5
 800dc1c:	d90c      	bls.n	800dc38 <xTaskIncrementTick+0x68>
BaseType_t xSwitchRequired = pdFALSE;
 800dc1e:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800dc20:	4b2c      	ldr	r3, [pc, #176]	; (800dcd4 <xTaskIncrementTick+0x104>)
 800dc22:	681b      	ldr	r3, [r3, #0]
 800dc24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dc26:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800dc2a:	009a      	lsls	r2, r3, #2
 800dc2c:	4b2a      	ldr	r3, [pc, #168]	; (800dcd8 <xTaskIncrementTick+0x108>)
 800dc2e:	589b      	ldr	r3, [r3, r2]
 800dc30:	2b01      	cmp	r3, #1
 800dc32:	d93d      	bls.n	800dcb0 <xTaskIncrementTick+0xe0>
				xSwitchRequired = pdTRUE;
 800dc34:	2401      	movs	r4, #1
 800dc36:	e03b      	b.n	800dcb0 <xTaskIncrementTick+0xe0>
BaseType_t xSwitchRequired = pdFALSE;
 800dc38:	2400      	movs	r4, #0
 800dc3a:	e016      	b.n	800dc6a <xTaskIncrementTick+0x9a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800dc3c:	4b24      	ldr	r3, [pc, #144]	; (800dcd0 <xTaskIncrementTick+0x100>)
 800dc3e:	f04f 32ff 	mov.w	r2, #4294967295
 800dc42:	601a      	str	r2, [r3, #0]
					break;
 800dc44:	e7ec      	b.n	800dc20 <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 800dc46:	4a22      	ldr	r2, [pc, #136]	; (800dcd0 <xTaskIncrementTick+0x100>)
 800dc48:	6013      	str	r3, [r2, #0]
						break;
 800dc4a:	e7e9      	b.n	800dc20 <xTaskIncrementTick+0x50>
					prvAddTaskToReadyList( pxTCB );
 800dc4c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800dc50:	009a      	lsls	r2, r3, #2
 800dc52:	4639      	mov	r1, r7
 800dc54:	4820      	ldr	r0, [pc, #128]	; (800dcd8 <xTaskIncrementTick+0x108>)
 800dc56:	4410      	add	r0, r2
 800dc58:	f7fe fbcc 	bl	800c3f4 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800dc5c:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800dc5e:	4b1d      	ldr	r3, [pc, #116]	; (800dcd4 <xTaskIncrementTick+0x104>)
 800dc60:	681b      	ldr	r3, [r3, #0]
 800dc62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dc64:	429a      	cmp	r2, r3
 800dc66:	d300      	bcc.n	800dc6a <xTaskIncrementTick+0x9a>
							xSwitchRequired = pdTRUE;
 800dc68:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800dc6a:	4b16      	ldr	r3, [pc, #88]	; (800dcc4 <xTaskIncrementTick+0xf4>)
 800dc6c:	681b      	ldr	r3, [r3, #0]
 800dc6e:	681b      	ldr	r3, [r3, #0]
 800dc70:	2b00      	cmp	r3, #0
 800dc72:	d0e3      	beq.n	800dc3c <xTaskIncrementTick+0x6c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800dc74:	4b13      	ldr	r3, [pc, #76]	; (800dcc4 <xTaskIncrementTick+0xf4>)
 800dc76:	681b      	ldr	r3, [r3, #0]
 800dc78:	68db      	ldr	r3, [r3, #12]
 800dc7a:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800dc7c:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
 800dc7e:	429d      	cmp	r5, r3
 800dc80:	d3e1      	bcc.n	800dc46 <xTaskIncrementTick+0x76>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800dc82:	1d37      	adds	r7, r6, #4
 800dc84:	4638      	mov	r0, r7
 800dc86:	f7fe fbd9 	bl	800c43c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800dc8a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800dc8c:	b11b      	cbz	r3, 800dc96 <xTaskIncrementTick+0xc6>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800dc8e:	f106 0018 	add.w	r0, r6, #24
 800dc92:	f7fe fbd3 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800dc96:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800dc98:	4a10      	ldr	r2, [pc, #64]	; (800dcdc <xTaskIncrementTick+0x10c>)
 800dc9a:	6812      	ldr	r2, [r2, #0]
 800dc9c:	4293      	cmp	r3, r2
 800dc9e:	d9d5      	bls.n	800dc4c <xTaskIncrementTick+0x7c>
 800dca0:	4a0e      	ldr	r2, [pc, #56]	; (800dcdc <xTaskIncrementTick+0x10c>)
 800dca2:	6013      	str	r3, [r2, #0]
 800dca4:	e7d2      	b.n	800dc4c <xTaskIncrementTick+0x7c>
		++uxPendedTicks;
 800dca6:	4a0e      	ldr	r2, [pc, #56]	; (800dce0 <xTaskIncrementTick+0x110>)
 800dca8:	6813      	ldr	r3, [r2, #0]
 800dcaa:	3301      	adds	r3, #1
 800dcac:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800dcae:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
 800dcb0:	4b0c      	ldr	r3, [pc, #48]	; (800dce4 <xTaskIncrementTick+0x114>)
 800dcb2:	681b      	ldr	r3, [r3, #0]
 800dcb4:	b103      	cbz	r3, 800dcb8 <xTaskIncrementTick+0xe8>
			xSwitchRequired = pdTRUE;
 800dcb6:	2401      	movs	r4, #1
}
 800dcb8:	4620      	mov	r0, r4
 800dcba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800dcbc:	200008b0 	.word	0x200008b0
 800dcc0:	2000092c 	.word	0x2000092c
 800dcc4:	2000043c 	.word	0x2000043c
 800dcc8:	20000440 	.word	0x20000440
 800dccc:	200008e8 	.word	0x200008e8
 800dcd0:	200008e4 	.word	0x200008e4
 800dcd4:	20000438 	.word	0x20000438
 800dcd8:	20000444 	.word	0x20000444
 800dcdc:	200008b8 	.word	0x200008b8
 800dce0:	200008ac 	.word	0x200008ac
 800dce4:	20000930 	.word	0x20000930

0800dce8 <xTaskResumeAll>:
{
 800dce8:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended );
 800dcea:	4b34      	ldr	r3, [pc, #208]	; (800ddbc <xTaskResumeAll+0xd4>)
 800dcec:	681b      	ldr	r3, [r3, #0]
 800dcee:	b943      	cbnz	r3, 800dd02 <xTaskResumeAll+0x1a>
 800dcf0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800dcf4:	f383 8811 	msr	BASEPRI, r3
 800dcf8:	f3bf 8f6f 	isb	sy
 800dcfc:	f3bf 8f4f 	dsb	sy
 800dd00:	e7fe      	b.n	800dd00 <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
 800dd02:	f001 fa69 	bl	800f1d8 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800dd06:	4b2d      	ldr	r3, [pc, #180]	; (800ddbc <xTaskResumeAll+0xd4>)
 800dd08:	681a      	ldr	r2, [r3, #0]
 800dd0a:	3a01      	subs	r2, #1
 800dd0c:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800dd0e:	681b      	ldr	r3, [r3, #0]
 800dd10:	2b00      	cmp	r3, #0
 800dd12:	d14d      	bne.n	800ddb0 <xTaskResumeAll+0xc8>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800dd14:	4b2a      	ldr	r3, [pc, #168]	; (800ddc0 <xTaskResumeAll+0xd8>)
 800dd16:	681b      	ldr	r3, [r3, #0]
 800dd18:	b90b      	cbnz	r3, 800dd1e <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 800dd1a:	2400      	movs	r4, #0
 800dd1c:	e049      	b.n	800ddb2 <xTaskResumeAll+0xca>
TCB_t *pxTCB = NULL;
 800dd1e:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800dd20:	4b28      	ldr	r3, [pc, #160]	; (800ddc4 <xTaskResumeAll+0xdc>)
 800dd22:	681b      	ldr	r3, [r3, #0]
 800dd24:	b31b      	cbz	r3, 800dd6e <xTaskResumeAll+0x86>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800dd26:	4b27      	ldr	r3, [pc, #156]	; (800ddc4 <xTaskResumeAll+0xdc>)
 800dd28:	68db      	ldr	r3, [r3, #12]
 800dd2a:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800dd2c:	f104 0018 	add.w	r0, r4, #24
 800dd30:	f7fe fb84 	bl	800c43c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800dd34:	1d25      	adds	r5, r4, #4
 800dd36:	4628      	mov	r0, r5
 800dd38:	f7fe fb80 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800dd3c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800dd3e:	4b22      	ldr	r3, [pc, #136]	; (800ddc8 <xTaskResumeAll+0xe0>)
 800dd40:	681b      	ldr	r3, [r3, #0]
 800dd42:	4298      	cmp	r0, r3
 800dd44:	d901      	bls.n	800dd4a <xTaskResumeAll+0x62>
 800dd46:	4b20      	ldr	r3, [pc, #128]	; (800ddc8 <xTaskResumeAll+0xe0>)
 800dd48:	6018      	str	r0, [r3, #0]
 800dd4a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800dd4e:	4629      	mov	r1, r5
 800dd50:	4b1e      	ldr	r3, [pc, #120]	; (800ddcc <xTaskResumeAll+0xe4>)
 800dd52:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800dd56:	f7fe fb4d 	bl	800c3f4 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800dd5a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800dd5c:	4b1c      	ldr	r3, [pc, #112]	; (800ddd0 <xTaskResumeAll+0xe8>)
 800dd5e:	681b      	ldr	r3, [r3, #0]
 800dd60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dd62:	429a      	cmp	r2, r3
 800dd64:	d3dc      	bcc.n	800dd20 <xTaskResumeAll+0x38>
						xYieldPending = pdTRUE;
 800dd66:	4b1b      	ldr	r3, [pc, #108]	; (800ddd4 <xTaskResumeAll+0xec>)
 800dd68:	2201      	movs	r2, #1
 800dd6a:	601a      	str	r2, [r3, #0]
 800dd6c:	e7d8      	b.n	800dd20 <xTaskResumeAll+0x38>
				if( pxTCB != NULL )
 800dd6e:	b10c      	cbz	r4, 800dd74 <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
 800dd70:	f7ff faf6 	bl	800d360 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800dd74:	4b18      	ldr	r3, [pc, #96]	; (800ddd8 <xTaskResumeAll+0xf0>)
 800dd76:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800dd78:	b974      	cbnz	r4, 800dd98 <xTaskResumeAll+0xb0>
				if( xYieldPending != pdFALSE )
 800dd7a:	4b16      	ldr	r3, [pc, #88]	; (800ddd4 <xTaskResumeAll+0xec>)
 800dd7c:	681c      	ldr	r4, [r3, #0]
 800dd7e:	b1c4      	cbz	r4, 800ddb2 <xTaskResumeAll+0xca>
					taskYIELD_IF_USING_PREEMPTION();
 800dd80:	4b16      	ldr	r3, [pc, #88]	; (800dddc <xTaskResumeAll+0xf4>)
 800dd82:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800dd86:	601a      	str	r2, [r3, #0]
 800dd88:	f3bf 8f4f 	dsb	sy
 800dd8c:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 800dd90:	2401      	movs	r4, #1
 800dd92:	e00e      	b.n	800ddb2 <xTaskResumeAll+0xca>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800dd94:	3c01      	subs	r4, #1
 800dd96:	d007      	beq.n	800dda8 <xTaskResumeAll+0xc0>
							if( xTaskIncrementTick() != pdFALSE )
 800dd98:	f7ff ff1a 	bl	800dbd0 <xTaskIncrementTick>
 800dd9c:	2800      	cmp	r0, #0
 800dd9e:	d0f9      	beq.n	800dd94 <xTaskResumeAll+0xac>
								xYieldPending = pdTRUE;
 800dda0:	4b0c      	ldr	r3, [pc, #48]	; (800ddd4 <xTaskResumeAll+0xec>)
 800dda2:	2201      	movs	r2, #1
 800dda4:	601a      	str	r2, [r3, #0]
 800dda6:	e7f5      	b.n	800dd94 <xTaskResumeAll+0xac>
						uxPendedTicks = 0;
 800dda8:	4b0b      	ldr	r3, [pc, #44]	; (800ddd8 <xTaskResumeAll+0xf0>)
 800ddaa:	2200      	movs	r2, #0
 800ddac:	601a      	str	r2, [r3, #0]
 800ddae:	e7e4      	b.n	800dd7a <xTaskResumeAll+0x92>
BaseType_t xAlreadyYielded = pdFALSE;
 800ddb0:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800ddb2:	f001 fa33 	bl	800f21c <vPortExitCritical>
}
 800ddb6:	4620      	mov	r0, r4
 800ddb8:	bd38      	pop	{r3, r4, r5, pc}
 800ddba:	bf00      	nop
 800ddbc:	200008b0 	.word	0x200008b0
 800ddc0:	200008a4 	.word	0x200008a4
 800ddc4:	200008ec 	.word	0x200008ec
 800ddc8:	200008b8 	.word	0x200008b8
 800ddcc:	20000444 	.word	0x20000444
 800ddd0:	20000438 	.word	0x20000438
 800ddd4:	20000930 	.word	0x20000930
 800ddd8:	200008ac 	.word	0x200008ac
 800dddc:	e000ed04 	.word	0xe000ed04

0800dde0 <vTaskDelayUntil>:
	{
 800dde0:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxPreviousWakeTime );
 800dde2:	b158      	cbz	r0, 800ddfc <vTaskDelayUntil+0x1c>
 800dde4:	460c      	mov	r4, r1
 800dde6:	4605      	mov	r5, r0
		configASSERT( ( xTimeIncrement > 0U ) );
 800dde8:	b989      	cbnz	r1, 800de0e <vTaskDelayUntil+0x2e>
 800ddea:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ddee:	f383 8811 	msr	BASEPRI, r3
 800ddf2:	f3bf 8f6f 	isb	sy
 800ddf6:	f3bf 8f4f 	dsb	sy
 800ddfa:	e7fe      	b.n	800ddfa <vTaskDelayUntil+0x1a>
 800ddfc:	f04f 0350 	mov.w	r3, #80	; 0x50
 800de00:	f383 8811 	msr	BASEPRI, r3
 800de04:	f3bf 8f6f 	isb	sy
 800de08:	f3bf 8f4f 	dsb	sy
		configASSERT( pxPreviousWakeTime );
 800de0c:	e7fe      	b.n	800de0c <vTaskDelayUntil+0x2c>
		configASSERT( uxSchedulerSuspended == 0 );
 800de0e:	4b1a      	ldr	r3, [pc, #104]	; (800de78 <vTaskDelayUntil+0x98>)
 800de10:	681b      	ldr	r3, [r3, #0]
 800de12:	b143      	cbz	r3, 800de26 <vTaskDelayUntil+0x46>
 800de14:	f04f 0350 	mov.w	r3, #80	; 0x50
 800de18:	f383 8811 	msr	BASEPRI, r3
 800de1c:	f3bf 8f6f 	isb	sy
 800de20:	f3bf 8f4f 	dsb	sy
 800de24:	e7fe      	b.n	800de24 <vTaskDelayUntil+0x44>
		vTaskSuspendAll();
 800de26:	f7ff fea3 	bl	800db70 <vTaskSuspendAll>
			const TickType_t xConstTickCount = xTickCount;
 800de2a:	4b14      	ldr	r3, [pc, #80]	; (800de7c <vTaskDelayUntil+0x9c>)
 800de2c:	6818      	ldr	r0, [r3, #0]
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 800de2e:	682a      	ldr	r2, [r5, #0]
 800de30:	4414      	add	r4, r2
			if( xConstTickCount < *pxPreviousWakeTime )
 800de32:	4282      	cmp	r2, r0
 800de34:	d909      	bls.n	800de4a <vTaskDelayUntil+0x6a>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 800de36:	42a2      	cmp	r2, r4
 800de38:	d801      	bhi.n	800de3e <vTaskDelayUntil+0x5e>
			*pxPreviousWakeTime = xTimeToWake;
 800de3a:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
 800de3c:	e00e      	b.n	800de5c <vTaskDelayUntil+0x7c>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 800de3e:	42a0      	cmp	r0, r4
 800de40:	d301      	bcc.n	800de46 <vTaskDelayUntil+0x66>
			*pxPreviousWakeTime = xTimeToWake;
 800de42:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
 800de44:	e00a      	b.n	800de5c <vTaskDelayUntil+0x7c>
			*pxPreviousWakeTime = xTimeToWake;
 800de46:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
 800de48:	e004      	b.n	800de54 <vTaskDelayUntil+0x74>
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 800de4a:	42a2      	cmp	r2, r4
 800de4c:	d801      	bhi.n	800de52 <vTaskDelayUntil+0x72>
 800de4e:	42a0      	cmp	r0, r4
 800de50:	d210      	bcs.n	800de74 <vTaskDelayUntil+0x94>
			*pxPreviousWakeTime = xTimeToWake;
 800de52:	602c      	str	r4, [r5, #0]
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 800de54:	2100      	movs	r1, #0
 800de56:	1a20      	subs	r0, r4, r0
 800de58:	f7ff fbc0 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
		xAlreadyYielded = xTaskResumeAll();
 800de5c:	f7ff ff44 	bl	800dce8 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800de60:	b938      	cbnz	r0, 800de72 <vTaskDelayUntil+0x92>
			portYIELD_WITHIN_API();
 800de62:	4b07      	ldr	r3, [pc, #28]	; (800de80 <vTaskDelayUntil+0xa0>)
 800de64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800de68:	601a      	str	r2, [r3, #0]
 800de6a:	f3bf 8f4f 	dsb	sy
 800de6e:	f3bf 8f6f 	isb	sy
	}
 800de72:	bd38      	pop	{r3, r4, r5, pc}
			*pxPreviousWakeTime = xTimeToWake;
 800de74:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
 800de76:	e7f1      	b.n	800de5c <vTaskDelayUntil+0x7c>
 800de78:	200008b0 	.word	0x200008b0
 800de7c:	2000092c 	.word	0x2000092c
 800de80:	e000ed04 	.word	0xe000ed04

0800de84 <vTaskDelay>:
	{
 800de84:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800de86:	b1a8      	cbz	r0, 800deb4 <vTaskDelay+0x30>
 800de88:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 800de8a:	4b0f      	ldr	r3, [pc, #60]	; (800dec8 <vTaskDelay+0x44>)
 800de8c:	681b      	ldr	r3, [r3, #0]
 800de8e:	b143      	cbz	r3, 800dea2 <vTaskDelay+0x1e>
 800de90:	f04f 0350 	mov.w	r3, #80	; 0x50
 800de94:	f383 8811 	msr	BASEPRI, r3
 800de98:	f3bf 8f6f 	isb	sy
 800de9c:	f3bf 8f4f 	dsb	sy
 800dea0:	e7fe      	b.n	800dea0 <vTaskDelay+0x1c>
			vTaskSuspendAll();
 800dea2:	f7ff fe65 	bl	800db70 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800dea6:	2100      	movs	r1, #0
 800dea8:	4620      	mov	r0, r4
 800deaa:	f7ff fb97 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800deae:	f7ff ff1b 	bl	800dce8 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800deb2:	b938      	cbnz	r0, 800dec4 <vTaskDelay+0x40>
			portYIELD_WITHIN_API();
 800deb4:	4b05      	ldr	r3, [pc, #20]	; (800decc <vTaskDelay+0x48>)
 800deb6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800deba:	601a      	str	r2, [r3, #0]
 800debc:	f3bf 8f4f 	dsb	sy
 800dec0:	f3bf 8f6f 	isb	sy
	}
 800dec4:	bd10      	pop	{r4, pc}
 800dec6:	bf00      	nop
 800dec8:	200008b0 	.word	0x200008b0
 800decc:	e000ed04 	.word	0xe000ed04

0800ded0 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800ded0:	4b1f      	ldr	r3, [pc, #124]	; (800df50 <vTaskSwitchContext+0x80>)
 800ded2:	681b      	ldr	r3, [r3, #0]
 800ded4:	b11b      	cbz	r3, 800dede <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 800ded6:	4b1f      	ldr	r3, [pc, #124]	; (800df54 <vTaskSwitchContext+0x84>)
 800ded8:	2201      	movs	r2, #1
 800deda:	601a      	str	r2, [r3, #0]
 800dedc:	4770      	bx	lr
		xYieldPending = pdFALSE;
 800dede:	4b1d      	ldr	r3, [pc, #116]	; (800df54 <vTaskSwitchContext+0x84>)
 800dee0:	2200      	movs	r2, #0
 800dee2:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800dee4:	4b1c      	ldr	r3, [pc, #112]	; (800df58 <vTaskSwitchContext+0x88>)
 800dee6:	681b      	ldr	r3, [r3, #0]
 800dee8:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800deec:	008a      	lsls	r2, r1, #2
 800deee:	491b      	ldr	r1, [pc, #108]	; (800df5c <vTaskSwitchContext+0x8c>)
 800def0:	588a      	ldr	r2, [r1, r2]
 800def2:	b95a      	cbnz	r2, 800df0c <vTaskSwitchContext+0x3c>
 800def4:	b10b      	cbz	r3, 800defa <vTaskSwitchContext+0x2a>
 800def6:	3b01      	subs	r3, #1
 800def8:	e7f6      	b.n	800dee8 <vTaskSwitchContext+0x18>
 800defa:	f04f 0350 	mov.w	r3, #80	; 0x50
 800defe:	f383 8811 	msr	BASEPRI, r3
 800df02:	f3bf 8f6f 	isb	sy
 800df06:	f3bf 8f4f 	dsb	sy
 800df0a:	e7fe      	b.n	800df0a <vTaskSwitchContext+0x3a>
{
 800df0c:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800df0e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 800df12:	0082      	lsls	r2, r0, #2
 800df14:	440a      	add	r2, r1
 800df16:	6850      	ldr	r0, [r2, #4]
 800df18:	6840      	ldr	r0, [r0, #4]
 800df1a:	6050      	str	r0, [r2, #4]
 800df1c:	eb03 0483 	add.w	r4, r3, r3, lsl #2
 800df20:	00a2      	lsls	r2, r4, #2
 800df22:	4614      	mov	r4, r2
 800df24:	3208      	adds	r2, #8
 800df26:	4411      	add	r1, r2
 800df28:	4288      	cmp	r0, r1
 800df2a:	d00c      	beq.n	800df46 <vTaskSwitchContext+0x76>
 800df2c:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800df30:	0091      	lsls	r1, r2, #2
 800df32:	4a0a      	ldr	r2, [pc, #40]	; (800df5c <vTaskSwitchContext+0x8c>)
 800df34:	440a      	add	r2, r1
 800df36:	6852      	ldr	r2, [r2, #4]
 800df38:	68d1      	ldr	r1, [r2, #12]
 800df3a:	4a09      	ldr	r2, [pc, #36]	; (800df60 <vTaskSwitchContext+0x90>)
 800df3c:	6011      	str	r1, [r2, #0]
 800df3e:	4a06      	ldr	r2, [pc, #24]	; (800df58 <vTaskSwitchContext+0x88>)
 800df40:	6013      	str	r3, [r2, #0]
}
 800df42:	bc10      	pop	{r4}
 800df44:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800df46:	6840      	ldr	r0, [r0, #4]
 800df48:	4a04      	ldr	r2, [pc, #16]	; (800df5c <vTaskSwitchContext+0x8c>)
 800df4a:	4422      	add	r2, r4
 800df4c:	6050      	str	r0, [r2, #4]
 800df4e:	e7ed      	b.n	800df2c <vTaskSwitchContext+0x5c>
 800df50:	200008b0 	.word	0x200008b0
 800df54:	20000930 	.word	0x20000930
 800df58:	200008b8 	.word	0x200008b8
 800df5c:	20000444 	.word	0x20000444
 800df60:	20000438 	.word	0x20000438

0800df64 <vTaskSuspend>:
	{
 800df64:	b538      	push	{r3, r4, r5, lr}
 800df66:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 800df68:	f001 f936 	bl	800f1d8 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800df6c:	b1e4      	cbz	r4, 800dfa8 <vTaskSuspend+0x44>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800df6e:	1d25      	adds	r5, r4, #4
 800df70:	4628      	mov	r0, r5
 800df72:	f7fe fa63 	bl	800c43c <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800df76:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800df78:	b11b      	cbz	r3, 800df82 <vTaskSuspend+0x1e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800df7a:	f104 0018 	add.w	r0, r4, #24
 800df7e:	f7fe fa5d 	bl	800c43c <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 800df82:	4629      	mov	r1, r5
 800df84:	4822      	ldr	r0, [pc, #136]	; (800e010 <vTaskSuspend+0xac>)
 800df86:	f7fe fa35 	bl	800c3f4 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 800df8a:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800df8e:	b2db      	uxtb	r3, r3
 800df90:	2b01      	cmp	r3, #1
 800df92:	d00c      	beq.n	800dfae <vTaskSuspend+0x4a>
		taskEXIT_CRITICAL();
 800df94:	f001 f942 	bl	800f21c <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800df98:	4b1e      	ldr	r3, [pc, #120]	; (800e014 <vTaskSuspend+0xb0>)
 800df9a:	681b      	ldr	r3, [r3, #0]
 800df9c:	b95b      	cbnz	r3, 800dfb6 <vTaskSuspend+0x52>
		if( pxTCB == pxCurrentTCB )
 800df9e:	4b1e      	ldr	r3, [pc, #120]	; (800e018 <vTaskSuspend+0xb4>)
 800dfa0:	681b      	ldr	r3, [r3, #0]
 800dfa2:	42a3      	cmp	r3, r4
 800dfa4:	d00e      	beq.n	800dfc4 <vTaskSuspend+0x60>
	}
 800dfa6:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800dfa8:	4b1b      	ldr	r3, [pc, #108]	; (800e018 <vTaskSuspend+0xb4>)
 800dfaa:	681c      	ldr	r4, [r3, #0]
 800dfac:	e7df      	b.n	800df6e <vTaskSuspend+0xa>
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800dfae:	2300      	movs	r3, #0
 800dfb0:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 800dfb4:	e7ee      	b.n	800df94 <vTaskSuspend+0x30>
			taskENTER_CRITICAL();
 800dfb6:	f001 f90f 	bl	800f1d8 <vPortEnterCritical>
				prvResetNextTaskUnblockTime();
 800dfba:	f7ff f9d1 	bl	800d360 <prvResetNextTaskUnblockTime>
			taskEXIT_CRITICAL();
 800dfbe:	f001 f92d 	bl	800f21c <vPortExitCritical>
 800dfc2:	e7ec      	b.n	800df9e <vTaskSuspend+0x3a>
			if( xSchedulerRunning != pdFALSE )
 800dfc4:	4b13      	ldr	r3, [pc, #76]	; (800e014 <vTaskSuspend+0xb0>)
 800dfc6:	681b      	ldr	r3, [r3, #0]
 800dfc8:	b1a3      	cbz	r3, 800dff4 <vTaskSuspend+0x90>
				configASSERT( uxSchedulerSuspended == 0 );
 800dfca:	4b14      	ldr	r3, [pc, #80]	; (800e01c <vTaskSuspend+0xb8>)
 800dfcc:	681b      	ldr	r3, [r3, #0]
 800dfce:	b143      	cbz	r3, 800dfe2 <vTaskSuspend+0x7e>
 800dfd0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800dfd4:	f383 8811 	msr	BASEPRI, r3
 800dfd8:	f3bf 8f6f 	isb	sy
 800dfdc:	f3bf 8f4f 	dsb	sy
 800dfe0:	e7fe      	b.n	800dfe0 <vTaskSuspend+0x7c>
				portYIELD_WITHIN_API();
 800dfe2:	4b0f      	ldr	r3, [pc, #60]	; (800e020 <vTaskSuspend+0xbc>)
 800dfe4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800dfe8:	601a      	str	r2, [r3, #0]
 800dfea:	f3bf 8f4f 	dsb	sy
 800dfee:	f3bf 8f6f 	isb	sy
 800dff2:	e7d8      	b.n	800dfa6 <vTaskSuspend+0x42>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 800dff4:	4b06      	ldr	r3, [pc, #24]	; (800e010 <vTaskSuspend+0xac>)
 800dff6:	681a      	ldr	r2, [r3, #0]
 800dff8:	4b0a      	ldr	r3, [pc, #40]	; (800e024 <vTaskSuspend+0xc0>)
 800dffa:	681b      	ldr	r3, [r3, #0]
 800dffc:	429a      	cmp	r2, r3
 800dffe:	d103      	bne.n	800e008 <vTaskSuspend+0xa4>
					pxCurrentTCB = NULL;
 800e000:	4b05      	ldr	r3, [pc, #20]	; (800e018 <vTaskSuspend+0xb4>)
 800e002:	2200      	movs	r2, #0
 800e004:	601a      	str	r2, [r3, #0]
 800e006:	e7ce      	b.n	800dfa6 <vTaskSuspend+0x42>
					vTaskSwitchContext();
 800e008:	f7ff ff62 	bl	800ded0 <vTaskSwitchContext>
	}
 800e00c:	e7cb      	b.n	800dfa6 <vTaskSuspend+0x42>
 800e00e:	bf00      	nop
 800e010:	20000904 	.word	0x20000904
 800e014:	20000900 	.word	0x20000900
 800e018:	20000438 	.word	0x20000438
 800e01c:	200008b0 	.word	0x200008b0
 800e020:	e000ed04 	.word	0xe000ed04
 800e024:	200008a4 	.word	0x200008a4

0800e028 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 800e028:	b158      	cbz	r0, 800e042 <vTaskPlaceOnEventList+0x1a>
{
 800e02a:	b510      	push	{r4, lr}
 800e02c:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800e02e:	4b09      	ldr	r3, [pc, #36]	; (800e054 <vTaskPlaceOnEventList+0x2c>)
 800e030:	6819      	ldr	r1, [r3, #0]
 800e032:	3118      	adds	r1, #24
 800e034:	f7fe f9e9 	bl	800c40a <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800e038:	2101      	movs	r1, #1
 800e03a:	4620      	mov	r0, r4
 800e03c:	f7ff face 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
}
 800e040:	bd10      	pop	{r4, pc}
 800e042:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e046:	f383 8811 	msr	BASEPRI, r3
 800e04a:	f3bf 8f6f 	isb	sy
 800e04e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 800e052:	e7fe      	b.n	800e052 <vTaskPlaceOnEventList+0x2a>
 800e054:	20000438 	.word	0x20000438

0800e058 <vTaskPlaceOnUnorderedEventList>:
{
 800e058:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxEventList );
 800e05a:	b168      	cbz	r0, 800e078 <vTaskPlaceOnUnorderedEventList+0x20>
 800e05c:	460b      	mov	r3, r1
 800e05e:	4614      	mov	r4, r2
	configASSERT( uxSchedulerSuspended != 0 );
 800e060:	4a11      	ldr	r2, [pc, #68]	; (800e0a8 <vTaskPlaceOnUnorderedEventList+0x50>)
 800e062:	6812      	ldr	r2, [r2, #0]
 800e064:	b98a      	cbnz	r2, 800e08a <vTaskPlaceOnUnorderedEventList+0x32>
 800e066:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e06a:	f383 8811 	msr	BASEPRI, r3
 800e06e:	f3bf 8f6f 	isb	sy
 800e072:	f3bf 8f4f 	dsb	sy
 800e076:	e7fe      	b.n	800e076 <vTaskPlaceOnUnorderedEventList+0x1e>
 800e078:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e07c:	f383 8811 	msr	BASEPRI, r3
 800e080:	f3bf 8f6f 	isb	sy
 800e084:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 800e088:	e7fe      	b.n	800e088 <vTaskPlaceOnUnorderedEventList+0x30>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800e08a:	4a08      	ldr	r2, [pc, #32]	; (800e0ac <vTaskPlaceOnUnorderedEventList+0x54>)
 800e08c:	6811      	ldr	r1, [r2, #0]
 800e08e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800e092:	618b      	str	r3, [r1, #24]
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800e094:	6811      	ldr	r1, [r2, #0]
 800e096:	3118      	adds	r1, #24
 800e098:	f7fe f9ac 	bl	800c3f4 <vListInsertEnd>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800e09c:	2101      	movs	r1, #1
 800e09e:	4620      	mov	r0, r4
 800e0a0:	f7ff fa9c 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
}
 800e0a4:	bd38      	pop	{r3, r4, r5, pc}
 800e0a6:	bf00      	nop
 800e0a8:	200008b0 	.word	0x200008b0
 800e0ac:	20000438 	.word	0x20000438

0800e0b0 <vTaskPlaceOnEventListRestricted>:
	{
 800e0b0:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 800e0b2:	b170      	cbz	r0, 800e0d2 <vTaskPlaceOnEventListRestricted+0x22>
 800e0b4:	460c      	mov	r4, r1
 800e0b6:	4615      	mov	r5, r2
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800e0b8:	4b0a      	ldr	r3, [pc, #40]	; (800e0e4 <vTaskPlaceOnEventListRestricted+0x34>)
 800e0ba:	6819      	ldr	r1, [r3, #0]
 800e0bc:	3118      	adds	r1, #24
 800e0be:	f7fe f999 	bl	800c3f4 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 800e0c2:	b10d      	cbz	r5, 800e0c8 <vTaskPlaceOnEventListRestricted+0x18>
			xTicksToWait = portMAX_DELAY;
 800e0c4:	f04f 34ff 	mov.w	r4, #4294967295
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 800e0c8:	4629      	mov	r1, r5
 800e0ca:	4620      	mov	r0, r4
 800e0cc:	f7ff fa86 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
	}
 800e0d0:	bd38      	pop	{r3, r4, r5, pc}
 800e0d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e0d6:	f383 8811 	msr	BASEPRI, r3
 800e0da:	f3bf 8f6f 	isb	sy
 800e0de:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 800e0e2:	e7fe      	b.n	800e0e2 <vTaskPlaceOnEventListRestricted+0x32>
 800e0e4:	20000438 	.word	0x20000438

0800e0e8 <xTaskRemoveFromEventList>:
{
 800e0e8:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800e0ea:	68c3      	ldr	r3, [r0, #12]
 800e0ec:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800e0ee:	b324      	cbz	r4, 800e13a <xTaskRemoveFromEventList+0x52>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800e0f0:	f104 0518 	add.w	r5, r4, #24
 800e0f4:	4628      	mov	r0, r5
 800e0f6:	f7fe f9a1 	bl	800c43c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800e0fa:	4b18      	ldr	r3, [pc, #96]	; (800e15c <xTaskRemoveFromEventList+0x74>)
 800e0fc:	681b      	ldr	r3, [r3, #0]
 800e0fe:	bb2b      	cbnz	r3, 800e14c <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800e100:	1d25      	adds	r5, r4, #4
 800e102:	4628      	mov	r0, r5
 800e104:	f7fe f99a 	bl	800c43c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800e108:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800e10a:	4b15      	ldr	r3, [pc, #84]	; (800e160 <xTaskRemoveFromEventList+0x78>)
 800e10c:	681b      	ldr	r3, [r3, #0]
 800e10e:	4298      	cmp	r0, r3
 800e110:	d901      	bls.n	800e116 <xTaskRemoveFromEventList+0x2e>
 800e112:	4b13      	ldr	r3, [pc, #76]	; (800e160 <xTaskRemoveFromEventList+0x78>)
 800e114:	6018      	str	r0, [r3, #0]
 800e116:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e11a:	4629      	mov	r1, r5
 800e11c:	4b11      	ldr	r3, [pc, #68]	; (800e164 <xTaskRemoveFromEventList+0x7c>)
 800e11e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e122:	f7fe f967 	bl	800c3f4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800e126:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e128:	4b0f      	ldr	r3, [pc, #60]	; (800e168 <xTaskRemoveFromEventList+0x80>)
 800e12a:	681b      	ldr	r3, [r3, #0]
 800e12c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e12e:	429a      	cmp	r2, r3
 800e130:	d911      	bls.n	800e156 <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
 800e132:	2001      	movs	r0, #1
 800e134:	4b0d      	ldr	r3, [pc, #52]	; (800e16c <xTaskRemoveFromEventList+0x84>)
 800e136:	6018      	str	r0, [r3, #0]
 800e138:	e00e      	b.n	800e158 <xTaskRemoveFromEventList+0x70>
 800e13a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e13e:	f383 8811 	msr	BASEPRI, r3
 800e142:	f3bf 8f6f 	isb	sy
 800e146:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 800e14a:	e7fe      	b.n	800e14a <xTaskRemoveFromEventList+0x62>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800e14c:	4629      	mov	r1, r5
 800e14e:	4808      	ldr	r0, [pc, #32]	; (800e170 <xTaskRemoveFromEventList+0x88>)
 800e150:	f7fe f950 	bl	800c3f4 <vListInsertEnd>
 800e154:	e7e7      	b.n	800e126 <xTaskRemoveFromEventList+0x3e>
		xReturn = pdFALSE;
 800e156:	2000      	movs	r0, #0
}
 800e158:	bd38      	pop	{r3, r4, r5, pc}
 800e15a:	bf00      	nop
 800e15c:	200008b0 	.word	0x200008b0
 800e160:	200008b8 	.word	0x200008b8
 800e164:	20000444 	.word	0x20000444
 800e168:	20000438 	.word	0x20000438
 800e16c:	20000930 	.word	0x20000930
 800e170:	200008ec 	.word	0x200008ec

0800e174 <vTaskRemoveFromUnorderedEventList>:
{
 800e174:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended != pdFALSE );
 800e176:	4a1c      	ldr	r2, [pc, #112]	; (800e1e8 <vTaskRemoveFromUnorderedEventList+0x74>)
 800e178:	6812      	ldr	r2, [r2, #0]
 800e17a:	b942      	cbnz	r2, 800e18e <vTaskRemoveFromUnorderedEventList+0x1a>
 800e17c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e180:	f383 8811 	msr	BASEPRI, r3
 800e184:	f3bf 8f6f 	isb	sy
 800e188:	f3bf 8f4f 	dsb	sy
 800e18c:	e7fe      	b.n	800e18c <vTaskRemoveFromUnorderedEventList+0x18>
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800e18e:	f041 4300 	orr.w	r3, r1, #2147483648	; 0x80000000
 800e192:	6003      	str	r3, [r0, #0]
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 800e194:	68c4      	ldr	r4, [r0, #12]
	configASSERT( pxUnblockedTCB );
 800e196:	b1f4      	cbz	r4, 800e1d6 <vTaskRemoveFromUnorderedEventList+0x62>
	( void ) uxListRemove( pxEventListItem );
 800e198:	f7fe f950 	bl	800c43c <uxListRemove>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800e19c:	1d25      	adds	r5, r4, #4
 800e19e:	4628      	mov	r0, r5
 800e1a0:	f7fe f94c 	bl	800c43c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 800e1a4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800e1a6:	4b11      	ldr	r3, [pc, #68]	; (800e1ec <vTaskRemoveFromUnorderedEventList+0x78>)
 800e1a8:	681b      	ldr	r3, [r3, #0]
 800e1aa:	4298      	cmp	r0, r3
 800e1ac:	d901      	bls.n	800e1b2 <vTaskRemoveFromUnorderedEventList+0x3e>
 800e1ae:	4b0f      	ldr	r3, [pc, #60]	; (800e1ec <vTaskRemoveFromUnorderedEventList+0x78>)
 800e1b0:	6018      	str	r0, [r3, #0]
 800e1b2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e1b6:	4629      	mov	r1, r5
 800e1b8:	4b0d      	ldr	r3, [pc, #52]	; (800e1f0 <vTaskRemoveFromUnorderedEventList+0x7c>)
 800e1ba:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e1be:	f7fe f919 	bl	800c3f4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800e1c2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e1c4:	4b0b      	ldr	r3, [pc, #44]	; (800e1f4 <vTaskRemoveFromUnorderedEventList+0x80>)
 800e1c6:	681b      	ldr	r3, [r3, #0]
 800e1c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e1ca:	429a      	cmp	r2, r3
 800e1cc:	d902      	bls.n	800e1d4 <vTaskRemoveFromUnorderedEventList+0x60>
		xYieldPending = pdTRUE;
 800e1ce:	4b0a      	ldr	r3, [pc, #40]	; (800e1f8 <vTaskRemoveFromUnorderedEventList+0x84>)
 800e1d0:	2201      	movs	r2, #1
 800e1d2:	601a      	str	r2, [r3, #0]
}
 800e1d4:	bd38      	pop	{r3, r4, r5, pc}
 800e1d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e1da:	f383 8811 	msr	BASEPRI, r3
 800e1de:	f3bf 8f6f 	isb	sy
 800e1e2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 800e1e6:	e7fe      	b.n	800e1e6 <vTaskRemoveFromUnorderedEventList+0x72>
 800e1e8:	200008b0 	.word	0x200008b0
 800e1ec:	200008b8 	.word	0x200008b8
 800e1f0:	20000444 	.word	0x20000444
 800e1f4:	20000438 	.word	0x20000438
 800e1f8:	20000930 	.word	0x20000930

0800e1fc <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 800e1fc:	b160      	cbz	r0, 800e218 <vTaskSetTimeOutState+0x1c>
{
 800e1fe:	b510      	push	{r4, lr}
 800e200:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800e202:	f000 ffe9 	bl	800f1d8 <vPortEnterCritical>
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 800e206:	4b09      	ldr	r3, [pc, #36]	; (800e22c <vTaskSetTimeOutState+0x30>)
 800e208:	681b      	ldr	r3, [r3, #0]
 800e20a:	6023      	str	r3, [r4, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
 800e20c:	4b08      	ldr	r3, [pc, #32]	; (800e230 <vTaskSetTimeOutState+0x34>)
 800e20e:	681b      	ldr	r3, [r3, #0]
 800e210:	6063      	str	r3, [r4, #4]
	taskEXIT_CRITICAL();
 800e212:	f001 f803 	bl	800f21c <vPortExitCritical>
}
 800e216:	bd10      	pop	{r4, pc}
 800e218:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e21c:	f383 8811 	msr	BASEPRI, r3
 800e220:	f3bf 8f6f 	isb	sy
 800e224:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 800e228:	e7fe      	b.n	800e228 <vTaskSetTimeOutState+0x2c>
 800e22a:	bf00      	nop
 800e22c:	200008e8 	.word	0x200008e8
 800e230:	2000092c 	.word	0x2000092c

0800e234 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800e234:	4b03      	ldr	r3, [pc, #12]	; (800e244 <vTaskInternalSetTimeOutState+0x10>)
 800e236:	681b      	ldr	r3, [r3, #0]
 800e238:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800e23a:	4b03      	ldr	r3, [pc, #12]	; (800e248 <vTaskInternalSetTimeOutState+0x14>)
 800e23c:	681b      	ldr	r3, [r3, #0]
 800e23e:	6043      	str	r3, [r0, #4]
}
 800e240:	4770      	bx	lr
 800e242:	bf00      	nop
 800e244:	200008e8 	.word	0x200008e8
 800e248:	2000092c 	.word	0x2000092c

0800e24c <xTaskCheckForTimeOut>:
{
 800e24c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 800e24e:	b1c8      	cbz	r0, 800e284 <xTaskCheckForTimeOut+0x38>
 800e250:	460c      	mov	r4, r1
 800e252:	4605      	mov	r5, r0
	configASSERT( pxTicksToWait );
 800e254:	b1f9      	cbz	r1, 800e296 <xTaskCheckForTimeOut+0x4a>
	taskENTER_CRITICAL();
 800e256:	f000 ffbf 	bl	800f1d8 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800e25a:	4b1b      	ldr	r3, [pc, #108]	; (800e2c8 <xTaskCheckForTimeOut+0x7c>)
 800e25c:	6819      	ldr	r1, [r3, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800e25e:	686b      	ldr	r3, [r5, #4]
 800e260:	1ac8      	subs	r0, r1, r3
			if( *pxTicksToWait == portMAX_DELAY )
 800e262:	6822      	ldr	r2, [r4, #0]
 800e264:	f1b2 3fff 	cmp.w	r2, #4294967295
 800e268:	d026      	beq.n	800e2b8 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800e26a:	682f      	ldr	r7, [r5, #0]
 800e26c:	4e17      	ldr	r6, [pc, #92]	; (800e2cc <xTaskCheckForTimeOut+0x80>)
 800e26e:	6836      	ldr	r6, [r6, #0]
 800e270:	42b7      	cmp	r7, r6
 800e272:	d001      	beq.n	800e278 <xTaskCheckForTimeOut+0x2c>
 800e274:	428b      	cmp	r3, r1
 800e276:	d924      	bls.n	800e2c2 <xTaskCheckForTimeOut+0x76>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800e278:	4282      	cmp	r2, r0
 800e27a:	d815      	bhi.n	800e2a8 <xTaskCheckForTimeOut+0x5c>
			*pxTicksToWait = 0;
 800e27c:	2300      	movs	r3, #0
 800e27e:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 800e280:	2401      	movs	r4, #1
 800e282:	e01a      	b.n	800e2ba <xTaskCheckForTimeOut+0x6e>
 800e284:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e288:	f383 8811 	msr	BASEPRI, r3
 800e28c:	f3bf 8f6f 	isb	sy
 800e290:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 800e294:	e7fe      	b.n	800e294 <xTaskCheckForTimeOut+0x48>
 800e296:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e29a:	f383 8811 	msr	BASEPRI, r3
 800e29e:	f3bf 8f6f 	isb	sy
 800e2a2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 800e2a6:	e7fe      	b.n	800e2a6 <xTaskCheckForTimeOut+0x5a>
			*pxTicksToWait -= xElapsedTime;
 800e2a8:	1a5b      	subs	r3, r3, r1
 800e2aa:	4413      	add	r3, r2
 800e2ac:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 800e2ae:	4628      	mov	r0, r5
 800e2b0:	f7ff ffc0 	bl	800e234 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 800e2b4:	2400      	movs	r4, #0
 800e2b6:	e000      	b.n	800e2ba <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
 800e2b8:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800e2ba:	f000 ffaf 	bl	800f21c <vPortExitCritical>
}
 800e2be:	4620      	mov	r0, r4
 800e2c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 800e2c2:	2401      	movs	r4, #1
 800e2c4:	e7f9      	b.n	800e2ba <xTaskCheckForTimeOut+0x6e>
 800e2c6:	bf00      	nop
 800e2c8:	2000092c 	.word	0x2000092c
 800e2cc:	200008e8 	.word	0x200008e8

0800e2d0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800e2d0:	4b01      	ldr	r3, [pc, #4]	; (800e2d8 <vTaskMissedYield+0x8>)
 800e2d2:	2201      	movs	r2, #1
 800e2d4:	601a      	str	r2, [r3, #0]
}
 800e2d6:	4770      	bx	lr
 800e2d8:	20000930 	.word	0x20000930

0800e2dc <uxTaskGetTaskNumber>:
		if( xTask != NULL )
 800e2dc:	b108      	cbz	r0, 800e2e2 <uxTaskGetTaskNumber+0x6>
			uxReturn = pxTCB->uxTaskNumber;
 800e2de:	6d80      	ldr	r0, [r0, #88]	; 0x58
 800e2e0:	4770      	bx	lr
			uxReturn = 0U;
 800e2e2:	2000      	movs	r0, #0
	}
 800e2e4:	4770      	bx	lr

0800e2e6 <vTaskSetTaskNumber>:
		if( xTask != NULL )
 800e2e6:	b100      	cbz	r0, 800e2ea <vTaskSetTaskNumber+0x4>
			pxTCB->uxTaskNumber = uxHandle;
 800e2e8:	6581      	str	r1, [r0, #88]	; 0x58
	}
 800e2ea:	4770      	bx	lr

0800e2ec <vTaskGetInfo>:
	{
 800e2ec:	b570      	push	{r4, r5, r6, lr}
 800e2ee:	460c      	mov	r4, r1
 800e2f0:	4616      	mov	r6, r2
		pxTCB = prvGetTCBFromHandle( xTask );
 800e2f2:	4605      	mov	r5, r0
 800e2f4:	b1d0      	cbz	r0, 800e32c <vTaskGetInfo+0x40>
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 800e2f6:	6025      	str	r5, [r4, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 800e2f8:	f105 0234 	add.w	r2, r5, #52	; 0x34
 800e2fc:	6062      	str	r2, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 800e2fe:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800e300:	6122      	str	r2, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 800e302:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 800e304:	61e2      	str	r2, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 800e306:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 800e308:	60a2      	str	r2, [r4, #8]
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 800e30a:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 800e30c:	6162      	str	r2, [r4, #20]
			pxTaskStatus->ulRunTimeCounter = 0;
 800e30e:	2200      	movs	r2, #0
 800e310:	61a2      	str	r2, [r4, #24]
		if( eState != eInvalid )
 800e312:	2b05      	cmp	r3, #5
 800e314:	d019      	beq.n	800e34a <vTaskGetInfo+0x5e>
			if( pxTCB == pxCurrentTCB )
 800e316:	4a12      	ldr	r2, [pc, #72]	; (800e360 <vTaskGetInfo+0x74>)
 800e318:	6812      	ldr	r2, [r2, #0]
 800e31a:	42aa      	cmp	r2, r5
 800e31c:	d009      	beq.n	800e332 <vTaskGetInfo+0x46>
				pxTaskStatus->eCurrentState = eState;
 800e31e:	7323      	strb	r3, [r4, #12]
					if( eState == eSuspended )
 800e320:	2b03      	cmp	r3, #3
 800e322:	d009      	beq.n	800e338 <vTaskGetInfo+0x4c>
		if( xGetFreeStackSpace != pdFALSE )
 800e324:	b9b6      	cbnz	r6, 800e354 <vTaskGetInfo+0x68>
			pxTaskStatus->usStackHighWaterMark = 0;
 800e326:	2300      	movs	r3, #0
 800e328:	8423      	strh	r3, [r4, #32]
	}
 800e32a:	bd70      	pop	{r4, r5, r6, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 800e32c:	4a0c      	ldr	r2, [pc, #48]	; (800e360 <vTaskGetInfo+0x74>)
 800e32e:	6815      	ldr	r5, [r2, #0]
 800e330:	e7e1      	b.n	800e2f6 <vTaskGetInfo+0xa>
				pxTaskStatus->eCurrentState = eRunning;
 800e332:	2300      	movs	r3, #0
 800e334:	7323      	strb	r3, [r4, #12]
 800e336:	e7f5      	b.n	800e324 <vTaskGetInfo+0x38>
						vTaskSuspendAll();
 800e338:	f7ff fc1a 	bl	800db70 <vTaskSuspendAll>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800e33c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800e33e:	b10b      	cbz	r3, 800e344 <vTaskGetInfo+0x58>
								pxTaskStatus->eCurrentState = eBlocked;
 800e340:	2302      	movs	r3, #2
 800e342:	7323      	strb	r3, [r4, #12]
						( void ) xTaskResumeAll();
 800e344:	f7ff fcd0 	bl	800dce8 <xTaskResumeAll>
 800e348:	e7ec      	b.n	800e324 <vTaskGetInfo+0x38>
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 800e34a:	4628      	mov	r0, r5
 800e34c:	f7ff fa4c 	bl	800d7e8 <eTaskGetState>
 800e350:	7320      	strb	r0, [r4, #12]
 800e352:	e7e7      	b.n	800e324 <vTaskGetInfo+0x38>
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 800e354:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800e356:	f7fe fff9 	bl	800d34c <prvTaskCheckFreeStackSpace>
 800e35a:	8420      	strh	r0, [r4, #32]
 800e35c:	e7e5      	b.n	800e32a <vTaskGetInfo+0x3e>
 800e35e:	bf00      	nop
 800e360:	20000438 	.word	0x20000438

0800e364 <prvListTasksWithinSingleList>:
	{
 800e364:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800e368:	680c      	ldr	r4, [r1, #0]
 800e36a:	b33c      	cbz	r4, 800e3bc <prvListTasksWithinSingleList+0x58>
 800e36c:	4607      	mov	r7, r0
 800e36e:	460d      	mov	r5, r1
 800e370:	4690      	mov	r8, r2
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 800e372:	684b      	ldr	r3, [r1, #4]
 800e374:	685b      	ldr	r3, [r3, #4]
 800e376:	604b      	str	r3, [r1, #4]
 800e378:	f101 0908 	add.w	r9, r1, #8
 800e37c:	454b      	cmp	r3, r9
 800e37e:	d004      	beq.n	800e38a <prvListTasksWithinSingleList+0x26>
 800e380:	686b      	ldr	r3, [r5, #4]
 800e382:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	UBaseType_t uxTask = 0;
 800e386:	2400      	movs	r4, #0
 800e388:	e012      	b.n	800e3b0 <prvListTasksWithinSingleList+0x4c>
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 800e38a:	685b      	ldr	r3, [r3, #4]
 800e38c:	604b      	str	r3, [r1, #4]
 800e38e:	e7f7      	b.n	800e380 <prvListTasksWithinSingleList+0x1c>
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 800e390:	685b      	ldr	r3, [r3, #4]
 800e392:	606b      	str	r3, [r5, #4]
 800e394:	686b      	ldr	r3, [r5, #4]
 800e396:	68de      	ldr	r6, [r3, #12]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 800e398:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 800e39c:	4643      	mov	r3, r8
 800e39e:	2201      	movs	r2, #1
 800e3a0:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 800e3a4:	4630      	mov	r0, r6
 800e3a6:	f7ff ffa1 	bl	800e2ec <vTaskGetInfo>
				uxTask++;
 800e3aa:	3401      	adds	r4, #1
			} while( pxNextTCB != pxFirstTCB );
 800e3ac:	45b2      	cmp	sl, r6
 800e3ae:	d005      	beq.n	800e3bc <prvListTasksWithinSingleList+0x58>
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 800e3b0:	686b      	ldr	r3, [r5, #4]
 800e3b2:	685b      	ldr	r3, [r3, #4]
 800e3b4:	606b      	str	r3, [r5, #4]
 800e3b6:	4599      	cmp	r9, r3
 800e3b8:	d1ec      	bne.n	800e394 <prvListTasksWithinSingleList+0x30>
 800e3ba:	e7e9      	b.n	800e390 <prvListTasksWithinSingleList+0x2c>
	}
 800e3bc:	4620      	mov	r0, r4
 800e3be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800e3c2 <uxTaskGetSystemState>:
	{
 800e3c2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e3c4:	4607      	mov	r7, r0
 800e3c6:	460c      	mov	r4, r1
 800e3c8:	4616      	mov	r6, r2
		vTaskSuspendAll();
 800e3ca:	f7ff fbd1 	bl	800db70 <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 800e3ce:	4b22      	ldr	r3, [pc, #136]	; (800e458 <uxTaskGetSystemState+0x96>)
 800e3d0:	681b      	ldr	r3, [r3, #0]
 800e3d2:	42a3      	cmp	r3, r4
 800e3d4:	d83b      	bhi.n	800e44e <uxTaskGetSystemState+0x8c>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 800e3d6:	2438      	movs	r4, #56	; 0x38
 800e3d8:	2500      	movs	r5, #0
					uxQueue--;
 800e3da:	3c01      	subs	r4, #1
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 800e3dc:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
 800e3e0:	eb04 0184 	add.w	r1, r4, r4, lsl #2
 800e3e4:	2201      	movs	r2, #1
 800e3e6:	4b1d      	ldr	r3, [pc, #116]	; (800e45c <uxTaskGetSystemState+0x9a>)
 800e3e8:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800e3ec:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800e3f0:	f7ff ffb8 	bl	800e364 <prvListTasksWithinSingleList>
 800e3f4:	4405      	add	r5, r0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e3f6:	2c00      	cmp	r4, #0
 800e3f8:	d1ef      	bne.n	800e3da <uxTaskGetSystemState+0x18>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 800e3fa:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
 800e3fe:	4b18      	ldr	r3, [pc, #96]	; (800e460 <uxTaskGetSystemState+0x9e>)
 800e400:	6819      	ldr	r1, [r3, #0]
 800e402:	2202      	movs	r2, #2
 800e404:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800e408:	f7ff ffac 	bl	800e364 <prvListTasksWithinSingleList>
 800e40c:	4405      	add	r5, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800e40e:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
 800e412:	4b14      	ldr	r3, [pc, #80]	; (800e464 <uxTaskGetSystemState+0xa2>)
 800e414:	6819      	ldr	r1, [r3, #0]
 800e416:	2202      	movs	r2, #2
 800e418:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800e41c:	f7ff ffa2 	bl	800e364 <prvListTasksWithinSingleList>
 800e420:	4405      	add	r5, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 800e422:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
 800e426:	2204      	movs	r2, #4
 800e428:	490f      	ldr	r1, [pc, #60]	; (800e468 <uxTaskGetSystemState+0xa6>)
 800e42a:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800e42e:	f7ff ff99 	bl	800e364 <prvListTasksWithinSingleList>
 800e432:	182c      	adds	r4, r5, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 800e434:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800e438:	2203      	movs	r2, #3
 800e43a:	490c      	ldr	r1, [pc, #48]	; (800e46c <uxTaskGetSystemState+0xaa>)
 800e43c:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800e440:	f7ff ff90 	bl	800e364 <prvListTasksWithinSingleList>
 800e444:	4404      	add	r4, r0
					if( pulTotalRunTime != NULL )
 800e446:	b11e      	cbz	r6, 800e450 <uxTaskGetSystemState+0x8e>
						*pulTotalRunTime = 0;
 800e448:	2300      	movs	r3, #0
 800e44a:	6033      	str	r3, [r6, #0]
 800e44c:	e000      	b.n	800e450 <uxTaskGetSystemState+0x8e>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 800e44e:	2400      	movs	r4, #0
		( void ) xTaskResumeAll();
 800e450:	f7ff fc4a 	bl	800dce8 <xTaskResumeAll>
	}
 800e454:	4620      	mov	r0, r4
 800e456:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e458:	200008a4 	.word	0x200008a4
 800e45c:	20000444 	.word	0x20000444
 800e460:	2000043c 	.word	0x2000043c
 800e464:	20000440 	.word	0x20000440
 800e468:	20000918 	.word	0x20000918
 800e46c:	20000904 	.word	0x20000904

0800e470 <uxTaskGetStackHighWaterMark>:
	{
 800e470:	b508      	push	{r3, lr}
		pxTCB = prvGetTCBFromHandle( xTask );
 800e472:	4603      	mov	r3, r0
 800e474:	b118      	cbz	r0, 800e47e <uxTaskGetStackHighWaterMark+0xe>
		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 800e476:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800e478:	f7fe ff68 	bl	800d34c <prvTaskCheckFreeStackSpace>
	}
 800e47c:	bd08      	pop	{r3, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 800e47e:	4b01      	ldr	r3, [pc, #4]	; (800e484 <uxTaskGetStackHighWaterMark+0x14>)
 800e480:	681b      	ldr	r3, [r3, #0]
 800e482:	e7f8      	b.n	800e476 <uxTaskGetStackHighWaterMark+0x6>
 800e484:	20000438 	.word	0x20000438

0800e488 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 800e488:	4b01      	ldr	r3, [pc, #4]	; (800e490 <xTaskGetCurrentTaskHandle+0x8>)
 800e48a:	6818      	ldr	r0, [r3, #0]
	}
 800e48c:	4770      	bx	lr
 800e48e:	bf00      	nop
 800e490:	20000438 	.word	0x20000438

0800e494 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 800e494:	4b05      	ldr	r3, [pc, #20]	; (800e4ac <xTaskGetSchedulerState+0x18>)
 800e496:	681b      	ldr	r3, [r3, #0]
 800e498:	b133      	cbz	r3, 800e4a8 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800e49a:	4b05      	ldr	r3, [pc, #20]	; (800e4b0 <xTaskGetSchedulerState+0x1c>)
 800e49c:	681b      	ldr	r3, [r3, #0]
 800e49e:	b10b      	cbz	r3, 800e4a4 <xTaskGetSchedulerState+0x10>
				xReturn = taskSCHEDULER_SUSPENDED;
 800e4a0:	2000      	movs	r0, #0
	}
 800e4a2:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 800e4a4:	2002      	movs	r0, #2
 800e4a6:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 800e4a8:	2001      	movs	r0, #1
 800e4aa:	4770      	bx	lr
 800e4ac:	20000900 	.word	0x20000900
 800e4b0:	200008b0 	.word	0x200008b0

0800e4b4 <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 800e4b4:	2800      	cmp	r0, #0
 800e4b6:	d03f      	beq.n	800e538 <xTaskPriorityInherit+0x84>
	{
 800e4b8:	b538      	push	{r3, r4, r5, lr}
 800e4ba:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 800e4bc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800e4be:	4a20      	ldr	r2, [pc, #128]	; (800e540 <xTaskPriorityInherit+0x8c>)
 800e4c0:	6812      	ldr	r2, [r2, #0]
 800e4c2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800e4c4:	4293      	cmp	r3, r2
 800e4c6:	d22f      	bcs.n	800e528 <xTaskPriorityInherit+0x74>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800e4c8:	6982      	ldr	r2, [r0, #24]
 800e4ca:	2a00      	cmp	r2, #0
 800e4cc:	db05      	blt.n	800e4da <xTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e4ce:	4a1c      	ldr	r2, [pc, #112]	; (800e540 <xTaskPriorityInherit+0x8c>)
 800e4d0:	6812      	ldr	r2, [r2, #0]
 800e4d2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800e4d4:	f1c2 0238 	rsb	r2, r2, #56	; 0x38
 800e4d8:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 800e4da:	6961      	ldr	r1, [r4, #20]
 800e4dc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800e4e0:	4a18      	ldr	r2, [pc, #96]	; (800e544 <xTaskPriorityInherit+0x90>)
 800e4e2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800e4e6:	4299      	cmp	r1, r3
 800e4e8:	d005      	beq.n	800e4f6 <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800e4ea:	4b15      	ldr	r3, [pc, #84]	; (800e540 <xTaskPriorityInherit+0x8c>)
 800e4ec:	681b      	ldr	r3, [r3, #0]
 800e4ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e4f0:	62e3      	str	r3, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
 800e4f2:	2001      	movs	r0, #1
	}
 800e4f4:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800e4f6:	1d25      	adds	r5, r4, #4
 800e4f8:	4628      	mov	r0, r5
 800e4fa:	f7fd ff9f 	bl	800c43c <uxListRemove>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800e4fe:	4b10      	ldr	r3, [pc, #64]	; (800e540 <xTaskPriorityInherit+0x8c>)
 800e500:	681b      	ldr	r3, [r3, #0]
 800e502:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800e504:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800e506:	4b10      	ldr	r3, [pc, #64]	; (800e548 <xTaskPriorityInherit+0x94>)
 800e508:	681b      	ldr	r3, [r3, #0]
 800e50a:	4298      	cmp	r0, r3
 800e50c:	d809      	bhi.n	800e522 <xTaskPriorityInherit+0x6e>
 800e50e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e512:	4629      	mov	r1, r5
 800e514:	4b0b      	ldr	r3, [pc, #44]	; (800e544 <xTaskPriorityInherit+0x90>)
 800e516:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e51a:	f7fd ff6b 	bl	800c3f4 <vListInsertEnd>
				xReturn = pdTRUE;
 800e51e:	2001      	movs	r0, #1
 800e520:	e7e8      	b.n	800e4f4 <xTaskPriorityInherit+0x40>
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800e522:	4b09      	ldr	r3, [pc, #36]	; (800e548 <xTaskPriorityInherit+0x94>)
 800e524:	6018      	str	r0, [r3, #0]
 800e526:	e7f2      	b.n	800e50e <xTaskPriorityInherit+0x5a>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 800e528:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 800e52a:	4b05      	ldr	r3, [pc, #20]	; (800e540 <xTaskPriorityInherit+0x8c>)
 800e52c:	681b      	ldr	r3, [r3, #0]
 800e52e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e530:	429a      	cmp	r2, r3
 800e532:	d303      	bcc.n	800e53c <xTaskPriorityInherit+0x88>
	BaseType_t xReturn = pdFALSE;
 800e534:	2000      	movs	r0, #0
 800e536:	e7dd      	b.n	800e4f4 <xTaskPriorityInherit+0x40>
 800e538:	2000      	movs	r0, #0
	}
 800e53a:	4770      	bx	lr
					xReturn = pdTRUE;
 800e53c:	2001      	movs	r0, #1
		return xReturn;
 800e53e:	e7d9      	b.n	800e4f4 <xTaskPriorityInherit+0x40>
 800e540:	20000438 	.word	0x20000438
 800e544:	20000444 	.word	0x20000444
 800e548:	200008b8 	.word	0x200008b8

0800e54c <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 800e54c:	2800      	cmp	r0, #0
 800e54e:	d03b      	beq.n	800e5c8 <xTaskPriorityDisinherit+0x7c>
	{
 800e550:	b538      	push	{r3, r4, r5, lr}
 800e552:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 800e554:	4b1e      	ldr	r3, [pc, #120]	; (800e5d0 <xTaskPriorityDisinherit+0x84>)
 800e556:	681b      	ldr	r3, [r3, #0]
 800e558:	4283      	cmp	r3, r0
 800e55a:	d008      	beq.n	800e56e <xTaskPriorityDisinherit+0x22>
 800e55c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e560:	f383 8811 	msr	BASEPRI, r3
 800e564:	f3bf 8f6f 	isb	sy
 800e568:	f3bf 8f4f 	dsb	sy
 800e56c:	e7fe      	b.n	800e56c <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 800e56e:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800e570:	b943      	cbnz	r3, 800e584 <xTaskPriorityDisinherit+0x38>
 800e572:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e576:	f383 8811 	msr	BASEPRI, r3
 800e57a:	f3bf 8f6f 	isb	sy
 800e57e:	f3bf 8f4f 	dsb	sy
 800e582:	e7fe      	b.n	800e582 <xTaskPriorityDisinherit+0x36>
			( pxTCB->uxMutexesHeld )--;
 800e584:	3b01      	subs	r3, #1
 800e586:	6603      	str	r3, [r0, #96]	; 0x60
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800e588:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800e58a:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 800e58c:	4291      	cmp	r1, r2
 800e58e:	d01d      	beq.n	800e5cc <xTaskPriorityDisinherit+0x80>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800e590:	b10b      	cbz	r3, 800e596 <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 800e592:	2000      	movs	r0, #0
	}
 800e594:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800e596:	1d05      	adds	r5, r0, #4
 800e598:	4628      	mov	r0, r5
 800e59a:	f7fd ff4f 	bl	800c43c <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800e59e:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800e5a0:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e5a2:	f1c0 0338 	rsb	r3, r0, #56	; 0x38
 800e5a6:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 800e5a8:	4b0a      	ldr	r3, [pc, #40]	; (800e5d4 <xTaskPriorityDisinherit+0x88>)
 800e5aa:	681b      	ldr	r3, [r3, #0]
 800e5ac:	4298      	cmp	r0, r3
 800e5ae:	d901      	bls.n	800e5b4 <xTaskPriorityDisinherit+0x68>
 800e5b0:	4b08      	ldr	r3, [pc, #32]	; (800e5d4 <xTaskPriorityDisinherit+0x88>)
 800e5b2:	6018      	str	r0, [r3, #0]
 800e5b4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e5b8:	4629      	mov	r1, r5
 800e5ba:	4b07      	ldr	r3, [pc, #28]	; (800e5d8 <xTaskPriorityDisinherit+0x8c>)
 800e5bc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e5c0:	f7fd ff18 	bl	800c3f4 <vListInsertEnd>
					xReturn = pdTRUE;
 800e5c4:	2001      	movs	r0, #1
 800e5c6:	e7e5      	b.n	800e594 <xTaskPriorityDisinherit+0x48>
	BaseType_t xReturn = pdFALSE;
 800e5c8:	2000      	movs	r0, #0
	}
 800e5ca:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
 800e5cc:	2000      	movs	r0, #0
 800e5ce:	e7e1      	b.n	800e594 <xTaskPriorityDisinherit+0x48>
 800e5d0:	20000438 	.word	0x20000438
 800e5d4:	200008b8 	.word	0x200008b8
 800e5d8:	20000444 	.word	0x20000444

0800e5dc <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 800e5dc:	2800      	cmp	r0, #0
 800e5de:	d047      	beq.n	800e670 <vTaskPriorityDisinheritAfterTimeout+0x94>
	{
 800e5e0:	b538      	push	{r3, r4, r5, lr}
 800e5e2:	460a      	mov	r2, r1
 800e5e4:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 800e5e6:	6e01      	ldr	r1, [r0, #96]	; 0x60
 800e5e8:	b941      	cbnz	r1, 800e5fc <vTaskPriorityDisinheritAfterTimeout+0x20>
 800e5ea:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e5ee:	f383 8811 	msr	BASEPRI, r3
 800e5f2:	f3bf 8f6f 	isb	sy
 800e5f6:	f3bf 8f4f 	dsb	sy
 800e5fa:	e7fe      	b.n	800e5fa <vTaskPriorityDisinheritAfterTimeout+0x1e>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 800e5fc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800e5fe:	4293      	cmp	r3, r2
 800e600:	d200      	bcs.n	800e604 <vTaskPriorityDisinheritAfterTimeout+0x28>
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 800e602:	4613      	mov	r3, r2
			if( pxTCB->uxPriority != uxPriorityToUse )
 800e604:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e606:	429a      	cmp	r2, r3
 800e608:	d001      	beq.n	800e60e <vTaskPriorityDisinheritAfterTimeout+0x32>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 800e60a:	2901      	cmp	r1, #1
 800e60c:	d000      	beq.n	800e610 <vTaskPriorityDisinheritAfterTimeout+0x34>
	}
 800e60e:	bd38      	pop	{r3, r4, r5, pc}
					configASSERT( pxTCB != pxCurrentTCB );
 800e610:	4918      	ldr	r1, [pc, #96]	; (800e674 <vTaskPriorityDisinheritAfterTimeout+0x98>)
 800e612:	6809      	ldr	r1, [r1, #0]
 800e614:	42a1      	cmp	r1, r4
 800e616:	d022      	beq.n	800e65e <vTaskPriorityDisinheritAfterTimeout+0x82>
					pxTCB->uxPriority = uxPriorityToUse;
 800e618:	62e3      	str	r3, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800e61a:	69a1      	ldr	r1, [r4, #24]
 800e61c:	2900      	cmp	r1, #0
 800e61e:	db02      	blt.n	800e626 <vTaskPriorityDisinheritAfterTimeout+0x4a>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e620:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 800e624:	61a3      	str	r3, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800e626:	6961      	ldr	r1, [r4, #20]
 800e628:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800e62c:	4b12      	ldr	r3, [pc, #72]	; (800e678 <vTaskPriorityDisinheritAfterTimeout+0x9c>)
 800e62e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800e632:	4291      	cmp	r1, r2
 800e634:	d1eb      	bne.n	800e60e <vTaskPriorityDisinheritAfterTimeout+0x32>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800e636:	1d25      	adds	r5, r4, #4
 800e638:	4628      	mov	r0, r5
 800e63a:	f7fd feff 	bl	800c43c <uxListRemove>
						prvAddTaskToReadyList( pxTCB );
 800e63e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800e640:	4b0e      	ldr	r3, [pc, #56]	; (800e67c <vTaskPriorityDisinheritAfterTimeout+0xa0>)
 800e642:	681b      	ldr	r3, [r3, #0]
 800e644:	4298      	cmp	r0, r3
 800e646:	d901      	bls.n	800e64c <vTaskPriorityDisinheritAfterTimeout+0x70>
 800e648:	4b0c      	ldr	r3, [pc, #48]	; (800e67c <vTaskPriorityDisinheritAfterTimeout+0xa0>)
 800e64a:	6018      	str	r0, [r3, #0]
 800e64c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e650:	4629      	mov	r1, r5
 800e652:	4b09      	ldr	r3, [pc, #36]	; (800e678 <vTaskPriorityDisinheritAfterTimeout+0x9c>)
 800e654:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e658:	f7fd fecc 	bl	800c3f4 <vListInsertEnd>
	}
 800e65c:	e7d7      	b.n	800e60e <vTaskPriorityDisinheritAfterTimeout+0x32>
 800e65e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e662:	f383 8811 	msr	BASEPRI, r3
 800e666:	f3bf 8f6f 	isb	sy
 800e66a:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 800e66e:	e7fe      	b.n	800e66e <vTaskPriorityDisinheritAfterTimeout+0x92>
 800e670:	4770      	bx	lr
 800e672:	bf00      	nop
 800e674:	20000438 	.word	0x20000438
 800e678:	20000444 	.word	0x20000444
 800e67c:	200008b8 	.word	0x200008b8

0800e680 <uxTaskResetEventItemValue>:
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 800e680:	4a04      	ldr	r2, [pc, #16]	; (800e694 <uxTaskResetEventItemValue+0x14>)
 800e682:	6813      	ldr	r3, [r2, #0]
 800e684:	6998      	ldr	r0, [r3, #24]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e686:	6813      	ldr	r3, [r2, #0]
 800e688:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e68a:	6812      	ldr	r2, [r2, #0]
 800e68c:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 800e690:	6193      	str	r3, [r2, #24]
}
 800e692:	4770      	bx	lr
 800e694:	20000438 	.word	0x20000438

0800e698 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 800e698:	4b05      	ldr	r3, [pc, #20]	; (800e6b0 <pvTaskIncrementMutexHeldCount+0x18>)
 800e69a:	681b      	ldr	r3, [r3, #0]
 800e69c:	b123      	cbz	r3, 800e6a8 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 800e69e:	4b04      	ldr	r3, [pc, #16]	; (800e6b0 <pvTaskIncrementMutexHeldCount+0x18>)
 800e6a0:	681a      	ldr	r2, [r3, #0]
 800e6a2:	6e13      	ldr	r3, [r2, #96]	; 0x60
 800e6a4:	3301      	adds	r3, #1
 800e6a6:	6613      	str	r3, [r2, #96]	; 0x60
		return pxCurrentTCB;
 800e6a8:	4b01      	ldr	r3, [pc, #4]	; (800e6b0 <pvTaskIncrementMutexHeldCount+0x18>)
 800e6aa:	6818      	ldr	r0, [r3, #0]
	}
 800e6ac:	4770      	bx	lr
 800e6ae:	bf00      	nop
 800e6b0:	20000438 	.word	0x20000438

0800e6b4 <ulTaskNotifyTake>:
	{
 800e6b4:	b538      	push	{r3, r4, r5, lr}
 800e6b6:	4605      	mov	r5, r0
 800e6b8:	460c      	mov	r4, r1
		taskENTER_CRITICAL();
 800e6ba:	f000 fd8d 	bl	800f1d8 <vPortEnterCritical>
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 800e6be:	4b19      	ldr	r3, [pc, #100]	; (800e724 <ulTaskNotifyTake+0x70>)
 800e6c0:	681b      	ldr	r3, [r3, #0]
 800e6c2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e6c4:	b92b      	cbnz	r3, 800e6d2 <ulTaskNotifyTake+0x1e>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 800e6c6:	4b17      	ldr	r3, [pc, #92]	; (800e724 <ulTaskNotifyTake+0x70>)
 800e6c8:	681b      	ldr	r3, [r3, #0]
 800e6ca:	2201      	movs	r2, #1
 800e6cc:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
				if( xTicksToWait > ( TickType_t ) 0 )
 800e6d0:	b9ac      	cbnz	r4, 800e6fe <ulTaskNotifyTake+0x4a>
		taskEXIT_CRITICAL();
 800e6d2:	f000 fda3 	bl	800f21c <vPortExitCritical>
		taskENTER_CRITICAL();
 800e6d6:	f000 fd7f 	bl	800f1d8 <vPortEnterCritical>
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 800e6da:	4b12      	ldr	r3, [pc, #72]	; (800e724 <ulTaskNotifyTake+0x70>)
 800e6dc:	681b      	ldr	r3, [r3, #0]
 800e6de:	6e5c      	ldr	r4, [r3, #100]	; 0x64
			if( ulReturn != 0UL )
 800e6e0:	b124      	cbz	r4, 800e6ec <ulTaskNotifyTake+0x38>
				if( xClearCountOnExit != pdFALSE )
 800e6e2:	b1cd      	cbz	r5, 800e718 <ulTaskNotifyTake+0x64>
					pxCurrentTCB->ulNotifiedValue = 0UL;
 800e6e4:	4b0f      	ldr	r3, [pc, #60]	; (800e724 <ulTaskNotifyTake+0x70>)
 800e6e6:	681b      	ldr	r3, [r3, #0]
 800e6e8:	2200      	movs	r2, #0
 800e6ea:	665a      	str	r2, [r3, #100]	; 0x64
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800e6ec:	4b0d      	ldr	r3, [pc, #52]	; (800e724 <ulTaskNotifyTake+0x70>)
 800e6ee:	681b      	ldr	r3, [r3, #0]
 800e6f0:	2200      	movs	r2, #0
 800e6f2:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		taskEXIT_CRITICAL();
 800e6f6:	f000 fd91 	bl	800f21c <vPortExitCritical>
	}
 800e6fa:	4620      	mov	r0, r4
 800e6fc:	bd38      	pop	{r3, r4, r5, pc}
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800e6fe:	4611      	mov	r1, r2
 800e700:	4620      	mov	r0, r4
 800e702:	f7fe ff6b 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 800e706:	4b08      	ldr	r3, [pc, #32]	; (800e728 <ulTaskNotifyTake+0x74>)
 800e708:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800e70c:	601a      	str	r2, [r3, #0]
 800e70e:	f3bf 8f4f 	dsb	sy
 800e712:	f3bf 8f6f 	isb	sy
 800e716:	e7dc      	b.n	800e6d2 <ulTaskNotifyTake+0x1e>
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 800e718:	4b02      	ldr	r3, [pc, #8]	; (800e724 <ulTaskNotifyTake+0x70>)
 800e71a:	681b      	ldr	r3, [r3, #0]
 800e71c:	1e62      	subs	r2, r4, #1
 800e71e:	665a      	str	r2, [r3, #100]	; 0x64
 800e720:	e7e4      	b.n	800e6ec <ulTaskNotifyTake+0x38>
 800e722:	bf00      	nop
 800e724:	20000438 	.word	0x20000438
 800e728:	e000ed04 	.word	0xe000ed04

0800e72c <xTaskNotifyWait>:
	{
 800e72c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e72e:	4606      	mov	r6, r0
 800e730:	460f      	mov	r7, r1
 800e732:	4614      	mov	r4, r2
 800e734:	461d      	mov	r5, r3
		taskENTER_CRITICAL();
 800e736:	f000 fd4f 	bl	800f1d8 <vPortEnterCritical>
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 800e73a:	4b20      	ldr	r3, [pc, #128]	; (800e7bc <xTaskNotifyWait+0x90>)
 800e73c:	681b      	ldr	r3, [r3, #0]
 800e73e:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 800e742:	b2d2      	uxtb	r2, r2
 800e744:	2a02      	cmp	r2, #2
 800e746:	d00a      	beq.n	800e75e <xTaskNotifyWait+0x32>
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 800e748:	4b1c      	ldr	r3, [pc, #112]	; (800e7bc <xTaskNotifyWait+0x90>)
 800e74a:	681a      	ldr	r2, [r3, #0]
 800e74c:	6e50      	ldr	r0, [r2, #100]	; 0x64
 800e74e:	ea20 0606 	bic.w	r6, r0, r6
 800e752:	6656      	str	r6, [r2, #100]	; 0x64
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 800e754:	681b      	ldr	r3, [r3, #0]
 800e756:	2201      	movs	r2, #1
 800e758:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
				if( xTicksToWait > ( TickType_t ) 0 )
 800e75c:	b9cd      	cbnz	r5, 800e792 <xTaskNotifyWait+0x66>
		taskEXIT_CRITICAL();
 800e75e:	f000 fd5d 	bl	800f21c <vPortExitCritical>
		taskENTER_CRITICAL();
 800e762:	f000 fd39 	bl	800f1d8 <vPortEnterCritical>
			if( pulNotificationValue != NULL )
 800e766:	b11c      	cbz	r4, 800e770 <xTaskNotifyWait+0x44>
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 800e768:	4b14      	ldr	r3, [pc, #80]	; (800e7bc <xTaskNotifyWait+0x90>)
 800e76a:	681b      	ldr	r3, [r3, #0]
 800e76c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e76e:	6023      	str	r3, [r4, #0]
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 800e770:	4b12      	ldr	r3, [pc, #72]	; (800e7bc <xTaskNotifyWait+0x90>)
 800e772:	681b      	ldr	r3, [r3, #0]
 800e774:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 800e778:	b2db      	uxtb	r3, r3
 800e77a:	2b02      	cmp	r3, #2
 800e77c:	d016      	beq.n	800e7ac <xTaskNotifyWait+0x80>
				xReturn = pdFALSE;
 800e77e:	2400      	movs	r4, #0
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800e780:	4b0e      	ldr	r3, [pc, #56]	; (800e7bc <xTaskNotifyWait+0x90>)
 800e782:	681b      	ldr	r3, [r3, #0]
 800e784:	2200      	movs	r2, #0
 800e786:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		taskEXIT_CRITICAL();
 800e78a:	f000 fd47 	bl	800f21c <vPortExitCritical>
	}
 800e78e:	4620      	mov	r0, r4
 800e790:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800e792:	4611      	mov	r1, r2
 800e794:	4628      	mov	r0, r5
 800e796:	f7fe ff21 	bl	800d5dc <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 800e79a:	4b09      	ldr	r3, [pc, #36]	; (800e7c0 <xTaskNotifyWait+0x94>)
 800e79c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800e7a0:	601a      	str	r2, [r3, #0]
 800e7a2:	f3bf 8f4f 	dsb	sy
 800e7a6:	f3bf 8f6f 	isb	sy
 800e7aa:	e7d8      	b.n	800e75e <xTaskNotifyWait+0x32>
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 800e7ac:	4b03      	ldr	r3, [pc, #12]	; (800e7bc <xTaskNotifyWait+0x90>)
 800e7ae:	681b      	ldr	r3, [r3, #0]
 800e7b0:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800e7b2:	ea21 0707 	bic.w	r7, r1, r7
 800e7b6:	665f      	str	r7, [r3, #100]	; 0x64
				xReturn = pdTRUE;
 800e7b8:	2401      	movs	r4, #1
 800e7ba:	e7e1      	b.n	800e780 <xTaskNotifyWait+0x54>
 800e7bc:	20000438 	.word	0x20000438
 800e7c0:	e000ed04 	.word	0xe000ed04

0800e7c4 <xTaskGenericNotify>:
	{
 800e7c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( xTaskToNotify );
 800e7c6:	b1a8      	cbz	r0, 800e7f4 <xTaskGenericNotify+0x30>
 800e7c8:	460e      	mov	r6, r1
 800e7ca:	4615      	mov	r5, r2
 800e7cc:	461f      	mov	r7, r3
 800e7ce:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 800e7d0:	f000 fd02 	bl	800f1d8 <vPortEnterCritical>
			if( pulPreviousNotificationValue != NULL )
 800e7d4:	b10f      	cbz	r7, 800e7da <xTaskGenericNotify+0x16>
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 800e7d6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800e7d8:	603b      	str	r3, [r7, #0]
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800e7da:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800e7de:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800e7e0:	2202      	movs	r2, #2
 800e7e2:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			switch( eAction )
 800e7e6:	1e6a      	subs	r2, r5, #1
 800e7e8:	2a03      	cmp	r2, #3
 800e7ea:	d823      	bhi.n	800e834 <xTaskGenericNotify+0x70>
 800e7ec:	e8df f002 	tbb	[pc, r2]
 800e7f0:	1d1a150b 	.word	0x1d1a150b
 800e7f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e7f8:	f383 8811 	msr	BASEPRI, r3
 800e7fc:	f3bf 8f6f 	isb	sy
 800e800:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToNotify );
 800e804:	e7fe      	b.n	800e804 <xTaskGenericNotify+0x40>
					pxTCB->ulNotifiedValue |= ulValue;
 800e806:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800e808:	4316      	orrs	r6, r2
 800e80a:	6666      	str	r6, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e80c:	2501      	movs	r5, #1
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800e80e:	2b01      	cmp	r3, #1
 800e810:	d014      	beq.n	800e83c <xTaskGenericNotify+0x78>
		taskEXIT_CRITICAL();
 800e812:	f000 fd03 	bl	800f21c <vPortExitCritical>
	}
 800e816:	4628      	mov	r0, r5
 800e818:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					( pxTCB->ulNotifiedValue )++;
 800e81a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800e81c:	3201      	adds	r2, #1
 800e81e:	6662      	str	r2, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e820:	2501      	movs	r5, #1
					break;
 800e822:	e7f4      	b.n	800e80e <xTaskGenericNotify+0x4a>
					pxTCB->ulNotifiedValue = ulValue;
 800e824:	6666      	str	r6, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e826:	2501      	movs	r5, #1
					break;
 800e828:	e7f1      	b.n	800e80e <xTaskGenericNotify+0x4a>
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 800e82a:	2b02      	cmp	r3, #2
 800e82c:	d004      	beq.n	800e838 <xTaskGenericNotify+0x74>
						pxTCB->ulNotifiedValue = ulValue;
 800e82e:	6666      	str	r6, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e830:	2501      	movs	r5, #1
 800e832:	e7ec      	b.n	800e80e <xTaskGenericNotify+0x4a>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800e834:	2501      	movs	r5, #1
 800e836:	e7ea      	b.n	800e80e <xTaskGenericNotify+0x4a>
						xReturn = pdFAIL;
 800e838:	2500      	movs	r5, #0
 800e83a:	e7e8      	b.n	800e80e <xTaskGenericNotify+0x4a>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800e83c:	1d26      	adds	r6, r4, #4
 800e83e:	4630      	mov	r0, r6
 800e840:	f7fd fdfc 	bl	800c43c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 800e844:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800e846:	4b14      	ldr	r3, [pc, #80]	; (800e898 <xTaskGenericNotify+0xd4>)
 800e848:	681b      	ldr	r3, [r3, #0]
 800e84a:	4298      	cmp	r0, r3
 800e84c:	d901      	bls.n	800e852 <xTaskGenericNotify+0x8e>
 800e84e:	4b12      	ldr	r3, [pc, #72]	; (800e898 <xTaskGenericNotify+0xd4>)
 800e850:	6018      	str	r0, [r3, #0]
 800e852:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e856:	4631      	mov	r1, r6
 800e858:	4b10      	ldr	r3, [pc, #64]	; (800e89c <xTaskGenericNotify+0xd8>)
 800e85a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e85e:	f7fd fdc9 	bl	800c3f4 <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800e862:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800e864:	b143      	cbz	r3, 800e878 <xTaskGenericNotify+0xb4>
 800e866:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e86a:	f383 8811 	msr	BASEPRI, r3
 800e86e:	f3bf 8f6f 	isb	sy
 800e872:	f3bf 8f4f 	dsb	sy
 800e876:	e7fe      	b.n	800e876 <xTaskGenericNotify+0xb2>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800e878:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e87a:	4b09      	ldr	r3, [pc, #36]	; (800e8a0 <xTaskGenericNotify+0xdc>)
 800e87c:	681b      	ldr	r3, [r3, #0]
 800e87e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e880:	429a      	cmp	r2, r3
 800e882:	d9c6      	bls.n	800e812 <xTaskGenericNotify+0x4e>
					taskYIELD_IF_USING_PREEMPTION();
 800e884:	4b07      	ldr	r3, [pc, #28]	; (800e8a4 <xTaskGenericNotify+0xe0>)
 800e886:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800e88a:	601a      	str	r2, [r3, #0]
 800e88c:	f3bf 8f4f 	dsb	sy
 800e890:	f3bf 8f6f 	isb	sy
 800e894:	e7bd      	b.n	800e812 <xTaskGenericNotify+0x4e>
 800e896:	bf00      	nop
 800e898:	200008b8 	.word	0x200008b8
 800e89c:	20000444 	.word	0x20000444
 800e8a0:	20000438 	.word	0x20000438
 800e8a4:	e000ed04 	.word	0xe000ed04

0800e8a8 <xTaskGenericNotifyFromISR>:
	{
 800e8a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800e8ac:	9e08      	ldr	r6, [sp, #32]
		configASSERT( xTaskToNotify );
 800e8ae:	b310      	cbz	r0, 800e8f6 <xTaskGenericNotifyFromISR+0x4e>
 800e8b0:	4688      	mov	r8, r1
 800e8b2:	4615      	mov	r5, r2
 800e8b4:	4699      	mov	r9, r3
 800e8b6:	4604      	mov	r4, r0
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800e8b8:	f000 fd7a 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800e8bc:	f3ef 8711 	mrs	r7, BASEPRI
 800e8c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e8c4:	f383 8811 	msr	BASEPRI, r3
 800e8c8:	f3bf 8f6f 	isb	sy
 800e8cc:	f3bf 8f4f 	dsb	sy
			if( pulPreviousNotificationValue != NULL )
 800e8d0:	f1b9 0f00 	cmp.w	r9, #0
 800e8d4:	d002      	beq.n	800e8dc <xTaskGenericNotifyFromISR+0x34>
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 800e8d6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800e8d8:	f8c9 3000 	str.w	r3, [r9]
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800e8dc:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800e8e0:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800e8e2:	2202      	movs	r2, #2
 800e8e4:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			switch( eAction )
 800e8e8:	1e6a      	subs	r2, r5, #1
 800e8ea:	2a03      	cmp	r2, #3
 800e8ec:	d827      	bhi.n	800e93e <xTaskGenericNotifyFromISR+0x96>
 800e8ee:	e8df f002 	tbb	[pc, r2]
 800e8f2:	170b      	.short	0x170b
 800e8f4:	201c      	.short	0x201c
	__asm volatile
 800e8f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e8fa:	f383 8811 	msr	BASEPRI, r3
 800e8fe:	f3bf 8f6f 	isb	sy
 800e902:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToNotify );
 800e906:	e7fe      	b.n	800e906 <xTaskGenericNotifyFromISR+0x5e>
					pxTCB->ulNotifiedValue |= ulValue;
 800e908:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800e90a:	ea42 0208 	orr.w	r2, r2, r8
 800e90e:	6662      	str	r2, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e910:	2501      	movs	r5, #1
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800e912:	2b01      	cmp	r3, #1
 800e914:	d017      	beq.n	800e946 <xTaskGenericNotifyFromISR+0x9e>
	__asm volatile
 800e916:	f387 8811 	msr	BASEPRI, r7
	}
 800e91a:	4628      	mov	r0, r5
 800e91c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					( pxTCB->ulNotifiedValue )++;
 800e920:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800e922:	3201      	adds	r2, #1
 800e924:	6662      	str	r2, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e926:	2501      	movs	r5, #1
					break;
 800e928:	e7f3      	b.n	800e912 <xTaskGenericNotifyFromISR+0x6a>
					pxTCB->ulNotifiedValue = ulValue;
 800e92a:	f8c4 8064 	str.w	r8, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e92e:	2501      	movs	r5, #1
					break;
 800e930:	e7ef      	b.n	800e912 <xTaskGenericNotifyFromISR+0x6a>
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 800e932:	2b02      	cmp	r3, #2
 800e934:	d005      	beq.n	800e942 <xTaskGenericNotifyFromISR+0x9a>
						pxTCB->ulNotifiedValue = ulValue;
 800e936:	f8c4 8064 	str.w	r8, [r4, #100]	; 0x64
	BaseType_t xReturn = pdPASS;
 800e93a:	2501      	movs	r5, #1
 800e93c:	e7e9      	b.n	800e912 <xTaskGenericNotifyFromISR+0x6a>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800e93e:	2501      	movs	r5, #1
 800e940:	e7e7      	b.n	800e912 <xTaskGenericNotifyFromISR+0x6a>
						xReturn = pdFAIL;
 800e942:	2500      	movs	r5, #0
 800e944:	e7e5      	b.n	800e912 <xTaskGenericNotifyFromISR+0x6a>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800e946:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800e948:	b143      	cbz	r3, 800e95c <xTaskGenericNotifyFromISR+0xb4>
	__asm volatile
 800e94a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e94e:	f383 8811 	msr	BASEPRI, r3
 800e952:	f3bf 8f6f 	isb	sy
 800e956:	f3bf 8f4f 	dsb	sy
 800e95a:	e7fe      	b.n	800e95a <xTaskGenericNotifyFromISR+0xb2>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800e95c:	4b15      	ldr	r3, [pc, #84]	; (800e9b4 <xTaskGenericNotifyFromISR+0x10c>)
 800e95e:	681b      	ldr	r3, [r3, #0]
 800e960:	b9eb      	cbnz	r3, 800e99e <xTaskGenericNotifyFromISR+0xf6>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800e962:	f104 0804 	add.w	r8, r4, #4
 800e966:	4640      	mov	r0, r8
 800e968:	f7fd fd68 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800e96c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800e96e:	4b12      	ldr	r3, [pc, #72]	; (800e9b8 <xTaskGenericNotifyFromISR+0x110>)
 800e970:	681b      	ldr	r3, [r3, #0]
 800e972:	4298      	cmp	r0, r3
 800e974:	d901      	bls.n	800e97a <xTaskGenericNotifyFromISR+0xd2>
 800e976:	4b10      	ldr	r3, [pc, #64]	; (800e9b8 <xTaskGenericNotifyFromISR+0x110>)
 800e978:	6018      	str	r0, [r3, #0]
 800e97a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800e97e:	4641      	mov	r1, r8
 800e980:	4b0e      	ldr	r3, [pc, #56]	; (800e9bc <xTaskGenericNotifyFromISR+0x114>)
 800e982:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800e986:	f7fd fd35 	bl	800c3f4 <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800e98a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e98c:	4b0c      	ldr	r3, [pc, #48]	; (800e9c0 <xTaskGenericNotifyFromISR+0x118>)
 800e98e:	681b      	ldr	r3, [r3, #0]
 800e990:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e992:	429a      	cmp	r2, r3
 800e994:	d9bf      	bls.n	800e916 <xTaskGenericNotifyFromISR+0x6e>
					if( pxHigherPriorityTaskWoken != NULL )
 800e996:	b146      	cbz	r6, 800e9aa <xTaskGenericNotifyFromISR+0x102>
						*pxHigherPriorityTaskWoken = pdTRUE;
 800e998:	2301      	movs	r3, #1
 800e99a:	6033      	str	r3, [r6, #0]
 800e99c:	e7bb      	b.n	800e916 <xTaskGenericNotifyFromISR+0x6e>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800e99e:	f104 0118 	add.w	r1, r4, #24
 800e9a2:	4808      	ldr	r0, [pc, #32]	; (800e9c4 <xTaskGenericNotifyFromISR+0x11c>)
 800e9a4:	f7fd fd26 	bl	800c3f4 <vListInsertEnd>
 800e9a8:	e7ef      	b.n	800e98a <xTaskGenericNotifyFromISR+0xe2>
						xYieldPending = pdTRUE;
 800e9aa:	4b07      	ldr	r3, [pc, #28]	; (800e9c8 <xTaskGenericNotifyFromISR+0x120>)
 800e9ac:	2201      	movs	r2, #1
 800e9ae:	601a      	str	r2, [r3, #0]
 800e9b0:	e7b1      	b.n	800e916 <xTaskGenericNotifyFromISR+0x6e>
 800e9b2:	bf00      	nop
 800e9b4:	200008b0 	.word	0x200008b0
 800e9b8:	200008b8 	.word	0x200008b8
 800e9bc:	20000444 	.word	0x20000444
 800e9c0:	20000438 	.word	0x20000438
 800e9c4:	200008ec 	.word	0x200008ec
 800e9c8:	20000930 	.word	0x20000930

0800e9cc <vTaskNotifyGiveFromISR>:
	{
 800e9cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( xTaskToNotify );
 800e9ce:	b1d8      	cbz	r0, 800ea08 <vTaskNotifyGiveFromISR+0x3c>
 800e9d0:	460d      	mov	r5, r1
 800e9d2:	4604      	mov	r4, r0
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800e9d4:	f000 fcec 	bl	800f3b0 <vPortValidateInterruptPriority>
	__asm volatile
 800e9d8:	f3ef 8611 	mrs	r6, BASEPRI
 800e9dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 800e9e0:	f383 8811 	msr	BASEPRI, r3
 800e9e4:	f3bf 8f6f 	isb	sy
 800e9e8:	f3bf 8f4f 	dsb	sy
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800e9ec:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800e9f0:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800e9f2:	2202      	movs	r2, #2
 800e9f4:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			( pxTCB->ulNotifiedValue )++;
 800e9f8:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800e9fa:	3201      	adds	r2, #1
 800e9fc:	6662      	str	r2, [r4, #100]	; 0x64
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800e9fe:	2b01      	cmp	r3, #1
 800ea00:	d00b      	beq.n	800ea1a <vTaskNotifyGiveFromISR+0x4e>
	__asm volatile
 800ea02:	f386 8811 	msr	BASEPRI, r6
	}
 800ea06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__asm volatile
 800ea08:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ea0c:	f383 8811 	msr	BASEPRI, r3
 800ea10:	f3bf 8f6f 	isb	sy
 800ea14:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToNotify );
 800ea18:	e7fe      	b.n	800ea18 <vTaskNotifyGiveFromISR+0x4c>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800ea1a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ea1c:	b143      	cbz	r3, 800ea30 <vTaskNotifyGiveFromISR+0x64>
 800ea1e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ea22:	f383 8811 	msr	BASEPRI, r3
 800ea26:	f3bf 8f6f 	isb	sy
 800ea2a:	f3bf 8f4f 	dsb	sy
 800ea2e:	e7fe      	b.n	800ea2e <vTaskNotifyGiveFromISR+0x62>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800ea30:	4b14      	ldr	r3, [pc, #80]	; (800ea84 <vTaskNotifyGiveFromISR+0xb8>)
 800ea32:	681b      	ldr	r3, [r3, #0]
 800ea34:	b9e3      	cbnz	r3, 800ea70 <vTaskNotifyGiveFromISR+0xa4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800ea36:	1d27      	adds	r7, r4, #4
 800ea38:	4638      	mov	r0, r7
 800ea3a:	f7fd fcff 	bl	800c43c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800ea3e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800ea40:	4b11      	ldr	r3, [pc, #68]	; (800ea88 <vTaskNotifyGiveFromISR+0xbc>)
 800ea42:	681b      	ldr	r3, [r3, #0]
 800ea44:	4298      	cmp	r0, r3
 800ea46:	d901      	bls.n	800ea4c <vTaskNotifyGiveFromISR+0x80>
 800ea48:	4b0f      	ldr	r3, [pc, #60]	; (800ea88 <vTaskNotifyGiveFromISR+0xbc>)
 800ea4a:	6018      	str	r0, [r3, #0]
 800ea4c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800ea50:	4639      	mov	r1, r7
 800ea52:	4b0e      	ldr	r3, [pc, #56]	; (800ea8c <vTaskNotifyGiveFromISR+0xc0>)
 800ea54:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800ea58:	f7fd fccc 	bl	800c3f4 <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800ea5c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ea5e:	4b0c      	ldr	r3, [pc, #48]	; (800ea90 <vTaskNotifyGiveFromISR+0xc4>)
 800ea60:	681b      	ldr	r3, [r3, #0]
 800ea62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ea64:	429a      	cmp	r2, r3
 800ea66:	d9cc      	bls.n	800ea02 <vTaskNotifyGiveFromISR+0x36>
					if( pxHigherPriorityTaskWoken != NULL )
 800ea68:	b145      	cbz	r5, 800ea7c <vTaskNotifyGiveFromISR+0xb0>
						*pxHigherPriorityTaskWoken = pdTRUE;
 800ea6a:	2301      	movs	r3, #1
 800ea6c:	602b      	str	r3, [r5, #0]
 800ea6e:	e7c8      	b.n	800ea02 <vTaskNotifyGiveFromISR+0x36>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800ea70:	f104 0118 	add.w	r1, r4, #24
 800ea74:	4807      	ldr	r0, [pc, #28]	; (800ea94 <vTaskNotifyGiveFromISR+0xc8>)
 800ea76:	f7fd fcbd 	bl	800c3f4 <vListInsertEnd>
 800ea7a:	e7ef      	b.n	800ea5c <vTaskNotifyGiveFromISR+0x90>
						xYieldPending = pdTRUE;
 800ea7c:	4b06      	ldr	r3, [pc, #24]	; (800ea98 <vTaskNotifyGiveFromISR+0xcc>)
 800ea7e:	2201      	movs	r2, #1
 800ea80:	601a      	str	r2, [r3, #0]
 800ea82:	e7be      	b.n	800ea02 <vTaskNotifyGiveFromISR+0x36>
 800ea84:	200008b0 	.word	0x200008b0
 800ea88:	200008b8 	.word	0x200008b8
 800ea8c:	20000444 	.word	0x20000444
 800ea90:	20000438 	.word	0x20000438
 800ea94:	200008ec 	.word	0x200008ec
 800ea98:	20000930 	.word	0x20000930

0800ea9c <xTaskNotifyStateClear>:
	{
 800ea9c:	b510      	push	{r4, lr}
		pxTCB = prvGetTCBFromHandle( xTask );
 800ea9e:	4604      	mov	r4, r0
 800eaa0:	b158      	cbz	r0, 800eaba <xTaskNotifyStateClear+0x1e>
		taskENTER_CRITICAL();
 800eaa2:	f000 fb99 	bl	800f1d8 <vPortEnterCritical>
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 800eaa6:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800eaaa:	b2db      	uxtb	r3, r3
 800eaac:	2b02      	cmp	r3, #2
 800eaae:	d007      	beq.n	800eac0 <xTaskNotifyStateClear+0x24>
				xReturn = pdFAIL;
 800eab0:	2400      	movs	r4, #0
		taskEXIT_CRITICAL();
 800eab2:	f000 fbb3 	bl	800f21c <vPortExitCritical>
	}
 800eab6:	4620      	mov	r0, r4
 800eab8:	bd10      	pop	{r4, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 800eaba:	4b04      	ldr	r3, [pc, #16]	; (800eacc <xTaskNotifyStateClear+0x30>)
 800eabc:	681c      	ldr	r4, [r3, #0]
 800eabe:	e7f0      	b.n	800eaa2 <xTaskNotifyStateClear+0x6>
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800eac0:	2300      	movs	r3, #0
 800eac2:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
				xReturn = pdPASS;
 800eac6:	2401      	movs	r4, #1
 800eac8:	e7f3      	b.n	800eab2 <xTaskNotifyStateClear+0x16>
 800eaca:	bf00      	nop
 800eacc:	20000438 	.word	0x20000438

0800ead0 <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800ead0:	4b06      	ldr	r3, [pc, #24]	; (800eaec <prvGetNextExpireTime+0x1c>)
 800ead2:	681a      	ldr	r2, [r3, #0]
 800ead4:	6813      	ldr	r3, [r2, #0]
 800ead6:	fab3 f383 	clz	r3, r3
 800eada:	095b      	lsrs	r3, r3, #5
 800eadc:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
 800eade:	b913      	cbnz	r3, 800eae6 <prvGetNextExpireTime+0x16>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800eae0:	68d3      	ldr	r3, [r2, #12]
 800eae2:	6818      	ldr	r0, [r3, #0]
 800eae4:	4770      	bx	lr
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 800eae6:	2000      	movs	r0, #0
	}

	return xNextExpireTime;
}
 800eae8:	4770      	bx	lr
 800eaea:	bf00      	nop
 800eaec:	20000934 	.word	0x20000934

0800eaf0 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 800eaf0:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800eaf2:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800eaf4:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
 800eaf6:	4291      	cmp	r1, r2
 800eaf8:	d80c      	bhi.n	800eb14 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800eafa:	1ad2      	subs	r2, r2, r3
 800eafc:	6983      	ldr	r3, [r0, #24]
 800eafe:	429a      	cmp	r2, r3
 800eb00:	d301      	bcc.n	800eb06 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 800eb02:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 800eb04:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800eb06:	1d01      	adds	r1, r0, #4
 800eb08:	4b09      	ldr	r3, [pc, #36]	; (800eb30 <prvInsertTimerInActiveList+0x40>)
 800eb0a:	6818      	ldr	r0, [r3, #0]
 800eb0c:	f7fd fc7d 	bl	800c40a <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 800eb10:	2000      	movs	r0, #0
 800eb12:	e7f7      	b.n	800eb04 <prvInsertTimerInActiveList+0x14>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800eb14:	429a      	cmp	r2, r3
 800eb16:	d201      	bcs.n	800eb1c <prvInsertTimerInActiveList+0x2c>
 800eb18:	4299      	cmp	r1, r3
 800eb1a:	d206      	bcs.n	800eb2a <prvInsertTimerInActiveList+0x3a>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800eb1c:	1d01      	adds	r1, r0, #4
 800eb1e:	4b05      	ldr	r3, [pc, #20]	; (800eb34 <prvInsertTimerInActiveList+0x44>)
 800eb20:	6818      	ldr	r0, [r3, #0]
 800eb22:	f7fd fc72 	bl	800c40a <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 800eb26:	2000      	movs	r0, #0
 800eb28:	e7ec      	b.n	800eb04 <prvInsertTimerInActiveList+0x14>
			xProcessTimerNow = pdTRUE;
 800eb2a:	2001      	movs	r0, #1
	return xProcessTimerNow;
 800eb2c:	e7ea      	b.n	800eb04 <prvInsertTimerInActiveList+0x14>
 800eb2e:	bf00      	nop
 800eb30:	20000938 	.word	0x20000938
 800eb34:	20000934 	.word	0x20000934

0800eb38 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 800eb38:	b530      	push	{r4, r5, lr}
 800eb3a:	b083      	sub	sp, #12
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 800eb3c:	f000 fb4c 	bl	800f1d8 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 800eb40:	4b11      	ldr	r3, [pc, #68]	; (800eb88 <prvCheckForValidListAndQueue+0x50>)
 800eb42:	681b      	ldr	r3, [r3, #0]
 800eb44:	b11b      	cbz	r3, 800eb4e <prvCheckForValidListAndQueue+0x16>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800eb46:	f000 fb69 	bl	800f21c <vPortExitCritical>
}
 800eb4a:	b003      	add	sp, #12
 800eb4c:	bd30      	pop	{r4, r5, pc}
			vListInitialise( &xActiveTimerList1 );
 800eb4e:	4d0f      	ldr	r5, [pc, #60]	; (800eb8c <prvCheckForValidListAndQueue+0x54>)
 800eb50:	4628      	mov	r0, r5
 800eb52:	f7fd fc41 	bl	800c3d8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 800eb56:	4c0e      	ldr	r4, [pc, #56]	; (800eb90 <prvCheckForValidListAndQueue+0x58>)
 800eb58:	4620      	mov	r0, r4
 800eb5a:	f7fd fc3d 	bl	800c3d8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800eb5e:	4b0d      	ldr	r3, [pc, #52]	; (800eb94 <prvCheckForValidListAndQueue+0x5c>)
 800eb60:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 800eb62:	4b0d      	ldr	r3, [pc, #52]	; (800eb98 <prvCheckForValidListAndQueue+0x60>)
 800eb64:	601c      	str	r4, [r3, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800eb66:	2300      	movs	r3, #0
 800eb68:	9300      	str	r3, [sp, #0]
 800eb6a:	4b0c      	ldr	r3, [pc, #48]	; (800eb9c <prvCheckForValidListAndQueue+0x64>)
 800eb6c:	4a0c      	ldr	r2, [pc, #48]	; (800eba0 <prvCheckForValidListAndQueue+0x68>)
 800eb6e:	2110      	movs	r1, #16
 800eb70:	200a      	movs	r0, #10
 800eb72:	f7fd fd72 	bl	800c65a <xQueueGenericCreateStatic>
 800eb76:	4b04      	ldr	r3, [pc, #16]	; (800eb88 <prvCheckForValidListAndQueue+0x50>)
 800eb78:	6018      	str	r0, [r3, #0]
				if( xTimerQueue != NULL )
 800eb7a:	2800      	cmp	r0, #0
 800eb7c:	d0e3      	beq.n	800eb46 <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800eb7e:	4909      	ldr	r1, [pc, #36]	; (800eba4 <prvCheckForValidListAndQueue+0x6c>)
 800eb80:	f7fe fb46 	bl	800d210 <vQueueAddToRegistry>
 800eb84:	e7df      	b.n	800eb46 <prvCheckForValidListAndQueue+0xe>
 800eb86:	bf00      	nop
 800eb88:	20000a58 	.word	0x20000a58
 800eb8c:	200009dc 	.word	0x200009dc
 800eb90:	200009f0 	.word	0x200009f0
 800eb94:	20000934 	.word	0x20000934
 800eb98:	20000938 	.word	0x20000938
 800eb9c:	20000a08 	.word	0x20000a08
 800eba0:	2000093c 	.word	0x2000093c
 800eba4:	0800feb0 	.word	0x0800feb0

0800eba8 <prvInitialiseNewTimer>:
{
 800eba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ebac:	9c07      	ldr	r4, [sp, #28]
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800ebae:	b941      	cbnz	r1, 800ebc2 <prvInitialiseNewTimer+0x1a>
 800ebb0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ebb4:	f383 8811 	msr	BASEPRI, r3
 800ebb8:	f3bf 8f6f 	isb	sy
 800ebbc:	f3bf 8f4f 	dsb	sy
 800ebc0:	e7fe      	b.n	800ebc0 <prvInitialiseNewTimer+0x18>
 800ebc2:	4607      	mov	r7, r0
 800ebc4:	4616      	mov	r6, r2
 800ebc6:	461d      	mov	r5, r3
 800ebc8:	4688      	mov	r8, r1
	if( pxNewTimer != NULL )
 800ebca:	b15c      	cbz	r4, 800ebe4 <prvInitialiseNewTimer+0x3c>
		prvCheckForValidListAndQueue();
 800ebcc:	f7ff ffb4 	bl	800eb38 <prvCheckForValidListAndQueue>
		pxNewTimer->pcTimerName = pcTimerName;
 800ebd0:	6027      	str	r7, [r4, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 800ebd2:	f8c4 8018 	str.w	r8, [r4, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
 800ebd6:	61e6      	str	r6, [r4, #28]
		pxNewTimer->pvTimerID = pvTimerID;
 800ebd8:	6225      	str	r5, [r4, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800ebda:	9b06      	ldr	r3, [sp, #24]
 800ebdc:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 800ebde:	1d20      	adds	r0, r4, #4
 800ebe0:	f7fd fc05 	bl	800c3ee <vListInitialiseItem>
}
 800ebe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ebe8 <xTimerCreateTimerTask>:
{
 800ebe8:	b510      	push	{r4, lr}
 800ebea:	b088      	sub	sp, #32
	prvCheckForValidListAndQueue();
 800ebec:	f7ff ffa4 	bl	800eb38 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 800ebf0:	4b12      	ldr	r3, [pc, #72]	; (800ec3c <xTimerCreateTimerTask+0x54>)
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	b1cb      	cbz	r3, 800ec2a <xTimerCreateTimerTask+0x42>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 800ebf6:	2400      	movs	r4, #0
 800ebf8:	9405      	str	r4, [sp, #20]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 800ebfa:	9406      	str	r4, [sp, #24]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 800ebfc:	aa07      	add	r2, sp, #28
 800ebfe:	a906      	add	r1, sp, #24
 800ec00:	a805      	add	r0, sp, #20
 800ec02:	f7fd f9eb 	bl	800bfdc <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 800ec06:	9b05      	ldr	r3, [sp, #20]
 800ec08:	9302      	str	r3, [sp, #8]
 800ec0a:	9b06      	ldr	r3, [sp, #24]
 800ec0c:	9301      	str	r3, [sp, #4]
 800ec0e:	2302      	movs	r3, #2
 800ec10:	9300      	str	r3, [sp, #0]
 800ec12:	4623      	mov	r3, r4
 800ec14:	9a07      	ldr	r2, [sp, #28]
 800ec16:	490a      	ldr	r1, [pc, #40]	; (800ec40 <xTimerCreateTimerTask+0x58>)
 800ec18:	480a      	ldr	r0, [pc, #40]	; (800ec44 <xTimerCreateTimerTask+0x5c>)
 800ec1a:	f7fe fd1d 	bl	800d658 <xTaskCreateStatic>
 800ec1e:	4a0a      	ldr	r2, [pc, #40]	; (800ec48 <xTimerCreateTimerTask+0x60>)
 800ec20:	6010      	str	r0, [r2, #0]
			if( xTimerTaskHandle != NULL )
 800ec22:	b110      	cbz	r0, 800ec2a <xTimerCreateTimerTask+0x42>
}
 800ec24:	2001      	movs	r0, #1
 800ec26:	b008      	add	sp, #32
 800ec28:	bd10      	pop	{r4, pc}
 800ec2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ec2e:	f383 8811 	msr	BASEPRI, r3
 800ec32:	f3bf 8f6f 	isb	sy
 800ec36:	f3bf 8f4f 	dsb	sy
	configASSERT( xReturn );
 800ec3a:	e7fe      	b.n	800ec3a <xTimerCreateTimerTask+0x52>
 800ec3c:	20000a58 	.word	0x20000a58
 800ec40:	0800feb8 	.word	0x0800feb8
 800ec44:	0800efad 	.word	0x0800efad
 800ec48:	20000a5c 	.word	0x20000a5c

0800ec4c <xTimerCreate>:
	{
 800ec4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ec50:	b082      	sub	sp, #8
 800ec52:	4604      	mov	r4, r0
 800ec54:	4688      	mov	r8, r1
 800ec56:	4615      	mov	r5, r2
 800ec58:	461e      	mov	r6, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 800ec5a:	2030      	movs	r0, #48	; 0x30
 800ec5c:	f000 fc36 	bl	800f4cc <pvPortMalloc>
		if( pxNewTimer != NULL )
 800ec60:	4607      	mov	r7, r0
 800ec62:	b158      	cbz	r0, 800ec7c <xTimerCreate+0x30>
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 800ec64:	9001      	str	r0, [sp, #4]
 800ec66:	9b08      	ldr	r3, [sp, #32]
 800ec68:	9300      	str	r3, [sp, #0]
 800ec6a:	4633      	mov	r3, r6
 800ec6c:	462a      	mov	r2, r5
 800ec6e:	4641      	mov	r1, r8
 800ec70:	4620      	mov	r0, r4
 800ec72:	f7ff ff99 	bl	800eba8 <prvInitialiseNewTimer>
				pxNewTimer->ucStaticallyAllocated = pdFALSE;
 800ec76:	2300      	movs	r3, #0
 800ec78:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
	}
 800ec7c:	4638      	mov	r0, r7
 800ec7e:	b002      	add	sp, #8
 800ec80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ec84 <xTimerCreateStatic>:
	{
 800ec84:	b530      	push	{r4, r5, lr}
 800ec86:	b085      	sub	sp, #20
 800ec88:	9c09      	ldr	r4, [sp, #36]	; 0x24
			volatile size_t xSize = sizeof( StaticTimer_t );
 800ec8a:	2530      	movs	r5, #48	; 0x30
 800ec8c:	9503      	str	r5, [sp, #12]
			configASSERT( xSize == sizeof( Timer_t ) );
 800ec8e:	9d03      	ldr	r5, [sp, #12]
 800ec90:	2d30      	cmp	r5, #48	; 0x30
 800ec92:	d008      	beq.n	800eca6 <xTimerCreateStatic+0x22>
 800ec94:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ec98:	f383 8811 	msr	BASEPRI, r3
 800ec9c:	f3bf 8f6f 	isb	sy
 800eca0:	f3bf 8f4f 	dsb	sy
 800eca4:	e7fe      	b.n	800eca4 <xTimerCreateStatic+0x20>
		configASSERT( pxTimerBuffer );
 800eca6:	b154      	cbz	r4, 800ecbe <xTimerCreateStatic+0x3a>
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 800eca8:	9401      	str	r4, [sp, #4]
 800ecaa:	9d08      	ldr	r5, [sp, #32]
 800ecac:	9500      	str	r5, [sp, #0]
 800ecae:	f7ff ff7b 	bl	800eba8 <prvInitialiseNewTimer>
				pxNewTimer->ucStaticallyAllocated = pdTRUE;
 800ecb2:	2301      	movs	r3, #1
 800ecb4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	}
 800ecb8:	4620      	mov	r0, r4
 800ecba:	b005      	add	sp, #20
 800ecbc:	bd30      	pop	{r4, r5, pc}
 800ecbe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ecc2:	f383 8811 	msr	BASEPRI, r3
 800ecc6:	f3bf 8f6f 	isb	sy
 800ecca:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTimerBuffer );
 800ecce:	e7fe      	b.n	800ecce <xTimerCreateStatic+0x4a>

0800ecd0 <xTimerGenericCommand>:
	configASSERT( xTimer );
 800ecd0:	b1c0      	cbz	r0, 800ed04 <xTimerGenericCommand+0x34>
{
 800ecd2:	b510      	push	{r4, lr}
 800ecd4:	b084      	sub	sp, #16
 800ecd6:	4614      	mov	r4, r2
 800ecd8:	461a      	mov	r2, r3
 800ecda:	4603      	mov	r3, r0
	if( xTimerQueue != NULL )
 800ecdc:	4816      	ldr	r0, [pc, #88]	; (800ed38 <xTimerGenericCommand+0x68>)
 800ecde:	6800      	ldr	r0, [r0, #0]
 800ece0:	b338      	cbz	r0, 800ed32 <xTimerGenericCommand+0x62>
		xMessage.xMessageID = xCommandID;
 800ece2:	9100      	str	r1, [sp, #0]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800ece4:	9401      	str	r4, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 800ece6:	9302      	str	r3, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 800ece8:	2905      	cmp	r1, #5
 800ecea:	dc1c      	bgt.n	800ed26 <xTimerGenericCommand+0x56>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800ecec:	f7ff fbd2 	bl	800e494 <xTaskGetSchedulerState>
 800ecf0:	2802      	cmp	r0, #2
 800ecf2:	d010      	beq.n	800ed16 <xTimerGenericCommand+0x46>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800ecf4:	2300      	movs	r3, #0
 800ecf6:	461a      	mov	r2, r3
 800ecf8:	4669      	mov	r1, sp
 800ecfa:	480f      	ldr	r0, [pc, #60]	; (800ed38 <xTimerGenericCommand+0x68>)
 800ecfc:	6800      	ldr	r0, [r0, #0]
 800ecfe:	f7fd fd7e 	bl	800c7fe <xQueueGenericSend>
 800ed02:	e014      	b.n	800ed2e <xTimerGenericCommand+0x5e>
 800ed04:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ed08:	f383 8811 	msr	BASEPRI, r3
 800ed0c:	f3bf 8f6f 	isb	sy
 800ed10:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800ed14:	e7fe      	b.n	800ed14 <xTimerGenericCommand+0x44>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800ed16:	2300      	movs	r3, #0
 800ed18:	9a06      	ldr	r2, [sp, #24]
 800ed1a:	4669      	mov	r1, sp
 800ed1c:	4806      	ldr	r0, [pc, #24]	; (800ed38 <xTimerGenericCommand+0x68>)
 800ed1e:	6800      	ldr	r0, [r0, #0]
 800ed20:	f7fd fd6d 	bl	800c7fe <xQueueGenericSend>
 800ed24:	e003      	b.n	800ed2e <xTimerGenericCommand+0x5e>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800ed26:	2300      	movs	r3, #0
 800ed28:	4669      	mov	r1, sp
 800ed2a:	f7fd fe6f 	bl	800ca0c <xQueueGenericSendFromISR>
}
 800ed2e:	b004      	add	sp, #16
 800ed30:	bd10      	pop	{r4, pc}
BaseType_t xReturn = pdFAIL;
 800ed32:	2000      	movs	r0, #0
	return xReturn;
 800ed34:	e7fb      	b.n	800ed2e <xTimerGenericCommand+0x5e>
 800ed36:	bf00      	nop
 800ed38:	20000a58 	.word	0x20000a58

0800ed3c <prvSwitchTimerLists>:
{
 800ed3c:	b570      	push	{r4, r5, r6, lr}
 800ed3e:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800ed40:	4b1a      	ldr	r3, [pc, #104]	; (800edac <prvSwitchTimerLists+0x70>)
 800ed42:	681b      	ldr	r3, [r3, #0]
 800ed44:	681a      	ldr	r2, [r3, #0]
 800ed46:	b352      	cbz	r2, 800ed9e <prvSwitchTimerLists+0x62>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800ed48:	68db      	ldr	r3, [r3, #12]
 800ed4a:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800ed4c:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800ed4e:	1d25      	adds	r5, r4, #4
 800ed50:	4628      	mov	r0, r5
 800ed52:	f7fd fb73 	bl	800c43c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800ed56:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ed58:	4620      	mov	r0, r4
 800ed5a:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800ed5c:	69e3      	ldr	r3, [r4, #28]
 800ed5e:	2b01      	cmp	r3, #1
 800ed60:	d1ee      	bne.n	800ed40 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800ed62:	69a3      	ldr	r3, [r4, #24]
 800ed64:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 800ed66:	429e      	cmp	r6, r3
 800ed68:	d207      	bcs.n	800ed7a <prvSwitchTimerLists+0x3e>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800ed6a:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800ed6c:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800ed6e:	4629      	mov	r1, r5
 800ed70:	4b0e      	ldr	r3, [pc, #56]	; (800edac <prvSwitchTimerLists+0x70>)
 800ed72:	6818      	ldr	r0, [r3, #0]
 800ed74:	f7fd fb49 	bl	800c40a <vListInsert>
 800ed78:	e7e2      	b.n	800ed40 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800ed7a:	2100      	movs	r1, #0
 800ed7c:	9100      	str	r1, [sp, #0]
 800ed7e:	460b      	mov	r3, r1
 800ed80:	4632      	mov	r2, r6
 800ed82:	4620      	mov	r0, r4
 800ed84:	f7ff ffa4 	bl	800ecd0 <xTimerGenericCommand>
				configASSERT( xResult );
 800ed88:	2800      	cmp	r0, #0
 800ed8a:	d1d9      	bne.n	800ed40 <prvSwitchTimerLists+0x4>
 800ed8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ed90:	f383 8811 	msr	BASEPRI, r3
 800ed94:	f3bf 8f6f 	isb	sy
 800ed98:	f3bf 8f4f 	dsb	sy
 800ed9c:	e7fe      	b.n	800ed9c <prvSwitchTimerLists+0x60>
	pxCurrentTimerList = pxOverflowTimerList;
 800ed9e:	4a04      	ldr	r2, [pc, #16]	; (800edb0 <prvSwitchTimerLists+0x74>)
 800eda0:	6810      	ldr	r0, [r2, #0]
 800eda2:	4902      	ldr	r1, [pc, #8]	; (800edac <prvSwitchTimerLists+0x70>)
 800eda4:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
 800eda6:	6013      	str	r3, [r2, #0]
}
 800eda8:	b002      	add	sp, #8
 800edaa:	bd70      	pop	{r4, r5, r6, pc}
 800edac:	20000934 	.word	0x20000934
 800edb0:	20000938 	.word	0x20000938

0800edb4 <prvSampleTimeNow>:
{
 800edb4:	b538      	push	{r3, r4, r5, lr}
 800edb6:	4605      	mov	r5, r0
	xTimeNow = xTaskGetTickCount();
 800edb8:	f7fe fee2 	bl	800db80 <xTaskGetTickCount>
 800edbc:	4604      	mov	r4, r0
	if( xTimeNow < xLastTime )
 800edbe:	4b07      	ldr	r3, [pc, #28]	; (800eddc <prvSampleTimeNow+0x28>)
 800edc0:	681b      	ldr	r3, [r3, #0]
 800edc2:	4283      	cmp	r3, r0
 800edc4:	d805      	bhi.n	800edd2 <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
 800edc6:	2300      	movs	r3, #0
 800edc8:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
 800edca:	4b04      	ldr	r3, [pc, #16]	; (800eddc <prvSampleTimeNow+0x28>)
 800edcc:	601c      	str	r4, [r3, #0]
}
 800edce:	4620      	mov	r0, r4
 800edd0:	bd38      	pop	{r3, r4, r5, pc}
		prvSwitchTimerLists();
 800edd2:	f7ff ffb3 	bl	800ed3c <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 800edd6:	2301      	movs	r3, #1
 800edd8:	602b      	str	r3, [r5, #0]
 800edda:	e7f6      	b.n	800edca <prvSampleTimeNow+0x16>
 800eddc:	20000a04 	.word	0x20000a04

0800ede0 <prvProcessExpiredTimer>:
{
 800ede0:	b570      	push	{r4, r5, r6, lr}
 800ede2:	b082      	sub	sp, #8
 800ede4:	4605      	mov	r5, r0
 800ede6:	460e      	mov	r6, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800ede8:	4b14      	ldr	r3, [pc, #80]	; (800ee3c <prvProcessExpiredTimer+0x5c>)
 800edea:	681b      	ldr	r3, [r3, #0]
 800edec:	68db      	ldr	r3, [r3, #12]
 800edee:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800edf0:	1d20      	adds	r0, r4, #4
 800edf2:	f7fd fb23 	bl	800c43c <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800edf6:	69e3      	ldr	r3, [r4, #28]
 800edf8:	2b01      	cmp	r3, #1
 800edfa:	d004      	beq.n	800ee06 <prvProcessExpiredTimer+0x26>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800edfc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800edfe:	4620      	mov	r0, r4
 800ee00:	4798      	blx	r3
}
 800ee02:	b002      	add	sp, #8
 800ee04:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800ee06:	69a1      	ldr	r1, [r4, #24]
 800ee08:	462b      	mov	r3, r5
 800ee0a:	4632      	mov	r2, r6
 800ee0c:	4429      	add	r1, r5
 800ee0e:	4620      	mov	r0, r4
 800ee10:	f7ff fe6e 	bl	800eaf0 <prvInsertTimerInActiveList>
 800ee14:	2800      	cmp	r0, #0
 800ee16:	d0f1      	beq.n	800edfc <prvProcessExpiredTimer+0x1c>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800ee18:	2100      	movs	r1, #0
 800ee1a:	9100      	str	r1, [sp, #0]
 800ee1c:	460b      	mov	r3, r1
 800ee1e:	462a      	mov	r2, r5
 800ee20:	4620      	mov	r0, r4
 800ee22:	f7ff ff55 	bl	800ecd0 <xTimerGenericCommand>
			configASSERT( xResult );
 800ee26:	2800      	cmp	r0, #0
 800ee28:	d1e8      	bne.n	800edfc <prvProcessExpiredTimer+0x1c>
 800ee2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ee2e:	f383 8811 	msr	BASEPRI, r3
 800ee32:	f3bf 8f6f 	isb	sy
 800ee36:	f3bf 8f4f 	dsb	sy
 800ee3a:	e7fe      	b.n	800ee3a <prvProcessExpiredTimer+0x5a>
 800ee3c:	20000934 	.word	0x20000934

0800ee40 <prvProcessTimerOrBlockTask>:
{
 800ee40:	b570      	push	{r4, r5, r6, lr}
 800ee42:	b082      	sub	sp, #8
 800ee44:	4606      	mov	r6, r0
 800ee46:	460c      	mov	r4, r1
	vTaskSuspendAll();
 800ee48:	f7fe fe92 	bl	800db70 <vTaskSuspendAll>
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800ee4c:	a801      	add	r0, sp, #4
 800ee4e:	f7ff ffb1 	bl	800edb4 <prvSampleTimeNow>
		if( xTimerListsWereSwitched == pdFALSE )
 800ee52:	9b01      	ldr	r3, [sp, #4]
 800ee54:	bb1b      	cbnz	r3, 800ee9e <prvProcessTimerOrBlockTask+0x5e>
 800ee56:	4605      	mov	r5, r0
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800ee58:	b90c      	cbnz	r4, 800ee5e <prvProcessTimerOrBlockTask+0x1e>
 800ee5a:	42b0      	cmp	r0, r6
 800ee5c:	d218      	bcs.n	800ee90 <prvProcessTimerOrBlockTask+0x50>
				if( xListWasEmpty != pdFALSE )
 800ee5e:	b12c      	cbz	r4, 800ee6c <prvProcessTimerOrBlockTask+0x2c>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800ee60:	4b11      	ldr	r3, [pc, #68]	; (800eea8 <prvProcessTimerOrBlockTask+0x68>)
 800ee62:	681b      	ldr	r3, [r3, #0]
 800ee64:	681c      	ldr	r4, [r3, #0]
 800ee66:	fab4 f484 	clz	r4, r4
 800ee6a:	0964      	lsrs	r4, r4, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 800ee6c:	4622      	mov	r2, r4
 800ee6e:	1b71      	subs	r1, r6, r5
 800ee70:	4b0e      	ldr	r3, [pc, #56]	; (800eeac <prvProcessTimerOrBlockTask+0x6c>)
 800ee72:	6818      	ldr	r0, [r3, #0]
 800ee74:	f7fe fa20 	bl	800d2b8 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 800ee78:	f7fe ff36 	bl	800dce8 <xTaskResumeAll>
 800ee7c:	b988      	cbnz	r0, 800eea2 <prvProcessTimerOrBlockTask+0x62>
					portYIELD_WITHIN_API();
 800ee7e:	4b0c      	ldr	r3, [pc, #48]	; (800eeb0 <prvProcessTimerOrBlockTask+0x70>)
 800ee80:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ee84:	601a      	str	r2, [r3, #0]
 800ee86:	f3bf 8f4f 	dsb	sy
 800ee8a:	f3bf 8f6f 	isb	sy
 800ee8e:	e008      	b.n	800eea2 <prvProcessTimerOrBlockTask+0x62>
				( void ) xTaskResumeAll();
 800ee90:	f7fe ff2a 	bl	800dce8 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 800ee94:	4629      	mov	r1, r5
 800ee96:	4630      	mov	r0, r6
 800ee98:	f7ff ffa2 	bl	800ede0 <prvProcessExpiredTimer>
 800ee9c:	e001      	b.n	800eea2 <prvProcessTimerOrBlockTask+0x62>
			( void ) xTaskResumeAll();
 800ee9e:	f7fe ff23 	bl	800dce8 <xTaskResumeAll>
}
 800eea2:	b002      	add	sp, #8
 800eea4:	bd70      	pop	{r4, r5, r6, pc}
 800eea6:	bf00      	nop
 800eea8:	20000938 	.word	0x20000938
 800eeac:	20000a58 	.word	0x20000a58
 800eeb0:	e000ed04 	.word	0xe000ed04

0800eeb4 <prvProcessReceivedCommands>:
{
 800eeb4:	b510      	push	{r4, lr}
 800eeb6:	b088      	sub	sp, #32
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800eeb8:	e006      	b.n	800eec8 <prvProcessReceivedCommands+0x14>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 800eeba:	9907      	ldr	r1, [sp, #28]
 800eebc:	9806      	ldr	r0, [sp, #24]
 800eebe:	9b05      	ldr	r3, [sp, #20]
 800eec0:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800eec2:	9b04      	ldr	r3, [sp, #16]
 800eec4:	2b00      	cmp	r3, #0
 800eec6:	da0b      	bge.n	800eee0 <prvProcessReceivedCommands+0x2c>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800eec8:	2200      	movs	r2, #0
 800eeca:	a904      	add	r1, sp, #16
 800eecc:	4b36      	ldr	r3, [pc, #216]	; (800efa8 <prvProcessReceivedCommands+0xf4>)
 800eece:	6818      	ldr	r0, [r3, #0]
 800eed0:	f7fd fe5c 	bl	800cb8c <xQueueReceive>
 800eed4:	2800      	cmp	r0, #0
 800eed6:	d065      	beq.n	800efa4 <prvProcessReceivedCommands+0xf0>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 800eed8:	9b04      	ldr	r3, [sp, #16]
 800eeda:	2b00      	cmp	r3, #0
 800eedc:	daf1      	bge.n	800eec2 <prvProcessReceivedCommands+0xe>
 800eede:	e7ec      	b.n	800eeba <prvProcessReceivedCommands+0x6>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 800eee0:	9c06      	ldr	r4, [sp, #24]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 800eee2:	6963      	ldr	r3, [r4, #20]
 800eee4:	b113      	cbz	r3, 800eeec <prvProcessReceivedCommands+0x38>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800eee6:	1d20      	adds	r0, r4, #4
 800eee8:	f7fd faa8 	bl	800c43c <uxListRemove>
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800eeec:	a803      	add	r0, sp, #12
 800eeee:	f7ff ff61 	bl	800edb4 <prvSampleTimeNow>
			switch( xMessage.xMessageID )
 800eef2:	9b04      	ldr	r3, [sp, #16]
 800eef4:	2b09      	cmp	r3, #9
 800eef6:	d8e7      	bhi.n	800eec8 <prvProcessReceivedCommands+0x14>
 800eef8:	a201      	add	r2, pc, #4	; (adr r2, 800ef00 <prvProcessReceivedCommands+0x4c>)
 800eefa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800eefe:	bf00      	nop
 800ef00:	0800ef29 	.word	0x0800ef29
 800ef04:	0800ef29 	.word	0x0800ef29
 800ef08:	0800ef29 	.word	0x0800ef29
 800ef0c:	0800eec9 	.word	0x0800eec9
 800ef10:	0800ef6f 	.word	0x0800ef6f
 800ef14:	0800ef95 	.word	0x0800ef95
 800ef18:	0800ef29 	.word	0x0800ef29
 800ef1c:	0800ef29 	.word	0x0800ef29
 800ef20:	0800eec9 	.word	0x0800eec9
 800ef24:	0800ef6f 	.word	0x0800ef6f
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800ef28:	9b05      	ldr	r3, [sp, #20]
 800ef2a:	69a1      	ldr	r1, [r4, #24]
 800ef2c:	4602      	mov	r2, r0
 800ef2e:	4419      	add	r1, r3
 800ef30:	4620      	mov	r0, r4
 800ef32:	f7ff fddd 	bl	800eaf0 <prvInsertTimerInActiveList>
 800ef36:	2800      	cmp	r0, #0
 800ef38:	d0c6      	beq.n	800eec8 <prvProcessReceivedCommands+0x14>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800ef3a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ef3c:	4620      	mov	r0, r4
 800ef3e:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800ef40:	69e3      	ldr	r3, [r4, #28]
 800ef42:	2b01      	cmp	r3, #1
 800ef44:	d1c0      	bne.n	800eec8 <prvProcessReceivedCommands+0x14>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800ef46:	69a2      	ldr	r2, [r4, #24]
 800ef48:	2100      	movs	r1, #0
 800ef4a:	9100      	str	r1, [sp, #0]
 800ef4c:	460b      	mov	r3, r1
 800ef4e:	9805      	ldr	r0, [sp, #20]
 800ef50:	4402      	add	r2, r0
 800ef52:	4620      	mov	r0, r4
 800ef54:	f7ff febc 	bl	800ecd0 <xTimerGenericCommand>
							configASSERT( xResult );
 800ef58:	2800      	cmp	r0, #0
 800ef5a:	d1b5      	bne.n	800eec8 <prvProcessReceivedCommands+0x14>
 800ef5c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ef60:	f383 8811 	msr	BASEPRI, r3
 800ef64:	f3bf 8f6f 	isb	sy
 800ef68:	f3bf 8f4f 	dsb	sy
 800ef6c:	e7fe      	b.n	800ef6c <prvProcessReceivedCommands+0xb8>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 800ef6e:	9905      	ldr	r1, [sp, #20]
 800ef70:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800ef72:	b131      	cbz	r1, 800ef82 <prvProcessReceivedCommands+0xce>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800ef74:	4603      	mov	r3, r0
 800ef76:	4602      	mov	r2, r0
 800ef78:	4401      	add	r1, r0
 800ef7a:	4620      	mov	r0, r4
 800ef7c:	f7ff fdb8 	bl	800eaf0 <prvInsertTimerInActiveList>
					break;
 800ef80:	e7a2      	b.n	800eec8 <prvProcessReceivedCommands+0x14>
 800ef82:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ef86:	f383 8811 	msr	BASEPRI, r3
 800ef8a:	f3bf 8f6f 	isb	sy
 800ef8e:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800ef92:	e7fe      	b.n	800ef92 <prvProcessReceivedCommands+0xde>
						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 800ef94:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 800ef98:	2b00      	cmp	r3, #0
 800ef9a:	d195      	bne.n	800eec8 <prvProcessReceivedCommands+0x14>
							vPortFree( pxTimer );
 800ef9c:	4620      	mov	r0, r4
 800ef9e:	f000 fb17 	bl	800f5d0 <vPortFree>
 800efa2:	e791      	b.n	800eec8 <prvProcessReceivedCommands+0x14>
}
 800efa4:	b008      	add	sp, #32
 800efa6:	bd10      	pop	{r4, pc}
 800efa8:	20000a58 	.word	0x20000a58

0800efac <prvTimerTask>:
{
 800efac:	b500      	push	{lr}
 800efae:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800efb0:	a801      	add	r0, sp, #4
 800efb2:	f7ff fd8d 	bl	800ead0 <prvGetNextExpireTime>
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 800efb6:	9901      	ldr	r1, [sp, #4]
 800efb8:	f7ff ff42 	bl	800ee40 <prvProcessTimerOrBlockTask>
		prvProcessReceivedCommands();
 800efbc:	f7ff ff7a 	bl	800eeb4 <prvProcessReceivedCommands>
	for( ;; )
 800efc0:	e7f6      	b.n	800efb0 <prvTimerTask+0x4>

0800efc2 <xTimerGetTimerDaemonTaskHandle>:
	configASSERT( ( xTimerTaskHandle != NULL ) );
 800efc2:	4b06      	ldr	r3, [pc, #24]	; (800efdc <xTimerGetTimerDaemonTaskHandle+0x1a>)
 800efc4:	6818      	ldr	r0, [r3, #0]
 800efc6:	b100      	cbz	r0, 800efca <xTimerGetTimerDaemonTaskHandle+0x8>
}
 800efc8:	4770      	bx	lr
 800efca:	f04f 0350 	mov.w	r3, #80	; 0x50
 800efce:	f383 8811 	msr	BASEPRI, r3
 800efd2:	f3bf 8f6f 	isb	sy
 800efd6:	f3bf 8f4f 	dsb	sy
	configASSERT( ( xTimerTaskHandle != NULL ) );
 800efda:	e7fe      	b.n	800efda <xTimerGetTimerDaemonTaskHandle+0x18>
 800efdc:	20000a5c 	.word	0x20000a5c

0800efe0 <xTimerGetPeriod>:
	configASSERT( xTimer );
 800efe0:	b108      	cbz	r0, 800efe6 <xTimerGetPeriod+0x6>
}
 800efe2:	6980      	ldr	r0, [r0, #24]
 800efe4:	4770      	bx	lr
 800efe6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800efea:	f383 8811 	msr	BASEPRI, r3
 800efee:	f3bf 8f6f 	isb	sy
 800eff2:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800eff6:	e7fe      	b.n	800eff6 <xTimerGetPeriod+0x16>

0800eff8 <xTimerGetExpiryTime>:
	configASSERT( xTimer );
 800eff8:	b108      	cbz	r0, 800effe <xTimerGetExpiryTime+0x6>
}
 800effa:	6840      	ldr	r0, [r0, #4]
 800effc:	4770      	bx	lr
 800effe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f002:	f383 8811 	msr	BASEPRI, r3
 800f006:	f3bf 8f6f 	isb	sy
 800f00a:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800f00e:	e7fe      	b.n	800f00e <xTimerGetExpiryTime+0x16>

0800f010 <pcTimerGetName>:
	configASSERT( xTimer );
 800f010:	b108      	cbz	r0, 800f016 <pcTimerGetName+0x6>
}
 800f012:	6800      	ldr	r0, [r0, #0]
 800f014:	4770      	bx	lr
 800f016:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f01a:	f383 8811 	msr	BASEPRI, r3
 800f01e:	f3bf 8f6f 	isb	sy
 800f022:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800f026:	e7fe      	b.n	800f026 <pcTimerGetName+0x16>

0800f028 <xTimerIsTimerActive>:
BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 800f028:	b158      	cbz	r0, 800f042 <xTimerIsTimerActive+0x1a>
{
 800f02a:	b510      	push	{r4, lr}
 800f02c:	4604      	mov	r4, r0

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 800f02e:	f000 f8d3 	bl	800f1d8 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) ); /*lint !e961. Cast is only redundant when NULL is passed into the macro. */
 800f032:	6964      	ldr	r4, [r4, #20]
 800f034:	3c00      	subs	r4, #0
 800f036:	bf18      	it	ne
 800f038:	2401      	movne	r4, #1
	}
	taskEXIT_CRITICAL();
 800f03a:	f000 f8ef 	bl	800f21c <vPortExitCritical>

	return xTimerIsInActiveList;
} /*lint !e818 Can't be pointer to const due to the typedef. */
 800f03e:	4620      	mov	r0, r4
 800f040:	bd10      	pop	{r4, pc}
 800f042:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f046:	f383 8811 	msr	BASEPRI, r3
 800f04a:	f3bf 8f6f 	isb	sy
 800f04e:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800f052:	e7fe      	b.n	800f052 <xTimerIsTimerActive+0x2a>

0800f054 <pvTimerGetTimerID>:
void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
Timer_t * const pxTimer = ( Timer_t * ) xTimer;
void *pvReturn;

	configASSERT( xTimer );
 800f054:	b140      	cbz	r0, 800f068 <pvTimerGetTimerID+0x14>
{
 800f056:	b510      	push	{r4, lr}
 800f058:	4604      	mov	r4, r0

	taskENTER_CRITICAL();
 800f05a:	f000 f8bd 	bl	800f1d8 <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 800f05e:	6a24      	ldr	r4, [r4, #32]
	}
	taskEXIT_CRITICAL();
 800f060:	f000 f8dc 	bl	800f21c <vPortExitCritical>

	return pvReturn;
}
 800f064:	4620      	mov	r0, r4
 800f066:	bd10      	pop	{r4, pc}
 800f068:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f06c:	f383 8811 	msr	BASEPRI, r3
 800f070:	f3bf 8f6f 	isb	sy
 800f074:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800f078:	e7fe      	b.n	800f078 <pvTimerGetTimerID+0x24>

0800f07a <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
 800f07a:	b538      	push	{r3, r4, r5, lr}
Timer_t * const pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 800f07c:	b138      	cbz	r0, 800f08e <vTimerSetTimerID+0x14>
 800f07e:	460c      	mov	r4, r1
 800f080:	4605      	mov	r5, r0

	taskENTER_CRITICAL();
 800f082:	f000 f8a9 	bl	800f1d8 <vPortEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
 800f086:	622c      	str	r4, [r5, #32]
	}
	taskEXIT_CRITICAL();
 800f088:	f000 f8c8 	bl	800f21c <vPortExitCritical>
}
 800f08c:	bd38      	pop	{r3, r4, r5, pc}
 800f08e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f092:	f383 8811 	msr	BASEPRI, r3
 800f096:	f3bf 8f6f 	isb	sy
 800f09a:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800f09e:	e7fe      	b.n	800f09e <vTimerSetTimerID+0x24>

0800f0a0 <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
 800f0a0:	b510      	push	{r4, lr}
 800f0a2:	b084      	sub	sp, #16
 800f0a4:	4614      	mov	r4, r2
 800f0a6:	461a      	mov	r2, r3
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
 800f0a8:	f06f 0301 	mvn.w	r3, #1
 800f0ac:	9300      	str	r3, [sp, #0]
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 800f0ae:	9001      	str	r0, [sp, #4]
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 800f0b0:	9102      	str	r1, [sp, #8]
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 800f0b2:	9403      	str	r4, [sp, #12]

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800f0b4:	2300      	movs	r3, #0
 800f0b6:	4669      	mov	r1, sp
 800f0b8:	4802      	ldr	r0, [pc, #8]	; (800f0c4 <xTimerPendFunctionCallFromISR+0x24>)
 800f0ba:	6800      	ldr	r0, [r0, #0]
 800f0bc:	f7fd fca6 	bl	800ca0c <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
 800f0c0:	b004      	add	sp, #16
 800f0c2:	bd10      	pop	{r4, pc}
 800f0c4:	20000a58 	.word	0x20000a58

0800f0c8 <xTimerPendFunctionCall>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
	{
 800f0c8:	b530      	push	{r4, r5, lr}
 800f0ca:	b085      	sub	sp, #20
 800f0cc:	4605      	mov	r5, r0
 800f0ce:	460c      	mov	r4, r1
 800f0d0:	4611      	mov	r1, r2
 800f0d2:	461a      	mov	r2, r3
	BaseType_t xReturn;

		/* This function can only be called after a timer has been created or
		after the scheduler has been started because, until then, the timer
		queue does not exist. */
		configASSERT( xTimerQueue );
 800f0d4:	4b0b      	ldr	r3, [pc, #44]	; (800f104 <xTimerPendFunctionCall+0x3c>)
 800f0d6:	6818      	ldr	r0, [r3, #0]
 800f0d8:	b158      	cbz	r0, 800f0f2 <xTimerPendFunctionCall+0x2a>

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
 800f0da:	f04f 33ff 	mov.w	r3, #4294967295
 800f0de:	9300      	str	r3, [sp, #0]
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 800f0e0:	9501      	str	r5, [sp, #4]
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 800f0e2:	9402      	str	r4, [sp, #8]
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 800f0e4:	9103      	str	r1, [sp, #12]

		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800f0e6:	2300      	movs	r3, #0
 800f0e8:	4669      	mov	r1, sp
 800f0ea:	f7fd fb88 	bl	800c7fe <xQueueGenericSend>

		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
 800f0ee:	b005      	add	sp, #20
 800f0f0:	bd30      	pop	{r4, r5, pc}
 800f0f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f0f6:	f383 8811 	msr	BASEPRI, r3
 800f0fa:	f3bf 8f6f 	isb	sy
 800f0fe:	f3bf 8f4f 	dsb	sy
		configASSERT( xTimerQueue );
 800f102:	e7fe      	b.n	800f102 <xTimerPendFunctionCall+0x3a>
 800f104:	20000a58 	.word	0x20000a58

0800f108 <uxTimerGetTimerNumber>:
#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
	}
 800f108:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800f10a:	4770      	bx	lr

0800f10c <vTimerSetTimerNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 800f10c:	6281      	str	r1, [r0, #40]	; 0x28
	}
 800f10e:	4770      	bx	lr

0800f110 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 800f110:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
 800f112:	2300      	movs	r3, #0
 800f114:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800f116:	4b0d      	ldr	r3, [pc, #52]	; (800f14c <prvTaskExitError+0x3c>)
 800f118:	681b      	ldr	r3, [r3, #0]
 800f11a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f11e:	d008      	beq.n	800f132 <prvTaskExitError+0x22>
 800f120:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f124:	f383 8811 	msr	BASEPRI, r3
 800f128:	f3bf 8f6f 	isb	sy
 800f12c:	f3bf 8f4f 	dsb	sy
 800f130:	e7fe      	b.n	800f130 <prvTaskExitError+0x20>
 800f132:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f136:	f383 8811 	msr	BASEPRI, r3
 800f13a:	f3bf 8f6f 	isb	sy
 800f13e:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800f142:	9b01      	ldr	r3, [sp, #4]
 800f144:	2b00      	cmp	r3, #0
 800f146:	d0fc      	beq.n	800f142 <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 800f148:	b002      	add	sp, #8
 800f14a:	4770      	bx	lr
 800f14c:	20000034 	.word	0x20000034

0800f150 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 800f150:	48ae      	ldr	r0, [pc, #696]	; (800f40c <vPortValidateInterruptPriority+0x5c>)
 800f152:	6800      	ldr	r0, [r0, #0]
 800f154:	6800      	ldr	r0, [r0, #0]
 800f156:	f380 8808 	msr	MSP, r0
 800f15a:	b662      	cpsie	i
 800f15c:	b661      	cpsie	f
 800f15e:	f3bf 8f4f 	dsb	sy
 800f162:	f3bf 8f6f 	isb	sy
 800f166:	df00      	svc	0
 800f168:	bf00      	nop

0800f16a <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800f16a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800f16e:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800f172:	f021 0101 	bic.w	r1, r1, #1
 800f176:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800f17a:	4b03      	ldr	r3, [pc, #12]	; (800f188 <pxPortInitialiseStack+0x1e>)
 800f17c:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800f180:	f840 2c20 	str.w	r2, [r0, #-32]
}
 800f184:	3840      	subs	r0, #64	; 0x40
 800f186:	4770      	bx	lr
 800f188:	0800f111 	.word	0x0800f111

0800f18c <SVC_Handler>:
	__asm volatile (
 800f18c:	4b08      	ldr	r3, [pc, #32]	; (800f1b0 <pxCurrentTCBConst2>)
 800f18e:	6819      	ldr	r1, [r3, #0]
 800f190:	6808      	ldr	r0, [r1, #0]
 800f192:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800f196:	f380 8809 	msr	PSP, r0
 800f19a:	f3bf 8f6f 	isb	sy
 800f19e:	f04f 0000 	mov.w	r0, #0
 800f1a2:	f380 8811 	msr	BASEPRI, r0
 800f1a6:	f04e 0e0d 	orr.w	lr, lr, #13
 800f1aa:	4770      	bx	lr
 800f1ac:	f3af 8000 	nop.w

0800f1b0 <pxCurrentTCBConst2>:
 800f1b0:	20000438 	.word	0x20000438

0800f1b4 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
 800f1b4:	4b07      	ldr	r3, [pc, #28]	; (800f1d4 <vPortEndScheduler+0x20>)
 800f1b6:	681b      	ldr	r3, [r3, #0]
 800f1b8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800f1bc:	d008      	beq.n	800f1d0 <vPortEndScheduler+0x1c>
 800f1be:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f1c2:	f383 8811 	msr	BASEPRI, r3
 800f1c6:	f3bf 8f6f 	isb	sy
 800f1ca:	f3bf 8f4f 	dsb	sy
 800f1ce:	e7fe      	b.n	800f1ce <vPortEndScheduler+0x1a>
}
 800f1d0:	4770      	bx	lr
 800f1d2:	bf00      	nop
 800f1d4:	20000034 	.word	0x20000034

0800f1d8 <vPortEnterCritical>:
 800f1d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f1dc:	f383 8811 	msr	BASEPRI, r3
 800f1e0:	f3bf 8f6f 	isb	sy
 800f1e4:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 800f1e8:	4a0a      	ldr	r2, [pc, #40]	; (800f214 <vPortEnterCritical+0x3c>)
 800f1ea:	6813      	ldr	r3, [r2, #0]
 800f1ec:	3301      	adds	r3, #1
 800f1ee:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800f1f0:	2b01      	cmp	r3, #1
 800f1f2:	d000      	beq.n	800f1f6 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
 800f1f4:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 800f1f6:	4b08      	ldr	r3, [pc, #32]	; (800f218 <vPortEnterCritical+0x40>)
 800f1f8:	681b      	ldr	r3, [r3, #0]
 800f1fa:	f013 0fff 	tst.w	r3, #255	; 0xff
 800f1fe:	d0f9      	beq.n	800f1f4 <vPortEnterCritical+0x1c>
 800f200:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f204:	f383 8811 	msr	BASEPRI, r3
 800f208:	f3bf 8f6f 	isb	sy
 800f20c:	f3bf 8f4f 	dsb	sy
 800f210:	e7fe      	b.n	800f210 <vPortEnterCritical+0x38>
 800f212:	bf00      	nop
 800f214:	20000034 	.word	0x20000034
 800f218:	e000ed04 	.word	0xe000ed04

0800f21c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 800f21c:	4b09      	ldr	r3, [pc, #36]	; (800f244 <vPortExitCritical+0x28>)
 800f21e:	681b      	ldr	r3, [r3, #0]
 800f220:	b943      	cbnz	r3, 800f234 <vPortExitCritical+0x18>
 800f222:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f226:	f383 8811 	msr	BASEPRI, r3
 800f22a:	f3bf 8f6f 	isb	sy
 800f22e:	f3bf 8f4f 	dsb	sy
 800f232:	e7fe      	b.n	800f232 <vPortExitCritical+0x16>
	uxCriticalNesting--;
 800f234:	3b01      	subs	r3, #1
 800f236:	4a03      	ldr	r2, [pc, #12]	; (800f244 <vPortExitCritical+0x28>)
 800f238:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800f23a:	b90b      	cbnz	r3, 800f240 <vPortExitCritical+0x24>
	__asm volatile
 800f23c:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 800f240:	4770      	bx	lr
 800f242:	bf00      	nop
 800f244:	20000034 	.word	0x20000034

0800f248 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800f248:	f3ef 8009 	mrs	r0, PSP
 800f24c:	f3bf 8f6f 	isb	sy
 800f250:	4b0f      	ldr	r3, [pc, #60]	; (800f290 <pxCurrentTCBConst>)
 800f252:	681a      	ldr	r2, [r3, #0]
 800f254:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800f258:	6010      	str	r0, [r2, #0]
 800f25a:	e92d 4008 	stmdb	sp!, {r3, lr}
 800f25e:	f04f 0050 	mov.w	r0, #80	; 0x50
 800f262:	f380 8811 	msr	BASEPRI, r0
 800f266:	f7fe fe33 	bl	800ded0 <vTaskSwitchContext>
 800f26a:	f04f 0000 	mov.w	r0, #0
 800f26e:	f380 8811 	msr	BASEPRI, r0
 800f272:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800f276:	6819      	ldr	r1, [r3, #0]
 800f278:	6808      	ldr	r0, [r1, #0]
 800f27a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800f27e:	f380 8809 	msr	PSP, r0
 800f282:	f3bf 8f6f 	isb	sy
 800f286:	4770      	bx	lr
 800f288:	f3af 8000 	nop.w
 800f28c:	f3af 8000 	nop.w

0800f290 <pxCurrentTCBConst>:
 800f290:	20000438 	.word	0x20000438

0800f294 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800f294:	b508      	push	{r3, lr}
	__asm volatile
 800f296:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f29a:	f383 8811 	msr	BASEPRI, r3
 800f29e:	f3bf 8f6f 	isb	sy
 800f2a2:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800f2a6:	f7fe fc93 	bl	800dbd0 <xTaskIncrementTick>
 800f2aa:	b118      	cbz	r0, 800f2b4 <SysTick_Handler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800f2ac:	4b03      	ldr	r3, [pc, #12]	; (800f2bc <SysTick_Handler+0x28>)
 800f2ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800f2b2:	601a      	str	r2, [r3, #0]
	__asm volatile
 800f2b4:	2300      	movs	r3, #0
 800f2b6:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 800f2ba:	bd08      	pop	{r3, pc}
 800f2bc:	e000ed04 	.word	0xe000ed04

0800f2c0 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800f2c0:	4a08      	ldr	r2, [pc, #32]	; (800f2e4 <vPortSetupTimerInterrupt+0x24>)
 800f2c2:	2300      	movs	r3, #0
 800f2c4:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800f2c6:	4908      	ldr	r1, [pc, #32]	; (800f2e8 <vPortSetupTimerInterrupt+0x28>)
 800f2c8:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800f2ca:	4b08      	ldr	r3, [pc, #32]	; (800f2ec <vPortSetupTimerInterrupt+0x2c>)
 800f2cc:	681b      	ldr	r3, [r3, #0]
 800f2ce:	4908      	ldr	r1, [pc, #32]	; (800f2f0 <vPortSetupTimerInterrupt+0x30>)
 800f2d0:	fba1 1303 	umull	r1, r3, r1, r3
 800f2d4:	099b      	lsrs	r3, r3, #6
 800f2d6:	3b01      	subs	r3, #1
 800f2d8:	4906      	ldr	r1, [pc, #24]	; (800f2f4 <vPortSetupTimerInterrupt+0x34>)
 800f2da:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800f2dc:	2307      	movs	r3, #7
 800f2de:	6013      	str	r3, [r2, #0]
}
 800f2e0:	4770      	bx	lr
 800f2e2:	bf00      	nop
 800f2e4:	e000e010 	.word	0xe000e010
 800f2e8:	e000e018 	.word	0xe000e018
 800f2ec:	20000028 	.word	0x20000028
 800f2f0:	10624dd3 	.word	0x10624dd3
 800f2f4:	e000e014 	.word	0xe000e014

0800f2f8 <xPortStartScheduler>:
{
 800f2f8:	b510      	push	{r4, lr}
 800f2fa:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800f2fc:	4b27      	ldr	r3, [pc, #156]	; (800f39c <xPortStartScheduler+0xa4>)
 800f2fe:	781a      	ldrb	r2, [r3, #0]
 800f300:	b2d2      	uxtb	r2, r2
 800f302:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800f304:	22ff      	movs	r2, #255	; 0xff
 800f306:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800f308:	781b      	ldrb	r3, [r3, #0]
 800f30a:	b2db      	uxtb	r3, r3
 800f30c:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800f310:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800f314:	f003 0350 	and.w	r3, r3, #80	; 0x50
 800f318:	4a21      	ldr	r2, [pc, #132]	; (800f3a0 <xPortStartScheduler+0xa8>)
 800f31a:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800f31c:	4b21      	ldr	r3, [pc, #132]	; (800f3a4 <xPortStartScheduler+0xac>)
 800f31e:	2207      	movs	r2, #7
 800f320:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800f322:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800f326:	f013 0f80 	tst.w	r3, #128	; 0x80
 800f32a:	d00a      	beq.n	800f342 <xPortStartScheduler+0x4a>
			ulMaxPRIGROUPValue--;
 800f32c:	4a1d      	ldr	r2, [pc, #116]	; (800f3a4 <xPortStartScheduler+0xac>)
 800f32e:	6813      	ldr	r3, [r2, #0]
 800f330:	3b01      	subs	r3, #1
 800f332:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800f334:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800f338:	005b      	lsls	r3, r3, #1
 800f33a:	b2db      	uxtb	r3, r3
 800f33c:	f88d 3003 	strb.w	r3, [sp, #3]
 800f340:	e7ef      	b.n	800f322 <xPortStartScheduler+0x2a>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800f342:	4b18      	ldr	r3, [pc, #96]	; (800f3a4 <xPortStartScheduler+0xac>)
 800f344:	681b      	ldr	r3, [r3, #0]
 800f346:	2b03      	cmp	r3, #3
 800f348:	d008      	beq.n	800f35c <xPortStartScheduler+0x64>
	__asm volatile
 800f34a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f34e:	f383 8811 	msr	BASEPRI, r3
 800f352:	f3bf 8f6f 	isb	sy
 800f356:	f3bf 8f4f 	dsb	sy
 800f35a:	e7fe      	b.n	800f35a <xPortStartScheduler+0x62>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800f35c:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800f35e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800f362:	4a10      	ldr	r2, [pc, #64]	; (800f3a4 <xPortStartScheduler+0xac>)
 800f364:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800f366:	9b01      	ldr	r3, [sp, #4]
 800f368:	b2db      	uxtb	r3, r3
 800f36a:	4a0c      	ldr	r2, [pc, #48]	; (800f39c <xPortStartScheduler+0xa4>)
 800f36c:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800f36e:	4b0e      	ldr	r3, [pc, #56]	; (800f3a8 <xPortStartScheduler+0xb0>)
 800f370:	681a      	ldr	r2, [r3, #0]
 800f372:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800f376:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800f378:	681a      	ldr	r2, [r3, #0]
 800f37a:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 800f37e:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800f380:	f7ff ff9e 	bl	800f2c0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800f384:	2400      	movs	r4, #0
 800f386:	4b09      	ldr	r3, [pc, #36]	; (800f3ac <xPortStartScheduler+0xb4>)
 800f388:	601c      	str	r4, [r3, #0]
	prvPortStartFirstTask();
 800f38a:	f7ff fee1 	bl	800f150 <prvPortStartFirstTask>
	vTaskSwitchContext();
 800f38e:	f7fe fd9f 	bl	800ded0 <vTaskSwitchContext>
	prvTaskExitError();
 800f392:	f7ff febd 	bl	800f110 <prvTaskExitError>
}
 800f396:	4620      	mov	r0, r4
 800f398:	b002      	add	sp, #8
 800f39a:	bd10      	pop	{r4, pc}
 800f39c:	e000e400 	.word	0xe000e400
 800f3a0:	20000a60 	.word	0x20000a60
 800f3a4:	20000a64 	.word	0x20000a64
 800f3a8:	e000ed20 	.word	0xe000ed20
 800f3ac:	20000034 	.word	0x20000034

0800f3b0 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 800f3b0:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 800f3b4:	2b0f      	cmp	r3, #15
 800f3b6:	d90f      	bls.n	800f3d8 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800f3b8:	4a10      	ldr	r2, [pc, #64]	; (800f3fc <vPortValidateInterruptPriority+0x4c>)
 800f3ba:	5c9b      	ldrb	r3, [r3, r2]
 800f3bc:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800f3be:	4a10      	ldr	r2, [pc, #64]	; (800f400 <vPortValidateInterruptPriority+0x50>)
 800f3c0:	7812      	ldrb	r2, [r2, #0]
 800f3c2:	429a      	cmp	r2, r3
 800f3c4:	d908      	bls.n	800f3d8 <vPortValidateInterruptPriority+0x28>
 800f3c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f3ca:	f383 8811 	msr	BASEPRI, r3
 800f3ce:	f3bf 8f6f 	isb	sy
 800f3d2:	f3bf 8f4f 	dsb	sy
 800f3d6:	e7fe      	b.n	800f3d6 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800f3d8:	4b0a      	ldr	r3, [pc, #40]	; (800f404 <vPortValidateInterruptPriority+0x54>)
 800f3da:	681b      	ldr	r3, [r3, #0]
 800f3dc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800f3e0:	4a09      	ldr	r2, [pc, #36]	; (800f408 <vPortValidateInterruptPriority+0x58>)
 800f3e2:	6812      	ldr	r2, [r2, #0]
 800f3e4:	4293      	cmp	r3, r2
 800f3e6:	d908      	bls.n	800f3fa <vPortValidateInterruptPriority+0x4a>
 800f3e8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f3ec:	f383 8811 	msr	BASEPRI, r3
 800f3f0:	f3bf 8f6f 	isb	sy
 800f3f4:	f3bf 8f4f 	dsb	sy
 800f3f8:	e7fe      	b.n	800f3f8 <vPortValidateInterruptPriority+0x48>
	}
 800f3fa:	4770      	bx	lr
 800f3fc:	e000e3f0 	.word	0xe000e3f0
 800f400:	20000a60 	.word	0x20000a60
 800f404:	e000ed0c 	.word	0xe000ed0c
 800f408:	20000a64 	.word	0x20000a64
 800f40c:	e000ed08 	.word	0xe000ed08

0800f410 <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 800f410:	4a13      	ldr	r2, [pc, #76]	; (800f460 <prvHeapInit+0x50>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800f412:	f012 0f07 	tst.w	r2, #7
 800f416:	d01f      	beq.n	800f458 <prvHeapInit+0x48>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800f418:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800f41a:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800f41e:	f5c1 535a 	rsb	r3, r1, #13952	; 0x3680
 800f422:	3330      	adds	r3, #48	; 0x30
 800f424:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800f426:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800f428:	480e      	ldr	r0, [pc, #56]	; (800f464 <prvHeapInit+0x54>)
 800f42a:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800f42c:	2100      	movs	r1, #0
 800f42e:	6041      	str	r1, [r0, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800f430:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 800f432:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800f434:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 800f438:	480b      	ldr	r0, [pc, #44]	; (800f468 <prvHeapInit+0x58>)
 800f43a:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
 800f43c:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800f43e:	6019      	str	r1, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800f440:	1a99      	subs	r1, r3, r2
 800f442:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800f444:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800f446:	4b09      	ldr	r3, [pc, #36]	; (800f46c <prvHeapInit+0x5c>)
 800f448:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800f44a:	4b09      	ldr	r3, [pc, #36]	; (800f470 <prvHeapInit+0x60>)
 800f44c:	6019      	str	r1, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800f44e:	4b09      	ldr	r3, [pc, #36]	; (800f474 <prvHeapInit+0x64>)
 800f450:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800f454:	601a      	str	r2, [r3, #0]
}
 800f456:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800f458:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800f45c:	e7e4      	b.n	800f428 <prvHeapInit+0x18>
 800f45e:	bf00      	nop
 800f460:	20000a6c 	.word	0x20000a6c
 800f464:	20004128 	.word	0x20004128
 800f468:	20000a68 	.word	0x20000a68
 800f46c:	20004124 	.word	0x20004124
 800f470:	20004120 	.word	0x20004120
 800f474:	2000411c 	.word	0x2000411c

0800f478 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800f478:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800f47a:	4b12      	ldr	r3, [pc, #72]	; (800f4c4 <prvInsertBlockIntoFreeList+0x4c>)
 800f47c:	461a      	mov	r2, r3
 800f47e:	681b      	ldr	r3, [r3, #0]
 800f480:	4283      	cmp	r3, r0
 800f482:	d3fb      	bcc.n	800f47c <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800f484:	6851      	ldr	r1, [r2, #4]
 800f486:	1854      	adds	r4, r2, r1
 800f488:	4284      	cmp	r4, r0
 800f48a:	d009      	beq.n	800f4a0 <prvInsertBlockIntoFreeList+0x28>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800f48c:	6841      	ldr	r1, [r0, #4]
 800f48e:	1844      	adds	r4, r0, r1
 800f490:	42a3      	cmp	r3, r4
 800f492:	d00a      	beq.n	800f4aa <prvInsertBlockIntoFreeList+0x32>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800f494:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800f496:	4290      	cmp	r0, r2
 800f498:	d000      	beq.n	800f49c <prvInsertBlockIntoFreeList+0x24>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800f49a:	6010      	str	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800f49c:	bc10      	pop	{r4}
 800f49e:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800f4a0:	6840      	ldr	r0, [r0, #4]
 800f4a2:	4401      	add	r1, r0
 800f4a4:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
 800f4a6:	4610      	mov	r0, r2
 800f4a8:	e7f0      	b.n	800f48c <prvInsertBlockIntoFreeList+0x14>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800f4aa:	4c07      	ldr	r4, [pc, #28]	; (800f4c8 <prvInsertBlockIntoFreeList+0x50>)
 800f4ac:	6824      	ldr	r4, [r4, #0]
 800f4ae:	42a3      	cmp	r3, r4
 800f4b0:	d006      	beq.n	800f4c0 <prvInsertBlockIntoFreeList+0x48>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800f4b2:	685b      	ldr	r3, [r3, #4]
 800f4b4:	4419      	add	r1, r3
 800f4b6:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800f4b8:	6813      	ldr	r3, [r2, #0]
 800f4ba:	681b      	ldr	r3, [r3, #0]
 800f4bc:	6003      	str	r3, [r0, #0]
 800f4be:	e7ea      	b.n	800f496 <prvInsertBlockIntoFreeList+0x1e>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 800f4c0:	6004      	str	r4, [r0, #0]
 800f4c2:	e7e8      	b.n	800f496 <prvInsertBlockIntoFreeList+0x1e>
 800f4c4:	20004128 	.word	0x20004128
 800f4c8:	20000a68 	.word	0x20000a68

0800f4cc <pvPortMalloc>:
{
 800f4cc:	b570      	push	{r4, r5, r6, lr}
 800f4ce:	4604      	mov	r4, r0
	vTaskSuspendAll();
 800f4d0:	f7fe fb4e 	bl	800db70 <vTaskSuspendAll>
		if( pxEnd == NULL )
 800f4d4:	4b39      	ldr	r3, [pc, #228]	; (800f5bc <pvPortMalloc+0xf0>)
 800f4d6:	681b      	ldr	r3, [r3, #0]
 800f4d8:	b19b      	cbz	r3, 800f502 <pvPortMalloc+0x36>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800f4da:	4b39      	ldr	r3, [pc, #228]	; (800f5c0 <pvPortMalloc+0xf4>)
 800f4dc:	681b      	ldr	r3, [r3, #0]
 800f4de:	421c      	tst	r4, r3
 800f4e0:	d112      	bne.n	800f508 <pvPortMalloc+0x3c>
			if( xWantedSize > 0 )
 800f4e2:	b134      	cbz	r4, 800f4f2 <pvPortMalloc+0x26>
				xWantedSize += xHeapStructSize;
 800f4e4:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800f4e6:	f014 0f07 	tst.w	r4, #7
 800f4ea:	d002      	beq.n	800f4f2 <pvPortMalloc+0x26>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800f4ec:	f024 0407 	bic.w	r4, r4, #7
 800f4f0:	3408      	adds	r4, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800f4f2:	b1d4      	cbz	r4, 800f52a <pvPortMalloc+0x5e>
 800f4f4:	4b33      	ldr	r3, [pc, #204]	; (800f5c4 <pvPortMalloc+0xf8>)
 800f4f6:	681b      	ldr	r3, [r3, #0]
 800f4f8:	42a3      	cmp	r3, r4
 800f4fa:	d31a      	bcc.n	800f532 <pvPortMalloc+0x66>
				pxBlock = xStart.pxNextFreeBlock;
 800f4fc:	4b32      	ldr	r3, [pc, #200]	; (800f5c8 <pvPortMalloc+0xfc>)
 800f4fe:	681d      	ldr	r5, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800f500:	e01d      	b.n	800f53e <pvPortMalloc+0x72>
			prvHeapInit();
 800f502:	f7ff ff85 	bl	800f410 <prvHeapInit>
 800f506:	e7e8      	b.n	800f4da <pvPortMalloc+0xe>
	( void ) xTaskResumeAll();
 800f508:	f7fe fbee 	bl	800dce8 <xTaskResumeAll>
void *pvReturn = NULL;
 800f50c:	2600      	movs	r6, #0
			vApplicationMallocFailedHook();
 800f50e:	f7f0 fe1f 	bl	8000150 <vApplicationMallocFailedHook>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800f512:	f016 0f07 	tst.w	r6, #7
 800f516:	d04f      	beq.n	800f5b8 <pvPortMalloc+0xec>
 800f518:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f51c:	f383 8811 	msr	BASEPRI, r3
 800f520:	f3bf 8f6f 	isb	sy
 800f524:	f3bf 8f4f 	dsb	sy
 800f528:	e7fe      	b.n	800f528 <pvPortMalloc+0x5c>
	( void ) xTaskResumeAll();
 800f52a:	f7fe fbdd 	bl	800dce8 <xTaskResumeAll>
void *pvReturn = NULL;
 800f52e:	2600      	movs	r6, #0
 800f530:	e7ed      	b.n	800f50e <pvPortMalloc+0x42>
	( void ) xTaskResumeAll();
 800f532:	f7fe fbd9 	bl	800dce8 <xTaskResumeAll>
void *pvReturn = NULL;
 800f536:	2600      	movs	r6, #0
 800f538:	e7e9      	b.n	800f50e <pvPortMalloc+0x42>
					pxPreviousBlock = pxBlock;
 800f53a:	462b      	mov	r3, r5
					pxBlock = pxBlock->pxNextFreeBlock;
 800f53c:	4615      	mov	r5, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800f53e:	686a      	ldr	r2, [r5, #4]
 800f540:	42a2      	cmp	r2, r4
 800f542:	d202      	bcs.n	800f54a <pvPortMalloc+0x7e>
 800f544:	682a      	ldr	r2, [r5, #0]
 800f546:	2a00      	cmp	r2, #0
 800f548:	d1f7      	bne.n	800f53a <pvPortMalloc+0x6e>
				if( pxBlock != pxEnd )
 800f54a:	4a1c      	ldr	r2, [pc, #112]	; (800f5bc <pvPortMalloc+0xf0>)
 800f54c:	6812      	ldr	r2, [r2, #0]
 800f54e:	42aa      	cmp	r2, r5
 800f550:	d014      	beq.n	800f57c <pvPortMalloc+0xb0>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800f552:	681e      	ldr	r6, [r3, #0]
 800f554:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800f556:	682a      	ldr	r2, [r5, #0]
 800f558:	601a      	str	r2, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800f55a:	686b      	ldr	r3, [r5, #4]
 800f55c:	1b1b      	subs	r3, r3, r4
 800f55e:	2b10      	cmp	r3, #16
 800f560:	d914      	bls.n	800f58c <pvPortMalloc+0xc0>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800f562:	1928      	adds	r0, r5, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800f564:	f010 0f07 	tst.w	r0, #7
 800f568:	d00c      	beq.n	800f584 <pvPortMalloc+0xb8>
 800f56a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f56e:	f383 8811 	msr	BASEPRI, r3
 800f572:	f3bf 8f6f 	isb	sy
 800f576:	f3bf 8f4f 	dsb	sy
 800f57a:	e7fe      	b.n	800f57a <pvPortMalloc+0xae>
	( void ) xTaskResumeAll();
 800f57c:	f7fe fbb4 	bl	800dce8 <xTaskResumeAll>
void *pvReturn = NULL;
 800f580:	2600      	movs	r6, #0
 800f582:	e7c4      	b.n	800f50e <pvPortMalloc+0x42>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800f584:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800f586:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800f588:	f7ff ff76 	bl	800f478 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800f58c:	686a      	ldr	r2, [r5, #4]
 800f58e:	490d      	ldr	r1, [pc, #52]	; (800f5c4 <pvPortMalloc+0xf8>)
 800f590:	680b      	ldr	r3, [r1, #0]
 800f592:	1a9b      	subs	r3, r3, r2
 800f594:	600b      	str	r3, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800f596:	490d      	ldr	r1, [pc, #52]	; (800f5cc <pvPortMalloc+0x100>)
 800f598:	6809      	ldr	r1, [r1, #0]
 800f59a:	428b      	cmp	r3, r1
 800f59c:	d201      	bcs.n	800f5a2 <pvPortMalloc+0xd6>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800f59e:	490b      	ldr	r1, [pc, #44]	; (800f5cc <pvPortMalloc+0x100>)
 800f5a0:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800f5a2:	4b07      	ldr	r3, [pc, #28]	; (800f5c0 <pvPortMalloc+0xf4>)
 800f5a4:	681b      	ldr	r3, [r3, #0]
 800f5a6:	4313      	orrs	r3, r2
 800f5a8:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 800f5aa:	2300      	movs	r3, #0
 800f5ac:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 800f5ae:	f7fe fb9b 	bl	800dce8 <xTaskResumeAll>
		if( pvReturn == NULL )
 800f5b2:	2e00      	cmp	r6, #0
 800f5b4:	d1ad      	bne.n	800f512 <pvPortMalloc+0x46>
 800f5b6:	e7aa      	b.n	800f50e <pvPortMalloc+0x42>
}
 800f5b8:	4630      	mov	r0, r6
 800f5ba:	bd70      	pop	{r4, r5, r6, pc}
 800f5bc:	20000a68 	.word	0x20000a68
 800f5c0:	2000411c 	.word	0x2000411c
 800f5c4:	20004120 	.word	0x20004120
 800f5c8:	20004128 	.word	0x20004128
 800f5cc:	20004124 	.word	0x20004124

0800f5d0 <vPortFree>:
	if( pv != NULL )
 800f5d0:	b380      	cbz	r0, 800f634 <vPortFree+0x64>
{
 800f5d2:	b538      	push	{r3, r4, r5, lr}
 800f5d4:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 800f5d6:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800f5da:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800f5de:	4a16      	ldr	r2, [pc, #88]	; (800f638 <vPortFree+0x68>)
 800f5e0:	6812      	ldr	r2, [r2, #0]
 800f5e2:	4213      	tst	r3, r2
 800f5e4:	d108      	bne.n	800f5f8 <vPortFree+0x28>
 800f5e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f5ea:	f383 8811 	msr	BASEPRI, r3
 800f5ee:	f3bf 8f6f 	isb	sy
 800f5f2:	f3bf 8f4f 	dsb	sy
 800f5f6:	e7fe      	b.n	800f5f6 <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800f5f8:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800f5fc:	b141      	cbz	r1, 800f610 <vPortFree+0x40>
 800f5fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f602:	f383 8811 	msr	BASEPRI, r3
 800f606:	f3bf 8f6f 	isb	sy
 800f60a:	f3bf 8f4f 	dsb	sy
 800f60e:	e7fe      	b.n	800f60e <vPortFree+0x3e>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800f610:	ea23 0302 	bic.w	r3, r3, r2
 800f614:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 800f618:	f7fe faaa 	bl	800db70 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800f61c:	f854 1c04 	ldr.w	r1, [r4, #-4]
 800f620:	4a06      	ldr	r2, [pc, #24]	; (800f63c <vPortFree+0x6c>)
 800f622:	6813      	ldr	r3, [r2, #0]
 800f624:	440b      	add	r3, r1
 800f626:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800f628:	4628      	mov	r0, r5
 800f62a:	f7ff ff25 	bl	800f478 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 800f62e:	f7fe fb5b 	bl	800dce8 <xTaskResumeAll>
}
 800f632:	bd38      	pop	{r3, r4, r5, pc}
 800f634:	4770      	bx	lr
 800f636:	bf00      	nop
 800f638:	2000411c 	.word	0x2000411c
 800f63c:	20004120 	.word	0x20004120

0800f640 <xPortGetFreeHeapSize>:
}
 800f640:	4b01      	ldr	r3, [pc, #4]	; (800f648 <xPortGetFreeHeapSize+0x8>)
 800f642:	6818      	ldr	r0, [r3, #0]
 800f644:	4770      	bx	lr
 800f646:	bf00      	nop
 800f648:	20004120 	.word	0x20004120

0800f64c <xPortGetMinimumEverFreeHeapSize>:
}
 800f64c:	4b01      	ldr	r3, [pc, #4]	; (800f654 <xPortGetMinimumEverFreeHeapSize+0x8>)
 800f64e:	6818      	ldr	r0, [r3, #0]
 800f650:	4770      	bx	lr
 800f652:	bf00      	nop
 800f654:	20004124 	.word	0x20004124

0800f658 <vPortInitialiseBlocks>:
}
 800f658:	4770      	bx	lr
 800f65a:	bf00      	nop

0800f65c <xMyArrayCreate>:
 *      Author: HoangXuan
 */

#include "MyArray.h"

MyArray* xMyArrayCreate(uint32_t len, uint32_t w, uint32_t h) {
 800f65c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f65e:	4605      	mov	r5, r0
 800f660:	460f      	mov	r7, r1
 800f662:	4616      	mov	r6, r2
	MyArray *arr = (MyArray*) pvPortMalloc(sizeof(MyArray));
 800f664:	2010      	movs	r0, #16
 800f666:	f7ff ff31 	bl	800f4cc <pvPortMalloc>
	if (arr == NULL)
 800f66a:	4604      	mov	r4, r0
 800f66c:	b138      	cbz	r0, 800f67e <xMyArrayCreate+0x22>
		return NULL;
	arr->data = (uint16_t*) pvPortMalloc(len * sizeof(uint16_t));
 800f66e:	0068      	lsls	r0, r5, #1
 800f670:	f7ff ff2c 	bl	800f4cc <pvPortMalloc>
 800f674:	6020      	str	r0, [r4, #0]
	if (arr->data == NULL)
 800f676:	b120      	cbz	r0, 800f682 <xMyArrayCreate+0x26>
		return NULL;

	arr->length = len;
 800f678:	6065      	str	r5, [r4, #4]
	arr->width = w;
 800f67a:	60a7      	str	r7, [r4, #8]
	arr->height = h;
 800f67c:	60e6      	str	r6, [r4, #12]

	return arr;
}
 800f67e:	4620      	mov	r0, r4
 800f680:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
 800f682:	4604      	mov	r4, r0
 800f684:	e7fb      	b.n	800f67e <xMyArrayCreate+0x22>

0800f686 <vMyArrayDelete>:

void vMyArrayDelete(MyArray *arr) {
 800f686:	b510      	push	{r4, lr}
 800f688:	4604      	mov	r4, r0
	vPortFree(arr->data);
 800f68a:	6800      	ldr	r0, [r0, #0]
 800f68c:	f7ff ffa0 	bl	800f5d0 <vPortFree>
	vPortFree(arr);
 800f690:	4620      	mov	r0, r4
 800f692:	f7ff ff9d 	bl	800f5d0 <vPortFree>
}
 800f696:	bd10      	pop	{r4, pc}

0800f698 <eMyArraySplit>:

eMyArray eMyArraySplit(const MyArray *src, MyArray *dst, uint32_t x0,
		uint32_t y0) {
 800f698:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t h, w, dstH, dstW, srcH, srcW;
	dstH = dst->height;
 800f69c:	f8d1 e00c 	ldr.w	lr, [r1, #12]
	dstW = dst->width;
 800f6a0:	688f      	ldr	r7, [r1, #8]
	srcH = src->height;
 800f6a2:	68c5      	ldr	r5, [r0, #12]
	srcW = src->width;
 800f6a4:	f8d0 c008 	ldr.w	ip, [r0, #8]

	if (x0 + dstW > srcW || y0 + dstH > srcH)
 800f6a8:	18bc      	adds	r4, r7, r2
 800f6aa:	4564      	cmp	r4, ip
 800f6ac:	d81e      	bhi.n	800f6ec <eMyArraySplit+0x54>
 800f6ae:	4699      	mov	r9, r3
 800f6b0:	eb0e 0403 	add.w	r4, lr, r3
 800f6b4:	42ac      	cmp	r4, r5
 800f6b6:	d81b      	bhi.n	800f6f0 <eMyArraySplit+0x58>
		return eMyArrayPositionError;

	for (h = 0u; h < dstH; h++) {
 800f6b8:	2600      	movs	r6, #0
 800f6ba:	e010      	b.n	800f6de <eMyArraySplit+0x46>
		for (w = 0u; w < dstW; w++) {
			dst->data[h * dstW + w] = src->data[((h + y0) * srcW) + w + x0];
 800f6bc:	eb06 0409 	add.w	r4, r6, r9
 800f6c0:	fb0c 5404 	mla	r4, ip, r4, r5
 800f6c4:	4414      	add	r4, r2
 800f6c6:	fb07 5806 	mla	r8, r7, r6, r5
 800f6ca:	6803      	ldr	r3, [r0, #0]
 800f6cc:	f833 4014 	ldrh.w	r4, [r3, r4, lsl #1]
 800f6d0:	680b      	ldr	r3, [r1, #0]
 800f6d2:	f823 4018 	strh.w	r4, [r3, r8, lsl #1]
		for (w = 0u; w < dstW; w++) {
 800f6d6:	3501      	adds	r5, #1
 800f6d8:	42bd      	cmp	r5, r7
 800f6da:	d3ef      	bcc.n	800f6bc <eMyArraySplit+0x24>
	for (h = 0u; h < dstH; h++) {
 800f6dc:	3601      	adds	r6, #1
 800f6de:	4576      	cmp	r6, lr
 800f6e0:	d201      	bcs.n	800f6e6 <eMyArraySplit+0x4e>
		for (w = 0u; w < dstW; w++) {
 800f6e2:	2500      	movs	r5, #0
 800f6e4:	e7f8      	b.n	800f6d8 <eMyArraySplit+0x40>
		}
	}

	return eMyArrayOK;
 800f6e6:	2000      	movs	r0, #0
}
 800f6e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return eMyArrayPositionError;
 800f6ec:	2002      	movs	r0, #2
 800f6ee:	e7fb      	b.n	800f6e8 <eMyArraySplit+0x50>
 800f6f0:	2002      	movs	r0, #2
 800f6f2:	e7f9      	b.n	800f6e8 <eMyArraySplit+0x50>

0800f6f4 <uMyArrayFindMax>:

uint16_t uMyArrayFindMax(const MyArray *arr) {
 800f6f4:	4601      	mov	r1, r0
	uint16_t max = 0u, temp;

	for (uint32_t i = 0; i < arr->length; i++) {
 800f6f6:	2300      	movs	r3, #0
	uint16_t max = 0u, temp;
 800f6f8:	4618      	mov	r0, r3
	for (uint32_t i = 0; i < arr->length; i++) {
 800f6fa:	e000      	b.n	800f6fe <uMyArrayFindMax+0xa>
 800f6fc:	3301      	adds	r3, #1
 800f6fe:	684a      	ldr	r2, [r1, #4]
 800f700:	429a      	cmp	r2, r3
 800f702:	d906      	bls.n	800f712 <uMyArrayFindMax+0x1e>
		temp = arr->data[i];
 800f704:	680a      	ldr	r2, [r1, #0]
 800f706:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
		if (temp > max)
 800f70a:	4290      	cmp	r0, r2
 800f70c:	d2f6      	bcs.n	800f6fc <uMyArrayFindMax+0x8>
			max = temp;
 800f70e:	4610      	mov	r0, r2
 800f710:	e7f4      	b.n	800f6fc <uMyArrayFindMax+0x8>
	}

	return max;
}
 800f712:	4770      	bx	lr

0800f714 <Scan_74238>:
//
//	++ScanRowth;
//	ScanRowth %= NumberOfScanLimit; //0 -> 43
//}

void Scan_74238(uint16_t scanRowth) {
 800f714:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ScanBitState0 = (scanRowth & (1 << 0)) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 800f718:	f000 0201 	and.w	r2, r0, #1
 800f71c:	4b20      	ldr	r3, [pc, #128]	; (800f7a0 <Scan_74238+0x8c>)
 800f71e:	701a      	strb	r2, [r3, #0]
	ScanBitState1 = (scanRowth & (1 << 1)) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 800f720:	f3c0 0340 	ubfx	r3, r0, #1, #1
 800f724:	f8df 9090 	ldr.w	r9, [pc, #144]	; 800f7b8 <Scan_74238+0xa4>
 800f728:	f889 3000 	strb.w	r3, [r9]
	ScanBitState2 = (scanRowth & (1 << 2)) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 800f72c:	f3c0 0380 	ubfx	r3, r0, #2, #1
 800f730:	f8df 8088 	ldr.w	r8, [pc, #136]	; 800f7bc <Scan_74238+0xa8>
 800f734:	f888 3000 	strb.w	r3, [r8]
	ScanBitState3 = (scanRowth & (1 << 3)) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 800f738:	f3c0 03c0 	ubfx	r3, r0, #3, #1
 800f73c:	4f19      	ldr	r7, [pc, #100]	; (800f7a4 <Scan_74238+0x90>)
 800f73e:	703b      	strb	r3, [r7, #0]
	ScanBitState4 = (scanRowth & (1 << 4)) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 800f740:	f3c0 1300 	ubfx	r3, r0, #4, #1
 800f744:	4e18      	ldr	r6, [pc, #96]	; (800f7a8 <Scan_74238+0x94>)
 800f746:	7033      	strb	r3, [r6, #0]
	ScanBitState5 = (scanRowth & (1 << 5)) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 800f748:	f3c0 1040 	ubfx	r0, r0, #5, #1
 800f74c:	4d17      	ldr	r5, [pc, #92]	; (800f7ac <Scan_74238+0x98>)
 800f74e:	7028      	strb	r0, [r5, #0]

	HAL_GPIO_WritePin(A_Port, A_Pin, ScanBitState0);
 800f750:	4c17      	ldr	r4, [pc, #92]	; (800f7b0 <Scan_74238+0x9c>)
 800f752:	2104      	movs	r1, #4
 800f754:	4620      	mov	r0, r4
 800f756:	f7f4 fccc 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(B_Port, B_Pin, ScanBitState1);
 800f75a:	f899 2000 	ldrb.w	r2, [r9]
 800f75e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800f762:	4620      	mov	r0, r4
 800f764:	f7f4 fcc5 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(C_Port, C_Pin, ScanBitState2);
 800f768:	f898 2000 	ldrb.w	r2, [r8]
 800f76c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800f770:	4620      	mov	r0, r4
 800f772:	f7f4 fcbe 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(D_Port, D_Pin, ScanBitState3);
 800f776:	783a      	ldrb	r2, [r7, #0]
 800f778:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800f77c:	4620      	mov	r0, r4
 800f77e:	f7f4 fcb8 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(E_Port, E_Pin, ScanBitState4);
 800f782:	7832      	ldrb	r2, [r6, #0]
 800f784:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800f788:	4620      	mov	r0, r4
 800f78a:	f7f4 fcb2 	bl	80040f2 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(F_Port, F_Pin, ScanBitState5);
 800f78e:	782a      	ldrb	r2, [r5, #0]
 800f790:	f44f 7180 	mov.w	r1, #256	; 0x100
 800f794:	4807      	ldr	r0, [pc, #28]	; (800f7b4 <Scan_74238+0xa0>)
 800f796:	f7f4 fcac 	bl	80040f2 <HAL_GPIO_WritePin>
}
 800f79a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800f79e:	bf00      	nop
 800f7a0:	20004594 	.word	0x20004594
 800f7a4:	20004592 	.word	0x20004592
 800f7a8:	20004593 	.word	0x20004593
 800f7ac:	20004591 	.word	0x20004591
 800f7b0:	40010c00 	.word	0x40010c00
 800f7b4:	40010800 	.word	0x40010800
 800f7b8:	20004590 	.word	0x20004590
 800f7bc:	20004595 	.word	0x20004595

0800f7c0 <vServoInit>:

volatile uint8_t servoLevel = 0;

void vServoInit(Servo *servo, TIM_HandleTypeDef *htim, uint32_t channel,
		osEventFlagsId_t event, uint32_t flag) {
	servo->htim = htim;
 800f7c0:	6081      	str	r1, [r0, #8]
	servo->channel = channel;
 800f7c2:	60c2      	str	r2, [r0, #12]
	switch (channel) {
 800f7c4:	2a0c      	cmp	r2, #12
 800f7c6:	d80b      	bhi.n	800f7e0 <vServoInit+0x20>
 800f7c8:	e8df f002 	tbb	[pc, r2]
 800f7cc:	0a0a0a07 	.word	0x0a0a0a07
 800f7d0:	0a0a0a0e 	.word	0x0a0a0a0e
 800f7d4:	0a0a0a12 	.word	0x0a0a0a12
 800f7d8:	16          	.byte	0x16
 800f7d9:	00          	.byte	0x00
	case TIM_CHANNEL_1:
		servo->CCRx = &htim->Instance->CCR1;
 800f7da:	680a      	ldr	r2, [r1, #0]
 800f7dc:	3234      	adds	r2, #52	; 0x34
 800f7de:	6102      	str	r2, [r0, #16]
	case TIM_CHANNEL_4:
		servo->CCRx = &htim->Instance->CCR4;
		break;
	}
	//
	servo->event = event;
 800f7e0:	6143      	str	r3, [r0, #20]
	servo->flag = flag;
 800f7e2:	9b00      	ldr	r3, [sp, #0]
 800f7e4:	6183      	str	r3, [r0, #24]
}
 800f7e6:	4770      	bx	lr
		servo->CCRx = &htim->Instance->CCR2;
 800f7e8:	680a      	ldr	r2, [r1, #0]
 800f7ea:	3238      	adds	r2, #56	; 0x38
 800f7ec:	6102      	str	r2, [r0, #16]
		break;
 800f7ee:	e7f7      	b.n	800f7e0 <vServoInit+0x20>
		servo->CCRx = &htim->Instance->CCR3;
 800f7f0:	680a      	ldr	r2, [r1, #0]
 800f7f2:	323c      	adds	r2, #60	; 0x3c
 800f7f4:	6102      	str	r2, [r0, #16]
		break;
 800f7f6:	e7f3      	b.n	800f7e0 <vServoInit+0x20>
		servo->CCRx = &htim->Instance->CCR4;
 800f7f8:	680a      	ldr	r2, [r1, #0]
 800f7fa:	3240      	adds	r2, #64	; 0x40
 800f7fc:	6102      	str	r2, [r0, #16]
		break;
 800f7fe:	e7ef      	b.n	800f7e0 <vServoInit+0x20>

0800f800 <vServoStart>:
void vServoStart(Servo *servo) {
 800f800:	b510      	push	{r4, lr}
 800f802:	4604      	mov	r4, r0
	HAL_TIM_PWM_Start(servo->htim, servo->channel);
 800f804:	68c1      	ldr	r1, [r0, #12]
 800f806:	6880      	ldr	r0, [r0, #8]
 800f808:	f7f7 f998 	bl	8006b3c <HAL_TIM_PWM_Start>
	if (servo->isReverse)
 800f80c:	7963      	ldrb	r3, [r4, #5]
 800f80e:	b11b      	cbz	r3, 800f818 <vServoStart+0x18>
		*servo->CCRx = servo->downLimit;
 800f810:	6923      	ldr	r3, [r4, #16]
 800f812:	78e2      	ldrb	r2, [r4, #3]
 800f814:	601a      	str	r2, [r3, #0]
	else
		*servo->CCRx = servo->upLimit;
}
 800f816:	bd10      	pop	{r4, pc}
		*servo->CCRx = servo->upLimit;
 800f818:	6923      	ldr	r3, [r4, #16]
 800f81a:	7922      	ldrb	r2, [r4, #4]
 800f81c:	601a      	str	r2, [r3, #0]
}
 800f81e:	e7fa      	b.n	800f816 <vServoStart+0x16>

0800f820 <vServoStop>:
void vServoStop(Servo *servo) {
 800f820:	b508      	push	{r3, lr}
	HAL_TIM_PWM_Stop(servo->htim, servo->channel);
 800f822:	68c1      	ldr	r1, [r0, #12]
 800f824:	6880      	ldr	r0, [r0, #8]
 800f826:	f7f7 f9f7 	bl	8006c18 <HAL_TIM_PWM_Stop>
}
 800f82a:	bd08      	pop	{r3, pc}

0800f82c <vServoStop1>:
	vServoReverseCommand(servo);
	if (servo->command != eServoStop)
		osEventFlagsSet(servo->event, servo->flag);
}

void vServoStop1(Servo *servo) {
 800f82c:	b510      	push	{r4, lr}
 800f82e:	4604      	mov	r4, r0
	osEventFlagsClear(servo->event, servo->flag);
 800f830:	6981      	ldr	r1, [r0, #24]
 800f832:	6940      	ldr	r0, [r0, #20]
 800f834:	f7fb ff1e 	bl	800b674 <osEventFlagsClear>
	servo->command = eServoStop;
 800f838:	2300      	movs	r3, #0
 800f83a:	70a3      	strb	r3, [r4, #2]
}
 800f83c:	bd10      	pop	{r4, pc}

0800f83e <eServoMove>:

eServoCommand eServoMove(Servo *servo) {
 800f83e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f840:	4604      	mov	r4, r0
	osEventFlagsWait(servo->event, servo->flag, osFlagsWaitAll | osFlagsNoClear,
 800f842:	f04f 33ff 	mov.w	r3, #4294967295
 800f846:	2203      	movs	r2, #3
 800f848:	6981      	ldr	r1, [r0, #24]
 800f84a:	6940      	ldr	r0, [r0, #20]
 800f84c:	f7fb ff60 	bl	800b710 <osEventFlagsWait>
	osWaitForever);

	eServoCommand res = eServoStop;
	uint8_t step = servo->step;
 800f850:	7821      	ldrb	r1, [r4, #0]
	uint8_t downLimit = servo->downLimit;
 800f852:	78e0      	ldrb	r0, [r4, #3]
	uint8_t upLimit = servo->upLimit;
 800f854:	7926      	ldrb	r6, [r4, #4]
	uint8_t value = *servo->CCRx;
 800f856:	6923      	ldr	r3, [r4, #16]
 800f858:	681a      	ldr	r2, [r3, #0]
 800f85a:	b2d2      	uxtb	r2, r2

	switch (servo->command) {
 800f85c:	78a5      	ldrb	r5, [r4, #2]
 800f85e:	2d04      	cmp	r5, #4
 800f860:	d875      	bhi.n	800f94e <eServoMove+0x110>
 800f862:	e8df f005 	tbb	[pc, r5]
 800f866:	0c03      	.short	0x0c03
 800f868:	4629      	.short	0x4629
 800f86a:	5d          	.byte	0x5d
 800f86b:	00          	.byte	0x00
	case eServoStop:
		osEventFlagsClear(servo->event, servo->flag);
 800f86c:	69a1      	ldr	r1, [r4, #24]
 800f86e:	6960      	ldr	r0, [r4, #20]
 800f870:	f7fb ff00 	bl	800b674 <osEventFlagsClear>
			res = eServoDown;
		}
		break;
	}

	osDelay(servo->delay);
 800f874:	7860      	ldrb	r0, [r4, #1]
 800f876:	f7fb fd11 	bl	800b29c <osDelay>

	return res;
}
 800f87a:	4628      	mov	r0, r5
 800f87c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*servo->CCRx + step <= upLimit) {
 800f87e:	681f      	ldr	r7, [r3, #0]
 800f880:	440f      	add	r7, r1
 800f882:	42b7      	cmp	r7, r6
 800f884:	d80e      	bhi.n	800f8a4 <eServoMove+0x66>
			*servo->CCRx += step;
 800f886:	681d      	ldr	r5, [r3, #0]
 800f888:	4429      	add	r1, r5
 800f88a:	6019      	str	r1, [r3, #0]
			if (value < downLimit)
 800f88c:	4290      	cmp	r0, r2
 800f88e:	d903      	bls.n	800f898 <eServoMove+0x5a>
				*servo->CCRx = downLimit;
 800f890:	6923      	ldr	r3, [r4, #16]
 800f892:	6018      	str	r0, [r3, #0]
	eServoCommand res = eServoStop;
 800f894:	2500      	movs	r5, #0
 800f896:	e008      	b.n	800f8aa <eServoMove+0x6c>
			else if (value > upLimit)
 800f898:	4296      	cmp	r6, r2
 800f89a:	d20b      	bcs.n	800f8b4 <eServoMove+0x76>
				*servo->CCRx = upLimit;
 800f89c:	6923      	ldr	r3, [r4, #16]
 800f89e:	601e      	str	r6, [r3, #0]
	eServoCommand res = eServoStop;
 800f8a0:	2500      	movs	r5, #0
 800f8a2:	e002      	b.n	800f8aa <eServoMove+0x6c>
			*servo->CCRx = upLimit;
 800f8a4:	601e      	str	r6, [r3, #0]
			servo->command = eServoStop;
 800f8a6:	2300      	movs	r3, #0
 800f8a8:	70a3      	strb	r3, [r4, #2]
		osEventFlagsClear(servo->event, servo->flag);
 800f8aa:	69a1      	ldr	r1, [r4, #24]
 800f8ac:	6960      	ldr	r0, [r4, #20]
 800f8ae:	f7fb fee1 	bl	800b674 <osEventFlagsClear>
		break;
 800f8b2:	e7df      	b.n	800f874 <eServoMove+0x36>
	eServoCommand res = eServoStop;
 800f8b4:	2500      	movs	r5, #0
 800f8b6:	e7f8      	b.n	800f8aa <eServoMove+0x6c>
		if (*servo->CCRx - step >= downLimit) {
 800f8b8:	681f      	ldr	r7, [r3, #0]
 800f8ba:	1a7f      	subs	r7, r7, r1
 800f8bc:	4287      	cmp	r7, r0
 800f8be:	d30e      	bcc.n	800f8de <eServoMove+0xa0>
			*servo->CCRx -= step;
 800f8c0:	681d      	ldr	r5, [r3, #0]
 800f8c2:	1a69      	subs	r1, r5, r1
 800f8c4:	6019      	str	r1, [r3, #0]
			if (value < downLimit)
 800f8c6:	4290      	cmp	r0, r2
 800f8c8:	d903      	bls.n	800f8d2 <eServoMove+0x94>
				*servo->CCRx = downLimit;
 800f8ca:	6923      	ldr	r3, [r4, #16]
 800f8cc:	6018      	str	r0, [r3, #0]
	eServoCommand res = eServoStop;
 800f8ce:	2500      	movs	r5, #0
 800f8d0:	e008      	b.n	800f8e4 <eServoMove+0xa6>
			else if (value > upLimit)
 800f8d2:	4296      	cmp	r6, r2
 800f8d4:	d20b      	bcs.n	800f8ee <eServoMove+0xb0>
				*servo->CCRx = upLimit;
 800f8d6:	6923      	ldr	r3, [r4, #16]
 800f8d8:	601e      	str	r6, [r3, #0]
	eServoCommand res = eServoStop;
 800f8da:	2500      	movs	r5, #0
 800f8dc:	e002      	b.n	800f8e4 <eServoMove+0xa6>
			*servo->CCRx = downLimit;
 800f8de:	6018      	str	r0, [r3, #0]
			servo->command = eServoStop;
 800f8e0:	2300      	movs	r3, #0
 800f8e2:	70a3      	strb	r3, [r4, #2]
		osEventFlagsClear(servo->event, servo->flag);
 800f8e4:	69a1      	ldr	r1, [r4, #24]
 800f8e6:	6960      	ldr	r0, [r4, #20]
 800f8e8:	f7fb fec4 	bl	800b674 <osEventFlagsClear>
		break;
 800f8ec:	e7c2      	b.n	800f874 <eServoMove+0x36>
	eServoCommand res = eServoStop;
 800f8ee:	2500      	movs	r5, #0
 800f8f0:	e7f8      	b.n	800f8e4 <eServoMove+0xa6>
		if (*servo->CCRx + step <= upLimit) {
 800f8f2:	681f      	ldr	r7, [r3, #0]
 800f8f4:	440f      	add	r7, r1
 800f8f6:	42b7      	cmp	r7, r6
 800f8f8:	d80e      	bhi.n	800f918 <eServoMove+0xda>
			*servo->CCRx += step;
 800f8fa:	681d      	ldr	r5, [r3, #0]
 800f8fc:	4429      	add	r1, r5
 800f8fe:	6019      	str	r1, [r3, #0]
			if (value < downLimit)
 800f900:	4290      	cmp	r0, r2
 800f902:	d903      	bls.n	800f90c <eServoMove+0xce>
				*servo->CCRx = downLimit;
 800f904:	6923      	ldr	r3, [r4, #16]
 800f906:	6018      	str	r0, [r3, #0]
	eServoCommand res = eServoStop;
 800f908:	2500      	movs	r5, #0
 800f90a:	e7b3      	b.n	800f874 <eServoMove+0x36>
			else if (value > upLimit)
 800f90c:	4296      	cmp	r6, r2
 800f90e:	d220      	bcs.n	800f952 <eServoMove+0x114>
				*servo->CCRx = upLimit;
 800f910:	6923      	ldr	r3, [r4, #16]
 800f912:	601e      	str	r6, [r3, #0]
	eServoCommand res = eServoStop;
 800f914:	2500      	movs	r5, #0
 800f916:	e7ad      	b.n	800f874 <eServoMove+0x36>
			*servo->CCRx = upLimit;
 800f918:	601e      	str	r6, [r3, #0]
			servo->command = eServoStop;
 800f91a:	2300      	movs	r3, #0
 800f91c:	70a3      	strb	r3, [r4, #2]
			res = eServoUp;
 800f91e:	e7a9      	b.n	800f874 <eServoMove+0x36>
		if (*servo->CCRx - step >= downLimit) {
 800f920:	681f      	ldr	r7, [r3, #0]
 800f922:	1a7f      	subs	r7, r7, r1
 800f924:	4287      	cmp	r7, r0
 800f926:	d30e      	bcc.n	800f946 <eServoMove+0x108>
			*servo->CCRx -= step;
 800f928:	681d      	ldr	r5, [r3, #0]
 800f92a:	1a69      	subs	r1, r5, r1
 800f92c:	6019      	str	r1, [r3, #0]
			if (value < downLimit)
 800f92e:	4290      	cmp	r0, r2
 800f930:	d903      	bls.n	800f93a <eServoMove+0xfc>
				*servo->CCRx = downLimit;
 800f932:	6923      	ldr	r3, [r4, #16]
 800f934:	6018      	str	r0, [r3, #0]
	eServoCommand res = eServoStop;
 800f936:	2500      	movs	r5, #0
 800f938:	e79c      	b.n	800f874 <eServoMove+0x36>
			else if (value > upLimit)
 800f93a:	4296      	cmp	r6, r2
 800f93c:	d20b      	bcs.n	800f956 <eServoMove+0x118>
				*servo->CCRx = upLimit;
 800f93e:	6923      	ldr	r3, [r4, #16]
 800f940:	601e      	str	r6, [r3, #0]
	eServoCommand res = eServoStop;
 800f942:	2500      	movs	r5, #0
 800f944:	e796      	b.n	800f874 <eServoMove+0x36>
			*servo->CCRx = downLimit;
 800f946:	6018      	str	r0, [r3, #0]
			servo->command = eServoStop;
 800f948:	2300      	movs	r3, #0
 800f94a:	70a3      	strb	r3, [r4, #2]
			res = eServoDown;
 800f94c:	e792      	b.n	800f874 <eServoMove+0x36>
	switch (servo->command) {
 800f94e:	2500      	movs	r5, #0
 800f950:	e790      	b.n	800f874 <eServoMove+0x36>
	eServoCommand res = eServoStop;
 800f952:	2500      	movs	r5, #0
 800f954:	e78e      	b.n	800f874 <eServoMove+0x36>
 800f956:	2500      	movs	r5, #0
 800f958:	e78c      	b.n	800f874 <eServoMove+0x36>

0800f95a <vServoReverseCommand>:

void vServoReverseCommand(Servo *servo) {
	if (servo->isReverse) {
 800f95a:	7943      	ldrb	r3, [r0, #5]
 800f95c:	b193      	cbz	r3, 800f984 <vServoReverseCommand+0x2a>
		switch (servo->command) {
 800f95e:	7883      	ldrb	r3, [r0, #2]
 800f960:	3b01      	subs	r3, #1
 800f962:	2b03      	cmp	r3, #3
 800f964:	d80e      	bhi.n	800f984 <vServoReverseCommand+0x2a>
 800f966:	e8df f003 	tbb	[pc, r3]
 800f96a:	0502      	.short	0x0502
 800f96c:	0b08      	.short	0x0b08
		case eServoStop:
			break;
		case eServoUp1:
			servo->command = eServoDown1;
 800f96e:	2302      	movs	r3, #2
 800f970:	7083      	strb	r3, [r0, #2]
			break;
 800f972:	4770      	bx	lr
		case eServoDown1:
			servo->command = eServoUp1;
 800f974:	2301      	movs	r3, #1
 800f976:	7083      	strb	r3, [r0, #2]
			break;
 800f978:	4770      	bx	lr
		case eServoUp:
			servo->command = eServoDown;
 800f97a:	2304      	movs	r3, #4
 800f97c:	7083      	strb	r3, [r0, #2]
			break;
 800f97e:	4770      	bx	lr
		case eServoDown:
			servo->command = eServoUp;
 800f980:	2303      	movs	r3, #3
 800f982:	7083      	strb	r3, [r0, #2]
			break;
		}
	}
}
 800f984:	4770      	bx	lr

0800f986 <vServoMove1>:
void vServoMove1(Servo *servo, eServoCommand cmd) {
 800f986:	b510      	push	{r4, lr}
 800f988:	4604      	mov	r4, r0
	servo->command = cmd;
 800f98a:	7081      	strb	r1, [r0, #2]
	vServoReverseCommand(servo);
 800f98c:	f7ff ffe5 	bl	800f95a <vServoReverseCommand>
	if (servo->command != eServoStop)
 800f990:	78a3      	ldrb	r3, [r4, #2]
 800f992:	b903      	cbnz	r3, 800f996 <vServoMove1+0x10>
}
 800f994:	bd10      	pop	{r4, pc}
		osEventFlagsSet(servo->event, servo->flag);
 800f996:	69a1      	ldr	r1, [r4, #24]
 800f998:	6960      	ldr	r0, [r4, #20]
 800f99a:	f7fb fe2d 	bl	800b5f8 <osEventFlagsSet>
}
 800f99e:	e7f9      	b.n	800f994 <vServoMove1+0xe>

0800f9a0 <vServoUpdateCommand>:

void vServoUpdateCommand(Servo *servo, uint8_t *rxData, uint8_t offset) {
 800f9a0:	b570      	push	{r4, r5, r6, lr}
 800f9a2:	4604      	mov	r4, r0
 800f9a4:	460e      	mov	r6, r1
 800f9a6:	4615      	mov	r5, r2
	osEventFlagsClear(servo->event, servo->flag);
 800f9a8:	6981      	ldr	r1, [r0, #24]
 800f9aa:	6940      	ldr	r0, [r0, #20]
 800f9ac:	f7fb fe62 	bl	800b674 <osEventFlagsClear>

	servo->step = rxData[offset];
 800f9b0:	5d73      	ldrb	r3, [r6, r5]
 800f9b2:	7023      	strb	r3, [r4, #0]
	servo->delay = rxData[offset + 1];
 800f9b4:	1973      	adds	r3, r6, r5
 800f9b6:	785b      	ldrb	r3, [r3, #1]
 800f9b8:	7063      	strb	r3, [r4, #1]
	servo->command = (eServoCommand) rxData[offset + 2];
 800f9ba:	3502      	adds	r5, #2
 800f9bc:	5d73      	ldrb	r3, [r6, r5]
 800f9be:	70a3      	strb	r3, [r4, #2]
//			servo->command = eServoUp;
//			break;
//		}
//	}

	vServoReverseCommand(servo);
 800f9c0:	4620      	mov	r0, r4
 800f9c2:	f7ff ffca 	bl	800f95a <vServoReverseCommand>

	if (servo->command != eServoStop)
 800f9c6:	78a3      	ldrb	r3, [r4, #2]
 800f9c8:	b903      	cbnz	r3, 800f9cc <vServoUpdateCommand+0x2c>
		osEventFlagsSet(servo->event, servo->flag);
}
 800f9ca:	bd70      	pop	{r4, r5, r6, pc}
		osEventFlagsSet(servo->event, servo->flag);
 800f9cc:	69a1      	ldr	r1, [r4, #24]
 800f9ce:	6960      	ldr	r0, [r4, #20]
 800f9d0:	f7fb fe12 	bl	800b5f8 <osEventFlagsSet>
}
 800f9d4:	e7f9      	b.n	800f9ca <vServoUpdateCommand+0x2a>

0800f9d6 <vServoUpdateSetup>:

void vServoUpdateSetup(Servo *servo, uint8_t *rxData, uint8_t offset) {
 800f9d6:	b570      	push	{r4, r5, r6, lr}
 800f9d8:	4604      	mov	r4, r0
 800f9da:	460d      	mov	r5, r1
 800f9dc:	4616      	mov	r6, r2
	osEventFlagsClear(servo->event, servo->flag);
 800f9de:	6981      	ldr	r1, [r0, #24]
 800f9e0:	6940      	ldr	r0, [r0, #20]
 800f9e2:	f7fb fe47 	bl	800b674 <osEventFlagsClear>

	servo->command = eServoStop;
 800f9e6:	2300      	movs	r3, #0
 800f9e8:	70a3      	strb	r3, [r4, #2]

	servo->downLimit = rxData[offset];
 800f9ea:	5dab      	ldrb	r3, [r5, r6]
 800f9ec:	70e3      	strb	r3, [r4, #3]
	servo->upLimit = rxData[offset + 1];
 800f9ee:	4435      	add	r5, r6
 800f9f0:	786b      	ldrb	r3, [r5, #1]
 800f9f2:	7123      	strb	r3, [r4, #4]
	servo->isReverse = rxData[offset + 2];
 800f9f4:	78ab      	ldrb	r3, [r5, #2]
 800f9f6:	7163      	strb	r3, [r4, #5]
}
 800f9f8:	bd70      	pop	{r4, r5, r6, pc}
	...

0800f9fc <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800f9fc:	480c      	ldr	r0, [pc, #48]	; (800fa30 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800f9fe:	490d      	ldr	r1, [pc, #52]	; (800fa34 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800fa00:	4a0d      	ldr	r2, [pc, #52]	; (800fa38 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800fa02:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800fa04:	e002      	b.n	800fa0c <LoopCopyDataInit>

0800fa06 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800fa06:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800fa08:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800fa0a:	3304      	adds	r3, #4

0800fa0c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800fa0c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800fa0e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800fa10:	d3f9      	bcc.n	800fa06 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800fa12:	4a0a      	ldr	r2, [pc, #40]	; (800fa3c <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 800fa14:	4c0a      	ldr	r4, [pc, #40]	; (800fa40 <LoopFillZerobss+0x22>)
  movs r3, #0
 800fa16:	2300      	movs	r3, #0
  b LoopFillZerobss
 800fa18:	e001      	b.n	800fa1e <LoopFillZerobss>

0800fa1a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800fa1a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800fa1c:	3204      	adds	r2, #4

0800fa1e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800fa1e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800fa20:	d3fb      	bcc.n	800fa1a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800fa22:	f7f2 f9bb 	bl	8001d9c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800fa26:	f000 f80f 	bl	800fa48 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800fa2a:	f7f1 f89b 	bl	8000b64 <main>
  bx lr
 800fa2e:	4770      	bx	lr
  ldr r0, =_sdata
 800fa30:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800fa34:	20000038 	.word	0x20000038
  ldr r2, =_sidata
 800fa38:	0800fec8 	.word	0x0800fec8
  ldr r2, =_sbss
 800fa3c:	20000038 	.word	0x20000038
  ldr r4, =_ebss
 800fa40:	20004598 	.word	0x20004598

0800fa44 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800fa44:	e7fe      	b.n	800fa44 <ADC1_2_IRQHandler>
	...

0800fa48 <__libc_init_array>:
 800fa48:	b570      	push	{r4, r5, r6, lr}
 800fa4a:	2600      	movs	r6, #0
 800fa4c:	4d0c      	ldr	r5, [pc, #48]	; (800fa80 <__libc_init_array+0x38>)
 800fa4e:	4c0d      	ldr	r4, [pc, #52]	; (800fa84 <__libc_init_array+0x3c>)
 800fa50:	1b64      	subs	r4, r4, r5
 800fa52:	10a4      	asrs	r4, r4, #2
 800fa54:	42a6      	cmp	r6, r4
 800fa56:	d109      	bne.n	800fa6c <__libc_init_array+0x24>
 800fa58:	f000 f830 	bl	800fabc <_init>
 800fa5c:	2600      	movs	r6, #0
 800fa5e:	4d0a      	ldr	r5, [pc, #40]	; (800fa88 <__libc_init_array+0x40>)
 800fa60:	4c0a      	ldr	r4, [pc, #40]	; (800fa8c <__libc_init_array+0x44>)
 800fa62:	1b64      	subs	r4, r4, r5
 800fa64:	10a4      	asrs	r4, r4, #2
 800fa66:	42a6      	cmp	r6, r4
 800fa68:	d105      	bne.n	800fa76 <__libc_init_array+0x2e>
 800fa6a:	bd70      	pop	{r4, r5, r6, pc}
 800fa6c:	f855 3b04 	ldr.w	r3, [r5], #4
 800fa70:	4798      	blx	r3
 800fa72:	3601      	adds	r6, #1
 800fa74:	e7ee      	b.n	800fa54 <__libc_init_array+0xc>
 800fa76:	f855 3b04 	ldr.w	r3, [r5], #4
 800fa7a:	4798      	blx	r3
 800fa7c:	3601      	adds	r6, #1
 800fa7e:	e7f2      	b.n	800fa66 <__libc_init_array+0x1e>
 800fa80:	0800fec0 	.word	0x0800fec0
 800fa84:	0800fec0 	.word	0x0800fec0
 800fa88:	0800fec0 	.word	0x0800fec0
 800fa8c:	0800fec4 	.word	0x0800fec4

0800fa90 <memcpy>:
 800fa90:	440a      	add	r2, r1
 800fa92:	4291      	cmp	r1, r2
 800fa94:	f100 33ff 	add.w	r3, r0, #4294967295
 800fa98:	d100      	bne.n	800fa9c <memcpy+0xc>
 800fa9a:	4770      	bx	lr
 800fa9c:	b510      	push	{r4, lr}
 800fa9e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800faa2:	4291      	cmp	r1, r2
 800faa4:	f803 4f01 	strb.w	r4, [r3, #1]!
 800faa8:	d1f9      	bne.n	800fa9e <memcpy+0xe>
 800faaa:	bd10      	pop	{r4, pc}

0800faac <memset>:
 800faac:	4603      	mov	r3, r0
 800faae:	4402      	add	r2, r0
 800fab0:	4293      	cmp	r3, r2
 800fab2:	d100      	bne.n	800fab6 <memset+0xa>
 800fab4:	4770      	bx	lr
 800fab6:	f803 1b01 	strb.w	r1, [r3], #1
 800faba:	e7f9      	b.n	800fab0 <memset+0x4>

0800fabc <_init>:
 800fabc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fabe:	bf00      	nop
 800fac0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800fac2:	bc08      	pop	{r3}
 800fac4:	469e      	mov	lr, r3
 800fac6:	4770      	bx	lr

0800fac8 <_fini>:
 800fac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800faca:	bf00      	nop
 800facc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800face:	bc08      	pop	{r3}
 800fad0:	469e      	mov	lr, r3
 800fad2:	4770      	bx	lr
